/***************************************************************************************************************************************************************************************************
	file: zt_game.h v 0.00 (active initial development)
	
	This software is dual-licensed to the public domain and under the following
	license: you are granted a perpetual, irrevocable license to copy, modify,
	publish, and distribute this file as you see fit.
	
	No warranty is offered or implied.  Use this at your own risk.
	
  ***************************************************************************************************************************************************************************************************
   
	Zero Tolerance Game Library
   
	In exactly one c/cpp source file of your project, you must:

		#define ZT_GAME_IMPLEMENTATION
		#include "zt_game.h"
    
	You must also defined the following

		ZT_GAME_FUNC_SETTINGS
			Called to getting settings required to setup the game.  Only as much work as is
			needed to populate the ztGameSettings structure should be done in this function.
			bool game_settings(ztGameDetails* game_details, ztGameSettings* game_settings)

		ZT_GAME_FUNC_INIT
			Called to initialize the game.
			bool game_init(ztGameDetails* game_details, ztGameSettings* game_settings)

		ZT_GAME_FUNC_SCREENCHANGE
			Called whenever the screen resolution changes (usually by user resizing)

		ZT_GAME_FUNC_CLEANUP
			Called to cleanup resources during shutdown.
			void game_cleanup()

		ZT_GAME_FUNC_LOOP
			Called once per frame.  This takes the time delta since the last frame completed.
			Return false to exit the game.
			bool game_loop(r32 dt)


 ***************************************************************************************************************************************************************************************************

    Options:
		ZT_NO_OPENGL
			Define this in order to disable OpenGL on platforms where it's supported

		ZT_NO_DIRECTX
			Define this in order to disable DirectX on platforms where it's supported

		ZT_OPENGL_DEBUGGING
			This will check the error value of every OpenGL call, even those in performance
			critical sections.  This should only be defined when a problem needs diagnosed.

		ZT_DIRECTX_DEBUGGING
			This will check the error value of every DirectX call, even those in performance
			critical sections.  This should only be defined when a problem needs diagnosed.


 ***************************************************************************************************************************************************************************************************

	Implimentation Options: (only used with ZT_GAME_IMPLEMENTATION #include)

	ZT_GAME_NAME
		This is used when the game name is needed, such as for naming user data directories.

	ZT_GAME_LOCAL_ONLY
		The user path passed in will be the same directory that the executable lives in instead of
		the typical user data directory (C:\Users\<user>\AppData\Roaming on Windows)

	ZT_GAME_NO_ALTF4
		This will disable ALT+F4 closing the window and exiting the game

 ***************************************************************************************************************************************************************************************************/

#ifndef __zt_game_h_included__
#define __zt_game_h_included__

#include "zt_tools.h"

#ifndef ZT_WINDOWS
#define ZT_NO_PROFILE
#endif

// ================================================================================================================================================================================================
// renderer defines
// ================================================================================================================================================================================================

#if !defined(ZT_NO_OPENGL)
#	include "zt_renderer_opengl.h"
#endif

#if !defined(ZT_NO_DIRECTX)
#	include "zt_renderer_directx.h"
#endif

#if !defined(ZT_NO_DSOUND)
#	include "zt_audio_dsound.h"
#elif !defined(ZT_NO_OPENAL)
#	include "zt_audio_openal.h"
#elif !defined(ZT_NO_OPENSL)
#	include "zt_audio_opensl.h"
#endif



#define ztInvalidID -1


// ================================================================================================================================================================================================
// common enumerations
// ================================================================================================================================================================================================

enum ztAlign_Enum
{
	ztAlign_None       = 0,
	ztAlign_Default    = 0,
	ztAlign_Left       = (1<<0),
	ztAlign_Right      = (1<<1),
	ztAlign_Center     = (1<<2),
	ztAlign_Top        = (1<<3),
	ztAlign_Bottom     = (1<<4),
	ztAlign_VertCenter = (1<<5),

	ztAlign_ToPixel = (1<<31),
};

// ================================================================================================================================================================================================

enum ztAnchor_Enum
{
	ztAnchor_None       = ztAlign_None,
	ztAnchor_Default    = ztAlign_None,
	ztAnchor_Left       = ztAlign_Left,
	ztAnchor_Right      = ztAlign_Right,
	ztAnchor_Center     = ztAlign_Center,
	ztAnchor_Top        = ztAlign_Top,
	ztAnchor_Bottom     = ztAlign_Bottom,
	ztAnchor_VertCenter = ztAlign_VertCenter,
};

// ================================================================================================================================================================================================

enum ztDirection_Enum
{
	ztDirection_Up,
	ztDirection_Down,
	ztDirection_Left,
	ztDirection_Right,

	ztDirection_UpLeft,
	ztDirection_UpRight,
	ztDirection_DownLeft,
	ztDirection_DownRight,

	ztDirection_North     = ztDirection_Up,
	ztDirection_South     = ztDirection_Down,
	ztDirection_East      = ztDirection_Right,
	ztDirection_West      = ztDirection_Left,

	ztDirection_NorthWest = ztDirection_UpLeft,
	ztDirection_NorthEast = ztDirection_UpRight,
	ztDirection_SouthWest = ztDirection_DownLeft,
	ztDirection_SouthEast = ztDirection_DownRight,
};


// ================================================================================================================================================================================================
// renderer enumerations
// ================================================================================================================================================================================================

enum ztRenderer_Enum
{
	ztRenderer_Invalid,

	ztRenderer_OpenGL,
	ztRenderer_DirectX,

	ztRenderer_MAX,
};

// ================================================================================================================================================================================================

enum ztRendererFlags_Enum
{
	ztRendererFlags_Windowed           = (1 << 0),
	ztRendererFlags_WindowedBorderless = (1 << 1),
	ztRendererFlags_Fullscreen         = (1 << 2),
	ztRendererFlags_Vsync              = (1 << 3),
	ztRendererFlags_RotationAllowed    = (1 << 4), // mobile
	ztRendererFlags_VertOrientation    = (1 << 5), // mobile
	ztRendererFlags_LockAspect         = (1 << 6),
	ztRendererFlags_HideCursor         = (1 << 7),
	ztRendererFlags_NoResize           = (1 << 8),
};

// ================================================================================================================================================================================================

enum ztRendererScreenChangeBehavior_Enum
{
	ztRendererScreenChangeBehavior_Resize,		// the viewport and native resolution scales to the window size
	ztRendererScreenChangeBehavior_ScaleAll,	// the viewport scales and distorts to keep the native resolution
	ztRendererScreenChangeBehavior_ScaleToHorz, // the viewport scales to the width of the screen (resizing up/down doesn't affect the size of things)
	ztRendererScreenChangeBehavior_ScaleToVert, // the viewport scales to the height of the screen (resizing left/right doesn't affect the size of things)
};


// ================================================================================================================================================================================================
// game settings
//
// these are set by the game in the ZT_GAME_FUNC_SETTINGS function, instructing the engine how to 
// configure everything
// ================================================================================================================================================================================================

struct ztGameSettings
{
	i32                                 memory; // how much memory should the global arena have?

	i32                                 screen_w, native_w;
	i32                                 screen_h, native_h;
	i32                                 monitor;
	ztRenderer_Enum                     renderer;
	i32                                 renderer_target_version_major;
	i32                                 renderer_target_version_minor;
	i32                                 renderer_flags;
	ztRendererScreenChangeBehavior_Enum renderer_screen_change_behavior;
	i32                                 renderer_memory;
	i32                                 pixels_per_unit;

	i32                                 threaded_frame_jobs;
	i32                                 threaded_background_jobs;
};

// ================================================================================================================================================================================================

ztRenderer_Enum zt_currentRenderer();

r32 zt_pixelsPerUnit();

// units default to meters
ztInline r32 zt_inchesToUnits(r32 inches) { return inches * .0254f; }
ztInline r32 zt_feetToUnits  (r32 feet  ) { return feet * 12 * .0254f; }
ztInline r32 zt_unitsToInches(r32 units ) { return units / .0254f; }
ztInline r32 zt_unitsToFeet  (r32 units ) { return units / .0254f / 12; }

void zt_requestQuit();

bool zt_appHasFocus();


// ================================================================================================================================================================================================
// game details
//
// these are set by the engine, providing useful information to the game
// ================================================================================================================================================================================================

struct ztGameDetails
{
	const char* app_path;
	const char *data_path;
	const char* user_path;

	int          argc;
	const char** argv;

	i32 current_frame;
	r32 current_dt;
	r64 app_start_time;

	struct {
		i32 shader_switches;
		i32 texture_switches;
		i32 triangles_drawn;
		i32 draw_calls;
	} curr_frame, prev_frame;
};


// ================================================================================================================================================================================================
// threading
// ================================================================================================================================================================================================

typedef i32 ztThreadJobID;

ztThreadJobID zt_threadJobQueueForFrame(ztThread_Func thread_func, void *user_data, r32 anticipated_length = 1); // use for jobs that will complete in the time of a frame
ztThreadJobID zt_threadJobQueueForBackground(ztThread_Func thread_func, void *user_data, r32 anticipated_length = 1); // use for jobs that will take multiple frames to complete

bool          zt_threadJobIsComplete(ztThreadJobID job_id);
void          zt_threadJobCancel(ztThreadJobID job_id);

void          zt_threadJobQueueStartFrameJobs();
void          zt_threadJobQueueWaitForFrameJobs();      // waits until all frame jobs are completed (called after the game loop if jobs are pending)
void          zt_threadJobQueueWaitForBackgroundJobs(); // waits until all background jobs are completed
void          zt_threadJobQueueWaitForAllJobs();        // waits until all jobs are completed

void          zt_threadJobQueueDllLoad();
void          zt_threadJobQueueDllUnload();

int           zt_threadGetIndex();


// ================================================================================================================================================================================================
// profiling
// ================================================================================================================================================================================================

struct ztDrawList;
struct ztProfiledSection;

// ================================================================================================================================================================================================

struct ztProfilerRenderState
{
	int display_frame = -1;
	int display_thread = 0;
};

// ================================================================================================================================================================================================

#define ZT_SYSTEM_PLATFORM           "Platform"
#define ZT_SYSTEM_RENDERING	         "Rendering"
#define ZT_SYSTEM_AUDIO              "Audio"
#define ZT_SYSTEM_INPUT              "Input"
#define ZT_SYSTEM_ASSETS             "Assets"
#define ZT_SYSTEM_PHYSICS            "Physics"
#define ZT_SYSTEM_ANIMATION          "Animation"
#define ZT_SYSTEM_PARTICLES          "Particles"
#define ZT_SYSTEM_PATHFINDING        "Pathfinding"
#define ZT_SYSTEM_GAME               "Game"


// ================================================================================================================================================================================================

void               zt_profilerPause              ();
void               zt_profilerResume             ();
bool               zt_profilerIsPaused           ();
void               zt_profilerRender             (ztDrawList *draw_list, const ztVec2 &pos, const ztVec2 &size, const ztVec2 &mouse_pos = ztVec2::min, bool mouse_clicked = false, ztProfilerRenderState *render_state = nullptr);
void               zt_profilerFrameBegin         ();
void               zt_profilerFrameEnd           ();

ztProfiledSection *zt_profiledSectionEnter       (const char *section, i32 section_hash, const char *system, i32 system_hash, int thread_idx = zt_threadGetIndex());
void               zt_profiledSectionExit        (ztProfiledSection *section);


// ================================================================================================================================================================================================

struct ztProfileBlock
{
	ztProfiledSection *profiled_section;

	// --------------------

	ztProfileBlock(const char *section, i32 section_hash, const char *system, i32 system_hash, int thread_idx = zt_threadGetIndex()) {
		profiled_section = zt_profiledSectionEnter(section, section_hash, system, system_hash, thread_idx);
	}

	// --------------------

	~ztProfileBlock() {
		zt_profiledSectionExit(profiled_section);
	}
};

// ================================================================================================================================================================================================

#ifndef ZT_NO_PROFILE
#	define ZT_PROFILE(section, system)           static i32 __zt_profileBlockHashSection##__LINE__ = zt_strHash((section)); \
                                                 static i32 __zt_profileBlockHashSystem##__LINE__ = zt_strHash((system));   \
                                                 ztProfileBlock __zt_profileBlock_##__LINE((section), __zt_profileBlockHashSection##__LINE__, (system), __zt_profileBlockHashSystem##__LINE__);

#	define ZT_PROFILE_PLATFORM(section)          ZT_PROFILE((section), ZT_SYSTEM_PLATFORM)
#	define ZT_PROFILE_RENDERING(section)         ZT_PROFILE((section), ZT_SYSTEM_RENDERING)
#	define ZT_PROFILE_AUDIO(section)             ZT_PROFILE((section), ZT_SYSTEM_AUDIO)
#	define ZT_PROFILE_INPUT(section)             ZT_PROFILE((section), ZT_SYSTEM_INPUT)
#	define ZT_PROFILE_ASSETS(section)            ZT_PROFILE((section), ZT_SYSTEM_ASSETS)
#	define ZT_PROFILE_PHYSICS(section)           ZT_PROFILE((section), ZT_SYSTEM_PHYSICS)
#	define ZT_PROFILE_ANIMATION(section)         ZT_PROFILE((section), ZT_SYSTEM_ANIMATION)
#	define ZT_PROFILE_PARTICLES(section)         ZT_PROFILE((section), ZT_SYSTEM_PARTICLES)
#	define ZT_PROFILE_PATHFINDING(section)       ZT_PROFILE((section), ZT_SYSTEM_PATHFINDING)
#	define ZT_PROFILE_GAME(section)              ZT_PROFILE((section), ZT_SYSTEM_GAME)

#else
#	define ZT_PROFILE(section, system)
#	define ZT_PROFILE_PLATFORM(section)
#	define ZT_PROFILE_RENDERING(section)
#	define ZT_PROFILE_AUDIO(section)
#	define ZT_PROFILE_INPUT(section)
#	define ZT_PROFILE_ASSETS(section)
#	define ZT_PROFILE_PHYSICS(section)
#	define ZT_PROFILE_ANIMATION(section)
#	define ZT_PROFILE_PARTICLES(section)
#	define ZT_PROFILE_PATHFINDING(section)
#	define ZT_PROFILE_GAME(section)
#endif


// ================================================================================================================================================================================================
// debugging
// ================================================================================================================================================================================================

typedef i32 ztDebugVarID;

void         zt_debuggingInit(const char *settings_file_name, const char *alt_path = nullptr);

ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, i8 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, i16 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, i32 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, i64 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, u8 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, u16 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, u32 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, u64 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, r32 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, r64 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, ztVec2 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, ztVec3 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, ztVec4 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, ztMat4 val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, ztQuat val);
ztDebugVarID   zt_debuggingRegisterVariable  (const char *name, bool val);

i8             zt_debuggingGet_i8            (ztDebugVarID debug_var);
i16            zt_debuggingGet_i16           (ztDebugVarID debug_var);
i32            zt_debuggingGet_i32           (ztDebugVarID debug_var);
i64            zt_debuggingGet_i64           (ztDebugVarID debug_var);
u8             zt_debuggingGet_u8            (ztDebugVarID debug_var);
u16            zt_debuggingGet_u16           (ztDebugVarID debug_var);
u32            zt_debuggingGet_u32           (ztDebugVarID debug_var);
u64            zt_debuggingGet_u64           (ztDebugVarID debug_var);
r32            zt_debuggingGet_r32           (ztDebugVarID debug_var);
r64            zt_debuggingGet_r64           (ztDebugVarID debug_var);
ztVec2         zt_debuggingGet_vec2          (ztDebugVarID debug_var);
ztVec3         zt_debuggingGet_vec3          (ztDebugVarID debug_var);
ztVec4         zt_debuggingGet_vec4          (ztDebugVarID debug_var);
ztMat4         zt_debuggingGet_mat4          (ztDebugVarID debug_var);
ztQuat         zt_debuggingGet_quat          (ztDebugVarID debug_var);
bool           zt_debuggingGet_bool          (ztDebugVarID debug_var);

void           zt_debuggingSet               (ztDebugVarID debug_var, i8 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, i16 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, i32 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, i64 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, u8 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, u16 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, u32 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, u64 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, r32 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, r64 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, ztVec2 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, ztVec3 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, ztVec4 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, ztMat4 val);
void           zt_debuggingSet               (ztDebugVarID debug_var, ztQuat val);
void           zt_debuggingSet               (ztDebugVarID debug_var, bool val);



// ================================================================================================================================================================================================
// loading
//
// the idea of the load state is to offer a consistent and easy way to allow for loading various assets.
//
// Each load function should accept a pointer to a ztLoadInfo, and process the state appropriately:
//
//      ztLoadState_Error:    Do nothing, exit function without changing state.
//      ztLoadState_Query:    Populate the ztLoadInfo with the total number of steps required and change state to ztLoadState_Loading
//      ztLoadState_Loading:  Process loading, one step at a time, setting state to ztLoadState_Complete when finished
//      ztLoadState_Complete: Do nothing, exit function without changing state.
// ================================================================================================================================================================================================

enum ztLoadState_Enum
{
	ztLoadState_Error,
	ztLoadState_Query,
	ztLoadState_Loading,
	ztLoadState_Complete,
};

// ================================================================================================================================================================================================

struct ztLoadInfo
{
	int              total_steps  = 0;
	int              current_step = 0;
	ztLoadState_Enum state        = ztLoadState_Query;
};



// ================================================================================================================================================================================================
// keyboard input
// ================================================================================================================================================================================================

#define _zt_inputKey(inputkey)	__zt_inputKey(inputkey)

#define _zt_input_keysDef \
	_zt_inputKey(ztInputKeys_Invalid),       _zt_inputKey(ztInputKeys_LeftButton),       _zt_inputKey(ztInputKeys_RightButton),    _zt_inputKey(ztInputKeys_Cancel), \
	_zt_inputKey(ztInputKeys_MiddleButton),  _zt_inputKey(ztInputKeys_XButton1),         _zt_inputKey(ztInputKeys_XButton2),       _zt_inputKey(ztInputKeys_Back), \
	_zt_inputKey(ztInputKeys_Tab),           _zt_inputKey(ztInputKeys_Clear),            _zt_inputKey(ztInputKeys_Return),         _zt_inputKey(ztInputKeys_Shift), \
	_zt_inputKey(ztInputKeys_Control),       _zt_inputKey(ztInputKeys_Menu),             _zt_inputKey(ztInputKeys_Pause),          _zt_inputKey(ztInputKeys_Capital), \
	_zt_inputKey(ztInputKeys_Kana),          _zt_inputKey(ztInputKeys_Hangul),           _zt_inputKey(ztInputKeys_Junja),          _zt_inputKey(ztInputKeys_Final), \
	_zt_inputKey(ztInputKeys_Hanja),         _zt_inputKey(ztInputKeys_Kanji),            _zt_inputKey(ztInputKeys_Escape),         _zt_inputKey(ztInputKeys_Convert), \
	_zt_inputKey(ztInputKeys_Nonconvert),    _zt_inputKey(ztInputKeys_Accept),           _zt_inputKey(ztInputKeys_ModeChange),     _zt_inputKey(ztInputKeys_Space), \
	_zt_inputKey(ztInputKeys_Prior),         _zt_inputKey(ztInputKeys_Next),             _zt_inputKey(ztInputKeys_End),            _zt_inputKey(ztInputKeys_Home), \
	_zt_inputKey(ztInputKeys_Left),          _zt_inputKey(ztInputKeys_Up),               _zt_inputKey(ztInputKeys_Right),          _zt_inputKey(ztInputKeys_Down), \
	_zt_inputKey(ztInputKeys_Select),        _zt_inputKey(ztInputKeys_Print),            _zt_inputKey(ztInputKeys_Execute),        _zt_inputKey(ztInputKeys_Snapshot), \
	_zt_inputKey(ztInputKeys_Insert),        _zt_inputKey(ztInputKeys_Delete),           _zt_inputKey(ztInputKeys_Help), \
	\
	_zt_inputKey(ztInputKeys_0),             _zt_inputKey(ztInputKeys_1),                _zt_inputKey(ztInputKeys_2),              _zt_inputKey(ztInputKeys_3),                    _zt_inputKey(ztInputKeys_4), \
	_zt_inputKey(ztInputKeys_5),             _zt_inputKey(ztInputKeys_6),                _zt_inputKey(ztInputKeys_7),              _zt_inputKey(ztInputKeys_8),                    _zt_inputKey(ztInputKeys_9), \
	_zt_inputKey(ztInputKeys_A),             _zt_inputKey(ztInputKeys_B),                _zt_inputKey(ztInputKeys_C),              _zt_inputKey(ztInputKeys_D),                    _zt_inputKey(ztInputKeys_E), \
	_zt_inputKey(ztInputKeys_F),             _zt_inputKey(ztInputKeys_G),                _zt_inputKey(ztInputKeys_H),              _zt_inputKey(ztInputKeys_I),                    _zt_inputKey(ztInputKeys_J), \
	_zt_inputKey(ztInputKeys_K),             _zt_inputKey(ztInputKeys_L),                _zt_inputKey(ztInputKeys_M),              _zt_inputKey(ztInputKeys_N),                    _zt_inputKey(ztInputKeys_O), \
	_zt_inputKey(ztInputKeys_P),             _zt_inputKey(ztInputKeys_Q),                _zt_inputKey(ztInputKeys_R),              _zt_inputKey(ztInputKeys_S),                    _zt_inputKey(ztInputKeys_T), \
	_zt_inputKey(ztInputKeys_U),             _zt_inputKey(ztInputKeys_V),                _zt_inputKey(ztInputKeys_W),              _zt_inputKey(ztInputKeys_X),                    _zt_inputKey(ztInputKeys_Y), \
	_zt_inputKey(ztInputKeys_Z), \
	\
	_zt_inputKey(ztInputKeys_LeftWin),       _zt_inputKey(ztInputKeys_RightWin),         _zt_inputKey(ztInputKeys_Apps),           _zt_inputKey(ztInputKeys_Sleep), \
	_zt_inputKey(ztInputKeys_Numpad0),       _zt_inputKey(ztInputKeys_Numpad1),          _zt_inputKey(ztInputKeys_Numpad2),        _zt_inputKey(ztInputKeys_Numpad3), \
	_zt_inputKey(ztInputKeys_Numpad4),       _zt_inputKey(ztInputKeys_Numpad5),          _zt_inputKey(ztInputKeys_Numpad6),        _zt_inputKey(ztInputKeys_Numpad7), \
	_zt_inputKey(ztInputKeys_Numpad8),       _zt_inputKey(ztInputKeys_Numpad9),          _zt_inputKey(ztInputKeys_Multiply),       _zt_inputKey(ztInputKeys_Add), \
	_zt_inputKey(ztInputKeys_Separator),     _zt_inputKey(ztInputKeys_Substract),        _zt_inputKey(ztInputKeys_Decimal),        _zt_inputKey(ztInputKeys_Divide), \
	\
	_zt_inputKey(ztInputKeys_F1),            _zt_inputKey(ztInputKeys_F2),               _zt_inputKey(ztInputKeys_F3),             _zt_inputKey(ztInputKeys_F4), \
	_zt_inputKey(ztInputKeys_F5),            _zt_inputKey(ztInputKeys_F6),               _zt_inputKey(ztInputKeys_F7),             _zt_inputKey(ztInputKeys_F8), \
	_zt_inputKey(ztInputKeys_F9),            _zt_inputKey(ztInputKeys_F10),              _zt_inputKey(ztInputKeys_F11),            _zt_inputKey(ztInputKeys_F12), \
	_zt_inputKey(ztInputKeys_F13),           _zt_inputKey(ztInputKeys_F14),              _zt_inputKey(ztInputKeys_F15),            _zt_inputKey(ztInputKeys_F16), \
	_zt_inputKey(ztInputKeys_F17),           _zt_inputKey(ztInputKeys_F18),              _zt_inputKey(ztInputKeys_F19),            _zt_inputKey(ztInputKeys_F20), \
	_zt_inputKey(ztInputKeys_F21),           _zt_inputKey(ztInputKeys_F22),              _zt_inputKey(ztInputKeys_F23),            _zt_inputKey(ztInputKeys_F24), \
	\
	_zt_inputKey(ztInputKeys_NumLock),       _zt_inputKey(ztInputKeys_Scroll),           _zt_inputKey(ztInputKeys_LeftShift),      _zt_inputKey(ztInputKeys_RightShift), \
	_zt_inputKey(ztInputKeys_LeftControl),   _zt_inputKey(ztInputKeys_RightControl),     _zt_inputKey(ztInputKeys_LeftMenu),       _zt_inputKey(ztInputKeys_RightMenu), \
	_zt_inputKey(ztInputKeys_BrowserBack),   _zt_inputKey(ztInputKeys_BrowserForward),   _zt_inputKey(ztInputKeys_BrowserRefresh), _zt_inputKey(ztInputKeys_BrowserStop), \
	_zt_inputKey(ztInputKeys_BrowserSearch), _zt_inputKey(ztInputKeys_BrowserFavorites), _zt_inputKey(ztInputKeys_BrowserHome),    _zt_inputKey(ztInputKeys_VolumeMute), \
	_zt_inputKey(ztInputKeys_VolumeDown),    _zt_inputKey(ztInputKeys_VolumeUp),         _zt_inputKey(ztInputKeys_MediaNextTrack), _zt_inputKey(ztInputKeys_MediaPrevTrack), \
	_zt_inputKey(ztInputKeys_MediaStop),     _zt_inputKey(ztInputKeys_MediaPlayPause),   _zt_inputKey(ztInputKeys_LaunchMail),     _zt_inputKey(ztInputKeys_LaunchMediaSelect), \
	_zt_inputKey(ztInputKeys_LaunchApp1),    _zt_inputKey(ztInputKeys_LaunchApp2),       _zt_inputKey(ztInputKeys_Semicolon),      _zt_inputKey(ztInputKeys_Plus), \
	_zt_inputKey(ztInputKeys_Comma),         _zt_inputKey(ztInputKeys_Minus),            _zt_inputKey(ztInputKeys_Period),         _zt_inputKey(ztInputKeys_ForwardSlash), \
	_zt_inputKey(ztInputKeys_Tilda),         _zt_inputKey(ztInputKeys_OpenBrace),        _zt_inputKey(ztInputKeys_BackSlash),      _zt_inputKey(ztInputKeys_CloseBrace), \
	_zt_inputKey(ztInputKeys_Apos),          _zt_inputKey(ztInputKeys_Oem_8),            _zt_inputKey(ztInputKeys_Oem_102),        _zt_inputKey(ztInputKeys_ProcessKey), \
	_zt_inputKey(ztInputKeys_Packet),        _zt_inputKey(ztInputKeys_Attn),             _zt_inputKey(ztInputKeys_Crsel),          _zt_inputKey(ztInputKeys_Exsel), \
	_zt_inputKey(ztInputKeys_Ereof),         _zt_inputKey(ztInputKeys_Play),             _zt_inputKey(ztInputKeys_Zoom),           _zt_inputKey(ztInputKeys_Pa1), \
	_zt_inputKey(ztInputKeys_OemClear),

#define __zt_inputKey(key)	key

// ================================================================================================================================================================================================

enum ztInputKeys_Enum
{
	_zt_input_keysDef

	ztInputKeys_MAX,
};

// ================================================================================================================================================================================================

#undef _zt_inputKey

// ================================================================================================================================================================================================

enum ztInputKeyFlags_Enum
{
	ztInputKeyFlags_Pressed      = (1<<0),
	ztInputKeyFlags_JustPressed  = (1<<1),
	ztInputKeyFlags_JustReleased = (1<<2),
	ztInputKeyFlags_JustRepeated = (1<<3),
	ztInputKeyFlags_StateKey     = (1<<4),
};

// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztInputKeys
{
	ztInputKeys_Enum code;
	i32 flags;

	char name[32];
	char display;
	char shift_display;

	i32 platform_mapping;

	r64 time_pressed;

	bool pressed()      { return zt_bitIsSet(flags, ztInputKeyFlags_Pressed); }
	bool justPressed()  { return zt_bitIsSet(flags, ztInputKeyFlags_JustPressed); }
	bool justReleased() { return zt_bitIsSet(flags, ztInputKeyFlags_JustReleased); }
	bool justRepeated() { return zt_bitIsSet(flags, ztInputKeyFlags_JustRepeated); }
	bool stateKey()     { return zt_bitIsSet(flags, ztInputKeyFlags_StateKey); }

	bool justPressedOrRepeated() {
		return justPressed() || justRepeated();
	}
};
#pragma pack(pop)

// ================================================================================================================================================================================================

#ifndef ZT_MAX_INPUT_KEYSTROKES
#define ZT_MAX_INPUT_KEYSTROKES	16
#endif

// ================================================================================================================================================================================================

bool         zt_inputThisFrame();
ztInputKeys* zt_inputKeysAccessState(); // not thread safe
void         zt_inputKeysCopyState(ztInputKeys input_keys[ztInputKeys_MAX]); // should only be called in main thread
void         zt_inputGetKeyStrokes(ztInputKeys_Enum key_strokes[ZT_MAX_INPUT_KEYSTROKES]);

// ================================================================================================================================================================================================

enum ztInputMouseCursor_Enum
{
	ztInputMouseCursor_None,
	ztInputMouseCursor_Arrow,
	ztInputMouseCursor_ResizeNS,
	ztInputMouseCursor_ResizeEW,
	ztInputMouseCursor_ResizeNWSE,
	ztInputMouseCursor_ResizeSWNE,
	ztInputMouseCursor_IBeam,
	ztInputMouseCursor_Wait,
	ztInputMouseCursor_Cross,
	ztInputMouseCursor_Stop,
	ztInputMouseCursor_Hand,
	ztInputMouseCursor_Help,
};

// ================================================================================================================================================================================================

enum ztInputMouseFlags_Enum
{
	ztInputMouseFlags_Pressed      = (1<<0),
	ztInputMouseFlags_JustPressed  = (1<<1),
	ztInputMouseFlags_JustReleased = (1<<2),
};

// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztInputMouse
{
	i32 screen_x;
	i32 screen_y;

	i32 delta_x;
	i32 delta_y;

	union {
		i32 button_states[3];

		struct {
			i32 button_state_left;
			i32 button_state_right;
			i32 button_state_middle;
		};
	};

	i32 wheel_delta;

	bool over_window;
	ztInputMouseCursor_Enum cursor;

	bool pressed(int button)      { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputKeyFlags_Pressed); }
	bool justPressed(int button)  { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputKeyFlags_JustPressed); }
	bool justReleased(int button) { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputKeyFlags_JustReleased); }

	bool leftPressed()      { return pressed(0); }
	bool leftJustPressed()  { return justPressed(0); }
	bool leftJustReleased() { return justReleased(0); }

	bool rightPressed()      { return pressed(1); }
	bool rightJustPressed()  { return justPressed(1); }
	bool rightJustReleased() { return justReleased(1); }

	bool middlePressed()      { return pressed(2); }
	bool middleJustPressed()  { return justPressed(2); }
	bool middleJustReleased() { return justReleased(2); }
};
#pragma pack(pop)

// ================================================================================================================================================================================================

ztInputMouse* zt_inputMouseAccessState(); // not thread safe
void          zt_inputMouseCopyState(ztInputMouse *input_mouse);

void          zt_inputMouseLook(bool mouse_look);
bool          zt_inputMouseIsLook();

void          zt_inputMouseSetCursor(ztInputMouseCursor_Enum cursor);

// ================================================================================================================================================================================================

enum ztInputControllerFlags_Enum
{
	ztInputControllerFlags_Pressed      = (1 << 0),
	ztInputControllerFlags_JustPressed  = (1 << 1),
	ztInputControllerFlags_JustReleased = (1 << 2),
};

// ================================================================================================================================================================================================

enum ztInputControllerButton_Enum
{
	ztInputControllerButton_DPadUp,
	ztInputControllerButton_DPadDown,
	ztInputControllerButton_DPadLeft,
	ztInputControllerButton_DPadRight,
	ztInputControllerButton_Start,
	ztInputControllerButton_Back,
	ztInputControllerButton_ThumbLeft,
	ztInputControllerButton_ThumbRight,
	ztInputControllerButton_ShoulderLeft,
	ztInputControllerButton_ShoulderRight,
	ztInputControllerButton_A,
	ztInputControllerButton_B,
	ztInputControllerButton_X,
	ztInputControllerButton_Y,
	ztInputControllerButton_TriggerLeft,
	ztInputControllerButton_TriggerRight,
	ztInputControllerButton_ThumbpadLeft,
	ztInputControllerButton_ThumbpadRight,

	ztInputControllerButton_MAX,
};

// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztInputController
{
	bool connected;

	union {
		i32 button_states[ztInputControllerButton_MAX];

		struct {
			i32 button_state_dpad_up;
			i32 button_state_dpad_down;
			i32 button_state_dpad_left;
			i32 button_state_dpad_right;
			i32 button_state_start;
			i32 button_state_back;
			i32 button_state_thumb_left;
			i32 button_state_thumb_right;
			i32 button_state_shoulder_left;
			i32 button_state_shoulder_right;
			i32 button_state_a;
			i32 button_state_b;
			i32 button_state_x;
			i32 button_state_y;

			i32 button_state_trigger_left;
			i32 button_state_trigger_right;
			i32 button_state_thumbpad_left;
			i32 button_state_thumbpad_right;
		};
	};

	union {
		r32 button_times[ztInputControllerButton_MAX];

		struct {
			r32 button_time_dpad_up;
			r32 button_time_dpad_down;
			r32 button_time_dpad_left;
			r32 button_time_dpad_right;
			r32 button_time_start;
			r32 button_time_back;
			r32 button_time_thumb_left;
			r32 button_time_thumb_right;
			r32 button_time_shoulder_left;
			r32 button_time_shoulder_right;
			r32 button_time_a;
			r32 button_time_b;
			r32 button_time_x;
			r32 button_time_y;

			r32 button_time_trigger_left;
			r32 button_time_trigger_right;
			r32 button_time_thumbpad_left;
			r32 button_time_thumbpad_right;
		};
	};

	union {
		r32 analog_values[6];

		struct {
			r32 analog_value_trigger_left;
			r32 analog_value_trigger_right;
			r32 analog_value_thumb_pad_left_x;
			r32 analog_value_thumb_pad_left_y;
			r32 analog_value_thumb_pad_right_x;
			r32 analog_value_thumb_pad_right_y;
		};
	};

	bool pressed(int button)      { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputControllerFlags_Pressed); }
	bool justPressed(int button)  { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputControllerFlags_JustPressed); }
	bool justReleased(int button) { zt_assert(button >= 0 && button < zt_elementsOf(button_states)); return zt_bitIsSet(button_states[button], ztInputControllerFlags_JustReleased); }
};
#pragma pack(pop)

// ================================================================================================================================================================================================

#define ZT_MAX_INPUT_CONTROLLERS	4

// ================================================================================================================================================================================================

ztInputController* zt_inputControllerAccessState(int idx); // not thread safe
void               zt_inputControllerCopyState(ztInputController *input_controller, int idx);
void               zt_inputControllerTriggerHapticFeedback(int idx, r32 strength_low, r32 strength_high);


// ================================================================================================================================================================================================
// Input recording
// ================================================================================================================================================================================================

struct ztInputReplayData
{
	ztInputKeys       input_keys[ztInputKeys_MAX];
	ztInputMouse      input_mouse;
	ztInputController input_controller;
	ztInputKeys_Enum  input_keystrokes[16];

	ztFile            file;

	void             *working_memory;
	i32               working_memory_size;
};

// ================================================================================================================================================================================================

bool zt_inputReplayMakeWriter(ztInputReplayData *replay_data, const char *file_name);
bool zt_inputReplayMakeReader(ztInputReplayData *replay_data, const char *file_name);
void zt_inputReplayFree(ztInputReplayData *replay_data);
bool zt_inputReplayProcessFrame(ztInputReplayData *replay_data, i32 frame, bool *input_this_frame, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztInputController *input_controller, ztInputKeys_Enum input_keystrokes[16]);


// ================================================================================================================================================================================================
// Asset Manager
//
// Using an asset manager is preferable over straight file access because it gives a lot of
// flexibility on how assets are managed.  Using this system allows for seamless use of straight
// files during development and a single packed file for releases.  The system can even be expanded
// to downloading resources from a network source.  It allows for resources to automatically
// reload themselves easily when needed or when the source changes (hot reloading of files).
// ================================================================================================================================================================================================

enum ztAssetManagerSource_Enum
{
	ztAssetManagerSource_Unknown,

	ztAssetManagerSource_Directory,
	ztAssetManagerSource_PackedFile,

	ztAssetManagerSource_MAX,
};

// ================================================================================================================================================================================================

enum ztAssetManagerType_Enum
{
	ztAssetManagerType_Unknown,

	ztAssetManagerType_ImagePNG,
	ztAssetManagerType_ImageJPG,
	ztAssetManagerType_ImageHDR,
	ztAssetManagerType_AudioWAV,

	ztAssetManagerType_Shader,
	ztAssetManagerType_Font,

	ztAssetManagerType_MeshOBJ,
	ztAssetManagerType_MeshFBX,
	ztAssetManagerType_Material,
	ztAssetManagerType_ModelZTM,

	ztAssetManagerType_Xml,

	ztAssetManagerType_MAX,
};

// ================================================================================================================================================================================================

struct ztAssetManager;

typedef i32 ztAssetID; // this is an index into the asset arrays

#define ZT_FUNC_ASSET_UPDATED(name) void name(ztAssetManager *asset_manager, ztAssetID asset_id, void *user_data)
typedef ZT_FUNC_ASSET_UPDATED(zt_assetManagerAssetUpdated_Func);

#define ztAssetManagerMaxAssets	1024

// ================================================================================================================================================================================================

struct ztAssetManager
{
	ztAssetManagerSource_Enum  source;

	const char                     *asset_name       [ztAssetManagerMaxAssets];
	i32                             asset_name_hash  [ztAssetManagerMaxAssets];
	i32                             asset_size       [ztAssetManagerMaxAssets];
	ztAssetManagerType_Enum         asset_type       [ztAssetManagerMaxAssets];
	void                           *asset_data       [ztAssetManagerMaxAssets];

	union {
		struct {
			i64                     asset_modified           [ztAssetManagerMaxAssets];
			ZT_FUNCTION_POINTER_VAR(asset_callbacks          [ztAssetManagerMaxAssets], zt_assetManagerAssetUpdated_Func);
			void                   *asset_callback_user_data [ztAssetManagerMaxAssets];
			ztAssetID               asset_callback_ids       [ztAssetManagerMaxAssets];
			i32                     asset_callbacks_count;
			i32                     asset_modified_check_last_idx; // used internally
		};

		const char                 *asset_file[ztAssetManagerMaxAssets];
	};

	i32                             asset_count;

	union {
		struct {
			ztFile                  packed_file;
			i32                     packed_file_pos[ztAssetManagerMaxAssets];
			char                   *packed_file_names;
		};

		struct {
			char                   *directory;
			int                     directory_len;
			ztDirectoryMonitor      directory_mon;
		};
	};

	ztMemoryArena                  *arena;
};

// ================================================================================================================================================================================================

#define ZT_FUNC_ASSET_MAKE_PACKED_FILE_IGNORE(name) bool name(const char *asset_name, void *user_data)
typedef ZT_FUNC_ASSET_MAKE_PACKED_FILE_IGNORE(ztAssetMakePackedFileIgnore_Func);

//        takes the given directory and places all files in all directories (recursively) into the given packed file (not yet implemented)
bool      zt_assetMakePackedFile         (const char *directory, const char *packed_file, ztMemoryArena *arena = nullptr, ztAssetMakePackedFileIgnore_Func *ignore_func = nullptr, void *ignore_func_user_data = nullptr);

bool      zt_assetManagerLoadDirectory   (ztAssetManager *asset_mgr, const char *directory, ztMemoryArena *arena = nullptr);
bool      zt_assetManagerLoadPackedFile  (ztAssetManager *asset_mgr, const char *packed_file, ztMemoryArena *arena = nullptr);
void      zt_assetManagerFree            (ztAssetManager *asset_mgr);

bool      zt_assetExists                 (ztAssetManager *asset_mgr, const char *asset);
bool      zt_assetExists                 (ztAssetManager *asset_mgr, i32 asset_hash);
bool      zt_assetFileExistsAsAsset      (ztAssetManager *asset_mgr, const char *file_name, i32 *asset_hash);
ztAssetID zt_assetLoad                   (ztAssetManager *asset_mgr, const char *asset);
ztAssetID zt_assetLoad                   (ztAssetManager *asset_mgr, i32 asset_hash);
ztAssetID zt_assetLoad                   (ztAssetManager *asset_mgr, const char *asset, ztAssetID same_location_as);
i32       zt_assetSize                   (ztAssetManager *asset_mgr, ztAssetID asset_id);
bool      zt_assetLoadData               (ztAssetManager *asset_mgr, ztAssetID asset_id, void *data, i32 data_size, bool always_reload = false);

bool      zt_assetClearCache             (ztAssetManager *asset_mgr, ztAssetID asset_id);

//        if reading from a directory, the passed function will be called whenever the file changes
void      zt_assetAddReloadCallback      (ztAssetManager *asset_mgr, ztAssetID asset_id, ZT_FUNCTION_POINTER_VAR(function, zt_assetManagerAssetUpdated_Func), void *user_data);
void      zt_assetRemoveReloadCallback   (ztAssetManager *asset_mgr, ztAssetID asset_id, void *user_data);

void      zt_assetManagerCheckForChanges (ztAssetManager *asset_mgr);


// ================================================================================================================================================================================================
// shaders
// ================================================================================================================================================================================================

typedef i32 ztShaderID;

ztShaderID zt_shaderMake(ztAssetManager *asset_mgr, ztAssetID asset_id);
ztShaderID zt_shaderMake(const char *name, const char *data, i32 data_len);
void       zt_shaderFree(ztShaderID shader_id);

// --------------------------------------------------------
// sets shader variables "model", "projection" and "view"
void       zt_shaderSetCameraMatrices(ztShaderID shader_id, const ztMat4& projection, const ztMat4& view);
void       zt_shaderSetModelMatrices(ztShaderID shader_id, const ztMat4& model);


// ================================================================================================================================================================================================

enum ztShaderVariable_Enum
{
	ztShaderVariable_Invalid,

	ztShaderVariable_Float,
	ztShaderVariable_Int,
	ztShaderVariable_Vec2,
	ztShaderVariable_Vec3,
	ztShaderVariable_Vec4,
	ztShaderVariable_Mat3,
	ztShaderVariable_Mat4,
	ztShaderVariable_Tex,
	ztShaderVariable_TexCube,

	ztShaderVariable_MAX,
};

// ================================================================================================================================================================================================

#ifndef ZT_SHADER_MAX_VARIABLES
#define ZT_SHADER_MAX_VARIABLES		512
#endif

// ================================================================================================================================================================================================

struct ztShaderVariableValues
{
	struct Variable
	{
		ztShaderVariable_Enum type;
		char                  name[64];
		u32                   name_hash;
		bool                  changed;

		union {
			r32 val_float;
			i32 val_int;
			r32 val_vec2[2];
			r32 val_vec3[3];
			r32 val_vec4[4];
			r32 val_mat3[9];
			r32 val_mat4[16];
			i32 val_tex;
		};
	};

	Variable variables[ZT_SHADER_MAX_VARIABLES];
	int      variables_count;
};

// ================================================================================================================================================================================================

void zt_shaderBegin(ztShaderID shader_id);
void zt_shaderEnd(ztShaderID shader_id);

// ================================================================================================================================================================================================

#define ZT_FUNC_SHADER_BEGIN(name) void name(ztShaderID shader_id, void *user_data)
typedef ZT_FUNC_SHADER_BEGIN(ztShaderBegin_Func);

#define ZT_FUNC_SHADER_END(name) void name(ztShaderID shader_id, void *user_data)
typedef ZT_FUNC_SHADER_END(ztShaderEnd_Func);

void zt_shaderSetCallbacks(ztShaderID shader_id, ZT_FUNCTION_POINTER_VAR(begin_func, ztShaderBegin_Func), void *begin_user_data, ZT_FUNCTION_POINTER_VAR(end_func, ztShaderEnd_Func), void *end_user_data);

// ================================================================================================================================================================================================

//   populates the ztShaderVariableValues instance with the variables for the shader, along with default values
void zt_shaderPopulateVariables(ztShaderID shader_id, ztShaderVariableValues *shader_vars);

//   applys the given variable values to the renderer's implementation of the shader
void zt_shaderApplyVariables(ztShaderID shader_id, ztShaderVariableValues *shader_vars);

//   applys the changed variables to the shader
void zt_shaderApplyVariables(ztShaderID shader_id);

// ================================================================================================================================================================================================

//   these functions change the default values of the shader
bool zt_shaderHasVariable(ztShaderID shader_id, const char *variable, ztShaderVariable_Enum *type);
void zt_shaderSetVariableFloat(ztShaderID shader_id, const char *variable, r32 value, bool apply_immediately = false);
void zt_shaderSetVariableInt(ztShaderID shader_id, const char *variable, i32 value, bool apply_immediately = false);
void zt_shaderSetVariableVec2(ztShaderID shader_id, const char *variable, const ztVec2 &value, bool apply_immediately = false);
void zt_shaderSetVariableVec3(ztShaderID shader_id, const char *variable, const ztVec3 &value, bool apply_immediately = false);
void zt_shaderSetVariableVec4(ztShaderID shader_id, const char *variable, const ztVec4 &value, bool apply_immediately = false);
void zt_shaderSetVariableMat4(ztShaderID shader_id, const char *variable, const ztMat4& value, bool apply_immediately = false);
void zt_shaderSetVariableMat3(ztShaderID shader_id, const char *variable, r32 value[12], bool apply_immediately = false);
void zt_shaderSetVariableTex(ztShaderID shader_id, const char *variable, i32 texture_id, bool apply_immediately = false);
void zt_shaderSetVariableTexCube(ztShaderID shader_id, const char *variable, i32 texture_id, bool apply_immediately = false);

bool zt_shaderHasVariable(ztShaderID shader_id, u32 variable_hash, ztShaderVariable_Enum *type);
void zt_shaderSetVariableFloat(ztShaderID shader_id, u32 variable_hash, r32 value, bool apply_immediately = false);
void zt_shaderSetVariableInt(ztShaderID shader_id, u32 variable_hash, i32 value, bool apply_immediately = false);
void zt_shaderSetVariableVec2(ztShaderID shader_id, u32 variable_hash, const ztVec2 &value, bool apply_immediately = false);
void zt_shaderSetVariableVec3(ztShaderID shader_id, u32 variable_hash, const ztVec3 &value, bool apply_immediately = false);
void zt_shaderSetVariableVec4(ztShaderID shader_id, u32 variable_hash, const ztVec4 &value, bool apply_immediately = false);
void zt_shaderSetVariableMat4(ztShaderID shader_id, u32 variable_hash, const ztMat4& value, bool apply_immediately = false);
void zt_shaderSetVariableMat3(ztShaderID shader_id, u32 variable_hash, r32 value[12], bool apply_immediately = false);
void zt_shaderSetVariableTex(ztShaderID shader_id, u32 variable_hash, i32 texture_id, bool apply_immediately = false);
void zt_shaderSetVariableTexCube(ztShaderID shader_id, u32 variable_hash, i32 texture_id, bool apply_immediately = false);

// ================================================================================================================================================================================================

//   these functions allow for temporary changes of a shader's variables
bool zt_shaderHasVariable(ztShaderVariableValues *shader_vars, const char *variable, ztShaderVariable_Enum *type);
int zt_shaderSetVariableFloat(ztShaderVariableValues *shader_vars, const char *variable, r32 value);
int zt_shaderSetVariableInt(ztShaderVariableValues *shader_vars, const char *variable, i32 value);
int zt_shaderSetVariableVec2(ztShaderVariableValues *shader_vars, const char *variable, const ztVec2 &value);
int zt_shaderSetVariableVec3(ztShaderVariableValues *shader_vars, const char *variable, const ztVec3 &value);
int zt_shaderSetVariableVec4(ztShaderVariableValues *shader_vars, const char *variable, const ztVec4 &value);
int zt_shaderSetVariableMat4(ztShaderVariableValues *shader_vars, const char *variable, const ztMat4& value);
int zt_shaderSetVariableMat3(ztShaderVariableValues *shader_vars, const char *variable, r32 value[12]);
int zt_shaderSetVariableTex(ztShaderVariableValues *shader_vars, const char *variable, i32 texture_id);
int zt_shaderSetVariableTexCube(ztShaderVariableValues *shader_vars, const char *variable, i32 texture_id);

bool zt_shaderHasVariable(ztShaderVariableValues *shader_vars, u32 variable_hash, ztShaderVariable_Enum *type);
int zt_shaderSetVariableFloat(ztShaderVariableValues *shader_vars, u32 variable_hash, r32 value);
int zt_shaderSetVariableInt(ztShaderVariableValues *shader_vars, u32 variable_hash, i32 value);
int zt_shaderSetVariableVec2(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec2 &value);
int zt_shaderSetVariableVec3(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec3 &value);
int zt_shaderSetVariableVec4(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec4 &value);
int zt_shaderSetVariableMat4(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztMat4& value);
int zt_shaderSetVariableMat3(ztShaderVariableValues *shader_vars, u32 variable_hash, r32 value[12]);
int zt_shaderSetVariableTex(ztShaderVariableValues *shader_vars, u32 variable_hash, i32 texture_id);
int zt_shaderSetVariableTexCube(ztShaderVariableValues *shader_vars, u32 variable_hash, i32 texture_id);

// ================================================================================================================================================================================================

enum ztShaderDefault_Enum
{
	ztShaderDefault_Solid,                       // no textures
	ztShaderDefault_Unlit,                       // diffuse

#	if !defined(ZT_SHADER_DEFAULT_NO_LIGHTING)
	ztShaderDefault_Lit,                         // diffuse
	ztShaderDefault_LitShadow,                   // diffuse, shadow map, material values
	ztShaderDefault_ShadowDirectional,           // shadow map
	ztShaderDefault_ShadowDirectionalTextured,   // shadow map using textures with alpha
#	endif

	ztShaderDefault_Depth,
	ztShaderDefault_DepthTextured,

	ztShaderDefault_Skybox,
	ztShaderDefault_SignedDistanceField,

	ztShaderDefault_Bright,                      // Renders areas of HDR texture that are > 1
	ztShaderDefault_BlurVert,                    // gaussian blur vertically
	ztShaderDefault_BlurHorz,                    // gaussian blur horizontally

	ztShaderDefault_MAX,
};

// ==============================================

ztShaderID zt_shaderGetDefault(ztShaderDefault_Enum shader_default);


// ================================================================================================================================================================================================

/*
	Shader that writes point light shadow maps to a depth cube map

	Requires vertex information:
		vec3 position

	Requires uniform values:
		mat4  shadow_matrices[6]
		vec3  light_pos
		float far_plane

*/

ztShaderID zt_shaderMakePointLightShadows();


// ================================================================================================================================================================================================

/*
	Standard shader.  Supports PBR (Physically Based Rendering)

	Requires vertex information:
		vec3        position : 0
		vec2        uv : 1
		vec3        normal : 2
		vec4        color : 3
		vec4        tangent : 4
		vec4        bitangent : 5
		ivec4       bones : 6
		vec4        weights : 7


	Requires input textures:
		texture2d   diffuse_tex
		texture2d   specular_tex (metallic)
		texture2d   normal_tex
		texture2d   height_tex
		texture2d   roughness_tex (pbr only)

		textureCube irradiance_map_tex (pbr only)
		textureCube prefilter_map_tex (pbr only)
		texture2d   brdf_lut_tex (pbr only)

		texture2d   directional_light_shadowmap
		textureCube point_lights_shadowmap[] (only if shadowmap_use != 0)
		textureCube spot_lights_shadowmap[] (only if shadowmap_use != 0)


	Requires uniform values (beyond standard)
		mat4        model
		mat4        view
		mat4        projection

		vec4        diffuse_color
		vec4        specular_color

		vec3        view_pos

		mat4        light_matrix
		vec3        light_pos
		float       light_ambient
		float       light_intensity
		vec4        light_color

		PointLight  point_lights[]
		int         point_lights_count
		SpotLight   spot_lights[];
		int         spot_lights_count;

		mat4        bones[]
		int         bones_count


	Lights

		struct PointLight
		{
			vec3  pos;
			float intensity;
			vec3  ambient_color;
			int   shadowmap_use;
			float far_plane;
		}

		struct SpotLight
		{
			vec3  pos;
			float intensity;
			vec3  direction;
			float cutoff_in;
			float cutoff_out;
			vec3  ambient_color;
			int   shadowmap_use;
			float far_plane;
		}

*/

struct ztShaderStandardSettings
{
	bool use_pbr           = false;
	bool directional_light = true;
	int  max_point_lights  = 4;
	int  max_spot_lights   = 4;
	bool support_bones     = false;
	int  max_bones         = 0;

	bool write_position    = true;
	bool write_normal      = true;
};

// ==============================================

ztShaderID zt_shaderMakeStandard(ztShaderStandardSettings *settings);


// ================================================================================================================================================================================================

/*
	Ambient Occlusion shader.
	
	Requires input textures:
		- position_tex : The positions of the pixel in view space (view * model * pos)
		- normal_tex   : The normals of the pixel in view space (view * model * normal)
		- noise_tex    : A 4x4 texture with random colors

	Requires uniform values (beyond standard):
		- mat4  cam_proj : The projection matrix of the 3D camera that rendered the scene
		- float radius   : The radius of the sample testing hemisphere (default .5)
		- float bias     : The bias used to prevent surfaces reading themselves (default .025)
		- int   samples  : The number of samples to take (max 64)
*/

struct ztShaderAmbientOcclusionSettings
{
	bool  generate_noise_tex  = false;
	i32   generated_noise_tex = ztInvalidID;
};

// ==============================================

ztShaderID zt_shaderBuildAmbientOcclusion(ztShaderAmbientOcclusionSettings *settings);

// ================================================================================================================================================================================================

/*
	Tonemap shader.  Adjusts gamma/exposure and adds SSAO and bloom.

	Requires input textures:
		- diffuse_tex : The final renderered image to display on screen
		- bloom_tex   : The blurred bright areas to enhance
		- ao_tex      : The blurred ambient occlusion texture

	Requires uniform values (beyond standard)
		- ao_intensity: intensity of the applied ambient occlusion (only used if name passed in, otherwise defaults to 5)
		- gamma	      : gamma value (0-5)
		- exposure    : exposure value (0-5)
*/

struct ztShaderTonemapSettings
{
	bool  bloom_enabled        = false;
	bool  ao_enabled           = false;

	char *ao_uniform_intensity = nullptr;    // default 5
};

// ==============================================

ztShaderID zt_shaderBuildTonemap(ztShaderTonemapSettings *settings);


// ================================================================================================================================================================================================
// textures
// ================================================================================================================================================================================================

typedef i32 ztTextureID;

#define ztTextureDefault	    0
#define ztTextureDefaultWhite   0
#define ztTextureDefaultBlack   1

enum ztTextureFlags_Enum
{
	ztTextureFlags_MipMaps            = (1<<0),
	ztTextureFlags_DepthMap           = (1<<1), // going to be used for depth information
	ztTextureFlags_PixelPerfect       = (1<<2),
	ztTextureFlags_CubeMap            = (1<<3),
	ztTextureFlags_RenderTargetScreen = (1<<4), // will re-adjust to fit the screen if resized
	ztTextureFlags_HDR                = (1<<5),
	ztTextureFlags_Repeat             = (1<<6), // default behavior is to clamp
	ztTextureFlags_Multisample        = (1<<7),
	ztTextureFlags_FlipOnLoad         = (1<<8),
};

// ================================================================================================================================================================================================

enum ztTextureCubeMapFiles_Enum
{
	ztTextureCubeMapFiles_Right,
	ztTextureCubeMapFiles_Left,
	ztTextureCubeMapFiles_Top,
	ztTextureCubeMapFiles_Bottom,
	ztTextureCubeMapFiles_Back,
	ztTextureCubeMapFiles_Front,

	ztTextureCubeMapFiles_MAX,
};

// ================================================================================================================================================================================================

enum ztTextureColorFormat_Enum
{
	ztTextureColorFormat_RGBA,
	ztTextureColorFormat_RGB,
	ztTextureColorFormat_RGBA16F,
	ztTextureColorFormat_RGB16F,

	ztTextureColorFormat_MAX,
};

// ================================================================================================================================================================================================

ztTextureID zt_textureMake(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 flags = 0);
ztTextureID zt_textureMake(byte *pixels, i32 width, i32 height, i32 flags = 0);
ztTextureID zt_textureMakeFromFile(const char *file, i32 flags = 0);
ztTextureID zt_textureMakeFromFileData(void *data, i32 size, i32 flags = 0);
ztTextureID zt_textureMakeFromPixelData(void *data, i32 width, i32 height, i32 flags = 0);
ztTextureID zt_textureMakeRenderTarget(i32 width, i32 height, i32 flags = 0, r32 scale = 1);
ztTextureID zt_textureMakeCubeMap(ztAssetManager *asset_mgr, const char *asset_format); // format is "data/textures/cubemap_%s.png", with lower case names matching the enum ("right", "left", etc.)
ztTextureID zt_textureMakeCubeMap(ztAssetManager *asset_mgr, ztAssetID files[ztTextureCubeMapFiles_MAX]);
ztTextureID zt_textureMakeCubeMapFromPixelData(byte *data[ztTextureCubeMapFiles_MAX], i32 width, i32 height, i32 depth);
ztTextureID zt_textureMakeCubeMapFromHDR(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 w, i32 h);
ztTextureID zt_textureMakeCubeMapForDepth(i32 dimension);
ztTextureID zt_textureMakeIrradianceCubeMapFromCubeMap(ztTextureID cube_map_texture_id);
ztTextureID zt_textureMakePrefilterCubeMapFromCubeMap(ztTextureID cube_map_texture_id);
ztTextureID zt_textureMakeBidirectionalReflectanceDistributionFunctionLUT(i32 w, i32 h);
ztTextureID zt_textureMakeRandom(ztRandom *random, i32 w, i32 h);
ztTextureID zt_textureMakeColorLUT();

byte       *zt_textureLoadPixelData(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 *width, i32 *height, i32* depth, bool should_flip = true);
byte       *zt_textureLoadPixelData(byte *data, i32 data_size, i32 *width, i32 *height, i32* depth, bool should_flip = true);
void        zt_textureFreePixelData(byte *pixels);

void        zt_textureFree(ztTextureID texture_id);

void        zt_textureSetName(ztTextureID texture_id, const char *name);

void        zt_textureRenderTargetPrepare(ztTextureID texture_id, bool clear);
void        zt_textureRenderTargetCommit(ztTextureID texture_id);
ztTextureID zt_textureRenderTargetAddAttachment(ztTextureID texture_id, ztTextureColorFormat_Enum color_format);
void        zt_textureRenderTargetAttachmentEnable(ztTextureID texture_id, int attachment_idx, bool enable);

ztVec2i     zt_textureGetSize(ztTextureID texture_id);
r32         zt_textureGetRenderTargetScale(ztTextureID texture_id);

void        zt_textureGetPixels(ztTextureID texture_id, byte *pixels); // pixels needs to be w * h * 4

bool        zt_textureIsRenderTarget(ztTextureID texture_id);

// ================================================================================================================================================================================================
// vertex arrays
// ================================================================================================================================================================================================

enum ztVertexArrayDataType_Enum
{
	ztVertexArrayDataType_Float,
	ztVertexArrayDataType_Int,

	ztVertexArrayDataType_MAX,
};

// ================================================================================================================================================================================================

enum ztVertexArrayDrawType_Enum
{
	ztVertexArrayDrawType_Triangles,
	ztVertexArrayDrawType_Lines,
	ztVertexArrayDrawType_Points,

	ztVertexArrayDrawType_MAX,
};

// ================================================================================================================================================================================================

typedef i32 ztVertexArrayID;

// ================================================================================================================================================================================================

struct ztVertexArrayEntry
{
	ztVertexArrayDataType_Enum type;
	i32                        count; // count of type variables (ztVec3 would be 3)
};

// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMake(ztVertexArrayEntry *entries, int entries_count, void *vert_data, int vert_count);
void            zt_vertexArrayFree(ztVertexArrayID vertex_array_id);

bool            zt_vertexArrayUpdate(ztVertexArrayID vertex_array_id, ztVertexArrayEntry *entries, int entries_count, void *vert_data, int vert_count);
void            zt_vertexArrayDraw(ztVertexArrayID vertex_array_id, ztVertexArrayDrawType_Enum draw_type = ztVertexArrayDrawType_Triangles);

int             zt_vertexArrayVertexCount(ztVertexArrayID vertex_array_id);

int             zt_vertexArrayDataSize(ztVertexArrayDataType_Enum type);

i32             zt_vertexArrayGetVertices(ztVertexArrayID vertex_array_id, ztVec3 *vertices, i32 vertices_size); // only works if the first entry is position

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztVertexDefault
{
	ztVec3 position;
	ztVec2 uv;
	ztVec3 normal;
	ztVec4 color;
};
#pragma pack(pop)

// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMakeDefault(ztVertexDefault *vertices, int vertices_count);
ztVertexArrayID zt_vertexArrayUpdateDefault(ztVertexArrayID vertex_array_id, ztVertexDefault *vertices, int vertices_count);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztVertexDefaultLit
{
	ztVec3 position;
	ztVec2 uv;
	ztVec3 normal;
	ztVec4 color;
	ztVec4 tangent;
	ztVec4 bitangent;
};
#pragma pack(pop)

// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMakeDefaultLit(ztVertexDefaultLit *vertices, int vertices_count);
ztVertexArrayID zt_vertexArrayUpdateDefaultLit(ztVertexArrayID vertex_array_id, ztVertexDefaultLit *vertices, int vertices_count);

void            zt_vertexArrayDefaultCalculateTangentBitangent(const ztVertexDefaultLit& v1, const ztVertexDefaultLit& v2, const ztVertexDefaultLit& v3, ztVec4 *tangent, ztVec4 *bitangent);

void            zt_triangleCalculateNormal(const ztVec3& v1, const ztVec3& v2, const ztVec3& v3, ztVec3 *normal);
void            zt_triangleCalculateTangentBitangent(const ztVec3& v1, const ztVec3& v2, const ztVec3& v3, const ztVec2& uv1, const ztVec2& uv2, const ztVec2& uv3, ztVec4 *tangent, ztVec4 *bitangent);


// ================================================================================================================================================================================================
// post processing
// ================================================================================================================================================================================================

struct ztPostProcessingEffect;
struct ztDrawList;
struct ztCamera;

// ================================================================================================================================================================================================

#define FUNC_POST_PROCESSING_EFFECT_RENDER(name)    void name(ztPostProcessingEffect *effect, ztDrawList *draw_list, ztCamera *camera, ztTextureID screen_texture, ztTextureID target_texture)
typedef FUNC_POST_PROCESSING_EFFECT_RENDER(ztPostProcessingEffectRender_Func);

#define FUNC_POST_PROCESSING_EFFECT_SCREEN_CHANGE(name)    void name(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h)
typedef FUNC_POST_PROCESSING_EFFECT_SCREEN_CHANGE(ztPostProcessingEffectScreenChange_Func);

// ================================================================================================================================================================================================

struct ztPostProcessingEffect
{
	ztShaderID  *shaders;
	i32          shaders_count;
	ztTextureID *render_textures;
	i32          render_textures_count;
	void        *user_data;
	i32          screen_width;
	i32          screen_height;

	ZT_FUNCTION_POINTER_VAR(render_func, ztPostProcessingEffectRender_Func);
	ZT_FUNCTION_POINTER_VAR(screen_change_func, ztPostProcessingEffectScreenChange_Func);
};

// ================================================================================================================================================================================================

void zt_postProcessingEffectMake(ztPostProcessingEffect *effect, ztShaderID *shaders, i32 screen_w, i32 screen_h, i32 shaders_count, ztTextureID *render_textures, i32 render_textures_count, void *user_data, ZT_FUNCTION_POINTER_VAR(render_func, ztPostProcessingEffectRender_Func), ZT_FUNCTION_POINTER_VAR(screen_change_func, ztPostProcessingEffectScreenChange_Func));
void zt_postProcessingEffectFree(ztPostProcessingEffect *effect);

void zt_postProcessingEffectUpdateScreen(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Gaussian Blur
// Performs vertical and horizontal gaussian blurs

struct ztPostProcessGaussianBlur
{
	i32 blur_passes;
};

ztPostProcessGaussianBlur *zt_postProcessingEffectMakeBlur(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, i32 blur_passes = 3);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Bloom
// Renders the bright areas of the scene to secondary buffers (sizes based on percentages passed in), then 
// performs vertical and horizontal blurs, then adds each secondary buffer to the scene

struct ztPostProcessBloom
{
	i32 blur_passes;
};

ztPostProcessBloom *zt_postProcessingEffectMakeBloom(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, i32 blur_passes = 3, r32 *percentages = nullptr, i32 percentages_count = 0);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Color LUT
// Uses look up table (LUT) textures to colorize the scene

struct ztPostProcessColorLUT
{
	ztTextureID texture_one;
	ztTextureID texture_two;
	r32         percentage;
};

ztPostProcessColorLUT *zt_postProcessingEffectMakeColorLUT(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, ztTextureID texture_one, ztTextureID texture_two = ztInvalidID, r32 percentage = 0);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: SSAO
// Screen Space Ambient Occlusion

struct ztPostProcessSSAO
{
	ztCamera *camera;
	r32       radius;
	r32       bias;
	int       samples;
	r32       intensity;


	ztTextureID position_tex;
	ztTextureID normal_tex;
	ztTextureID noise_tex;
};

ztPostProcessSSAO *zt_postProcessingEffectMakeSSAO(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, ztCamera *camera, ztTextureID position_tex, ztTextureID normal_tex, ztTextureID noise_tex, r32 radius = .5f, r32 bias = .025f, int samples = 64, r32 intensity = 1.f);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Brightness & Contrast

struct ztPostProcessBrightnessContrast
{
	r32 brightness;
	r32 contrast;
};

ztPostProcessBrightnessContrast *zt_postProcessingEffectMakeBrightnessContrast(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 brightness = 1.f, r32 contrast = 1.f);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Tonemap
// Tonemaps the scene

struct ztPostProcessTonemap
{
	r32 gamma;
	r32 exposure;
};

ztPostProcessTonemap *zt_postProcessingEffectMakeTonemap(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 gamma = 2.2f, r32 exposure = 1.f);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// Effect: Vignette
// Adds a vignette to the scene

struct ztPostProcessVignette
{
	r32 radius;
	r32 softness;
	r32 opacity;
};

ztPostProcessVignette *zt_postProcessingEffectMakeVignette(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 radius = .55f, r32 softness = .75f, r32 opacity = .5f);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessingStack
{
	ztPostProcessingEffect *effects;
	i32                     effects_count;

	ztTextureID             buffer_tex;
};

// ================================================================================================================================================================================================

void zt_postProcessingStackMake(ztPostProcessingStack *stack, i32 screen_w, i32 screen_h, ztPostProcessingEffect *effects, i32 effects_count);
void zt_postProcessingStackFree(ztPostProcessingStack *stack);

void zt_postProcessingStackRender(ztPostProcessingStack *stack, ztTextureID scene_texture, ztDrawList *draw_list, ztCamera *camera);
void zt_postProcessingStackUpdateScreen(ztPostProcessingStack *stack, i32 screen_w, i32 screen_h);


// ================================================================================================================================================================================================
// materials
// ================================================================================================================================================================================================

enum ztMaterialFlags_Enum
{
	ztMaterialFlags_OwnsTexture = (1 << 0),
};

// ================================================================================================================================================================================================

struct ztMaterial
{
	char        name[64]; // used when loading from files

	ztTextureID diffuse_tex;
	ztVec4      diffuse_color;
	i32         diffuse_flags;
	u32         diffuse_tex_override; // shader variable name override
	u32         diffuse_color_override;

	ztTextureID specular_tex;
	ztVec4      specular_color;
	i32         specular_flags;
	u32         specular_tex_override;
	u32         specular_color_override;

	ztTextureID normal_tex;
	i32         normal_flags;
	u32         normal_tex_override;

	ztTextureID height_tex;
	i32         height_flags;
	u32         height_tex_override;

	ztTextureID roughness_tex;
	i32         roughness_flags;
	u32         roughness_tex_override;

	ztTextureID emissive_tex;
	i32         emissive_flags;
	u32         emissive_tex_override;
	r32         emissive_strength;
	u32         emissive_strength_override;

	r32         shininess;
	u32         shininess_override;
};


ztMaterial zt_materialMake(ztTextureID diffuse_tex = ztInvalidID, const ztVec4 &diffuse_color = ztVec4::one, i32 diffuse_flags = 0, 
						   ztTextureID specular_tex = ztInvalidID, const ztVec4 &specular_color = ztVec4::one, i32 specular_flags = 0,
						   ztTextureID normal_tex = ztInvalidID, i32 normal_flags = 0,
						   ztTextureID height_tex = ztInvalidID, i32 height_flags = 0,
						   ztTextureID roughness_tex = ztInvalidID, i32 roughness_flags = 0,
						   ztTextureID emissive_tex = ztInvalidID, i32 emissive_flags = 0, r32 emissive_strength = 1.f,
						   r32 shininess = 0.5f);

int zt_materialLoad(ztAssetManager *asset_mgr, ztAssetID asset_id, ztMaterial *materials_arr, int materials_arr_size);
int zt_materialLoadFromFile(char *file_name, ztMaterial *materials_arr, int materials_arr_size);

void zt_materialFree(ztMaterial *material);

bool zt_materialIsEmpty(ztMaterial *material);
bool zt_materialIsEqual(ztMaterial *material1, ztMaterial *material2);

void zt_materialPrepare(ztMaterial *material, ztShaderID shader, ztTextureID *additional_tex = nullptr, u32 *additional_tex_name_hashes = nullptr, int additional_tex_count = 0);


// ================================================================================================================================================================================================
// meshes
//
// The standard mesh consists of six parts, in this order:
// 
// ztVec3 position
// ztVec2 uv
// ztVec3 normal
// ztVec4 color
// ztVec4 tangent
// ztVec4 bitangent
// 
// If you need to pass additional information through to the shader, use the version of the call that
// takes the additional_data param and the stride amount.  For example, if you need to also send the
// following to the shader:
//
// int    bone_index	(4 bytes)
// float  bone_weight	(4 bytes)
//
// You would do that like this:
//
// #pragma pack(push, 1)
// struct BoneInfo {
//     int bone_index;
//     float bone_weight;
// };
// #pragma pack(pop)
//
// BoneInfo bone_info_array[vert_count] = {
//     {ztVec4i(0, 1, 2, 3), zt_vec4(.25f, .25f, .25f, .25f)},
//     {ztVec4i(0, 1, 2, 3), zt_vec4(.25f, .25f, .25f, .25f)},
//     {ztVec4i(0, 1, 2, 3), zt_vec4(.25f, .25f, .25f, .25f)},
//     ...
// };
//
// ztVertexArrayEntry bone_info_entry[2] = {
//     { ztVertexArrayDataType_Int, 4 },
//     { ztVertexArrayDataType_Float, 4 },
// };
//
// zt_meshMake(verts, uvs, normals, vert_count, indices, indices_count, bone_info_array, bone_info_entry, zt_elementsOf(bone_info_entry));
// ================================================================================================================================================================================================

typedef i32 ztMeshID;

// ================================================================================================================================================================================================

// NOTE: UV coordinates are 0,0 = top left, 1,1 = bottom right

ztMeshID zt_meshMake(ztVec3 *verts, ztVec2 *uvs, ztVec3 *normals, i32 vert_count, u32 *indices, i32 indices_count, ztColor color = ztColor_White);
ztMeshID zt_meshMake(ztVec3 *verts, ztVec2 *uvs, ztVec3 *normals, i32 vert_count, u32 *indices, i32 indices_count, void *additional_data, ztVertexArrayEntry *entries, int entries_count, ztColor color = ztColor_White);
void     zt_meshFree(ztMeshID mesh_id);

ztMeshID zt_meshMakePrimitiveBox(r32 width, r32 height, r32 depth, ztColor color = ztColor_White);
ztMeshID zt_meshMakePrimitivePlane(r32 width, r32 depth, int grid_w = 1, int grid_d = 1, ztColor color = ztColor_White);
ztMeshID zt_meshMakePrimitiveDiamond(r32 width, r32 top, r32 bottom, int sides, ztColor color = ztColor_White);

void     zt_meshGetOBB(ztMeshID mesh_id, ztVec3 *center, ztVec3 *size);

enum ztMeshPrimativeSphere_Enum
{
	ztMeshPrimitiveSphere_TexDuplicatedPerFace, // the quadrilateralised spherical cube maps the same texture on each of the 6 faces
	ztMeshPrimitiveSphere_TexWrapped,           // the texture coordinates are in the shape of a T with the T at the top of the texture
};

ztMeshID zt_meshMakePrimitiveSphere(r32 radius, int rings, ztMeshPrimativeSphere_Enum texture, ztColor color = ztColor_White);

int      zt_meshLoadOBJ(ztAssetManager *asset_mgr, ztAssetID asset_id, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale = ztVec3::one, const ztVec3 &offset = ztVec3::zero);
int      zt_meshLoadOBJ(char *data, i32 data_len, const char *mtl_search_dir, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale = ztVec3::one, const ztVec3 &offset = ztVec3::zero);
int      zt_meshLoadOBJ(char *file_name, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale = ztVec3::one, const ztVec3 &offset = ztVec3::zero);

void     zt_meshRender(ztMeshID mesh_id);

i32      zt_meshGetVertices(ztMeshID mesh_id, ztVec3 *vertices, i32 vertices_size);

// ================================================================================================================================================================================================
// transform
// ================================================================================================================================================================================================

struct ztTransform
{
	ztVec3 position;
	ztQuat rotation;
	ztVec3 scale;
};


ztTransform zt_transformMake(const ztVec3 &position = ztVec3::zero, const ztQuat &rotation = ztQuat::identity, const ztVec3 &scale = ztVec3::one);
void        zt_transformMake(ztTransform *transform, const ztVec3 &position = ztVec3::zero, const ztQuat &rotation = ztQuat::identity, const ztVec3 &scale = ztVec3::one);

ztMat4      zt_transformToMat4(ztTransform *transform);     // scale, translate, rotate
ztMat4      zt_transformToMat4SRT(ztTransform *transform);  // scale, rotate, translate
ztMat4      zt_transformToMat4RT(ztTransform *transform);   // rotate, translate
ztMat4      zt_transformToMat4TR(ztTransform *transform);   // translate, rotate

ztMat4      zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation);
ztMat4      zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale);

void        zt_transformToMat4(ztTransform *transform, ztMat4 *mat);     // translate, rotate, scale
void        zt_transformToMat4SRT(ztTransform *transform, ztMat4 *mat);  // rotate, scale, translate
void        zt_transformToMat4RT(ztTransform *transform, ztMat4 *mat);  // rotate, translate
void        zt_transformToMat4TR(ztTransform *transform, ztMat4 *mat);  // translate, rotate

void        zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, ztMat4 *mat);
void        zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale, ztMat4 *mat);

ztTransform zt_transformFromMat4(const ztMat4 *mat);
void        zt_transformFromMat4(ztTransform *transform, const ztMat4 *mat);

void        zt_transformApplyMat4(ztTransform *transform, const ztMat4 *mat);


// ================================================================================================================================================================================================
// plane
// ================================================================================================================================================================================================

struct ztPlane
{
	ztVec3 normal;
	r32    distance;
};


ztPlane zt_planeMake(const ztVec3 &p0, const ztVec3 &p1, const ztVec3 &p2);
void    zt_planeNormalize(ztPlane *plane);
r32     zt_planeDistanceFromPoint(const ztPlane *plane, const ztVec3 &point);

// ================================================================================================================================================================================================
// camera
// ================================================================================================================================================================================================

enum ztCameraType_Enum
{
	ztCameraType_Invalid,
	ztCameraType_Orthographic,
	ztCameraType_Perspective,

	ztCameraType_MAX,
};

// ================================================================================================================================================================================================

struct ztCamera
{
	ztCameraType_Enum type;

	ztVec3 position;

	i32 width, height;
	r32 near_z, far_z;

	ztMat4 mat_view, mat_proj;

	union {
		struct { // orthographic only
			i32 native_w, native_h;
			r32 zoom;
		};

		struct { // perspective only
			r32 fov;
			ztQuat rotation;
			ztVec3 direction;
		};
	};

};

// ================================================================================================================================================================================================

void zt_cameraMakeOrtho(ztCamera *camera, i32 width, i32 height, i32 native_w, i32 native_h, r32 near_z, r32 far_z, const ztVec3 &position = ztVec3::zero);
void zt_cameraMakePersp(ztCamera *camera, i32 width, i32 height, r32 fov, r32 near_z, r32 far_z, const ztVec3 &position = ztVec3::zero, const ztQuat& rotation = ztQuat::identity);

void zt_cameraRecalcMatrices(ztCamera *camera); // should be called anytime position or rotation changes
void zt_cameraCalcFinalMatrix(ztCamera *camera, ztMat4* final_mat);

// it is sometimes useful to set the camera matrices when the position/rotation is not known (such as with vr hmds)
void zt_cameraSetMatrices(ztCamera *camera, ztMat4& proj, ztMat4& view);

void     zt_cameraOrthoGetExtents(ztCamera *camera, ztVec2 *min_ext, ztVec2 *max_ext);
ztVec2   zt_cameraOrthoGetMaxExtent(ztCamera *camera);
ztVec2   zt_cameraOrthoGetMinExtent(ztCamera *camera);
ztVec2   zt_cameraOrthoGetViewportSize(ztCamera *camera);
ztVec2   zt_cameraOrthoScreenToWorld(ztCamera *camera, int sx, int sy);
ztVec2i  zt_cameraOrthoWorldToScreen(ztCamera *camera, ztVec2 pos);

void     zt_cameraPerspGetMouseRay(ztCamera *camera, int sx, int sy, ztVec3 *point, ztVec3 *direction);
void     zt_cameraPerspGetMouseRayLocalToMatrix(ztCamera *camera, int sx, int sy, ztVec3 *point, ztVec3 *direction, ztMat4 *matrix_inv);
ztVec2i  zt_cameraPerspWorldToScreen(ztCamera *camera, ztVec3 pos);

void     zt_cameraLookAt(ztCamera *camera, const ztVec3 &target, const ztVec3 &up = zt_vec3(0,1,0));

bool     zt_cameraSave(ztCamera *camera, ztSerial *serial);
bool     zt_cameraLoad(ztCamera *camera, ztSerial *serial);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef CAMERA_SHAKE_MAX_SAMPLES
#define CAMERA_SHAKE_MAX_SAMPLES	1000
#endif

// ================================================================================================================================================================================================

struct ztCameraShake
{
	ztVec3   original_position;
	r32      duration;
	r32      current_time;

	r32      frequency;
	r32      amplitude;
	i32      sample_count;

	r32      samples_x[CAMERA_SHAKE_MAX_SAMPLES];
	r32      samples_y[CAMERA_SHAKE_MAX_SAMPLES];

	ztRandom randomizer;

	ztVec2   offset;

	r32      ramp_up;
	r32      ramp_up_progress;
};

// ================================================================================================================================================================================================

// NOTE: Once prerender is applied, camera matrices need recalculated.  Also after postrender.

ztCameraShake zt_cameraShakeMake(r32 duration, r32 speed, r32 intensity, i32 seed, r32 ramp_up = 0);
void          zt_cameraShakeStart(ztCameraShake *camera_shake);
void          zt_cameraShakeUpdate(ztCameraShake *camera_shake, r32 dt);
bool          zt_cameraShakePreRender(ztCameraShake *camera_shake, ztCamera *camera);
bool          zt_cameraShakePostRender(ztCameraShake *camera_shake, ztCamera *camera);
void          zt_cameraShakeUpdateMultiple(ztCameraShake *camera_shake, int camera_shake_count, r32 dt);
void          zt_cameraShakePreRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztCamera *camera);
void          zt_cameraShakePostRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztCamera *camera);

struct ztDrawList;

void          zt_cameraShakePreRender(ztCameraShake *camera_shake, ztDrawList *draw_list);
void          zt_cameraShakePostRender(ztCameraShake *camera_shake, ztDrawList *draw_list);
void          zt_cameraShakePreRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztDrawList *draw_list);
void          zt_cameraShakePostRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztDrawList *draw_list);

// ================================================================================================================================================================================================

struct ztFrustum
{
	union {
		struct {
			ztVec3 near_nw;
			ztVec3 near_ne;
			ztVec3 near_se;
			ztVec3 near_sw;
			ztVec3 far_nw;
			ztVec3 far_ne;
			ztVec3 far_se;
			ztVec3 far_sw;
		};

		struct{
			ztVec3 points[8];
		};

		struct {
			ztVec3 near_rect[4];
			ztVec3 far_rect[4];
		};
	};

	union {
		struct {
			ztPlane plane_near;
			ztPlane plane_left;
			ztPlane plane_right;
			ztPlane plane_top;
			ztPlane plane_bottom;
			ztPlane plane_far;
		};

		struct {
			ztPlane planes[6];
		};
	};

	ztFrustum& operator=(const ztFrustum& f);
};

// ================================================================================================================================================================================================

ztFrustum zt_cameraCalcViewFrustum(ztCamera *camera, r32 far_z = 0, r32 near_z = 0, const ztVec3 &world_offset = ztVec3::zero);
void      zt_cameraCalcViewFrustum(ztFrustum *frustum, ztCamera *camera, r32 far_z = 0, r32 near_z = 0, const ztVec3 &world_offset = ztVec3::zero);

ztFrustum zt_mat4CalcViewFrustumPersp(ztMat4 *mat_view, ztMat4 *mat_proj, r32 fov, r32 width, r32 height, r32 near_z, r32 far_z);
void      zt_mat4CalcViewFrustumPersp(ztFrustum *frustum, ztMat4 *mat_view, ztMat4 *mat_proj, r32 fov, r32 width, r32 height, r32 near_z, r32 far_z);

ztFrustum zt_mat4CalcViewFrustumOrtho(ztMat4 *mat_view, ztMat4 *mat_proj, r32 width, r32 height, r32 near_z, r32 far_z);
void      zt_mat4CalcViewFrustumOrtho(ztFrustum *frustum, ztMat4 *mat_view, ztMat4 *mat_proj, r32 width, r32 height, r32 near_z, r32 far_z);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztCameraControllerFPSFlags_Enum
{
	ztCameraControllerFPSFlags_LockYAxis      = (1<<0),
	ztCameraControllerFPSFlags_MoveYDirection = (1<<1),
};

// ================================================================================================================================================================================================

struct ztCameraControllerFPS
{
	// settings:
	ztCamera *camera;

	ztVec3 prev_pos;

	r32 mouse_sensitivity;
	r32 speed;
	r32 boosted_speed;
	r32 sneaking_speed;

	i32 flags;

	// per-frame input:
	r32 mouse_delta_x;
	r32 mouse_delta_y;

	bool is_boosted;
	bool is_sneaking;

	r32 move_back;
	r32 move_forward;
	r32 strafe_left;
	r32 strafe_right;

	// used internally:
	ztVec3 rotation;
	ztVec3 velocity;
};

// ================================================================================================================================================================================================

ztCameraControllerFPS zt_cameraControllerMakeFPS(ztCamera *camera, ztVec3 initial_rotation = ztVec3::zero, i32 flags = ztCameraControllerFPSFlags_MoveYDirection);
void                  zt_cameraControlUpdateFPS(ztCameraControllerFPS *controller, r32 dt);
void                  zt_cameraControlUpdateWASD(ztCameraControllerFPS *controller, ztInputMouse *input_mouse, ztInputKeys *input_keys, r32 dt); // simple WASD + mouse look camera manipulation - good for testing

bool                  zt_cameraControllerFPSSave(ztCameraControllerFPS *controller, ztSerial *serial); // saves/loads the camera as well
bool                  zt_cameraControllerFPSLoad(ztCameraControllerFPS *controller, ztSerial *serial);

// ================================================================================================================================================================================================

enum ztCameraControllerArcballUpdateFlags_Enum
{
	ztCameraControllerArcballUpdateFlags_IgnoreKeys = (1 << 0),
};

struct ztCameraControllerArcball
{
	// settings:
	ztCamera *camera;

	r32 mouse_sensitivity;

	ztVec3 target;
	ztQuat rotation;

	// per-frame input:
	r32 mouse_delta_x;
	r32 mouse_delta_y;

	bool is_boosted;
	bool is_sneaking;


	// used internally:
};	

// ================================================================================================================================================================================================

ztCameraControllerArcball zt_cameraControllerMakeArcball(ztCamera *camera, ztVec3 target = ztVec3::zero);
void                      zt_cameraControlUpdateArcball(ztCameraControllerArcball *controller, ztInputMouse *input_mouse, ztInputKeys *input_keys, r32 dt, i32 flags);

bool                      zt_cameraControllerArcballSave(ztCameraControllerArcball *controller, ztSerial *serial); // saves/loads the camera as well
bool                      zt_cameraControllerArcballLoad(ztCameraControllerArcball *controller, ztSerial *serial);


// ================================================================================================================================================================================================
// character controller
// ================================================================================================================================================================================================

struct ztMovingBody;
struct ztPhysics;

// ================================================================================================================================================================================================

enum ztCharacterControllerFlags_Enum
{
	ztCharacterControllerFlags_CanFly           = (1 << 0),
	ztCharacterControllerFlags_FloatsOverGround = (1 << 1), // makes movement speed consistent regardless of ground angle
	ztCharacterControllerFlags_IgnoreXRotation  = (1 << 2),
};

// ================================================================================================================================================================================================

enum ztCharacterControllerStateFlags_Enum
{
	ztCharacterControllerStateFlags_Grounded      = (1 << 0),
	ztCharacterControllerStateFlags_OnSlope       = (1 << 1),
	ztCharacterControllerStateFlags_CollidingWall = (1 << 2),
};

// ================================================================================================================================================================================================

struct ztCharacterController
{
	// settings
	ztMovingBody *moving_body;

	i32           flags;
	i32           state_flags;
	r32           state_time;
	i32           state_flags_prev;

	r32           speed_sneak;
	r32           speed_walk;
	r32           speed_run;
	r32           velocity_jump;
	r32           slowdown_speed;
	r32           velocity_damping;
	r32           min_ramp_dot;

	// current status
	ztVec3        velocity;
	ztVec3        rotation;
	ztVec3        last_dir;

	ztVec3        grounded_normal;


	r32           move_z;
	r32           move_x;
	r32           move_y;
	r32           jumping;

	r32           rotate_horz;
	r32           rotate_vert;

	r32           running_time;
	r32           sneaking_time;
};


void zt_characterControllerMake             (ztCharacterController *controller, ztMovingBody *moving_body, i32 flags = 0);
void zt_characterControllerUpdatePrePhysics (ztCharacterController *controllers, int controllers_count, ztPhysics *physics, r32 dt, const ztVec3 &gravity);
void zt_characterControllerUpdatePostPhysics(ztCharacterController *controllers, int controllers_count, r32 dt);

// ================================================================================================================================================================================================

struct ztCharacterCameraController
{
	ztCharacterController *ctrl;
	ztCamera              *camera;
	ztVec3                 offset_from_center;

	r32                    mouse_sensitivity;

	ztTransform            transform;
};


void zt_characterCameraControllerMake       (ztCharacterCameraController *char_cam_ctrl, ztCharacterController *character_controller, ztMovingBody *moving_body, ztCamera *camera, r32 player_height, const ztVec3 &offset_from_center, ztPhysics *physics);
void zt_characterCameraControllerPlayerInput(ztCharacterCameraController *char_cam_ctrl, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztInputController *input_controller, r32 dt);
void zt_characterCameraControllerSync       (ztCharacterCameraController *char_cam_ctrl);


// ================================================================================================================================================================================================
// renderer functions
// ================================================================================================================================================================================================

bool zt_rendererSupported(ztRenderer_Enum renderer);
int zt_rendererSupportedList(ztRenderer_Enum* renderers, int renderers_count);

bool zt_rendererVersionSupported(ztRenderer_Enum renderer, i32 v_major, i32 v_minor);
bool zt_rendererGetMaxVersionSupported(ztRenderer_Enum renderer, i32* v_major, i32* v_minor);

void zt_rendererClear(r32 r, r32 g, r32 b, r32 a);
void zt_rendererClear(ztVec4 clr);
void zt_rendererClearDepth();

bool zt_rendererUvsFlipYRenderTarget();

// ================================================================================================================================================================================================

enum ztRendererDepthTestFunction_Enum
{
	ztRendererDepthTestFunction_Never,
	ztRendererDepthTestFunction_Less,
	ztRendererDepthTestFunction_LessEqual,
	ztRendererDepthTestFunction_Equal,
	ztRendererDepthTestFunction_Greater,
	ztRendererDepthTestFunction_NotEqual,
	ztRendererDepthTestFunction_GreaterEqual,
	ztRendererDepthTestFunction_Always,
};

void zt_rendererSetDepthTest(bool depth_test, ztRendererDepthTestFunction_Enum function);
void zt_rendererEnableDepthWriting(bool depth_writing);


// ================================================================================================================================================================================================

enum ztRendererFaceCulling_Enum
{
	ztRendererFaceCulling_CullBack,
	ztRendererFaceCulling_CullFront,
	ztRendererFaceCulling_CullNone,
};

void zt_rendererSetFaceCulling(ztRendererFaceCulling_Enum culling);

// ================================================================================================================================================================================================

enum ztRendererBlendMode_Enum
{
	ztRendererBlendMode_Zero,
	ztRendererBlendMode_One,
	ztRendererBlendMode_SourceColor,
	ztRendererBlendMode_OneMinusSourceColor,
	ztRendererBlendMode_DestColor,
	ztRendererBlendMode_OneMinusDestColor,
	ztRendererBlendMode_SourceAlpha,
	ztRendererBlendMode_OneMinusSourceAlpha,
	ztRendererBlendMode_DestAlpha,
	ztRendererBlendMode_OneMinusDestAlpha,

	ztRendererBlendMode_MAX,
};

void zt_rendererSetBlendMode(ztRendererBlendMode_Enum source = ztRendererBlendMode_SourceAlpha, ztRendererBlendMode_Enum dest = ztRendererBlendMode_OneMinusSourceAlpha);

// ================================================================================================================================================================================================

void zt_rendererRequestChange(ztRenderer_Enum renderer);
void zt_rendererRequestWindowed();
void zt_rendererRequestWindowedBorderless();
void zt_rendererRequestFullscreen();
void zt_rendererRequestResolution(ztVec2i resolution);
void zt_rendererRequestUpdatePixelsPerUnit(r32 ppu);

void zt_alignToPixel(r32 *val, r32 ppu);
void zt_alignToPixel(r32 *val, r32 ppu, r32 *offset);
void zt_alignToPixel(ztVec2 *val, r32 ppu);
void zt_alignToPixel(ztVec3 *val, r32 ppu);

// ================================================================================================================================================================================================
// resolutions
// ================================================================================================================================================================================================

enum ztAspectRatio_Enum
{
	ztAspectRatio_Unknown,

	ztAspectRatio_16x10,
	ztAspectRatio_16x9,
	ztAspectRatio_4x3,

	ztAspectRatio_MAX,
};

// ================================================================================================================================================================================================

struct ztResolution
{
	ztDisplay          display;
	ztAspectRatio_Enum aspect_ratio;
	ztVec2i            dimensions;
};

int zt_resolutionGetAvailable(ztResolution *resolutions, int resolutions_count, i32 aspect_ratio_flags, ztVec2i minimum = zt_vec2i(0,0), bool current_display_only = true); // use zt_bit() on aspect ratios to limit


// ================================================================================================================================================================================================
// rendering
// ================================================================================================================================================================================================

enum ztDrawCommandType_Enum
{
	ztDrawCommandType_Invalid,

	ztDrawCommandType_Point,
	ztDrawCommandType_Line,
	ztDrawCommandType_Triangle,

	ztDrawCommandType_Skybox,
	ztDrawCommandType_Billboard,
	ztDrawCommandType_VertexArray,

	ztDrawCommandType_ChangeShader,
	ztDrawCommandType_ChangeTexture,
	ztDrawCommandType_ChangeColor,
	ztDrawCommandType_ChangeClipping,
	ztDrawCommandType_ChangeFlags,
	ztDrawCommandType_ChangeOffset,
	ztDrawCommandType_ChangeTransform,
	ztDrawCommandType_ChangeBlendMode,

	ztDrawCommandType_DebugItem,

	ztDrawCommandType_MAX,
};

// ================================================================================================================================================================================================

enum ztDrawCommandBillboardFlags_Enum
{
	ztDrawCommandBillboardFlags_AxisX = (1<<0),
	ztDrawCommandBillboardFlags_AxisY = (1<<1),
	ztDrawCommandBillboardFlags_AxisZ = (1<<2),

	ztDrawCommandBillboardFlags_AxisAll = ztDrawCommandBillboardFlags_AxisX | ztDrawCommandBillboardFlags_AxisY | ztDrawCommandBillboardFlags_AxisZ,
};

// ================================================================================================================================================================================================

#ifndef ZT_DRAW_COMMAND_MAX_TEXTURES
#define ZT_DRAW_COMMAND_MAX_TEXTURES	12
#endif

// ================================================================================================================================================================================================

struct ztDrawCommand
{
	ztDrawCommandType_Enum type;

	union {
		struct {
			char debug[64];
		};

		struct {
			ztVec3 point;
		};

		struct {
			ztVec3 line[2];
		};

		struct {
			ztVec3 tri_pos[3];
			ztVec2 tri_uv[3];
			ztVec3 tri_norm[3];
			ztVec4 tri_color[3];
		};

		struct {
			ztShaderID shader;
			bool       shader_pop;
		};

		struct {
			ztColor color;
			bool    color_pop;
		};

		struct {
			ztTextureID texture[ZT_DRAW_COMMAND_MAX_TEXTURES];
			i32         texture_count;
			bool        texture_pop;
		};

		struct {
			ztVec2         clip_center;
			ztVec2         clip_size;
			int            clip_idx;
			ztDrawCommand *clip_prev;
			bool           clip_pop;
		};

		struct {
			i32 flags;
		};

		struct {
			ztVec3 offset;
			bool   offset_pop;
		};

		struct {
			ztMat4 transform;
			bool   transform_pop;
		};

		struct {
			ztVec3 billboard_center;
			ztVec2 billboard_size;
			ztVec4 billboard_uv;
			ztVec3 billboard_up;
			i32    billboard_flags;
			r32    billboard_rotation;
		};

		struct {
			ztVertexArrayID            vertex_array;
			ztVertexArrayDrawType_Enum vertex_array_draw_type;
		};

		struct {
			ztRendererBlendMode_Enum blend_src;
			ztRendererBlendMode_Enum blend_dest;
			bool                     blend_pop;
		};
	};

	zt_debugOnly(i32 debug_id);
};

// ================================================================================================================================================================================================

enum ztDrawListFlags_Enum
{
	ztDrawListFlags_NoReset = (1 << 0),
};

// ================================================================================================================================================================================================

struct ztDrawList
{
	ztDrawCommand *commands;
	i32 commands_size;
	i32 commands_count;

	i32 flags;

	ztDrawCommand *current_clip;

	ztMemoryArena *arena;

	zt_debugOnly(int active_shaders);
	zt_debugOnly(int active_textures);
};

// ================================================================================================================================================================================================

// NOTE: UV coordinates for draw lists are 0,0 = top left, 1,1 = top right

bool zt_drawListMake(ztDrawList *draw_list, i32 max_commands, i32 flags = 0, ztMemoryArena *arena = zt_memGetGlobalArena());
void zt_drawListFree(ztDrawList *draw_list);

bool zt_drawListAddPoint(ztDrawList *draw_list, const ztVec3 &p);
bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2);
bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec3 p[2]);
bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec2 &p1, const ztVec2 &p2);
bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec2 p[2]);
bool zt_drawListAddBezierCurve(ztDrawList *draw_list, ztVec2 beg, ztVec2 end, ztVec2 beg_cp, ztVec2 end_cp, int segments);
bool zt_drawListAddBezierCurve(ztDrawList *draw_list, ztVec3 beg, ztVec3 end, ztVec3 beg_cp, ztVec3 end_cp, int segments);
bool zt_drawListAddEmptyTriangle(ztDrawList *draw_list, const ztVec3 p[3]);
bool zt_drawListAddEmptyTriangle(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3);
bool zt_drawListAddEmptyQuad(ztDrawList *draw_list, const ztVec3 p[4]); // clockwise or counter clockwise positions
bool zt_drawListAddEmptyQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4);
bool zt_drawListAddEmptyRect(ztDrawList *draw_list, const ztVec2 &pos, const ztVec2 &size);
bool zt_drawListAddEmptyRect(ztDrawList *draw_list, const ztVec3 &pos, const ztVec2 &size);
bool zt_drawListAddEmptyCircle(ztDrawList *draw_list, const ztVec2 &pos, r32 radius, int points);
bool zt_drawListAddEmptyCircle(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points);
bool zt_drawListAddEmptyCubeFromCenterSize(ztDrawList *draw_list, const ztVec3 &pos, const ztVec3 &size);
bool zt_drawListAddEmptyCubeFromMinMax(ztDrawList *draw_list, const ztVec3 &min, const ztVec3 &max);
bool zt_drawListAddEmptySimpleSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points);
bool zt_drawListAddEmptySimpleSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points, int rings);
bool zt_drawListAddEmptySimpleAxisSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points, const ztVec4 &color_x = zt_vec4(1, 0, 0, 1), const ztVec4 &color_y = zt_vec4(0, 1, 0, 1), const ztVec4 &color_z = zt_vec4(0, 0, 1, 1));
bool zt_drawListAddEmptyBone(ztDrawList *draw_list, const ztVec3 &start, r32 size, r32 radius, r32 top);
bool zt_drawListAddFilledTriangle(ztDrawList *draw_list, const ztVec3 p[3], const ztVec2 uvs[3], const ztVec3 normals[3]);
bool zt_drawListAddFilledTriangle(ztDrawList *draw_list, const ztVec3 p[3], const ztVec2 uvs[3], const ztVec3 normals[3], const ztVec4 colors[3]);
bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4, const ztVec2 &uv1, const ztVec2 &uv2, const ztVec2 &uv3, const ztVec2 &uv4, const ztVec3 &n1, const ztVec3 &n2, const ztVec3 &n3, const ztVec3 &n4); // points need to be ccw
bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4, const ztVec2 &uv1, const ztVec2 &uv2, const ztVec2 &uv3, const ztVec2 &uv4, const ztVec3 &n1, const ztVec3 &n2, const ztVec3 &n3, const ztVec3 &n4, const ztVec4 &c1, const ztVec4 &c2, const ztVec4 &c3, const ztVec4 &c4); // points need to be ccw
bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 p[4], const ztVec2 uvs[4], const ztVec3 normals[4]);
bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 p[4], const ztVec2 uvs[4], const ztVec3 normals[4], const ztVec4 colors[4]);
bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se);
bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, const ztVec4 colors[4]);
bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se);
bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, const ztVec4 colors[4]);
bool zt_drawListAddFilledCubeFromCenterSize(ztDrawList *draw_list, const ztVec3 &pos, const ztVec3 &size);
bool zt_drawListAddFilledCubeFromMinMax(ztDrawList *draw_list, const ztVec3 &min, const ztVec3 &max);
bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor& color);
bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor colors[4]);
bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor& color);
bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor color[4]);
bool zt_drawListAddSolidCircle2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, r32 radius, int points, const ztColor& color, ztQuat *apply_rotation = nullptr);
bool zt_drawListAddSolidCircle2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, r32 radius, int points, const ztColor& color, ztQuat *apply_rotation = nullptr);
bool zt_drawListAddSolidOutlinedRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor& color, const ztColor& outline_color);
bool zt_drawListAddSolidOutlinedRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor& color, const ztColor& outline_color);
bool zt_drawListAddSolidOutlinedCircle2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, r32 radius, int points, const ztColor& color, const ztColor& outline_color);
bool zt_drawListAddSolidOutlinedCircle2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, r32 radius, int points, const ztColor& color, const ztColor& outline_color);
bool zt_drawListAddBillboard(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, i32 flags = ztDrawCommandBillboardFlags_AxisAll, ztVec3 up = zt_vec3(0,1,0));
bool zt_drawListAddBillboard(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, r32 rotation, const ztVec2 &uv_nw, const ztVec2 &uv_se, i32 flags = ztDrawCommandBillboardFlags_AxisAll, ztVec3 up = zt_vec3(0, 1, 0));
bool zt_drawListAddFilledPoly(ztDrawList *draw_list, const ztVec3 *p, const ztVec2 *uvs, const ztVec3 *normals, int count);
bool zt_drawListAddFilledPoly(ztDrawList *draw_list, const ztVec3 *p, const ztVec2 *uvs, const ztVec3 *normals, ztVec4 *colors, int count);
bool zt_drawListAddDrawList(ztDrawList *draw_list, ztDrawList *draw_list_to_add, const ztVec3 &offset = ztVec3::zero);

bool zt_drawListAddFrustum(ztDrawList *draw_list, ztFrustum *frustum);
bool zt_drawListAddFloorGrid(ztDrawList *draw_list, const ztVec3 &center, r32 width, r32 depth, r32 grid_w = 1, r32 grid_d = 1);
bool zt_drawListAddVertexArray(ztDrawList *draw_list, ztVertexArrayID vertex_array_id, ztVertexArrayDrawType_Enum draw_type);
bool zt_drawListAddAxis(ztDrawList *draw_list, r32 size = 1, const ztVec3 &center = ztVec3::zero, const ztVec4 &color_x = zt_vec4(1, 0, 0, 1), const ztVec4 &color_y = zt_vec4(0, 1, 0, 1), const ztVec4 &color_z = zt_vec4(0, 0, 1, 1));
bool zt_drawListAddAxis(ztDrawList *draw_list, const ztMat4& mat, r32 size = 1, const ztVec3 &center = ztVec3::zero, const ztVec4 &color_x = zt_vec4(1, 0, 0, 1), const ztVec4 &color_y = zt_vec4(0, 1, 0, 1), const ztVec4 &color_z = zt_vec4(0, 0, 1, 1));
bool zt_drawListAddPointMarker(ztDrawList *draw_list, const ztVec3 &pos, r32 size = 1, bool color_axis = false);

bool zt_drawListAddScreenRenderTexture(ztDrawList *draw_list, ztTextureID tex, ztCamera *camera, r32 scale = 1, ztShaderID shader = ztInvalidID);

bool zt_drawListPushShader(ztDrawList *draw_list, ztShaderID shader);
bool zt_drawListPopShader(ztDrawList *draw_list);
bool zt_drawListPushColor(ztDrawList *draw_list, const ztColor& color);
bool zt_drawListPopColor(ztDrawList *draw_list);
bool zt_drawListPushTexture(ztDrawList *draw_list, ztTextureID tex_id);
bool zt_drawListPushTexture(ztDrawList *draw_list, ztTextureID *tex_ids, int tex_count);
bool zt_drawListPopTexture(ztDrawList *draw_list);
bool zt_drawListPushClipRegion(ztDrawList *draw_list, ztVec2 center, ztVec2 size); // window coords
bool zt_drawListPopClipRegion(ztDrawList *draw_list);
bool zt_drawListPushDrawFlags(ztDrawList *draw_list, i32 flags);
bool zt_drawListPopDrawFlags(ztDrawList *draw_list);
bool zt_drawListPushOffset(ztDrawList *draw_list, const ztVec3 &offset);
bool zt_drawListPopOffset(ztDrawList *draw_list);
bool zt_drawListPushTransform(ztDrawList *draw_list, const ztMat4& transform);
bool zt_drawListPopTransform(ztDrawList *draw_list);
bool zt_drawListPushBlendMode(ztDrawList *draw_list, ztRendererBlendMode_Enum src, ztRendererBlendMode_Enum dest);
bool zt_drawListPopBlendMode(ztDrawList *draw_list);

bool zt_drawListAddDebugItem(ztDrawList *draw_list, const char *debug); // useful when inspecting array of drawlist in debugger

ztShaderID zt_drawListGetCurrentShader(ztDrawList *draw_list);


void zt_drawListReset(ztDrawList *draw_list);

enum ztRenderDrawListFlags_Enum
{
	ztRenderDrawListFlags_NoClear = (1<<0),
	ztRenderDrawListFlags_Wireframe = (1<<1),
	ztRenderDrawListFlags_NoDepthTest = (1<<2),

	ztRenderDrawListFlags_DebugDump = (1<<31),
};

void zt_renderDrawList(ztCamera *camera, ztDrawList *draw_list, const ztColor& clear, i32 flags, ztTextureID render_target_id = ztInvalidID);
void zt_renderDrawLists(ztCamera *camera, ztDrawList **draw_lists, int draw_lists_count, const ztColor& clear, i32 flags, ztTextureID render_target_id = ztInvalidID);


// ================================================================================================================================================================================================
// debug
// ================================================================================================================================================================================================

struct ztDebugDisplayItem
{
	r32    time_to_persist; // keep item displayed for this time period
	ztGuid guid;            // group items.  if this is set, these items will persist until the guid is removed
};

// do not store the ztDebugDisplayItem pointer, it's for immediate use only

ztDebugDisplayItem *zt_debugDisplayGuiLine(const ztVec3 &p0, const ztVec3 &p1, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayGuiCircle(r32 radius, i32 points, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayGuiRect(const ztVec2 &size, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayGuiText(const char *text, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayGuiTextList(const char *text);

ztDebugDisplayItem *zt_debugDisplayLine(const ztVec3 &p0, const ztVec3 &p1, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayCircle(r32 radius, i32 points, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayCircle(r32 radius, i32 points, const ztMat4 &transform, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayRect(const ztVec2 &size, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayRect(const ztVec2 &size, const ztMat4 &transform, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplaySphere(r32 radius, i32 points, i32 rings, const ztVec3 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplaySphere(r32 radius, i32 points, i32 rings, const ztMat4 &transform, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayCube(const ztVec3 &size, const ztVec3 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayCube(const ztVec3 &size, const ztMat4 &transform, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayText(const char *text, const ztVec2 &pos, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayText(const char *text, const ztMat4 &transform, const ztColor &color);
ztDebugDisplayItem *zt_debugDisplayAxis(r32 size, const ztVec3 &pos, const ztQuat &rot);
ztDebugDisplayItem *zt_debugDisplayAxis(r32 size, const ztMat4 &transform);


void zt_debugDisplayInit(i32 max_items = 1024, i32 string_pool_size = zt_megabytes(1));
void zt_debugDisplayCleanup();

void zt_debugDisplayRemoveGuidItems(const ztGuid &guid);

void zt_debugDisplayRenderWorld(ztDrawList *draw_list, ztCamera *camera);
void zt_debugDisplayRenderGui(ztDrawList *draw_list, ztCamera *camera, bool clear_for_next_frame = true);

void zt_debugDisplayManualClear();



// ================================================================================================================================================================================================
// sprites
// ================================================================================================================================================================================================

struct ztSprite
{
	ztTextureID tex;
	ztVec4 tex_uv;
	ztVec2 half_size;
	ztVec2 anchor;
};

ztSprite zt_spriteMake(ztTextureID tex, int x, int y, int w, int h, int anchor_x = 0, int anchor_y = 0);
ztSprite zt_spriteMake(ztTextureID tex, ztVec2i pos, ztVec2i size, ztVec2i anchor = zt_vec2i(0, 0));
ztSprite zt_spriteMakeFromGrid(ztTextureID tex, int x, int y, int w, int h, int anchor_x = 0, int anchor_y = 0, int pixel_border = 0);
ztSprite zt_spriteMakeFromGrid(ztTextureID tex, ztVec2i pos, ztVec2i size, ztVec2i anchor = zt_vec2i(0, 0), int pixel_border = 0);
void     zt_spriteGetTriangles(ztSprite *sprite, const ztVec3 &at_pos, ztVec3 pos[6], ztVec2 uvs[6]);
void     zt_spriteGetTriangles(ztSprite *sprite, const ztVec3 &at_pos, const ztVec3 &rotation, const ztVec3 &scale, ztVec3 pos[6], ztVec2 uvs[6]);

// the fast versions do not align to pixel (useful if the positions are already pixel aligned)
void     zt_spriteGetTrianglesFast(ztSprite *sprite, const ztVec3 &at_pos, ztVec3 pos[6], ztVec2 uvs[6]);
void     zt_spriteGetTrianglesFast(ztSprite *sprite, const ztVec3 &at_pos, const ztVec3 &rotation, const ztVec3 &scale, ztVec3 pos[6], ztVec2 uvs[6]);

void zt_drawListAddSprite(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos);
void zt_drawListAddSprite(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos, const ztVec3 &rot, const ztVec3 &scale);
void zt_drawListAddSpriteTiled(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos, const ztVec2 &area);

// the fast versions do not align to pixel (useful if the positions are already pixel aligned)
void zt_drawListAddSpriteFast(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos);
void zt_drawListAddSpriteFast(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos, const ztVec3 &rot, const ztVec3 &scale);


// ================================================================================================================================================================================================

struct ztSpriteNineSlice
{
	ztTextureID tex;
	ztVec4 sp_nw, sp_n, sp_ne, sp_w, sp_c, sp_e, sp_sw, sp_s, sp_se;
	r32 sz_n, sz_s, sz_e, sz_w, sz_cw, sz_ch;

	ztVec4 offset;
};

ztSpriteNineSlice zt_spriteNineSliceMake(ztTextureID tex, int tex_x, int tex_y, int tex_w, int tex_h, int nw_interior_x, int nw_interior_y, int se_interior_x, int se_interior_y, int offset_l = 0, int offset_t = 0, int offset_r = 0, int offset_b = 0);
ztSpriteNineSlice zt_spriteNineSliceMake(ztTextureID tex, ztVec2i tex_pos, ztVec2i tex_size, ztVec2i nw_interior, ztVec2i se_interior, int offset_l = 0, int offset_t = 0, int offset_r = 0, int offset_b = 0);

void zt_drawListAddSpriteNineSlice(ztDrawList *draw_list, ztSpriteNineSlice *sns, const ztVec2 &pos, const ztVec2 &size);
void zt_spriteNineSliceGetTriangles(ztSpriteNineSlice *sns, const ztVec2 &at_pos, const ztVec2 &size, ztVec2 pos[54], ztVec2 uvs[54]);

// ================================================================================================================================================================================================

enum ztSpriteType_Enum
{
	ztSpriteType_Invalid,
	ztSpriteType_SpriteNineSlice,
	ztSpriteType_Sprite,
};

// ================================================================================================================================================================================================

struct ztSpriteManager
{
	struct Entry {
		i32                    hash;
		char                   name[64];
		ztSpriteType_Enum      type;

		union {
			ztSprite           s;
			ztSpriteNineSlice  sns;
		};
	};

	Entry  *sprites;
	int     sprites_count;
};


void               zt_spriteManagerMake(ztSpriteManager *sprite_manager, int max_sprites);
bool               zt_spriteManagerLoad(ztSpriteManager *sprite_manager, ztAssetManager *asset_mgr, ztAssetID asset_id, ztTextureID tex);
bool               zt_spriteManagerLoad(ztSpriteManager *sprite_manager, ztSerial *serial, ztTextureID tex);
bool               zt_spriteManagerLoadAll(ztSpriteManager *sprite_manager); // loads all .spr files from the data/textures directory
bool               zt_spriteManagerSave(ztSpriteManager *sprite_manager, ztSerial *serial);
void               zt_spriteManagerFree(ztSpriteManager *sprite_manager, bool should_free_textures = false);

void               zt_spriteManagerAddSprite(ztSpriteManager *sprite_manager, ztSprite *s, char *name);
void               zt_spriteManagerAddSpriteNineSlice(ztSpriteManager *sprite_manager, ztSpriteNineSlice *sns, char *name);

ztSprite          *zt_spriteManagerGetSprite(ztSpriteManager *sprite_manager, const char *name);
ztSprite          *zt_spriteManagerGetSprite(ztSpriteManager *sprite_manager, i32 sprite_hash);
ztSpriteNineSlice *zt_spriteManagerGetSpriteNineSlice(ztSpriteManager *sprite_manager, const char *name);
ztSpriteNineSlice *zt_spriteManagerGetSpriteNineSlice(ztSpriteManager *sprite_manager, i32 sprite_hash);

i32                zt_spriteManagerFindSpriteHash(ztSpriteManager *sprite_manager, ztSprite *sprite);

// ================================================================================================================================================================================================
// lighting
// ================================================================================================================================================================================================

enum ztLightType_Enum
{
	ztLightType_Directional,
	ztLightType_Spot,
	ztLightType_Point,

	ztLightType_MAX,
};

// ================================================================================================================================================================================================

struct ztLight
{
	ztLightType_Enum   type;

	ztVec3             position;
	ztVec3             direction;
	bool               casts_shadows;
	
	ztColor            color;
	r32                intensity;
	r32                ambient;

	r32                cutoff_in;
	r32                cutoff_out;
};

// ================================================================================================================================================================================================

ztLight zt_lightMakeDirectional  (const ztVec3 &pos, const ztVec3 &dir, r32 intensity = 1, r32 ambient = .25f, bool casts_shadows = true, const ztColor& color = ztVec4::one);
ztLight zt_lightMakeSpot         (const ztVec3 &pos, const ztVec3 &dir, r32 intensity = 1, r32 cutoff_in = zt_degreesToRadians(45), r32 cutoff_out = zt_degreesToRadians(65), bool casts_shadows = true, const ztColor& color = ztVec4::one);
ztLight zt_lightMakeArea         (const ztVec3 &pos, r32 intensity = 1, bool casts_shadows = true, const ztColor& color = ztVec4::one);


// ================================================================================================================================================================================================
// bones
// ================================================================================================================================================================================================

enum ztBoneFlags_Enum
{
	ztBoneFlags_DebugDrawHighlight = (1<<31),
};

// ================================================================================================================================================================================================

struct ztModel;
struct ztSpriteAnimController;
struct ztParticleEmitter;
struct ztAnimController;

// ================================================================================================================================================================================================

struct ztBone
{
	int         index;
	ztString    name;
	i32         flags;

	ztTransform transform;      // current location of bone
	ztTransform transform_base; // resting location of bone
	r32         size;

	ztBone     *first_child;
	ztBone     *next;
	ztBone     *parent;

	ztMat4      mat_model;      // bone in model space
	ztMat4      mat_offset;
	ztMat4      mat_local_bind_transform;
	ztMat4      mat_inverse_bind_transform;
};

// ================================================================================================================================================================================================

#define ZT_MAX_BONES	200

// ================================================================================================================================================================================================
// models
// ================================================================================================================================================================================================

enum ztModelFlags_Enum
{
	ztModelFlags_Initialized    = (1<<0),

	ztModelFlags_NoFaceCull     = (1<<1),
	ztModelFlags_Translucent    = (1<<2),
	ztModelFlags_CastsShadows   = (1<<3),
	ztModelFlags_Hidden         = (1<<4),
	ztModelFlags_OwnsMaterials  = (1<<5),
	ztModelFlags_OwnsMesh       = (1<<6),
	ztModelFlags_NoCalcBones    = (1<<7), // sometimes models share bones, and only one needs to do the transform calculations
	ztModelFlags_ShadowOnly     = (1<<8), // only renders shadows

	ztModelFlags_DebugDrawAxis  = (1<<16),
	ztModelFlags_DrawOrigin     = (1<<17),
	ztModelFlags_DebugDrawAABB  = (1<<18),
	ztModelFlags_DebugDrawOBB   = (1<<19),
	ztModelFlags_DebugDrawBones = (1<<20),

	// set automically when using internal shaders, but can be set manually
	ztModelFlags_ShaderSupportsDiffuse          = (1<<26),		// "diffuse_tex", "diffuse_color"
	ztModelFlags_ShaderSupportsSpecular         = (1<<27),		// "specular_tex", "specular_color"
	ztModelFlags_ShaderSupportsNormal           = (1<<28),		// "normal_tex"
	ztModelFlags_ShaderSupportsHeight           = (1<<29),		// "height_tex"
	ztModelFlags_ShaderSupportsDirectionalLight = (1<<30),		// "light_matrix", "light_pos", "view_pos"
};

// ================================================================================================================================================================================================

enum ztModelType_Enum
{
	ztModelType_Invalid,

	ztModelType_Empty,
	ztModelType_Mesh,
	ztModelType_VertexArray,
	ztModelType_Sprite,
	ztModelType_SpriteAnimation,
	ztModelType_ParticleSystem,

	ztModelType_MAX,
};

// ================================================================================================================================================================================================

enum ztModelSpriteFacing_Enum
{
	ztModelSpriteFacing_Billboard,

	ztModelSpriteFacing_PosX,
	ztModelSpriteFacing_PosY,
	ztModelSpriteFacing_PosZ,
	ztModelSpriteFacing_NegX,
	ztModelSpriteFacing_NegY,
	ztModelSpriteFacing_NegZ,

	ztModelSpriteFacing_MAX,
};

// ================================================================================================================================================================================================

struct ztModel
{
	ztModelType_Enum        type;

	union
	{
		struct {
			ztMeshID                 mesh_id;
		};

		struct {
			ztVertexArrayID          vertex_array_id;
		};

		struct {
			ztSprite                 sprite;
			ztModelSpriteFacing_Enum sprite_facing;
		};

		struct {
			ztSpriteAnimController  *sprite_anim_controller;
			ztModelSpriteFacing_Enum sprite_anim_facing;
		};

		struct {
			ztParticleEmitter       *particle_emitter;
		};
	};

	ztTransform             transform;
	i32                     flags;

	ztString                name;

	ztShaderID              shader;
	ztShaderVariableValues *shader_vars;

	ztMaterial              material;
	ztModel                *first_child;
	ztModel                *next;
	ztModel                *parent;

	ztMat4                  calculated_mat;
	ztTransform             calculated_transform;

	ztBone                 *bones;
	int                     bones_count;
	int                     bones_root_idx;

	ztMat4                  prev_mat;
	ztVec3                  aabb_center, aabb_size;
	ztVec3                  obb_center, obb_size;

	ztAnimController       *anim_controller;
};

// ================================================================================================================================================================================================

bool     zt_modelMakeFromMesh                (ztModel *model, ztMeshID mesh_id, ztMaterial *materials, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent = nullptr);
bool     zt_modelMakeFromVertexArray         (ztModel *model, ztVertexArrayID va_id, ztMaterial *material, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent = nullptr);
bool     zt_modelMakeFromSprite              (ztModel *model, ztSprite *sprite, ztModelSpriteFacing_Enum facing, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent = nullptr);
bool     zt_modelMakeFromSpriteAnimController(ztModel *model, ztSpriteAnimController *sprite_anim_controller, ztModelSpriteFacing_Enum facing, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent = nullptr);
bool     zt_modelMakeFromParticleEmitter     (ztModel *model, ztParticleEmitter *emitter, ztMaterial *materials, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent = nullptr);
void     zt_modelFree                        (ztModel *model);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztAnimController;

struct ztModelLoaderInput
{
	ztModel          *models;         // pointer to cache of models available for use
	int               models_size;    // size of cache

	ztBone           *bones;          // pointer to cache of bones available for use
	int               bones_size;     // size of cache

	int               models_used;    // (OUT) number of models used out of cache
	int               bones_used;     // (OUT) number of bones used out of cache

	ztModel          *root_model;     // (OUT) the root model of the hierarchy
};

bool     zt_modelMakeFromZtmFile(ztModelLoaderInput *input, ztAssetManager *asset_manager, ztAssetID asset_id, ztShaderID shader, int flags);
bool     zt_modelMakeFromZtmFile(ztModelLoaderInput *input, const char *file_name, ztShaderID shader, int flags);
bool     zt_modelMakeFromZtmFile(ztModelLoaderInput *input, void *data, i32 data_size, ztShaderID shader, int flags);

bool     zt_modelClone(ztModelLoaderInput *input, ztModel *model_to_clone);


// ================================================================================================================================================================================================

bool     zt_modelMakeSkybox (ztModel *model, ztTextureID texture_id, bool owns_texture = false);

void     zt_modelCalcMatrix (ztModel *model, const ztVec3 &world_offset = ztVec3::zero);

void     zt_modelGetAABB    (ztModel *model, ztVec3 *center, ztVec3 *size);
void     zt_modelGetOBB     (ztModel *model, ztVec3 *center, ztVec3 *size);


// ================================================================================================================================================================================================

enum ztModelGetVerticesTransform_Enum
{
	ztModelGetVerticesTransform_NoTransform,
	ztModelGetVerticesTransform_LocalTransform,
	ztModelGetVerticesTransform_WorldTransform,

	ztModelGetVerticesTransform_MAX,
};

// ================================================================================================================================================================================================

i32      zt_modelGetVertices(ztModel *model, ztVec3 *vertices, i32 vertices_size, ztModelGetVerticesTransform_Enum transform);


// ================================================================================================================================================================================================

void     zt_modelChildAdd   (ztModel *parent_model, ztModel *child_model);
void     zt_modelChildRemove(ztModel *parent_model, ztModel *child_model);

i32      zt_modelGetChildCount(ztModel *model, bool immediate_children_only);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================

struct ztModelEditWidget
{
	ztModel                   *model;
	ztBone                    *bone;
	ztTransform               *transform;

	bool                       hover;
	int                        hover_axis;
	bool                       dragging;

	r32                        ray_intersect_dist;
	ztVec3                     ray_intersect_offset;
	ztVec3                     start_value;
	r32                        accum_value;

	enum Control_Enum
	{
		Control_RotateX,
		Control_RotateY,
		Control_RotateZ,
		Control_TranslateX,
		Control_TranslateY,
		Control_TranslateZ,
		Control_ScaleX,
		Control_ScaleY,
		Control_ScaleZ,
		Control_ScaleAll,

		Control_MAX,
	};

	ztVec3     *verts             [Control_MAX];
	i32         verts_count       [Control_MAX];
	ztVec3      verts_aabb_center [Control_MAX];
	ztVec3      verts_aabb_size   [Control_MAX];
	i32         verts_active;
	ztVec2i     pull_dir;
	r32         pull_dist;

	r32         snap_amount_translate;
	r32         snap_amount_rotation;
	r32         snap_amount_scale;

	ztVec2i     dragging_origin;
	ztTransform dragging_transform_origin;
};

// ================================================================================================================================================================================================

bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztModel *model);
bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztBone  *bone);
bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztTransform *transform);
void zt_modelEditWidgetFree(ztModelEditWidget *widget);
bool zt_modelEditWidgetUpdate(ztModelEditWidget *widget, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztCamera *camera, r32 dt);
void zt_modelEditWidgetRender(ztModelEditWidget *widget, ztCamera *camera, ztDrawList *draw_list);
void zt_modelEditWidgetRenderText(ztModelEditWidget *widget, ztCamera *camera_3d, ztCamera *camera_2d, /*ztFontID*/i32 font_id, ztVec2 offset, ztDrawList *draw_list);
bool zt_modelEditWidgetIsMouseWithinBounds(ztModelEditWidget *widget, ztCamera *camera_3d, int screen_x, int screen_y);

void zt_modelEditWidgetProcessWidgetModelFile(const char *file_name);

// ================================================================================================================================================================================================
// scenes
// ================================================================================================================================================================================================

enum ztSceneModelFlags_Enum
{
	ztSceneModelFlags_ShaderLit       = (1<<1),
	ztSceneModelFlags_ShaderBones     = (1<<2),
	ztSceneModelFlags_HasTranslucent  = (1<<3),
	ztSceneModelFlags_ExcludeFromCull = (1<<4),

	ztSceneModelFlags_Culled          = (1<<31),
};

// ================================================================================================================================================================================================

enum ztSceneLightFlags_Enum
{
	ztSceneLightFlags_ExcludeFromCull = (1<<4),

	ztSceneLightFlags_Culled          = (1<<31),
};

// ================================================================================================================================================================================================

#ifndef ZT_SCENE_MAX_LIGHTS
#define ZT_SCENE_MAX_LIGHTS	64
#endif

// ================================================================================================================================================================================================

enum ztSceneRenderStage_Enum
{
	ztSceneRenderStage_Invalid,
	ztSceneRenderStage_Shadows,
	ztSceneRenderStage_Depth,
	ztSceneRenderStage_Render,

	ztSceneRenderStage_MAX,
};

// ================================================================================================================================================================================================

struct ztScene;

// ================================================================================================================================================================================================

#define ZT_FUNC_SCENE_RENDER_MODEL_OVERRIDE(name) void name(ztScene *scene, i32 scene_model_info_index, ztModel *model, ztShaderID *shader_to_use, i32 *model_info_flags_to_use, i32 *model_flags_to_use, ztSceneRenderStage_Enum render_stage, void *user_data)
typedef ZT_FUNC_SCENE_RENDER_MODEL_OVERRIDE(ztSceneRenderModelOverride_Func);

// ================================================================================================================================================================================================

struct ztScene
{
	struct ModelInfo
	{
		ztModel                        *model;
		i32                             flags;
		r32                             dist_from_cam;

		ztVec3                          aabb_center;
		ztVec3                          aabb_size;

		ztModel                        *root_parent;

		ZT_FUNCTION_POINTER_VAR(        render_override, ztSceneRenderModelOverride_Func);
		void                           *render_override_user_data;

		i32                             index;
	};

	struct LightInfo
	{
		ztLight                        *light;
		ztTextureID                     shadowmap_tex;
		r32                             far_plane;
		i32                             flags;
		r32                             dist_from_cam;
	};


	ModelInfo                          *models;
	int                                 models_count;
	int                                 models_size;

	ModelInfo                         **list_std; // standard/opaque models ordered in distance from camera
	i32                                 list_std_count;
	ModelInfo                         **list_trn;
	i32                                 list_trn_count;

	LightInfo                         **list_light; // ordered in distance from camera
	i32                                 list_light_count;

	LightInfo                           directional_light;
	LightInfo                           lights[ZT_SCENE_MAX_LIGHTS];
	i32                                 lights_count;

	ModelInfo                           skybox;

	r32                                 culling_distance;
	i32                                 models_culled;

	ztMemoryArena                      *arena;

	ztTextureID                         tex_directional_shadow_map;
	ztTextureID                         tex_depth;
	ztTextureID                         tex_irradiance_map;
	ztTextureID                         tex_prefilter_map;
	ztTextureID                         tex_brdf_lut;

	ztShaderID                          shader_point_light_shadows;

	ztVertexArrayID                     vertex_array;
	ztVertexDefaultLit                 *vertex_array_vertices;
	int                                 vertex_array_vertices_idx;
	int                                 vertex_array_size;

	ZT_FUNCTION_POINTER_VAR(            render_override, ztSceneRenderModelOverride_Func);
	void                               *render_override_user_data;

	ztVec3                              extents_min;
	ztVec3                              extents_max;
};

// ================================================================================================================================================================================================

struct ztSceneLightingRules
{
	r32 shadow_max_distance           = 50.f;
	r32 shadow_distance_behind_camera = 20.f;
};

// ================================================================================================================================================================================================

ztScene *zt_sceneMake(ztMemoryArena *arena, int max_models = 1024, int shadow_map_res = 4096);
void     zt_sceneFree(ztScene *scene);

bool     zt_sceneMakeVertexArray(ztScene *scene, int max_vertices);

void     zt_sceneAddLight(ztScene *scene, ztLight *light, int shadow_map_res = 1024, i32 flags = 0);
void     zt_sceneSetSkybox(ztScene *scene, ztModel *skybox);
void     zt_sceneAddDepthPass(ztScene *scene, i32 w, i32 h);

void     zt_sceneAddModel(ztScene *scene, ztModel *model, i32 flags = 0);
void     zt_sceneRemoveModel(ztScene *scene, ztModel *model);
void     zt_sceneRefreshModel(ztScene *scene, ztModel *model);
bool     zt_sceneHasModel(ztScene *scene, ztModel *model);
bool     zt_sceneHasLight(ztScene *scene, ztLight *light);

bool     zt_sceneAddRenderOverride(ztScene *scene, ZT_FUNCTION_POINTER_VAR(render_override, ztSceneRenderModelOverride_Func), void *render_override_user_data);
bool     zt_sceneAddRenderOverrideForModel(ztScene *scene, ztModel *model, ZT_FUNCTION_POINTER_VAR(render_override, ztSceneRenderModelOverride_Func), void *render_override_user_data);

// --------------------------------------------------------
// Updates model animations
void     zt_sceneUpdate(ztScene *scene, r32 dt);

// --------------------------------------------------------
// Calculates matrices for scene models (should be called after physics)
void     zt_scenePrepare(ztScene *scene, ztCamera *camera, const ztVec3 &world_offset = ztVec3::zero);

// --------------------------------------------------------
// Culls models and lights based on camera view (not absolutely necessary)
void     zt_sceneOptimize(ztScene *scene, ztCamera *camera);

// --------------------------------------------------------
// Generate shadow maps for non-culled lights
void     zt_sceneLighting(ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules = nullptr);

// --------------------------------------------------------
// Generate depth map
void     zt_sceneDepth(ztScene *scene, ztCamera *camera);


void     zt_sceneRender(ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules = nullptr);

void     zt_sceneRenderDebug(ztDrawList *draw_list, i32 debug_flags, ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules = nullptr);


// ================================================================================================================================================================================================
// quadtree
// ================================================================================================================================================================================================

struct ztQuadTree
{
	struct Node
	{
		ztVec2 center;
		ztVec2 size;

		i32 *objects;
		i32  objects_count;

		Node *nodes[4];
	};

	i32 *objects_cache;
	i32  objects_cache_size;
	i32  objects_cache_used;

	Node *nodes_cache;
	i32   nodes_cache_size;
	i32   nodes_cache_used;

	Node *root_node;
};

// ================================================================================================================================================================================================

enum ztQuadTreeItemContainedResult_Enum
{
	ztQuadTreeItemContainedResult_Outside,
	ztQuadTreeItemContainedResult_Inside,
	ztQuadTreeItemContainedResult_InvalidIndex,

	ztQuadTreeItemContainedResult_MAX,
};

// ================================================================================================================================================================================================

#define ZT_FUNC_QUADTREE_ITEM_CONTAINED(name) ztQuadTreeItemContainedResult_Enum name(i32 object_idx, ztVec2 center, ztVec2 size, void *user_data)
typedef ZT_FUNC_QUADTREE_ITEM_CONTAINED(zt_QuadTreeItemContained_Func);

// ================================================================================================================================================================================================

void zt_quadTreeMake(ztQuadTree *quadtree, i32 max_objects_per_node, i32 max_node_levels, ztVec2 center, ztVec2 size, zt_QuadTreeItemContained_Func *callback, void *user_data);
bool zt_quadTreeMake(ztQuadTree *quadtree, ztAssetManager *asset_mgr, ztAssetID asset_id);
void zt_quadTreeFree(ztQuadTree *quadtree);
i32  zt_quadTreeFindNodesThatIntersect(ztQuadTree *quadtree, ztQuadTree::Node **nodes, i32 nodes_size, ztVec2 center, ztVec2 size);
i32  zt_quadTreeFindNodesThatIntersectLine(ztQuadTree *quadtree, ztQuadTree::Node **nodes, i32 nodes_size, ztVec2 line_beg, ztVec2 line_end);

bool zt_quadTreeSaveToFile(ztQuadTree *quadtree, const char *file);
bool zt_quadTreeSave(ztQuadTree *quadtree, ztSerial *serial);
bool zt_quadTreeLoad(ztQuadTree *quadtree, ztSerial *serial);

// ================================================================================================================================================================================================
// octree
// ================================================================================================================================================================================================

struct ztOcTree
{
	struct Node
	{
		ztVec3 center;
		ztVec3 size;

		i32 *objects;
		i32  objects_count;

		Node *nodes[8];
	};

	i32 *objects_cache;
	i32  objects_cache_size;
	i32  objects_cache_used;

	Node *nodes_cache;
	i32   nodes_cache_size;
	i32   nodes_cache_used;

	Node *root_node;
};

// ================================================================================================================================================================================================

enum ztOcTreeItemContainedResult_Enum
{
	ztOcTreeItemContainedResult_Outside,
	ztOcTreeItemContainedResult_Inside,
	ztOcTreeItemContainedResult_InvalidIndex,

	ztOcTreeItemContainedResult_MAX,
};

// ================================================================================================================================================================================================

#define ZT_FUNC_OCTREE_ITEM_CONTAINED(name) ztOcTreeItemContainedResult_Enum name(i32 object_idx, ztVec3 center, ztVec3 size, void *user_data)
typedef ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_OcTreeItemContained_Func);

// ================================================================================================================================================================================================

void zt_ocTreeMake(ztOcTree *octree, i32 max_objects_per_node, i32 max_node_levels, ztVec3 center, ztVec3 size, zt_OcTreeItemContained_Func *callback, void *user_data);
bool zt_ocTreeMake(ztOcTree *octree, ztAssetManager *asset_mgr, ztAssetID asset_id);
void zt_ocTreeFree(ztOcTree *octree);
i32  zt_ocTreeFindNodesThatIntersect(ztOcTree *octree, ztOcTree::Node **nodes, i32 nodes_size, ztVec3 center, ztVec3 size);
i32  zt_ocTreeFindNodesThatIntersectLine(ztOcTree *octree, ztOcTree::Node **nodes, i32 nodes_size, ztVec3 line_beg, ztVec3 line_end);

bool zt_ocTreeSaveToFile(ztOcTree *octree, const char *file);
bool zt_ocTreeSave(ztOcTree *octree, ztSerial *serial);
bool zt_ocTreeLoad(ztOcTree *octree, ztSerial *serial);

bool zt_ocTreeClone(ztOcTree *dest, ztOcTree *source);

// ================================================================================================================================================================================================

struct ztOcTreeItemContainedTestModelData
{
	ztModel **models;
	i32       models_count;

	bool      should_test_submodels;
};

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestModel);

// ================================================================================================================================================================================================

struct ztOcTreeItemContainedTestVerticesData
{
	ztVec3 *vertices;
	i32     vertices_count;
};

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestVertices);

// ================================================================================================================================================================================================

struct ztTriangle
{
	ztVec3 points[3];
	ztVec3 normal;
};

// ================================================================================================================================================================================================

struct ztOcTreeItemContainedTestTriangles
{
	ztTriangle *triangles;
	i32         triangles_count;
};

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestTriangles);


// ================================================================================================================================================================================================
// fonts
// ================================================================================================================================================================================================

typedef i32 ztFontID;

#define ztFontDefault		0
#define ztFontDefaultMono	1

#define ZT_FUNC_TEXT_ANIM(name) void name(ztDrawList *draw_list, int ch, int ch_idx, int ch_max, int row, ztVec3 *pos, ztVec2 *uvs, r32 *x_adv, r32 *y_adv, bool *should_skip, bool *pop_color, void *user_data)
typedef ZT_FUNC_TEXT_ANIM(ztTextAnim_Func);

const char *zt_fontGetCharsetStandard(i32 *size);

ztFontID    zt_fontMakeFromTrueTypeAsset(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 size_in_pixels, const char *charset = nullptr, i32 charset_size = 0);
ztFontID    zt_fontMakeFromTrueTypeFile(const char *file_name, i32 size_in_pixels, const char *charset = nullptr, i32 charset_size = 0);
ztFontID    zt_fontMakeFromBmpFontAsset(ztAssetManager *asset_mgr, ztAssetID asset_id, ztAssetID texture_override_asset_id = ztInvalidID, const ztVec2i& override_offset = zt_vec2i(0,0));
ztFontID    zt_fontMakeFromBmpFontFile(const char *file_name, ztTextureID texture_override_id = ztInvalidID, const ztVec2i& override_offset = zt_vec2i(0, 0));
ztFontID    zt_fontMakeFromBmpFontData(const char *file_data, ztTextureID texture_override_id, const ztVec2i& override_offset = zt_vec2i(0, 0));
void        zt_fontFree(ztFontID font_id);

void        zt_fontMakeMonoSpaced(ztFontID font);

const char *zt_fontGetName(ztFontID font_id);
i32         zt_fontGetSizeInPixels(ztFontID font_id);
ztTextureID zt_fontGetTexture(ztFontID font_id);

ztVec2      zt_fontGetExtents(ztFontID font_id, const char *text, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
ztVec2      zt_fontGetExtents(ztFontID font_id, const char *text, int text_len, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

void        zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
void        zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

void        zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, ztVec2 scale, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
void        zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, ztVec2 scale, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

// fancy text allows colors to be added in the middle of text using the format:
// "This text is <color=ff0000ff>red</color> text.
// be sure to avoid spaces in the color specifier
//
// fancy text also allows for sprites to be added in the middle of the text using the format:
// "This is a sprite: <sprite=tex_id,x,y,w,h,scale_x,scale_y>
// where tex_id is the id of the texture to use, x,y are the pixel coordinates of the top left corner, w,h are the pixel width and height, and scale_x,scale_y are r32 scale values to apply
// be sure to avoid spaces in the sprite specifier

ztVec2      zt_fontGetExtentsFancy(ztFontID font_id, const char *text, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
ztVec2      zt_fontGetExtentsFancy(ztFontID font_id, const char *text, int text_len, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

void        zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztColor default_color = ztColor_White, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
void        zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztColor default_color = ztColor_White, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

void        zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, ztVec2 scale, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztColor default_color = ztColor_White, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);
void        zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, ztVec2 scale, i32 align_flags = ztAlign_Default, i32 anchor_flags = ztAnchor_Default, ztVec2 *extents = nullptr, ztColor default_color = ztColor_White, ztMat4 *transform = nullptr, ztTextAnim_Func *text_anim = nullptr, void *text_anim_user_data = nullptr);

// ================================================================================================================================================================================================
// physics
// ================================================================================================================================================================================================

enum ztCollisionGeometryType_Enum
{
	ztCollisionGeometryType_AxisAlignedBox,
	ztCollisionGeometryType_OrientedBox,
	ztCollisionGeometryType_Sphere,
	ztCollisionGeometryType_Capsule,
	ztCollisionGeometryType_Triangles,
	
	ztCollisionGeometryType_MAX,
};

// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztCollisionGeometry
{
	ztCollisionGeometryType_Enum type;

	union
	{
		struct {
			ztVec3 aabb_center;
			ztVec3 aabb_extents;
		};

		struct {
			ztVec3 obb_center;
			ztVec3 obb_extents;
			ztQuat obb_rotation;
		};

		struct {
			ztVec3 sphere_center;
			r32    sphere_radius;
		};

		struct {
			ztVec3 capsule_center;
			r32    capsule_radius;
			r32    capsule_height;
		};

		struct {
			ztVec3 *vertices;
			i32     vertices_count;
		};
	};
};
#pragma pack(pop)

// ================================================================================================================================================================================================

void zt_collisionGeometryMakeAABB      (ztCollisionGeometry *geo, const ztVec3 &center, const ztVec3 &extents);
void zt_collisionGeometryMakeOBB       (ztCollisionGeometry *geo, const ztVec3 &center, const ztVec3 &extents, const ztQuat &rotation);
void zt_collisionGeometryMakeSphere    (ztCollisionGeometry *geo, const ztVec3 &center, r32 radius);
void zt_collisionGeometryMakeCapsule   (ztCollisionGeometry *geo, const ztVec3 &center, r32 radius, r32 height);
void zt_collisionGeometryMakeTriangles (ztCollisionGeometry *geo, ztVec3 *vertices, i32 vertices_count);

void zt_collisionGeometryFree          (ztCollisionGeometry *geo);

bool zt_collisionGeometryIntersecting(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point);

bool zt_collisionGeometrySave(ztSerial *serial, ztCollisionGeometry *geo);
bool zt_collisionGeometryLoad(ztSerial *serial, ztCollisionGeometry *geo);

void zt_collisionGeometryRenderDebug(ztCollisionGeometry *geo, ztDrawList *draw_list, ztVec3 position, ztMat4 mat);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// Rigid Bodies represent objects that are moved by forces
// ================================================================================================================================================================================================

enum ztRigidBodyFlags_Enum
{
	ztRigidBodyFlags_Static          = (1 << 0),
	ztRigidBodyFlags_NeverSleep      = (1 << 1),

	ztRigidBodyFlags_Sleeping        = (1 << 29),
	ztRigidBodyFlags_HadCollision    = (1 << 30),
	ztRigidBodyFlags_NeedsMatrixCalc = (1 << 31),
};

#ifndef ZT_MAX_RIGID_BODY_COLLISION_GEOMETRIES
#define ZT_MAX_RIGID_BODY_COLLISION_GEOMETRIES 4
#endif

//#pragma pack(push, 1)
struct ztRigidBody
{
	ztModel *model;

	r32      damping;
	r32      angular_damping;
	r32      inverse_mass;
	ztMat3   inverse_inertia_tensor;
	ztVec3   force_gravity;

	ztVec3   velocity;
	ztVec3   angular_velocity;
	ztVec3   acceleration;
	ztVec3   prev_acceleration;
	ztVec3   force_accum;
	ztVec3   torque_accum;
	ztMat4   prev_mat;
	r32      time_with_minimal_movement;

	ztMat3   inverse_inertia_tensor_world;
	r32      motion;

	i32      flags;

	i32      collision_layer;        // 1-31
	i32      collides_with_layers;   // bits to determine which layers this body, when moving, can collide with

	ztCollisionGeometry  cg_bounding;
	ztCollisionGeometry  cg_details[ZT_MAX_RIGID_BODY_COLLISION_GEOMETRIES];
	int                  cg_details_count;
};
//#pragma pack(pop)

// ================================================================================================================================================================================================

#define ztRigidBodyDampingDefaults_Low      .99f
#define ztRigidBodyDampingDefaults_Medium   .50f
#define ztRigidBodyDampingDefaults_High     .01f

#define ztRigidBodyMass_Infinite      0

#ifndef ZT_RIGID_BODY_DEFAULT_GRAVITY
#define ZT_RIGID_BODY_DEFAULT_GRAVITY zt_vec3(0, -9.8f, 0)
#endif

// ================================================================================================================================================================================================

void zt_rigidBodyMake(ztRigidBody *rigid_body, ztModel *model, r32 one_over_mass_in_kg, ztCollisionGeometry cg_bounding, ztCollisionGeometry *details, int details_count, r32 damping = ztRigidBodyDampingDefaults_Medium, ztVec3 force_gravity = ZT_RIGID_BODY_DEFAULT_GRAVITY);
void zt_rigidBodyMake(ztRigidBody *rigid_body, ztModel *model, r32 one_over_mass_in_kg, ztCollisionGeometry cg_bounding, ztCollisionGeometry detail, r32 damping = ztRigidBodyDampingDefaults_Medium, ztVec3 force_gravity = ZT_RIGID_BODY_DEFAULT_GRAVITY);
void zt_rigidBodyFree(ztRigidBody *rigid_body);

void zt_rigidBodiesUpdatePreCollision(ztRigidBody **rbs, int rbs_count, r32 dt);
void zt_rigidBodiesUpdatePostCollision(ztRigidBody **rbs, int rbs_count, r32 dt);

void zt_rigidBodyAddForce(ztRigidBody *rigid_body, const ztVec3 &force);
void zt_rigidBodyAddForceAtWorldPoint(ztRigidBody *rigid_body, const ztVec3 &force, const ztVec3 &point);
void zt_rigidBodyAddForceAtBodyPoint(ztRigidBody *rigid_body, const ztVec3 &force, const ztVec3 &point);

bool zt_rigidBodySave(ztSerial *serial, ztRigidBody *rigid_body);
bool zt_rigidBodyLoad(ztSerial *serial, ztRigidBody *rigid_body);

void zt_rigidBodyRenderDebug(ztRigidBody *rigid_body, ztDrawList *draw_list);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// Static Bodies represent objects that do not move
// ================================================================================================================================================================================================

struct ztStaticBody
{
	ztTriangle *triangles;
	i32         triangles_count;
	i32         triangles_size;

	ztVec3      min, max;

	ztOcTree octree;
};


bool zt_staticBodyMake(ztStaticBody *static_body, i32 max_triangles_count);
void zt_staticBodyFree(ztStaticBody *static_body);

bool zt_staticBodyAddTriangles(ztStaticBody *static_body, ztVec3 *verts, i32 verts_count);

void zt_staticBodyGenerateOcTree(ztStaticBody *static_body, i32 max_objects_per_node, i32 max_node_levels);

bool zt_staticBodySave(ztSerial *serial, ztStaticBody *static_body);
bool zt_staticBodyLoad(ztSerial *serial, ztStaticBody *static_body);

i32 zt_staticBodyHasCollisionsAABB(ztStaticBody *static_body, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, ztVec3 *contact_points = nullptr, ztVec3 *contact_normals = nullptr, i32 *contact_triangles = nullptr, i32 contact_count = 0);
i32 zt_staticBodyHasCollisionsOBB(ztStaticBody *static_body, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat &obb_rot, ztVec3 *contact_points = nullptr, ztVec3 *contact_normals = nullptr, i32 *contact_triangles = nullptr, i32 contact_count = 0);
i32 zt_staticBodyHasCollisionsSphere(ztStaticBody *static_body, const ztVec3 &sphere_center, r32 sphere_radius, ztVec3 *contact_points = nullptr, ztVec3 *contact_normal = nullptr, i32 *contact_triangle = nullptr, i32 contact_count = 0);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// Moving Bodies represent objects that are moved outside of the physics system
// ================================================================================================================================================================================================

struct ztMovingBodyCollision;

enum ztMovingBodyFlags_Enum
{
	ztMovingBodyFlags_AllowPenetration = (1 << 0),
	ztMovingBodyFlags_TrackCollisions = (1 << 1),

	ztMovingBodyFlags_NeedsCollisionCheck = (1 << 30),
	ztMovingBodyFlags_NeedsMatrixCalc = (1 << 31),
};

// ================================================================================================================================================================================================

struct ztMovingBody
{
	ztModel               *model;
	ztTransform           *transform;
	ztTransform            transform_prev;

	r32                    restitution;

	i32                    flags;
	i32                    collision_layer;        // 1-31
	i32                    collides_with_layers;   // bits to determine which layers this body, when moving, can collide with

	ztCollisionGeometry    cg_bounding;
	ztCollisionGeometry    cg_details[ZT_MAX_RIGID_BODY_COLLISION_GEOMETRIES];
	int                    cg_details_count;

	ztMovingBodyCollision *collisions; // populated each update if ztMovingBodyFlags_TrackCollisions is set (only valid for the frame the collision happens in the case of penetratable moving bodies)
};

// ================================================================================================================================================================================================

void zt_movingBodyMake(ztMovingBody *moving_body, ztModel *model, r32 restitution, ztCollisionGeometry cg_bounding, ztCollisionGeometry *details, int details_count);
void zt_movingBodyMake(ztMovingBody *moving_body, ztModel *model, r32 restitution, ztCollisionGeometry cg_bounding, ztCollisionGeometry detail);
void zt_movingBodyFree(ztMovingBody *moving_body);

bool zt_movingBodySave(ztSerial *serial, ztMovingBody *moving_body);
bool zt_movingBodyLoad(ztSerial *serial, ztMovingBody *moving_body);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================


enum ztForceAnchorType_Enum
{
	ztForceAnchorType_RigidBody,
	ztForceAnchorType_Transform,
	ztForceAnchorType_Vec3Ptr,
	ztForceAnchorType_Vec3,

	ztForceAnchorType_MAX,
};

// ================================================================================================================================================================================================

struct ztForceAnchor
{
	ztForceAnchorType_Enum type;

	union {
		struct {
			ztRigidBody *rigid_body;
			ztVec3       connection_point;
		};

		ztTransform *transform;
		struct { ztVec3 *vec3_ptr; };
		struct { ztVec3  vec3; };
	};
};

// ================================================================================================================================================================================================

ztForceAnchor zt_forceAnchor(ztRigidBody *rigid_body, const ztVec3 &connection_point = ztVec3::zero);
ztForceAnchor zt_forceAnchor(ztTransform *transform);
ztForceAnchor zt_forceAnchor(ztVec3 *vec3_ptr);
ztForceAnchor zt_forceAnchor(ztVec3 vec3);


// ================================================================================================================================================================================================

enum ztForceType_Enum
{
	ztForceType_Spring,
	ztForceType_StiffSpring,
	ztForceType_Bungee,
	ztForceType_Buoyancy,

	ztForceType_MAX,
};

// ================================================================================================================================================================================================

struct ztForce
{
	ztForceType_Enum type;

	ztRigidBody *rigid_body;
	ztVec3       connection_point;

	ztForceAnchor anchor;

	union {
		struct {
			r32 spring_constant;
			r32 rest_length;
		} spring;

		struct {
			r32 spring_constant;
			r32 damping;
		} stiff_spring;

		struct {
			r32 max_depth;
			r32 volume;
			r32 water_height;
			r32 liquid_density; // water density is 1000 kg/cubic meter
		} buoyancy;
	};
};

// ================================================================================================================================================================================================

ztForce zt_forceMakeSpring      (ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 rest_length);
ztForce zt_forceMakeStiffSpring (ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 damping);
ztForce zt_forceMakeBungee      (ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 rest_length);
ztForce zt_forceMakeBuoyancy    (ztRigidBody *rigid_body, const ztVec3 &connection_point, r32 max_depth, r32 volume, r32 water_height = 0, r32 liquid_density = 1000.f);

void zt_forcesUpdate(ztForce *forces, int forces_count, r32 dt);


// ================================================================================================================================================================================================
// collisions
// ================================================================================================================================================================================================

struct ztRigidBodyCollision
{
	ztRigidBody *rigid_bodies[2];

	r32          restitution;
	ztVec3       contact_point;
	ztVec3       contact_normal;
	r32          penetration;
};

// ================================================================================================================================================================================================

void zt_rigidBodyCollisionsResolve(ztRigidBodyCollision *collisions, int collisions_count, r32 dt, int max_iterations);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztMovingBodyCollision
{
	ztMovingBody          *moving_bodies[2];
	r32                    penetration;
	ztVec3                 contact_point;
	ztVec3                 contact_normal;

	ztMovingBodyCollision *next;
};


// ================================================================================================================================================================================================
// connectors
// ================================================================================================================================================================================================

enum ztConnectorType_Enum
{
	ztConnectorType_Cable,
	ztConnectorType_Rod,

	ztConnectorType_MAX,
};

// ================================================================================================================================================================================================

struct ztConnector
{
	ztConnectorType_Enum type;

	ztRigidBody *rigid_bodies[2];

	union {
		struct {
			r32 max_length;
			r32 restitution;

		} cable;

		struct {
			r32 length;
		} rod;
	};
};

// ================================================================================================================================================================================================

ztConnector zt_connectorMakeCable(r32 max_length, r32 restitution);
ztConnector zt_connectorMakeRod(r32 length);

int zt_connectorCalculateCollisions(ztConnector *connectors, int connectors_count, ztRigidBodyCollision *collisions, int collisions_size);


// ================================================================================================================================================================================================

int zt_collisionBrute(ztRigidBody **rigid_bodies, int rigid_bodies_count, ztRigidBodyCollision *collisions, int collisions_size);


// ================================================================================================================================================================================================
// physics manager
// ================================================================================================================================================================================================

struct ztPhysics
{
	ztRigidBody          **rigid_bodies;
	int                    rigid_bodies_size;
	int                    rigid_bodies_count;

	ztStaticBody         **static_bodies;
	int                    static_bodies_size;
	int                    static_bodies_count;

	ztMovingBody         **moving_bodies;
	int                    moving_bodies_size;
	int                    moving_bodies_count;

	ztForce              **forces;
	int                    forces_size;
	int                    forces_count;

	ztConnector          **connectors;
	int                    connectors_size;
	int                    connectors_count;

	ztRigidBodyCollision  *collisions;
	int                    collisions_size;

	ztVec3                 extents_min;
	ztVec3                 extents_max;
	r32                    extents_restitution;

	ztMovingBodyCollision *moving_body_collisions;
	int                    moving_body_collisions_size;
	int                    moving_body_collisions_count;

	ztMemoryArena *arena;
};

// ================================================================================================================================================================================================

ztPhysics *zt_physicsMake   (ztMemoryArena *arena, int max_rigid_bodies, int max_static_bodies, int max_moving_bodies, int max_forces, int max_connectors);
void       zt_physicsFree   (ztPhysics *physics);

// these return indexes into the respective arrays
int zt_physicsAddRigidBody  (ztPhysics *physics, ztRigidBody *rigid_body);
int zt_physicsAddStaticBody (ztPhysics *physics, ztStaticBody *static_body);
int zt_physicsAddMovingBody (ztPhysics *physics, ztMovingBody *moving_body);
int zt_physicsAddForce      (ztPhysics *physics, ztForce *force);
int zt_physicsAddConnector  (ztPhysics *physics, ztConnector *connector);

bool zt_physicsRemoveRigidBody(ztPhysics *physics, ztRigidBody *rigid_body);
bool zt_physicsRemoveStaticBody(ztPhysics *physics, ztStaticBody *static_body);
bool zt_physicsRemoveMovingBody(ztPhysics *physics, ztMovingBody *moving_body);
bool zt_physicsRemoveForce(ztPhysics *physics, ztForce *force);
bool zt_physicsRemoveConnector(ztPhysics *physics, ztConnector *connector);


void zt_physicsUpdate       (ztPhysics *physics, r32 dt);
void zt_physicsRenderDebug  (ztPhysics *physics, ztDrawList *draw_list);


// ================================================================================================================================================================================================
// collision tests
// ================================================================================================================================================================================================

// rects have a center and a size
// the LL functions use a rect with the x/y point being the lower left corner

bool   zt_collisionPointInRect                (const ztVec2 &point, const ztVec2 &rect_pos, const ztVec2 &rect_size);
bool   zt_collisionPointInRect                (r32 p_x, r32 p_y, r32 rect_x, r32 rect_y, r32 rect_w, r32 rect_h);
bool   zt_collisionPointInRectLL              (const ztVec2 &point, const ztVec2 &rect_pos, const ztVec2 &rect_size);
bool   zt_collisionPointInRectLL              (r32 p_x, r32 p_y, r32 rect_x, r32 rect_y, r32 rect_w, r32 rect_h);

bool   zt_collisionPointInCircle              (const ztVec2 &point, const ztVec2 &circle_pos, r32 radius);
bool   zt_collisionPointInSphere              (const ztVec3 &point, const ztVec3 &sphere_pos, r32 radius);
bool   zt_collisionPointInTriangle            (const ztVec3 &point, const ztVec3 &t0, const ztVec3 &t1, const ztVec3 &t2);

bool   zt_collisionLineInPlane                (const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &plane_coord, const ztVec3 &plane_normal, ztVec3 *intersection_point = nullptr, r32 *intersection_time = nullptr);
bool   zt_collisionLineInPlane                (const ztVec3 &line_beg, const ztVec3 &line_end, const ztPlane& plane, ztVec3 *intersection_point = nullptr, r32 *intersection_time = nullptr);
bool   zt_collisionLineInTriangle             (const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &p1, const ztVec2 &p2, const ztVec2 &p3, ztVec2 *intersection_point = nullptr, r32 *intersection_time = nullptr);
bool   zt_collisionLineInTriangle             (const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, ztVec3 *intersection_point = nullptr, r32 *intersection_time = nullptr);
bool   zt_collisionLineWithLine               (const ztVec2 &line1_beg, const ztVec2 &line1_end, const ztVec2 &line2_beg, const ztVec2 &line2_end, ztVec2 *intersection_point = nullptr, r32 *intersection_time = nullptr);
bool   zt_collisionLineInCircle               (const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &circle_pos, r32 radius);

bool   zt_collisionPointInAABB                (const ztVec2 &point, const ztVec2 &aabb_center, const ztVec2 &aabb_extents);
bool   zt_collisionPointInAABB                (const ztVec3 &point, const ztVec3 &aabb_center, const ztVec3 &aabb_extents);
bool   zt_collisionRayInAABB                  (const ztVec3 &point, const ztVec3 &direction, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time = nullptr, ztVec3 *intersection_point = nullptr);
bool   zt_collisionRayInSphere                (const ztVec3 &point, const ztVec3 &direction, const ztVec3 &sphere_center, r32 sphere_radius, r32 *intersection_time = nullptr, ztVec3 *intersection_point = nullptr);
bool   zt_collisionLineSegmentInAABB          (const ztVec2 &line_0, const ztVec2 &line_1, const ztVec2 &aabb_center, const ztVec2 &aabb_extents, r32 *intersection_time = nullptr, ztVec2 intersection_points[2] = nullptr);
bool   zt_collisionLineSegmentInAABB          (const ztVec3 &line_0, const ztVec3 &line_1, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time = nullptr, ztVec3 intersection_points[2] = nullptr, i32 *intersection_axis = nullptr);
bool   zt_collisionAABBInAABB                 (const ztVec2 &aabb_center_1, const ztVec2 &aabb_extents_1, const ztVec2 &aabb_center_2, const ztVec2 &aabb_extents_2);
bool   zt_collisionAABBInAABB                 (const ztVec2 &aabb_center_1, const ztVec2 &aabb_extents_1, const ztVec2 &aabb_center_2, const ztVec2 &aabb_extents_2, ztVec2 *collision_normal, r32 *collision_depth, int *collision_face);
bool   zt_collisionAABBInAABB                 (const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2);
bool   zt_collisionAABBInAABB                 (const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2, ztVec3 *collision_normal, r32 *collision_depth, int *collision_face);
bool   zt_collisionMovingAABBInAABB           (const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_velocity_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2, const ztVec3 &aabb_velocity_2, r32 *time_first, r32 *time_last);
bool   zt_collisionAABBInPlane                (const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztPlane& plane, ztVec3 *intersection_point = nullptr);
bool   zt_collisionTriangleInAABB             (const ztVec2 &p1, const ztVec2 &p2, const ztVec2 &p3, const ztVec2 &aabb_center, const ztVec2& aabb_size, ztVec3 *intersection_point = nullptr);
bool   zt_collisionTriangleInAABB             (const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &aabb_center, const ztVec3& aabb_size, ztVec3 *intersection_point = nullptr);
bool   zt_collisionTriangleInOBB              (const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &obb_center, const ztVec3& obb_size, const ztQuat &obb_rot, ztVec3 *intersection_point = nullptr);
bool   zt_collisionTriangleInSphere           (const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &sphere_center, r32 sphere_radius, ztVec3 *intersection_point = nullptr);

bool   zt_collisionOBBInOBB                   (const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2);
bool   zt_collisionOBBInOBB                   (const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 obb_axis_1[3], const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, const ztVec3 obb_axis_2[3]);
int    zt_collisionOBBInOBBGetContactPoints   (const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, ztVec3 *contact_normal, ztVec3 *contacts, r32 *penetrations, int contacts_size);
int    zt_collisionOBBInOBBGetContactPoints   (const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 obb_axis_1[3], const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, const ztVec3 obb_axis_2[3], ztVec3 *contact_normal, ztVec3 *contacts, r32 *penetrations, int contacts_size);
bool   zt_collisionLineSegmentInOBB           (const ztVec3 &line_0, const ztVec3 &line_1, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat& obb_rot, r32 *intersection_time = nullptr, ztVec3 intersections[2] = nullptr, i32 *intersection_axis = nullptr);

bool   zt_collisionPointInFrustum             (const ztFrustum& frustum, const ztVec3 &point, bool check_near_far = true);
bool   zt_collisionLineInFrustum              (const ztFrustum& frustum, const ztVec3 &line_beg, const ztVec3 &line_end, ztVec3 *intersection_point = nullptr);
bool   zt_collisionAABBInFrustum              (const ztFrustum& frustum, const ztVec3 &aabb_center, const ztVec3 &aabb_extents);
bool   zt_collisionSphereInFrustum            (const ztFrustum& frustum, const ztVec3 &sphere_center, r32 sphere_radius);

bool   zt_collisionLineInGrid                 (int x1, int y1, int x2, int y2, byte* array2d, int cols, int rows); // check for non-zero elements in the given line

bool   zt_collisionMovingSphereInPlane        (const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &sphere_velocity, const ztPlane& plane, r32 *intersection_time = nullptr, ztVec3 *intersection_point = nullptr);
bool   zt_collisionMovingSphereInMovingSphere (const ztVec3 &sphere1_pos, r32 sphere1_radius, const ztVec3 &sphere1_velocity, const ztVec3 &sphere2_pos, r32 sphere2_radius, const ztVec3 &sphere2_velocity, r32 *intersection_time = nullptr);
bool   zt_collisionMovingSphereInAABB         (const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &sphere_velocity, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time = nullptr);

r32    zt_collisionSquareDistPointToSegment   (const ztVec3 &point, const ztVec3 &seg_beg, const ztVec3 &seg_end);
r32    zt_collisionSquareDistPointToAABB      (const ztVec3 &point, const ztVec3 &aabb_center, const ztVec3 &aabb_extents);

bool   zt_collisionSphereCapsule              (const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &capsule_beg, ztVec3 &capsule_end, r32 capsule_radius);
bool   zt_collisionSpherePlane                (const ztVec3 &sphere_pos, r32 sphere_radius, const ztPlane& plane); bool zt_collisionRaySphere(const ztVec3 &ray_pos, const ztVec3 &ray_dir, const ztVec3 &sphere_pos, r32 sphere_radius, r32 *intersection_time = nullptr, ztVec3 *intersection_point = nullptr);
bool   zt_collisionSphereSphere               (const ztVec3 &sphere1_pos, r32 sphere1_radius, const ztVec3 &sphere2_pos, r32 sphere2_radius);
bool   zt_collisionSphereInAABB               (const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &aabb_center, const ztVec3 &aabb_extents);
bool   zt_collisionSphereInOBB                (const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat& obb_rot);
bool   zt_collisionCircleInAABB               (const ztVec2 &circle_pos, r32 circle_radius, const ztVec2 &aabb_center, const ztVec2 &aabb_extents);
bool   zt_collisionLineSegmentSphere          (const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &sphere_pos, r32 sphere_radius, r32 *intersection_time = nullptr, ztVec3 *intersection_point = nullptr);
bool   zt_collisionLineSegmentCapsule         (const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &capsule_beg, const ztVec3 &capsule_end, r32 capsule_radius, r32 *intersection_time = nullptr);

ztVec2 zt_closestPointLineSegmentPoint        (const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &point);
ztVec3 zt_closestPointLineSegmentPoint        (const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &point);
ztVec3 zt_closestPointAABBPoint               (const ztVec3 &aabb_center, const ztVec3 &aabb_size, const ztVec3& point);
ztVec3 zt_closestPointOBBPoint                (const ztVec3 &obb_center, const ztVec3 &obb_size, const ztQuat &obb_rot, const ztVec3& point);
ztVec3 zt_closestPointTrianglePoint           (const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3& point);

void   zt_collisionResizeAABBToFitAABB        (ztVec3 *aabb_center, ztVec3 *aabb_size, ztVec3 fit_aabb_center, ztVec3 fit_aabb_size);


// ================================================================================================================================================================================================
// tweening
// ================================================================================================================================================================================================

#define ZT_FUNC_TWEEN_EASE(name)	r32 name(r32 value, void *user_data)
typedef ZT_FUNC_TWEEN_EASE(ztTweenEase_Func);

ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseLinear,  ZT_FUNC_TWEEN_EASE(zt_tweenEaseLinear  ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseBack,    ZT_FUNC_TWEEN_EASE(zt_tweenEaseBack    ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseBounce,  ZT_FUNC_TWEEN_EASE(zt_tweenEaseBounce  ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseCirc,    ZT_FUNC_TWEEN_EASE(zt_tweenEaseCirc    ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseCubic,   ZT_FUNC_TWEEN_EASE(zt_tweenEaseCubic   ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseElastic, ZT_FUNC_TWEEN_EASE(zt_tweenEaseElastic ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseExpo,    ZT_FUNC_TWEEN_EASE(zt_tweenEaseExpo    ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseQuad,    ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuad    ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseQuart,   ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuart   ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseQuint,   ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuint   ));
ZT_FUNCTION_POINTER_REGISTER_EXTERN( zt_tweenEaseSine,    ZT_FUNC_TWEEN_EASE(zt_tweenEaseSine    ));

r32 zt_tweenValue(r32 val_beg, r32 val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out);
r32 zt_tweenValue(r32 val_beg, r32 val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data);

ztVec2 zt_tweenValue(const ztVec2 &val_beg, const ztVec2 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out);
ztVec2 zt_tweenValue(const ztVec2 &val_beg, const ztVec2 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data);

ztVec3 zt_tweenValue(const ztVec3 &val_beg, const ztVec3 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out);
ztVec3 zt_tweenValue(const ztVec3 &val_beg, const ztVec3 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data);

ztVec4 zt_tweenValue(const ztVec4 &val_beg, const ztVec4 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out);
ztVec4 zt_tweenValue(const ztVec4 &val_beg, const ztVec4 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztTweenItemType_Enum
{
	ztTweenItemType_Invalid,

	ztTweenItemType_Real,
	ztTweenItemType_Vec2,
	ztTweenItemType_Vec3,
	ztTweenItemType_Vec4,
	ztTweenItemType_Quat,

	ztTweenItemType_MAX,
};

// ================================================================================================================================================================================================

enum ztTweenItemFlags_Enum
{
	ztTweenItemFlags_Loops         = (1 << 0),
	ztTweenItemFlags_PingPongs     = (1 << 1),
	ztTweenItemFlags_Paused        = (1 << 2),
	ztTweenItemFlags_Stopped       = (1 << 3),
	ztTweenItemFlags_DirectionBack = (1 << 4),
};

// ================================================================================================================================================================================================

struct ztAnimCurve;

// ================================================================================================================================================================================================

struct ztTweenItem
{
	ztTweenItemType_Enum type;

	union {
		struct {
			r32  value_beg;
			r32  value_end;
			r32 *value;
		} real;

		struct {
			ztVec2  value_beg;
			ztVec2  value_end;
			ztVec2 *value;
		} vec2;

		struct {
			ztVec3  value_beg;
			ztVec3  value_end;
			ztVec3 *value;
		} vec3;

		struct {
			ztVec4  value_beg;
			ztVec4  value_end;
			ztVec4 *value;
		} vec4;

		struct {
			ztQuat  value_beg;
			ztQuat  value_end;
			ztQuat *value;
		} quat;
	};

	i32 flags;
	r32 length;
	r32 time;
	r32 delay;

	ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func);
	ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func);
	ztAnimCurve *curve;
};


void zt_tweenItemMake            (ztTweenItem *tween_item, r32    beg_val, r32    end_val, r32    *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func));
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec2 beg_val, ztVec2 end_val, ztVec2 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func));
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec3 beg_val, ztVec3 end_val, ztVec3 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func));
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec4 beg_val, ztVec4 end_val, ztVec4 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func));
void zt_tweenItemMake            (ztTweenItem *tween_item, ztQuat beg_val, ztQuat end_val, ztQuat *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func));

void zt_tweenItemMake            (ztTweenItem *tween_item, r32    beg_val, r32    end_val, r32    *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve);
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec2 beg_val, ztVec2 end_val, ztVec2 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve);
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec3 beg_val, ztVec3 end_val, ztVec3 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve);
void zt_tweenItemMake            (ztTweenItem *tween_item, ztVec4 beg_val, ztVec4 end_val, ztVec4 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve);
void zt_tweenItemMake            (ztTweenItem *tween_item, ztQuat beg_val, ztQuat end_val, ztQuat *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve);

r32  zt_tweenItemPercentComplete (ztTweenItem *tween_item);
bool zt_tweenItemIsComplete      (ztTweenItem *tween_item);

void zt_tweenItemStart           (ztTweenItem *tween_item);
void zt_tweenItemPause           (ztTweenItem *tween_item);
void zt_tweenItemStop            (ztTweenItem *tween_item);

void zt_tweenItemUpdate          (ztTweenItem *tween_item, int tween_item_count, r32 dt);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef ZT_TWEEN_MAX_ITEMS_PER_GROUP
#define ZT_TWEEN_MAX_ITEMS_PER_GROUP 8
#endif

struct ztTweenGroup
{
	ztTweenItem  items[ZT_TWEEN_MAX_ITEMS_PER_GROUP];
	int          items_count;
};

void zt_tweenGroupMake            (ztTweenGroup *tween_group, ztTweenItem *tween_items, int tween_items_count);

r32  zt_tweenGroupPercentComplete (ztTweenGroup *tween_group);
bool zt_tweenGroupIsComplete      (ztTweenGroup *tween_group);

void zt_tweenGroupUpdate          (ztTweenGroup *tween_group, int tween_group_count, r32 dt);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef ZT_TWEEN_MAX_GROUPS_PER_MANAGER
#define ZT_TWEEN_MAX_GROUPS_PER_MANAGER      32
#endif

#ifndef ZT_TWEEN_MAX_TWEENS_PER_MANAGER
#define ZT_TWEEN_MAX_TWEENS_PER_MANAGER     128
#endif

enum ztTweenManagerFlags_Enum
{
	ztTweenManagerFlags_Claimed             = (1<<0),
	ztTweenManagerFlags_ReclaimOnceComplete = (1<<1),
};

struct ztTweenManager
{
	ztTweenGroup groups      [ZT_TWEEN_MAX_GROUPS_PER_MANAGER];
	i32          groups_flags[ZT_TWEEN_MAX_GROUPS_PER_MANAGER];
	ztTweenItem  items       [ZT_TWEEN_MAX_TWEENS_PER_MANAGER];
	i32          items_flags [ZT_TWEEN_MAX_TWEENS_PER_MANAGER];

};

void           zt_tweenManagerMake              (ztTweenManager *tween_manager);
void           zt_tweenManagerReset             (ztTweenManager *tween_manager);

ztTweenGroup  *zt_tweenManagerGetTemporaryGroup (ztTweenManager *tween_manager);
ztTweenGroup  *zt_tweenManagerGetPermanentGroup (ztTweenManager *tween_manager);
void           zt_tweenManagerReclaimGroup      (ztTweenManager *tween_manager, ztTweenGroup *tween_group);

ztTweenItem   *zt_tweenManagerGetTemporaryItem  (ztTweenManager *tween_manager);
ztTweenItem   *zt_tweenManagerGetPermanentItem  (ztTweenManager *tween_manager);
void           zt_tweenManagerReclaimItem(ztTweenManager *tween_manager, ztTweenItem *tween_item);

void           zt_tweenManagerUpdate(ztTweenManager *tween_manager, r32 dt);


// ================================================================================================================================================================================================
// variable cache
//
// variable caches allow for easy tweening without having to creating member/static variables specifically for the
// tween.  it helps keep all functionality for the tween local
// ================================================================================================================================================================================================

#define ztVariableCacheFrameGapNone		ztInt32Min

struct ztVariableCache
{
	ztVariant *variables;
	i32       *ids;
	i32       *frame_referenced;

	i32        variables_count;
};


void       zt_variableCacheMake(ztVariableCache *cache, int max_variables);
void       zt_variableCacheFree(ztVariableCache *cache);

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVariant defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, r32       defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, i32       defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec2    defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec3    defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec4    defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztQuat    defval, i32 frame_gap = ztVariableCacheFrameGapNone);
ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, bool      defval, i32 frame_gap = ztVariableCacheFrameGapNone);

bool       zt_variableCacheSetFrameGap(ztVariableCache *cache, i32 id, i32 frames); // the maximum number of frames that can pass before resetting variable.  returns true if variable has been reset.  make sure to call before zt_variableCacheGet

// ================================================================================================================================================================================================
// animation
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// ztAnimCurve
// 
// Represents a way to get from 0 to 1.
// ================================================================================================================================================================================================

enum ztAnimCurveType_Enum
{
	ztAnimCurveType_Linear,
	ztAnimCurveType_EaseIn,
	ztAnimCurveType_EaseOut,
	ztAnimCurveType_EaseInOut,
	ztAnimCurveType_Spline,

	ztAnimCurveType_MAX,
};

// ================================================================================================================================================================================================

enum ztAnimCurveEaseType_Enum
{
	ztAnimCurveEaseType_Linear,
	ztAnimCurveEaseType_Back,
	ztAnimCurveEaseType_Bounce,
	ztAnimCurveEaseType_Circ,
	ztAnimCurveEaseType_Cubic,
	ztAnimCurveEaseType_Elastic,
	ztAnimCurveEaseType_Expo,
	ztAnimCurveEaseType_Quad,
	ztAnimCurveEaseType_Quart,
	ztAnimCurveEaseType_Quint,
	ztAnimCurveEaseType_Sine,

	ztAnimCurveEaseType_MAX,
};

// ================================================================================================================================================================================================

#ifndef ZT_ANIM_CURVE_SPLINE_MAX_SEGMENTS
#define ZT_ANIM_CURVE_SPLINE_MAX_SEGMENTS   16
#endif

// ================================================================================================================================================================================================

struct ztAnimCurveSplineSegment
{
	ztVec2 pos_beg;
	ztVec2 pos_end;
	ztVec2 control_point_beg;
	ztVec2 control_point_end;
};

// ================================================================================================================================================================================================

struct ztAnimCurve
{
	ztAnimCurveType_Enum             type;

	r32                              val_max;
	r32                              val_beg;
	r32                              val_end;

	union
	{
		struct {
			ztAnimCurveEaseType_Enum ease_in;
			ztAnimCurveEaseType_Enum ease_out;
		};

		struct {
			ztAnimCurveSplineSegment segments[ZT_ANIM_CURVE_SPLINE_MAX_SEGMENTS];
			int                      segments_count;
		};
	};
};

// ================================================================================================================================================================================================

ztTweenEase_Func *zt_animCurveFindEaseFunction  (ztAnimCurveEaseType_Enum type);
r32               zt_animCurveGetValue          (ztAnimCurve *curve, r32 percent);

bool              zt_serialRead                 (ztSerial *serial, ztAnimCurve *curve);
bool              zt_serialWrite                (ztSerial *serial, ztAnimCurve *curve);


// ================================================================================================================================================================================================
// ztAnimKey
// 
// Represents a single key frame in an animation.  Can point to any ztVariant value.
// ================================================================================================================================================================================================

struct ztAnimKey
{
	ztVariant         value;
	r32               time;
};

// ================================================================================================================================================================================================

ztAnimKey zt_animKeyMake(ztVariant value, r32 time);


// ================================================================================================================================================================================================
// ztAnimLayer
//
// Represents a collection of key frames for a single variable
// ================================================================================================================================================================================================

enum ztAnimLayerState_Enum
{
	ztAnimLayerState_Sleeping,
	ztAnimLayerState_Transitioning,
	ztAnimLayerState_Playing,
};

// ================================================================================================================================================================================================

struct ztAnimLayer
{
	ztVariantPointer      target;

	ztString              name;

	ztAnimKey            *keys;
	int                   keys_count;

	ztAnimLayerState_Enum state;
	int                   current_key;
	r32                   current_time;

	ztVariant             value_beg;
	ztVariant             value_end;
	r32                   target_time;
};

// ================================================================================================================================================================================================

ztAnimLayer zt_animLayerMake(ztVariantPointer target, ztAnimKey *keys, int keys_count, const char *name = nullptr);
void        zt_animLayerFree(ztAnimLayer *layer);

r32         zt_animLayerRunTime(ztAnimLayer *layer);
r32         zt_animLayerPercentComplete(ztAnimLayer *layer);


// ================================================================================================================================================================================================
// ztAnimSequence
//
// Represents a group of layers combined together, such as a walking animation that has
// arms, legs and bodies all keyframed together
// ================================================================================================================================================================================================

enum ztAnimSequenceType_Enum
{
	ztAnimSequenceType_Synchronous,     // only one of these can be running at the same time (running, jumping, idle, etc)
	ztAnimSequenceType_Asynchronous,    // any number of these can be running at the same time (blinking, breathing, talking)

	ztAnimSequenceType_MAX,
};

// ================================================================================================================================================================================================

struct ztAnimSequence
{
	ztAnimSequenceType_Enum type;

	ztAnimLayer            *layers;
	int                     layers_count;

	bool                    loops;
};

// ================================================================================================================================================================================================

ztAnimSequence *zt_animSequenceMake(ztAnimSequenceType_Enum type, ztAnimLayer *layers, int layers_count, bool loops);
void            zt_animSequenceFree(ztAnimSequence *sequence);

r32             zt_animSequenceRunTime(ztAnimSequence *sequence);
r32             zt_animSequencePercentComplete(ztAnimSequence *sequence);
void            zt_animSequenceSetPercentComplete(ztAnimSequence *sequence, r32 percent);


// ================================================================================================================================================================================================
// ztAnimController
//
// Represents a collection of animation sequences for a single actor/game object
// ================================================================================================================================================================================================

struct ztAnimController
{
	i32              *sequences_name_hash;
	ztString         *sequences_name;
	ztAnimSequence  **sequences;
	int               sequences_size;
	int               sequences_count;

	ztAnimSequence   *anim_sync;
	ztAnimSequence  **anim_async;
	int               anim_async_count;

	i32               queued;
};

// ================================================================================================================================================================================================

ztAnimController *zt_animControllerMake(int max_sequences, int max_async = 4);
void              zt_animControllerFree(ztAnimController *controller);
i32               zt_animControllerAddSequence(ztAnimController *controller, const char *sequence_name, ztAnimSequence *sequence);
int               zt_animControllerStartSequence(ztAnimController *controller, i32 anim_sequence_hash, r32 transition_time);
void              zt_animControllerUpdate(ztAnimController **controllers, int controllers_count, r32 dt);


// ================================================================================================================================================================================================
// sprite animation
// ================================================================================================================================================================================================

struct ztSpriteAnimController
{
	struct Sequence
	{
		ztSprite *sprites;
		int       sprites_size;
		int       current_sprite;
	};

	Sequence         *sequences;
	int               sequences_size;
	int               sequences_count;

	int               active_sequence;

	ztAnimController *controller;
};

// ================================================================================================================================================================================================

ztSpriteAnimController *zt_spriteAnimControllerMake(int max_sequences);
void zt_spriteAnimControllerFree(ztSpriteAnimController *controller);

void zt_spriteAnimControllerAddSequence(ztSpriteAnimController *controller, const char *sequence_name, ztSprite *sprites, r32 *times, int sprites_count, bool loops);
void zt_spriteAnimControllerStartSequence(ztSpriteAnimController *controller, i32 sequence_name_hash);
void zt_spriteAnimControllerUpdate(ztSpriteAnimController **controllers, int controllers_count, r32 dt);

bool      zt_spriteAnimControllerIsActive(ztSpriteAnimController *controller);
ztSprite *zt_spriteAnimControllerActiveSprite(ztSpriteAnimController *controller);
r32       zt_spriteAnimControllerActiveSequencePercentComplete(ztSpriteAnimController *controller);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES
#define ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES   128
#endif

#define ZT_SPRITE_ANIM_FILE_GUID     "3b8be0a7-e7d8-4633-b439-21305a9e9f6f"
#define ZT_SPRITE_ANIM_FILE_VERSION   100000

// ================================================================================================================================================================================================

struct ztSpriteAnimManager
{
	struct Entry {
		i32  hash;
		char name[64];

		i32  sprite_hash[ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES];
		i32  sprite_prop[ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES];

		i32  sprite_count;
		r32  length;
		bool loops;
	};

	Entry *sequences;
	int    sequences_count;
};

void zt_spriteAnimManagerMake(ztSpriteAnimManager *anim_manager, int max_sequences);
bool zt_spriteAnimManagerLoad(ztSpriteAnimManager *anim_manager, ztAssetManager *asset_mgr, ztAssetID asset_id);
bool zt_spriteAnimManagerLoad(ztSpriteAnimManager *anim_manager, ztSerial *serial);
bool zt_spriteAnimManagerSave(ztSpriteAnimManager *anim_manager, ztSerial *serial);
void zt_spriteAnimManagerFree(ztSpriteAnimManager *anim_manager);

void zt_spriteAnimManagerAddSequence(ztSpriteAnimManager *anim_manager, const char *name, i32 *sprite_hash, int *sprite_prop, int sprites, r32 length, bool loops);
bool zt_spriteAnimManagerLoadSequence(ztSpriteAnimManager *anim_manager, ztSpriteManager *sprite_manager, ztSpriteAnimController *anim_controller, const char *name);


// ================================================================================================================================================================================================
// Particles
// ================================================================================================================================================================================================

struct ztColorGradient
{
	struct Entry
	{
		ztColor color;
		i32     proportion; // the proportion of time spent between this color and the next color (ignored for final color)
	};

	Entry colors[32];
	int   colors_count = 0;
};

// ================================================================================================================================================================================================

ztColor zt_colorGradientGetValue(ztColorGradient *color_gradient, r32 percent);
void    zt_colorGradientGetValue(ztColorGradient *color_gradient, r32 percent, ztColor *color);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef ZT_COLOR_GRADIENT_MAX_VALUES
#define ZT_COLOR_GRADIENT_MAX_VALUES   32
#endif

// ================================================================================================================================================================================================

struct ztColorGradient2
{
	r32    alpha_vals[ZT_COLOR_GRADIENT_MAX_VALUES];
	r32    alpha_locs[ZT_COLOR_GRADIENT_MAX_VALUES];
	i32    alpha_entries;

	ztVec4 color_vals[ZT_COLOR_GRADIENT_MAX_VALUES];
	r32    color_locs[ZT_COLOR_GRADIENT_MAX_VALUES];
	i32    color_entries;
};

// ================================================================================================================================================================================================

ztColor zt_colorGradientColorAtLocation(ztColorGradient2 *gradient, r32 location);
r32     zt_colorGradientAlphaAtLocation(ztColorGradient2 *gradient, r32 location);

ztColor zt_colorGradientGetValue(ztColorGradient2 *gradient, r32 location);
void    zt_colorGradientGetValue(ztColorGradient2 *gradient, r32 location, ztColor *color);

int     zt_colorGradientGetColors(ztColorGradient2 *gradient, ztColor *colors, r32 *locations, int colors_count);

bool    zt_colorGradientIsEqual(ztColorGradient2 *grad1, ztColorGradient2 *grad2);

bool    zt_serialRead(ztSerial *serial, ztColorGradient2 *gradient);
bool    zt_serialWrite(ztSerial *serial, ztColorGradient2 *gradient);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztValueGradient
{
	struct Entry
	{
		r32 value;
		i32 proportion; // the proportion of time spent between this value and the next value (ignored for final value)
	};

	Entry values[32];
	int   values_count = 0;
};

// ================================================================================================================================================================================================

r32 zt_valueGradientGetValue(ztValueGradient *value_gradient, r32 percent);


// ================================================================================================================================================================================================

#ifndef ZT_MAX_PARTICLES
#define ZT_MAX_PARTICLES	500
#endif

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_PARTICLE_SYSTEM_FILE_GUID   "fb6eb861-ae3d-42a6-920c-cb42b4976700"
#define ZT_PARTICLE_SYSTEM_FILE_VERSION 100000

// ================================================================================================================================================================================================

enum ztParticleVariableRealType_Enum
{
	ztParticleVariableRealType_Constant,                      // single value at all times
	ztParticleVariableRealType_RandomBetweenTwoConstants,     // a random value chosen between (and including) the two constants
	ztParticleVariableRealType_Curve,                         // value based on an animation curve based on life of particle
	ztParticleVariableRealType_RandomBetweenTwoCurves,        // new random curve is generated based off the given curves

	ztParticleVariableRealType_MAX,
};

// ================================================================================================================================================================================================

struct ztParticleVariableReal
{
	ztParticleVariableRealType_Enum type;

	union {
		struct {
			r32         constant;
		};
		struct {
			r32         random_value_min;
			r32         random_value_max;
		};
		struct {
			ztAnimCurve curve;
		};
		struct {
			ztAnimCurve random_curve_min;
			ztAnimCurve random_curve_max;
		};
	};
};

// ================================================================================================================================================================================================

struct ztParticleVariableRealValue
{
	ztParticleVariableReal *variable;

	union {
		struct {
			r32 random_value;
		};

		struct {
			r32 curve_lerp;
		};
	};
};

// ================================================================================================================================================================================================

void zt_particleVariableRealInit     (ztParticleVariableRealValue *value, ztParticleVariableReal *variable, ztRandom *random);
r32  zt_particleVariableRealGetValue (ztParticleVariableRealValue *value, r32 percent);

bool zt_serialRead                   (ztSerial *serial, ztParticleVariableReal *variable);
bool zt_serialWrite                  (ztSerial *serial, ztParticleVariableReal *variable);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztParticleVariableVec2
{
	ztParticleVariableRealType_Enum type;

	union {
		struct {
			ztVec2      constant;
		};
		struct {
			ztVec2      random_value_min;
			ztVec2      random_value_max;
		};
		struct {
			ztAnimCurve curve[2];
		};
		struct {
			ztAnimCurve random_curve_min[2];
			ztAnimCurve random_curve_max[2];
		};
	};
};

// ================================================================================================================================================================================================

struct ztParticleVariableVec2Value
{
	ztParticleVariableVec2* variable;

	union {
		ztVec2 random_value;

		struct {
			r32 curve_lerp[2];
		};
	};
};

// ================================================================================================================================================================================================

void   zt_particleVariableVec2Init(ztParticleVariableVec2Value *value, ztParticleVariableVec2 *variable, ztRandom *random);
ztVec2 zt_particleVariableVec2GetValue (ztParticleVariableVec2Value *value, r32 percent);

bool   zt_serialRead                   (ztSerial *serial, ztParticleVariableVec2 *variable);
bool   zt_serialWrite                  (ztSerial *serial, ztParticleVariableVec2 *variable);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztParticleVariableVec3
{
	ztParticleVariableRealType_Enum type;

	union {
		struct {
			ztVec3      constant;
		};
		struct {
			ztVec3      random_value_min;
			ztVec3      random_value_max;
		};
		struct {
			ztAnimCurve curve[3];
		};
		struct {
			ztAnimCurve random_curve_min[3];
			ztAnimCurve random_curve_max[3];
		};
	};
};

// ================================================================================================================================================================================================

struct ztParticleVariableVec3Value
{
	ztParticleVariableVec3* variable;

	union {
		ztVec3 random_value;

		struct {
			r32 curve_lerp[3];
		};
	};
};

// ================================================================================================================================================================================================

void   zt_particleVariableVec3Init     (ztParticleVariableVec3Value *value, ztParticleVariableVec3 *variable, ztRandom *random);
ztVec3 zt_particleVariableVec3GetValue (ztParticleVariableVec3Value *value, r32 percent);

bool   zt_serialRead                   (ztSerial *serial, ztParticleVariableVec3 *variable);
bool   zt_serialWrite                  (ztSerial *serial, ztParticleVariableVec3 *variable);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztParticleVariableColorType_Enum
{
	ztParticleVariableColorType_Constant,                      // single color at all times
	ztParticleVariableColorType_RandomBetweenTwoConstants,     // a random value chosen between (and including) the two colors
	ztParticleVariableColorType_Gradient,                      // value based on an gradient based on life of particle
	ztParticleVariableColorType_RandomBetweenTwoGradients,     // new random gradient is generated based off the given gradient

	ztParticleVariableColorType_MAX,
};

// ================================================================================================================================================================================================

struct ztParticleVariableColor
{
	ztParticleVariableColorType_Enum type;

	union {
		struct {
			ztColor constant;
		};
		struct {
			ztColor random_value_min;
			ztColor random_value_max;
		};
		struct {
			ztColorGradient2 gradient;
		};
		struct {
			ztColorGradient2 random_gradient_min;
			ztColorGradient2 random_gradient_max;
		};
	};
};

// ================================================================================================================================================================================================

struct ztParticleVariableColorValue
{
	ztParticleVariableColor *variable;

	union {
		struct {
			ztColor random_value;
		};

		struct {
			r32 gradient_lerp;
		};

	};
};

// ================================================================================================================================================================================================

void    zt_particleVariableColorInit     (ztParticleVariableColorValue *value, ztParticleVariableColor *variable, ztRandom *random);
ztColor zt_particleVariableColorGetValue (ztParticleVariableColorValue *value, r32 percent);

bool    zt_serialRead                    (ztSerial *serial, ztParticleVariableColor *variable);
bool    zt_serialWrite                   (ztSerial *serial, ztParticleVariableColor *variable);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztParticle2
{
	r32                          life_span;
	r32                          life_left;

	ztVec3                       position;
	ztVec3                       velocity;
	ztVec3                       scale;
	ztVec3                       rotation;
	r32                          speed;
	ztVec4                       start_color;
	ztVec4                       color;

	ztVec3                       history[32];

	ztParticleVariableRealValue  speed_over_lifetime;
	ztParticleVariableVec3Value  size_over_lifetime;
	ztParticleVariableVec3Value  size_over_speed;
	ztParticleVariableVec3Value  velocity_over_lifetime;
	ztParticleVariableVec3Value  velocity_damping_over_lifetime;
	ztParticleVariableVec3Value  rotation_over_lifetime;
	ztParticleVariableVec3Value  rotation_over_speed;
	ztParticleVariableColorValue color_over_lifetime;
	ztParticleVariableColorValue color_over_speed;

	r32                          dist_from_camera;
	r32                          final_speed;
};

// ================================================================================================================================================================================================

struct ztParticleBurst
{
	r32 time_start;
	i32 min_particles;
	i32 max_particles;
	i32 cycles;
	r32 interval;
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_PARTICLE_BURSTS
#define ZT_MAX_PARTICLE_BURSTS 8
#endif

// ================================================================================================================================================================================================

enum ztParticleShapeType_Enum
{
	ztParticleShapeType_Point,
	ztParticleShapeType_Sphere,
	ztParticleShapeType_Circle,
	ztParticleShapeType_Box,
	ztParticleShapeType_Square,

	ztParticleShapeType_MAX,
};

// ================================================================================================================================================================================================

struct ztParticleShape
{
	ztParticleShapeType_Enum type;
	ztParticleVariableReal   spawn_volume;
	bool                     spawn_volume_local; // determines if rotation of emitter affects shape spawn volume restrictions (if true, it does)

	struct {
		ztParticleVariableReal radius;
		ztParticleVariableReal volume_angle_min;
		ztParticleVariableReal volume_angle_max;
	} sphere;

	struct {
		ztParticleVariableReal radius;
		ztParticleVariableReal volume_angle_min;
		ztParticleVariableReal volume_angle_max;
	} circle;

	struct {
		ztParticleVariableVec3 extents;
	} box;

	struct {
		ztParticleVariableVec2 extents;
	} square;
};

// ================================================================================================================================================================================================

enum ztParticleRenderingType_Enum
{
	ztParticleRenderingType_BillBoard,
	ztParticleRenderingType_Facing,
	ztParticleRenderingType_Mesh,

	ztParticleRenderingType_MAX,
};

// ================================================================================================================================================================================================

struct ztParticleRendering
{
	ztParticleRenderingType_Enum type;

	ztRendererBlendMode_Enum blend_mode_src;
	ztRendererBlendMode_Enum blend_mode_dst;

	struct {
		ztSprite sprite;
	} billboard;

	struct {
		ztSprite sprite;
	} facing;

	struct {
		ztMeshID mesh_id;
	} mesh;
};

// ================================================================================================================================================================================================

struct ztParticleMeshInfo
{
	ztMeshID mesh_id;
	char     name[128];
};

// ================================================================================================================================================================================================

struct ztParticleSystem
{
	// system settings
	r32                      system_duration;
	r32                      system_delay;
	bool                     system_loops;
	r32                      system_prewarm;
	ztParticleVariableReal   system_gravity_multiplier; // amount of force applied on the Y axis
	bool                     system_local_space;
	ztParticleVariableReal   system_rate_over_time;
	ztParticleVariableVec3   system_rotation;

	bool                     system_burst; // this is temporary until bursts can be properly implemented
	ztParticleBurst          system_bursts[ZT_MAX_PARTICLE_BURSTS];
	int                      system_bursts_count;

	ztParticleShape          system_shape;
	ztParticleRendering      system_rendering;


	// particle settings
	ztParticleVariableReal   lifetime;
	ztParticleVariableReal   start_speed;

	ztParticleVariableVec3   start_scale;
	ztParticleVariableVec3   start_rotation; // the initial starting rotation of the particle (not over lifetime)
	ztParticleVariableColor  start_color;

	bool                     velocity_inherit; // inherit velocity from emitter
	bool                     velocity_over_lifetime_used;
	ztParticleVariableVec3   velocity_over_lifetime;
	bool                     velocity_damping_over_lifetime_used;
	ztParticleVariableVec3   velocity_damping_over_lifetime;

	bool                     speed_over_lifetime_used;
	ztParticleVariableReal   speed_over_lifetime;

	ztParticleVariableColor  color_over_lifetime;
	bool                     color_over_speed_used;
	ztParticleVariableColor  color_over_speed;
	r32                      color_over_speed_range[2];

	bool                     size_over_lifetime_used;
	ztParticleVariableVec3   size_over_lifetime;

	bool                     size_over_speed_used;
	ztParticleVariableVec3   size_over_speed;
	r32                      size_over_speed_range[2];

	bool                     rotate_towards_movement;
	bool                     rotation_over_lifetime_used;
	ztParticleVariableVec3   rotation_over_lifetime;

	bool                     rotation_over_speed_used;
	ztParticleVariableVec3   rotation_over_speed;
	r32                      rotation_over_speed_range[2];

	// noise
	bool                     noise_use;
	ztParticleVariableReal   noise_multiplier;
	ztParticleVariableVec3   noise_position_amount;
	ztParticleVariableVec3   noise_rotation_amount;
	ztParticleVariableVec3   noise_scale_amount;

	// trails
	bool                     trails_use;
	ztParticleVariableReal   trails_percentage;
	ztParticleVariableReal   trails_lifetime;
	bool                     trails_width_is_size;
	bool                     trails_inherit_color;
	bool                     trails_color_over_lifetime_use;
	ztParticleVariableColor  trails_color_over_lifetime;
	ztParticleVariableReal   trails_width;
	ztParticleVariableColor  trails_color_over_trail;
	ztSprite                 trails_sprite;

};

// ================================================================================================================================================================================================

bool zt_particleSystemLoad(ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count, ztAssetManager *asset_manager, ztAssetID asset_id);

bool zt_serialRead (ztSerial *serial, ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count);
bool zt_serialWrite(ztSerial *serial, ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztParticleEmitter
{
	ztParticleSystem                   *system;

	bool                                enabled;
	i32                                 seed;

	ztVec3                              position;
	ztVec3                              rotation;
	ztParticle2                        *particles;
	int                                 particles_size;

	r32                                 speed;
	r32                                 life_left;
	r32                                 delay;

	ztParticleVariableRealValue         system_gravity_multiplier;
	ztParticleVariableRealValue         system_rate_over_time;
	ztParticleVariableRealValue         system_shape_spawn_volume;
	ztParticleVariableVec3Value         system_rotation;

	ztSimplexNoise                     *noise;
	ztParticleVariableRealValue         noise_multiplier;
	ztParticleVariableVec3Value         noise_position_amount;
	ztParticleVariableVec3Value         noise_rotation_amount;
	ztParticleVariableVec3Value         noise_scale_amount;

	ztParticleVariableRealValue         trails_width;
	ztParticleVariableColorValue        trails_color_over_time;
	ztParticleVariableColorValue        trails_color;

	union {
		struct {
			ztParticleVariableRealValue radius;
			ztParticleVariableRealValue volume_angle_min;
			ztParticleVariableRealValue volume_angle_max;
		} system_shape_sphere;

		struct {
			ztParticleVariableRealValue radius;
			ztParticleVariableRealValue volume_angle_min;
			ztParticleVariableRealValue volume_angle_max;
		} system_shape_circle;

		struct {
			ztParticleVariableVec3Value extents;
		} system_shape_box;

		struct {
			ztParticleVariableVec2Value extents;
		} system_shape_square;
	};

	ztVec3                              prev_pos;
	r32                                 time_last_particle;
	ztRandom                            random;
	ztVec3                              particle_ext_min;
	ztVec3                              particle_ext_max;
};

// ================================================================================================================================================================================================

struct ztParticleEmitterPool
{
	ztParticleSystem    system;
	ztParticleEmitter **emitters;
	int                 emitters_count;
};

// ================================================================================================================================================================================================

#define ZT_FUNC_PARTICLE_EMITTER_MESH_RENDER(name) void name(ztParticleEmitter *emitter, ztCamera *camera, ztDrawList *draw_list, ztMeshID mesh_id, ztParticle2 *particle, const ztVec3 &position, const ztVec3 &rotation, const ztVec3 &scale, const ztColor &color, void *user_data)
typedef ZT_FUNC_PARTICLE_EMITTER_MESH_RENDER(ztParticleEmitterRenderMesh_Func);

// ================================================================================================================================================================================================

ztParticleEmitter *zt_particleEmitterInit            (ztParticleSystem *system, i32 seed);
void               zt_particleEmitterFree            (ztParticleEmitter *emitter);
void               zt_particleEmitterReset           (ztParticleEmitter *emitter);
bool               zt_particleEmitterUpdate          (ztParticleEmitter *emitter, r32 dt);
void               zt_particleEmitterRender          (ztParticleEmitter *emitter, ztDrawList *draw_list, ztCamera *camera, ztParticleEmitterRenderMesh_Func *render_mesh = nullptr, void *render_mesh_user_data = nullptr);
int                zt_particleEmitterGetTriangles    (ztParticleEmitter *emitter, ztCamera *camera, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size);
int                zt_particleEmitterFillVertices    (ztParticleEmitter *emitter, ztCamera *camera, ztVertexDefault *vertices, int size);
int                zt_particleEmitterFillVertices    (ztParticleEmitter *emitter, ztCamera *camera, ztVertexDefaultLit *vertices, int size);

void               zt_particleEmitterPoolInit        (ztParticleEmitterPool *pool, int emitters_count, ztParticleSystem *system, i32 seed, bool random_seeds = true);
void               zt_particleEmitterPoolFree        (ztParticleEmitterPool *pool);
void               zt_particleEmitterPoolUpdate      (ztParticleEmitterPool *pool, r32 dt);
void               zt_particleEmitterPoolRender      (ztParticleEmitterPool *pool, ztDrawList *draw_list, ztCamera *camera);
int                zt_particleEmitterPoolGetTriangles(ztParticleEmitterPool *pool, ztCamera *camera, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size);
int                zt_particleEmitterPoolFillVertices(ztParticleEmitterPool *pool, ztCamera *camera, ztVertexDefault *vertices, int size);
int                zt_particleEmitterPoolFillVertices(ztParticleEmitterPool *pool, ztCamera *camera, ztVertexDefaultLit *vertices, int size);
void               zt_particleEmitterPoolResetAll    (ztParticleEmitterPool *pool);
ztParticleEmitter *zt_particleEmitterPoolGetAvailable(ztParticleEmitterPool *pool);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztParticleEmitterSettings
{
	ztVec3          origin                       = ztVec3::zero;
	ztVec3          size                         = ztVec3::one;

	r32             emission_rate                = 10;               // particles per second

	r32             lifetime                     = 1;                // particle lifetime
	r32             lifetime_random              = 0;                // 0 = no randomness, 1 = complete randomness (lifetime is max, so .5 would be from half lifetime to lifetime)

	r32             velocity_speed               = 1;                // units per second
	r32             velocity_speed_random        = 0;                // 0 = no randomness, 1 = complete randomness (0 - velocity_speed)

	r32             velocity_angle               = 360;              // 0 up, 90, right, 180 down, 270 left
	r32             velocity_angle_random        = 1;                // 0 = no randomness, 1 = complete randomness (0-360, percentage is based off angle (.125 on a 90 angle would be 45-135)

	r32             rotation                     = 0;                // rotation amount for each particle per second
	r32             rotation_random              = 0;                // 0 = no randomness, 1 = complete randomness (0-360)
	i32             rotation_direction           = 0;                // 0 = both direction, -1 = counter clockwise, 1 = clockwise

	r32             scale                        = 1;                // scale amount for each particle
	r32             scale_random                 = 0;                // 0 = no randomness, 1 = complete randomness (0-scale)
	ztValueGradient scale_life                   = {};

	ztVec3          gravity_velocity             = ztVec3::zero;

	ztVec4          color_life_begin             = ztColor_White;
	ztVec4          color_life_end               = ztColor_White;

	ztColorGradient color_life                   = {};               // if colors_count > 0, this is used instead of the above colors

	r32             z_life_begin                 = 0;
	r32             z_life_end                   = 0;

	bool            random_rotation              = false;            // particles are randomly rotated
	bool            local_space                  = false;            // particles position relative to emitter origin
	bool            burst_emit                   = false;            // emit all particles at once
	bool            z_sort                       = false;

	bool            enabled                      = true;

	r32             emitter_lifetime             = 0;                // 0 = persistent, otherwise life in seconds
};

// ================================================================================================================================================================================================

struct ztParticle
{
	ztTransform transform;
	r32         life;
	r32         life_span;
	r32         speed;
	r32         angle;
	r32         rotation;
	i32         sprite_idx;
};

// ================================================================================================================================================================================================

struct ztParticleEmitter2D
{
	ztParticleEmitterSettings settings;

	ztSprite                  sprites[8];
	int                       sprites_props[8];
	int                       sprites_count;

	ztParticle                particles[ZT_MAX_PARTICLES];
	int                       particles_count;

	i32                       live_particles;

	r32                       time_between_particles;
	r32                       time_last_particle;

	ztRandom                  randomizer;

	r32                       lifetime;
	bool                      enabled;
};

// ================================================================================================================================================================================================

#define ZT_FUNC_PARTICLE_EMIT(name) void name(ztParticleEmitter2D* emitter, int particle, void *user_data)
typedef ZT_FUNC_PARTICLE_EMIT(ztParticleEmitParticle_Func);

// ================================================================================================================================================================================================

ztParticleEmitter2D  zt_particleEmitter2DMake(ztParticleEmitterSettings *settings, ztSprite *sprite, i32 seed, r32 prewarm_time = 0);
ztParticleEmitter2D  zt_particleEmitter2DMake(ztParticleEmitterSettings *settings, ztSprite *sprites, int *sprites_props, int sprites_count, i32 seed, r32 prewarm_time = 0);
bool                 zt_particleEmitter2DUpdate(ztParticleEmitter2D *emitter, r32 dt, ztParticleEmitParticle_Func emit_particle = nullptr, void *user_data = nullptr); // returns false when emitter is exhausted
void                 zt_particleEmitter2DRender(ztParticleEmitter2D *emitter, ztDrawList *draw_list);
int                  zt_particleEmitter2DGetTriangles(ztParticleEmitter2D *emitter, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size);

void                 zt_particleEmitter2DEnable(ztParticleEmitter2D *emitter, bool enabled = true);
void                 zt_particleEmitter2DReset(ztParticleEmitter2D *emitter, r32 prewarm_time = 0);

// ================================================================================================================================================================================================
// Pathfinding
// ================================================================================================================================================================================================

#ifndef ZT_PATH_NODE_MAX_NEIGHBORS
#define ZT_PATH_NODE_MAX_NEIGHBORS 16
#endif

#define ztPathNodeValue_Reset       -1
#define ztPathNodeValue_Impassable  -100

// ================================================================================================================================================================================================

struct ztPathProgress;

// ================================================================================================================================================================================================

enum ztPathNodeFlags_Enum
{
	ztPathNodeFlags_Ignore      = (1<<0),
	ztPathNodeFlags_Waypoint    = (1<<1),
	ztPathNodeFlags_Obstructed  = (1<<2),
};

// ================================================================================================================================================================================================

struct ztPathNode
{
	ztVec3      position; // not necessarily world coords, but used to determine node distances
	void       *user_data; // passed to the path cost function
	u8          flags;

	ztPathNode *neighbors[ZT_PATH_NODE_MAX_NEIGHBORS];
	int         neighbors_count;

	r32        _my_move_cost;
};

// ================================================================================================================================================================================================

#define ZT_FUNC_PATH_NODE_COST(name)   r32 name(ztPathNode *origin, ztPathNode *destination, void *user_data)
typedef ZT_FUNC_PATH_NODE_COST(ztPathNodeCost_Func);

ztPathNode *zt_pathNodesFindClosest(ztPathNode *nodes, int nodes_count, ztVec3 point);

void zt_pathNodesPrepareForPathfinding(ztPathNode *nodes, int nodes_count, ztPathProgress *progress);


// ================================================================================================================================================================================================

struct ztPathGridSquare
{
	int rows;
	int cols;

	ztPathNode *nodes;
};

ztPathGridSquare *zt_pathGridSquareMake(int rows, int cols, bool allow_diagonals);
void              zt_pathGridSquareFree(ztPathGridSquare *grid);
ztPathNode       *zt_pathGridSquareAccessNode(ztPathGridSquare *grid, int row, int col);
bool              zt_pathGridSquareGetCoords(ztPathGridSquare *grid, ztPathNode *node, int *row, int *col);
bool              zt_pathGridSquareGetNodeIndex(ztPathGridSquare *grid, ztPathNode *node, int *index);
r32               zt_pathNodeGetDistance(ztPathNode *node_one, ztPathNode *node_two);
ztPathNode       *zt_pathGridSquareGetNode(ztPathGridSquare *grid, int col, int row);

void zt_pathGridSquarePrepareForPathfinding(ztPathGridSquare *grid, ztPathProgress *progress);


// ================================================================================================================================================================================================

struct ztPathProgress
{
	ztPathNode    *origin;
	ztPathNode    *destination;

	ztPathNode   **frontier;
	int            frontier_len;

	ztPathNode   **visited;
	int            visited_len;

	ztPathNode   **path;
	int            path_size;
	int            path_count;

	int            frontier_idx;
	int            visited_idx;

	ztMemoryArena *arena;
};

// ================================================================================================================================================================================================

#define ZT_FUNC_PATH_EARLY_EXIT(name)	bool name(ztPathProgress *progress, void *user_data)
typedef ZT_FUNC_PATH_EARLY_EXIT(ztPathEarlyExit_Func);

// ================================================================================================================================================================================================

ztPathProgress *zt_pathProgressMake(ztPathNode *nodes, int nodes_count, ztMemoryArena *arena);
ztPathProgress *zt_pathProgressMake(ztPathGridSquare *grid, ztMemoryArena *arena);
void            zt_pathProgressFree(ztPathProgress *progress);

// ================================================================================================================================================================================================

enum ztPathType_Enum
{
	ztPathType_Dijkstra,  // dijkstra's algorithm - prioritize by movement cost
	ztPathType_Heuristic, // heuristic search - prioritize by distance from goal
	ztPathType_Astar,     // a* uses both movement cost and distance from goal

	ztPathType_MAX,
};

// ================================================================================================================================================================================================

int zt_pathCalculatePath(ztPathProgress *progress, ztPathNodeCost_Func *path_node_cost_func, void *path_cost_user_data, ztPathEarlyExit_Func *early_exit_func, void *early_exit_user_data, ztPathType_Enum path_type);



// ================================================================================================================================================================================================
// events
// ================================================================================================================================================================================================

enum ztEventFlags_Enum
{
	ztEventFlags_TrackTime           = (1<<0),
	ztEventFlags_ResetEachFrame      = (1<<1),
	ztEventFlags_TriggerOneFrameOnly = (1<<2),
	ztEventFlags_TriggerOnTimeEnd    = (1<<3),
	ztEventFlags_Disabled            = (1<<4),
	ztEventFlags_DisableOnTimeEnd    = (1<<5),
	ztEventFlags_ResetOnTimeEnd      = (1<<6),
};

// ================================================================================================================================================================================================

struct ztEvent
{
	r32  time;
	i32  flags;
	bool triggered;
	r32  time_set;
};

// ================================================================================================================================================================================================

bool zt_eventIsTriggered            (ztEvent *evt, bool condition, i32 flags = 0, r32 timeout = 0);
bool zt_eventIsTriggered            (ztEvent *evt);

bool zt_eventIsTriggeredAndComplete (ztEvent *evt, bool condition, i32 flags = 0, r32 timeout = 0);
bool zt_eventIsTriggeredAndComplete (ztEvent *evt);

bool zt_eventTrigger                (ztEvent *evt, i32 flags = 0, r32 timeout = 0);

bool zt_eventJustTriggered          (ztEvent *evt);

void zt_eventDisable                (ztEvent *evt);

r32  zt_eventPercentComplete        (ztEvent *evt);
r32  zt_eventPercentCompleteClamp   (ztEvent *evt);
bool zt_eventIsComplete             (ztEvent *evt);

void zt_eventReset                  (ztEvent *evt);
void zt_eventResetAll               (ztEvent *evts, int evts_count);

void zt_eventUpdate                 (ztEvent *evt, r32 dt);
void zt_eventUpdateAll              (ztEvent *evts, int evts_count, r32 dt);


// ================================================================================================================================================================================================
// audio
// ================================================================================================================================================================================================

typedef i32 ztAudioClipID;

#define ztAudioClipDefaultFrequency	.5f


ztAudioClipID zt_audioClipMake(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 audio_system = 0);
ztAudioClipID zt_audioClipMakeFromFile(const char *file_name, i32 audio_system);

void zt_audioClipFree(ztAudioClipID audio_clip_id);

void zt_audioClipPlayOnce(ztAudioClipID audio_clip_id, r32 frequency = ztAudioClipDefaultFrequency);
void zt_audioClipPlayOnceDelayed(ztAudioClipID audio_clip_id, r32 delay, r32 frequency = ztAudioClipDefaultFrequency);
void zt_audioClipPlayLooped(ztAudioClipID audio_clip_id, r32 frequency = ztAudioClipDefaultFrequency);

bool zt_audioClipIsPlaying(ztAudioClipID audio_clip_id);
bool zt_audioClipStop(ztAudioClipID audio_clip_id, r32 fade_out_time = 0);

void zt_audioClipSetVolume(ztAudioClipID audio_clip_id, r32 volume);

void zt_audioSetMute(bool mute);
bool zt_audioGetMute();

void zt_audioSystemSetVolume(i32 audio_system, r32 volume);
r32  zt_audioSystemGetVolume(i32 audio_system);


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_FUNC_DLL_SET_GAME_GLOBALS(name) void name(void *memory, int version)
typedef ZT_FUNC_DLL_SET_GAME_GLOBALS(zt_dllSetGameGlobals_Func);

#if !defined(ZT_DLL)

#if defined(ZT_OPENGL)
void zt_dllSendGameGlobals(zt_dllSetGameGlobals_Func *set_globals, zt_dllSetOpenGLGlobals_Func *set_globals_opengl);
#else
void zt_dllSendGameGlobals(zt_dllSetGameGlobals_Func *set_globals);
#endif
#endif


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// ================================================================================================================================================================================================
// This is the data for the custom shader language used by zt_game.  Each renderer system should
// provide a function that turns the syntax tree into a valid shader program for that api.
// ================================================================================================================================================================================================

enum ztShLangTokenType_Enum
{
	ztShLangTokenType_Invalid,

	// groupings
	ztShLangTokenType_ParenOpen,
	ztShLangTokenType_ParenClose,
	ztShLangTokenType_BraceOpen,
	ztShLangTokenType_BraceClose,
	ztShLangTokenType_BracketOpen,
	ztShLangTokenType_BracketClose,
	ztShLangTokenType_Comma,

	// maths
	ztShLangTokenType_Equal,
	ztShLangTokenType_DoubleEqual,
	ztShLangTokenType_Plus,
	ztShLangTokenType_PlusEqual,
	ztShLangTokenType_DoublePlus,
	ztShLangTokenType_Minus,
	ztShLangTokenType_MinusEqual,
	ztShLangTokenType_DoubleMinus,
	ztShLangTokenType_Multiply,
	ztShLangTokenType_MultiplyEqual,
	ztShLangTokenType_Divide,
	ztShLangTokenType_DivideEqual,
	ztShLangTokenType_GreaterThan,
	ztShLangTokenType_GreaterThanOrEqual,
	ztShLangTokenType_LessThan,
	ztShLangTokenType_LessThanOrEqual,
	ztShLangTokenType_Mod,
	ztShLangTokenType_ModEqual,
	ztShLangTokenType_Not,
	ztShLangTokenType_NotEqual,
	ztShLangTokenType_And,
	ztShLangTokenType_Or,

	// bitwise
	ztShLangTokenType_BitwiseAnd,
	ztShLangTokenType_BitwiseAndEqual,
	ztShLangTokenType_BitwiseOr,
	ztShLangTokenType_BitwiseOrEqual,
	ztShLangTokenType_BitwiseNot,
	ztShLangTokenType_BitwiseXor,
	ztShLangTokenType_BitwiseXorEqual,
	ztShLangTokenType_BitwiseShiftLeft,
	ztShLangTokenType_BitwiseShiftRight,

	// language features
	ztShLangTokenType_EndCommand,
	ztShLangTokenType_Question,
	ztShLangTokenType_Colon,

	ztShLangTokenType_QuotedChar,
	ztShLangTokenType_QuotedString,

	ztShLangTokenType_Comment,

	ztShLangTokenType_If,
	ztShLangTokenType_Else,
	ztShLangTokenType_For,
	ztShLangTokenType_While,
	ztShLangTokenType_Const,
	ztShLangTokenType_Struct,
	ztShLangTokenType_Return,
	ztShLangTokenType_Break,
	ztShLangTokenType_Continue,

	// data types
	ztShLangTokenType_void,
	ztShLangTokenType_int,
	ztShLangTokenType_uint,
	ztShLangTokenType_float,
	ztShLangTokenType_double,
	ztShLangTokenType_bool,
	ztShLangTokenType_vec2,
	ztShLangTokenType_vec3,
	ztShLangTokenType_vec4,
	ztShLangTokenType_ivec2,
	ztShLangTokenType_ivec3,
	ztShLangTokenType_ivec4,
	ztShLangTokenType_mat2,
	ztShLangTokenType_mat3,
	ztShLangTokenType_mat4,
	ztShLangTokenType_texture2d,
	ztShLangTokenType_textureCube,

	ztShLangTokenType_NumberInteger,
	ztShLangTokenType_NumberFloat,
	ztShLangTokenType_True,
	ztShLangTokenType_False,

	ztShLangTokenType_Program,

	ztShLangTokenType_Identifier,
	ztShLangTokenType_PreprocessCommand,

	ztShLangTokenType_Access,

	_ztShLangTokenType_MAX
};

// ================================================================================================================================================================================================

enum ztShLangTokenFlags_Enum
{
	ztShLangTokenFlags_Operator = (1 << 1),
	ztShLangTokenFlags_ConditionOperator = (1 << 2),
	ztShLangTokenFlags_DataType = (1 << 3),
	ztShLangTokenFlags_Command = (1 << 4),
	ztShLangTokenFlags_String = (1 << 5),
	ztShLangTokenFlags_Number = (1 << 6),
	ztShLangTokenFlags_Bool = (1 << 7),
	ztShLangTokenFlags_ScopeChange = (1 << 8),
	ztShLangTokenFlags_VariableDeclaration = (1 << 9),
	ztShLangTokenFlags_IdentifierWithAccess = (1 << 10),
};

// ================================================================================================================================================================================================

struct ztShLangToken
{
	ztShLangTokenType_Enum type;
	i32                    token_beg;
	int                    token_len;
	int                    line;
	int                    col;
	i32                    flags;
};

// ================================================================================================================================================================================================

enum ztShLangSyntaxNodeType_Enum
{
	ztShLangSyntaxNodeType_Scope,
	ztShLangSyntaxNodeType_Structure,
	ztShLangSyntaxNodeType_VariableDecl,
	ztShLangSyntaxNodeType_ProgramDecl,
	ztShLangSyntaxNodeType_FunctionDecl,
	ztShLangSyntaxNodeType_ConditionTest,
	ztShLangSyntaxNodeType_Return,
	ztShLangSyntaxNodeType_Loop,
	ztShLangSyntaxNodeType_Continue,
	ztShLangSyntaxNodeType_Break,
	ztShLangSyntaxNodeType_Variable,
	ztShLangSyntaxNodeType_Operation,
	ztShLangSyntaxNodeType_FunctionCall,
	ztShLangSyntaxNodeType_Group,
	ztShLangSyntaxNodeType_ValueNumberInt,
	ztShLangSyntaxNodeType_ValueNumberFloat,
	ztShLangSyntaxNodeType_ValueString,
	ztShLangSyntaxNodeType_ValueBool,
	ztShLangSyntaxNodeType_ValueEmpty,
};

// ================================================================================================================================================================================================

struct ztShLangSyntaxNode;

struct ztShLangSyntaxNodeCache
{
	ztShLangSyntaxNode *cache;
	int                 cache_size;
	int                 cache_used;

	char               *string_cache;
	int                 string_cache_size;
	int                 string_cache_used;
};

// ================================================================================================================================================================================================

struct ztShLangSyntaxNode
{
	ztShLangSyntaxNodeType_Enum type;

	ztShLangSyntaxNode         *next;
	ztShLangSyntaxNode         *parent;
	ztShLangSyntaxNode         *first_child;
	ztShLangToken              *token;

	ztShLangSyntaxNodeCache    *cache;

	union {
		struct {
			char                  *name;
		} scope;

		struct {
			char                  *name;
		} structure;

		struct {
			char                  *name;
			ztShLangTokenType_Enum type;
			char                  *type_name;
			char                  *qualifier;
			int                    array_size;
			bool                   is_const;
		} variable_decl;

		struct {
			char                  *name;
		} program;

		struct {
			char                  *name;
			char                  *returns_name;
			ztShLangTokenType_Enum returns;
		} function_decl;

		struct {
			ztShLangTokenType_Enum op;
			ztShLangSyntaxNode    *expr;
			ztShLangSyntaxNode    *if_true;
			ztShLangSyntaxNode    *if_false;
			bool                   is_inline;
		} condition;

		struct {
			ztShLangSyntaxNode *init;
			ztShLangSyntaxNode *condition;
			ztShLangSyntaxNode *loop;
		} loop;

		struct {
			char                  *name;
			ztShLangTokenType_Enum token_type;
			ztShLangSyntaxNode    *decl;
		} variable_val;

		struct {
			ztShLangSyntaxNode    *left;
			ztShLangSyntaxNode    *right;
			ztShLangTokenType_Enum op;
			ztShLangTokenType_Enum returns;
			ztShLangTokenType_Enum left_type;
			ztShLangTokenType_Enum right_type;
		} operation;

		struct {
			char                  *name;
			ztShLangSyntaxNode    *decl;
		} function_call;

		struct {
			char                  *value;
		} value;
	};
};

// ================================================================================================================================================================================================

ztShLangSyntaxNode *_zt_shaderLangFindStructure(ztShLangSyntaxNode *node, const char *name);
bool                _zt_shaderLangIsVariableReferenced(ztShLangSyntaxNode *node, ztShLangSyntaxNode *var_decl_node);
bool                _zt_shaderLangIsStructureReferenced(ztShLangSyntaxNode *node, const char *name);
bool                _zt_shaderLangIsFunctionReferenced(ztShLangSyntaxNode *node, const char *name);
const char         *_zt_shaderLangTokenTypeDesc(ztShLangTokenType_Enum token_type);

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#endif // include guard



#if defined(ZT_GAME_IMPLEMENTATION) || defined(ZT_GAME_INTERNAL_DECLARATIONS)

#ifndef __zt_game_h_internal_included__
#define __zt_game_h_internal_included__

// configure renderers
#if defined(ZT_OPENGL)
#	define zt_openGLSupport(code) code
#	define zt_noOpenGLSupport(code)
#else
#	define zt_openGLSupport(code)
#	define zt_noOpenGLSupport(code) code
#endif

#if defined(ZT_DIRECTX)
#	define zt_directxSupport(code) code
#	define zt_noDirectxSupport(code)
#else
#	define zt_directxSupport(code)
#	define zt_noDirectxSupport(code) code
#endif

#if defined(ZT_DSOUND)
#	define zt_dsoundSupport(code) code
#	define zt_noDsoundSupport(code)
#else
#	define zt_dsoundSupport(code)
#	define zt_noDsoundSupport(code) code
#endif

#if defined(ZT_OPENAL)
#	define zt_openALSupport(code) code
#	define zt_noOpenALSupport(code)
#else
#	define zt_openALSupport(code)
#	define zt_noOpenALSupport(code) code
#endif

#if defined(ZT_OPENSL)
#	define zt_openSLSupport(code) code
#	define zt_noOpenSLSupport(code)
#else
#	define zt_openSLSupport(code)
#	define zt_noOpenSLSupport(code) code
#endif


// ================================================================================================================================================================================================
// Windows implementation
// ================================================================================================================================================================================================

#if defined(ZT_WINDOWS)

#if defined(ZT_COMPILER_MSVC)
#define VC_EXTRALEAN
#endif

#define WIN32_LEAN_AND_MEAN

// headers (strive to avoid including anything if possible)
#include <windows.h>
#include <windowsx.h>
#include <xinput.h>

#elif defined(ZT_EMSCRIPTEN) // end ZT_WINDOWS
#include <emscripten.h>
#include <emscripten/html5.h>

#elif defined(ZT_ANDROID) // end ZT_EMSCRIPTEN
#include <android/log.h>
#include <android_native_app_glue.h>

#endif // ZT_ANDROID

#if !defined(ZT_NO_OPENGL)
#define ZT_OPENGL_IMPLEMENTATION
#include "zt_renderer_opengl.h"
#endif

#if !defined(ZT_NO_DIRECTX)
#define ZT_DIRECTX_IMPLEMENTATION
#include "zt_renderer_directx.h"
#endif

#if !defined(ZT_NO_DSOUND)
#define ZT_DSOUND_IMPLEMENTATION
#include "zt_audio_dsound.h"
#endif

#if defined(ZT_OPENAL)
#define ZT_OPENAL_IMPLEMENTATION
#include "zt_audio_openal.h"
#endif

#if defined(ZT_OPENSL)
#define ZT_OPENSL_IMPLEMENTATION
#include "zt_audio_opensl.h"
#endif



// ================================================================================================================================================================================================
#if defined(ZT_WINDOWS)

struct ztWindowDetails
{
	RECT client_rect;
	RECT window_rect;
	ztVec4 client_rect_buffer;
	HWND handle;

	int screen_w, screen_h;
	r32 aspect_ratio;
	r32 resize_cooldown;

	zt_openGLSupport(ztContextGL *gl_context);
	zt_openGLSupport(ztVertexArrayGL gl_tri_verts_array);

	zt_directxSupport(ztContextDX *dx_context);
	zt_directxSupport(ztVertexArrayDX *dx_tri_verts_array);
};

#elif defined(ZT_EMSCRIPTEN)|| defined(ZT_ANDROID) // end ZT_WINDOWS


struct ztWindowDetails
{
	ztVec4i client_rect;
	ztVec4 client_rect_buffer;
	void *handle; // unused

	int screen_w, screen_h;
	r32 aspect_ratio;
	r32 resize_cooldown;

	zt_openGLSupport(ztContextGL *gl_context);
	zt_openGLSupport(ztVertexArrayGL gl_tri_verts_array);
};

#endif // ZT_WINDOWS
// ================================================================================================================================================================================================

struct ztProfiledThread;

// ================================================================================================================================================================================================

struct ztProfiledSection
{
	const char        *system;
	i32                system_hash;

	const char        *section;
	i32                section_hash;

	r64                time_begin;
	r64                time_accum;
	int                called;

	ztProfiledSection  *parent;
	ztProfiledSection  *children;
	ztProfiledSection  *next;

	ztProfiledThread  *thread;
};

// ================================================================================================================================================================================================

struct ztProfiledThread
{
	ztProfiledSection  *root;                           // the first section in this frame
	ztProfiledSection  *current;                        // the most recently active section

	ztProfiledSection **allocations;                    // an allocated chunk of profiled sections for a series of past frames
	ztProfiledSection **roots;                          // roots for each saved frame
	int                *sections;                       // total sections used for each saved frame

	int                 allocations_current_frame;      // current section in the current frame
	int                 allocations_current_section;    // current section in the current frame
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_THREADS // needs to be main thread + additional threads
#define ZT_MAX_THREADS	7
#endif

#ifndef ZT_PROFILER_FRAMES_KEPT
#define ZT_PROFILER_FRAMES_KEPT		180
#endif

#ifndef ZT_PROFILER_MAX_SECTIONS_PER_FRAME
#define ZT_PROFILER_MAX_SECTIONS_PER_FRAME	1024 * 4
#endif

// ================================================================================================================================================================================================

struct ztProfiler
{
	bool             paused;
	ztProfiledThread threads[ZT_MAX_THREADS];

	int              current_frame;      // current frame we're using
};


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_THREAD_JOB_QUEUE_SIZE		256

// ================================================================================================================================================================================================

enum ztThreadJobType_Enum
{
	ztThreadJobType_Frame,
	ztThreadJobType_Background,

	ztThreadJobType_MAX,
};

// ================================================================================================================================================================================================

struct ztThreadJob
{
	ztThreadJobID         id;
	ztThreadJobType_Enum  type;
	ztThread_Func        *thread_func;
	void                 *thread_func_user_data;
	r32                   anticipated_length;
	i32                   frame_created;

	ztAtomicBool          completed;
	ztAtomicBool          cancelled;

	ztThreadJob          *next;
};

// ================================================================================================================================================================================================

struct ztThreadJobThreadData
{
	ztThread            *thread;
	ztThreadID           thread_id;
	ztThreadJobType_Enum type;

	ztThreadMonitor     *start;
	ztThreadMonitor     *finish;

	ztAtomicBool         should_exit;
	ztAtomicBool         processing;

	ztThreadJob         *next_job;
};

// ================================================================================================================================================================================================

struct ztThreadJobQueue
{
	ztThreadJobThreadData  *threads;
	int                     threads_count;

	int                     frame_threads;
	int                     background_threads;

	ztThreadJob             job_queue[ZT_THREAD_JOB_QUEUE_SIZE];

	i32                     total_job_count;
};

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztDebugVar
{
	char      name[64];
	i32       name_hash;
	ztVariant variable;
};


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztRendererRequest_Enum
{
	ztRendererRequest_Change,
	ztRendererRequest_Windowed,
	ztRendererRequest_WindowedBorderless,
	ztRendererRequest_Fullscreen,

	ztRendererRequest_Resolution,
	ztRendererRequest_UpdatePixelsPerUnit,

	ztRendererRequest_MAX,
};

// ================================================================================================================================================================================================

struct ztRendererRequest
{
	ztRendererRequest_Enum type;

	union {
		struct {
			ztRenderer_Enum change_to;
		};

		struct {
			ztVec2i resolution;
		};

		struct {
			r32 ppu;
		};
	};
};


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztShaderLoadType_Enum
{
	ztShaderLoadType_Asset,
	ztShaderLoadType_Data,

	ztShaderLoadType_MAX,
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_SHADERS
#define ZT_MAX_SHADERS		64
#endif

// ================================================================================================================================================================================================

struct ztShaderCallbacks
{
	ZT_FUNCTION_POINTER_VAR(begin_func, ztShaderBegin_Func);
	void                   *begin_user_data;
	ZT_FUNCTION_POINTER_VAR(end_func, ztShaderEnd_Func);
	void                   *end_user_data;
};

// ================================================================================================================================================================================================

struct ztShader
{
	zt_openGLSupport(ztShaderGL *gl_shader);
	zt_directxSupport(ztShaderDX *dx_shader);

	char                  name[64];
	ztRenderer_Enum       renderer;
	ztShaderLoadType_Enum load_type;

	union {
		struct {
			ztAssetManager *asset_mgr;
			ztAssetID asset_id;
		};

		struct {
			const char *data;
			i32 data_len;
		};
	};

	ztShaderVariableValues variables;

	int textures_bound;

	ztShaderCallbacks callbacks;
};


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztTextureLoadType_Enum
{
	ztTextureLoadType_Invalid,

	ztTextureLoadType_Asset,
	ztTextureLoadType_Data,
	ztTextureLoadType_RenderTarget,

	ztTextureLoadType_MAX,
};

// ================================================================================================================================================================================================

struct ztTexture
{
	zt_openGLSupport(ztTextureGL *gl_texture);
	zt_directxSupport(ztTextureDX *dx_texture);

	i32 width, height;
	i32 width_actual, height_actual;
	i32 flags;
	r32 render_texture_scale;

	ztRenderer_Enum renderer;
	ztTextureLoadType_Enum load_type;

	char name[128];

	union {
		struct {
			ztAssetManager *asset_mgr;
			ztAssetID asset_id;
		};

		struct {
			byte *data;
			i32 data_len;
			ztMemoryArena *arena;
			char file_name[64];
		};
	};
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_TEXTURES
#define ZT_MAX_TEXTURES	256
#endif


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztVertexArray
{
	ztRenderer_Enum renderer;

	union {
		zt_openGLSupport(ztVertexArrayGL gl_va);
		zt_directxSupport(ztVertexArrayDX *dx_va);
	};

	i32 vertices;
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_VERTEX_ARRAYS
#define ZT_MAX_VERTEX_ARRAYS	1024 * 16
#endif


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztDebugDisplayType_Enum
{
	ztDebugDisplayType_Invalid,

	ztDebugDisplayType_GuiLine,
	ztDebugDisplayType_GuiCircle,
	ztDebugDisplayType_GuiRect,
	ztDebugDisplayType_GuiText,
	ztDebugDisplayType_GuiTextList,

	ztDebugDisplayType_Line,
	ztDebugDisplayType_Circle,
	ztDebugDisplayType_Rect,
	ztDebugDisplayType_Sphere,
	ztDebugDisplayType_Cube,
	ztDebugDisplayType_Text,
	ztDebugDisplayType_Axis,

	ztDebugDisplayType_MAX,
};

// ================================================================================================================================================================================================

struct ztDebugDisplayEntry
{
	ztDebugDisplayType_Enum type;
	ztMat4                  transform;
	ztDebugDisplayItem      item;
	ztColor                 color;
	r32                     persist_time;

	union {
		struct {
			ztVec3 p0;
			ztVec3 p1;
		} line;

		struct {
			r32 radius;
			i32 points;
		} circle;

		struct {
			ztVec2 size;
		} rect;

		struct {
			ztString text;
		} text;

		struct {
			r32 radius;
			i32 points;
			i32 rings;
		} sphere;

		struct {
			ztVec3 size;
		} cube;

		struct {
			r32 size;
		} axis;
	};
};

// ================================================================================================================================================================================================

struct ztDebugDisplay
{
	ztStringPool         string_pool;
	ztDebugDisplayEntry *display_entries;
	i32                  display_entries_count;
	i32                  display_entries_size;
};

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztFont
{
	char           name[128];
	i32            size_pixels;
	ztTextureID    texture;

	i32           *glyph_code_point;

	struct Kerning
	{
		i32        next_code;
		r32        spacing;
		Kerning   *next;
	};

	struct Glyph
	{
		ztVec2     offset;
		ztVec2     size;
		ztVec4     tex_uv;
		r32        x_adv;
		Kerning   *kerning;
	};

	Glyph         *glyphs;
	i32            glyph_count;
	Kerning       *kernings;
	i32            kernings_count;

	r32            line_height;
	r32            line_spacing;
	r32            space_width;

	ztMemoryArena *arena;
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_FONTS
#define ZT_MAX_FONTS	64
#endif


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztMesh
{
	i32 triangles;
	i32 indices;

	ztVec3 obb_center;
	ztVec3 obb_size;

	zt_openGLSupport(ztVertexArrayGL gl_vertex_array);
	zt_directxSupport(ztVertexArrayDX *dx_vertex_array);
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_MESHES
#define ZT_MAX_MESHES	256
#endif

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_MODEL_FILE_IDENTIFIER            "ZeroTolerance.Model"
#define ZT_MODEL_FILE_VERSION               1000
#define ZT_MODEL_FILE_GUID                  zt_guidMake(0x2f7b8d04, 0xe86344b2, 0xa3275a4a, 0x0fbc74e0)

#define ZT_MODEL_FILE_GUID_END_OF_SECTION   zt_guidMake(0, 1, 2, 3)

#define ZT_MODEL_FILE_GUID_BONES            zt_guidMake(0xeb718b7b, 0xfcc44bd8, 0xae4af8e0, 0x58ba5322)

#define ZT_MODEL_FILE_GUID_MESH             zt_guidMake(0x426a2a3a, 0xebfd4dda, 0xa46a8f47, 0xf0c8a843)
#define ZT_MODEL_FILE_GUID_MESH_VERTICES    zt_guidMake(0x21ebf7a9, 0xfd194301, 0x82febc0a, 0x1dcd9909)
#define ZT_MODEL_FILE_GUID_MESH_UVS         zt_guidMake(0x1b59a959, 0xb8b041da, 0x885b1980, 0xe2921e14)
#define ZT_MODEL_FILE_GUID_MESH_NORMALS     zt_guidMake(0xe5c3488a, 0x12994a1c, 0xabd3a2ac, 0x635f650c)
#define ZT_MODEL_FILE_GUID_MESH_COLORS      zt_guidMake(0xd0910d89, 0x4eb04ac6, 0xbca147df, 0x1f568658)
#define ZT_MODEL_FILE_GUID_MESH_TANGENTS    zt_guidMake(0x8e002469, 0xbbad42db, 0xa5087224, 0x3e9cc00b)
#define ZT_MODEL_FILE_GUID_MESH_INDICES     zt_guidMake(0xdd687266, 0x7d1a4c8b, 0xa203577a, 0xae66127f)
#define ZT_MODEL_FILE_GUID_MESH_BONES       zt_guidMake(0x5f9aa150, 0x083c467c, 0x81062f4f, 0xa4e5dbb0)

#define ZT_MODEL_FILE_GUID_TEXTURE          zt_guidMake(0xd8adcfdc, 0x061f4699, 0xb117c359, 0x7169632f)
#define ZT_MODEL_FILE_TEXTURE_IMAGE_FILE    (i32)0
#define ZT_MODEL_FILE_TEXTURE_IMAGE_PIXELS  (i32)1

#define ZT_MODEL_FILE_GUID_HIERARCHY        zt_guidMake(0x87cc882f, 0x517f423d, 0x868af26b, 0xbc340fa6)

#define ZT_MODEL_FILE_GUID_MATERIAL         zt_guidMake(0xf6e8c175, 0xd8554037, 0x9380bcb2, 0xb542643f)

#define ZT_MODEL_FILE_MATTEXTYPE_DIFFUSE    1
#define ZT_MODEL_FILE_MATTEXTYPE_NORMALS    2
#define ZT_MODEL_FILE_MATTEXTYPE_SPECULAR   3
#define ZT_MODEL_FILE_MATTEXTYPE_HEIGHT     4
#define ZT_MODEL_FILE_MATTEXTYPE_REFLECTION 5
#define ZT_MODEL_FILE_MATTEXTYPE_EMISSIVE   6

#define ZT_MODEL_FILE_GUID_ANIMATION        zt_guidMake(0x15682e4c, 0x586142ed, 0xbd8416a1, 0x14a35318)


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

enum ztAudioClipFlags_Enum
{
	ztAudioClipFlags_Playing = (1<<0),
	ztAudioClipFlags_Looping = (1<<1),
};

// ================================================================================================================================================================================================

struct ztAudioClip
{
	zt_dsoundSupport(ztDirectSoundBuffer *ds_buffer);
	zt_openALSupport(ztOpenALBuffer      *al_buffer);
	zt_openSLSupport(ztOpenSLBuffer      *sl_buffer);

	i32 flags;

	r32 length;
	r32 play_time;
	r32 fade_out_curr;
	r32 fade_out_time;
	r32 volume;

	i32 system;
};

// ================================================================================================================================================================================================

struct ztAudioDelay
{
	ztAudioClipID clip_id;
	r32           frequency;
	r32           delay;
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_AUDIO_CLIPS
#define ZT_MAX_AUDIO_CLIPS  128
#endif

// ================================================================================================================================================================================================

struct ztAudioSystem
{
	r32 volume;
};

// ================================================================================================================================================================================================

#ifndef ZT_MAX_AUDIO_SYSTEMS
#define ZT_MAX_AUDIO_SYSTEMS  16
#endif

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================


#define ZT_SPRITE_FILE_GUID      "3ab6d99a-afe6-4a1a-9f52-5cd62973c028"
#define ZT_SPRITE_FILE_VERSION    1

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#ifndef ZT_MAX_WINDOWS
#define ZT_MAX_WINDOWS	8
#endif

// ================================================================================================================================================================================================

#ifndef ZT_MAX_RENDERER_REQUESTS
#define ZT_MAX_RENDERER_REQUESTS	8
#endif

// ================================================================================================================================================================================================

#ifndef ZT_MAX_DEBUG_VARIABLES
#define ZT_MAX_DEBUG_VARIABLES		256
#endif

// ================================================================================================================================================================================================

struct ztGameGlobals
{
#	if defined(ZT_WINDOWS)
	HINSTANCE                 hinstance = NULL;
	HICON                     exe_icon = NULL;
	HMODULE                   hmod_xinput = NULL;

	typedef DWORD (__stdcall *xinput_getState_Func)(DWORD, XINPUT_STATE *);
	typedef DWORD (__stdcall *xinput_setState_Func)(DWORD, XINPUT_VIBRATION *);
	xinput_getState_Func      xinput_getState = nullptr;
	xinput_setState_Func      xinput_setState = nullptr;
	r32                       xinput_haptic[ZT_MAX_INPUT_CONTROLLERS];
#	endif

#	if defined(ZT_ANDROID)
	android_app              *android_app;
#	endif

	bool                      app_has_focus = true;

	zt_openGLSupport(zt_dllSetOpenGLGlobals_Func *zt_dllSetOpenGLGlobals = nullptr);

	bool                      quit_requested = false;

	ztProfiler               *profiler         = nullptr;

	ztThreadID                main_thread_id   = ztInvalidID;
	ztThreadJobQueue         *thread_job_queue = nullptr;

	// ----------------------

	ztDebugVar                debug_vars[ZT_MAX_DEBUG_VARIABLES];
	int                       debug_vars_count;
	char                      debug_vars_file[ztFileMaxPath];
	char                     *debug_vars_file_data;
	i32                       debug_vars_file_size;

	// ----------------------

	ztWindowDetails           win_details[ZT_MAX_WINDOWS];
	ztGameSettings            win_game_settings[ZT_MAX_WINDOWS];
	i32                       win_count = 0;
	ztRendererRequest         renderer_requests[ZT_MAX_RENDERER_REQUESTS];
	i32                       renderer_requests_count = 0;
	byte                     *renderer_memory;
	i32                       renderer_memory_size;

	ztGameDetails             game_details;
	i32                       last_drawn_frame = 0;

	// ----------------------

	ztShader                  shaders[ZT_MAX_SHADERS];
	i32                       shaders_count = 0;
	ztShaderID                shader_defaults[ztShaderDefault_MAX];
	bool                      shader_loading_default = false;

	ztShaderID                default_shader_solid = 0;

	// ----------------------

	ztTexture                 textures[ZT_MAX_TEXTURES];
	i32                       textures_count = 0;
	bool                      textures_active_render_target = false;

	// ----------------------

	ztVertexArray             vertex_arrays[ZT_MAX_VERTEX_ARRAYS];
	i32                       vertex_arrays_count = 0;

	// ----------------------

	ztFont                    fonts[ZT_MAX_FONTS];
	i32                       fonts_count = 0;
	i32                       fonts_count_system = 0;

	// ----------------------

	ztMesh                    meshes[ZT_MAX_MESHES];
	i32                       meshes_count = 0;

	// ----------------------

	ztDebugDisplay           *debug_display = nullptr;

	// ----------------------

	zt_dsoundSupport(ztDirectSoundContext *ds_context = nullptr);
	zt_openALSupport(ztOpenALContext      *al_context = nullptr);
	zt_openSLSupport(ztOpenSLContext      *sl_context = nullptr);

	ztAudioClip               audio_clips[ZT_MAX_AUDIO_CLIPS];
	ztAudioDelay              audio_delays[ZT_MAX_AUDIO_CLIPS];
	i32                       audio_clips_count = 0;
	bool                      audio_muted = false;
	bool                      audio_has_delay = false;
	ztAudioSystem             audio_systems[ZT_MAX_AUDIO_SYSTEMS];

	// ----------------------

	bool                      input_this_frame = false;

	ztInputKeys_Enum          input_key_strokes[ZT_MAX_INPUT_KEYSTROKES];
	i32                       input_key_strokes_count = 0;

	i32                       input_keys_mapping[zt_winOnly(256) zt_emscriptenOnly(1254) zt_androidOnly(256)];
	ztInputKeys               input_keys[ztInputKeys_MAX];

	ztInputMouse              input_mouse;
	bool                      input_mouse_look = false;
	i32                       input_mouse_captures = 0;

	ztInputController         input_controllers[ZT_MAX_INPUT_CONTROLLERS];

	// ----------------------
};

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_GAME_GLOBALS_VERSION   1 // update this any time ztGameGlobals is changed

ztGameGlobals *zt_game = nullptr;


#endif // internal include guard
#endif // internal declarations


#if defined(ZT_GAME_IMPLEMENTATION)
#	ifndef __zt_game_implementation__
#	define __zt_game_implementation__

#	if !defined(ZT_DLL)
		// check for valid setup
#		if !defined(ZT_GAME_FUNC_SETTINGS)
#			error You must define ZT_GAME_FUNC_SETTINGS
#		endif
#		if !defined(ZT_GAME_FUNC_INIT)
#			error You must define ZT_GAME_FUNC_INIT
#		endif
#		if !defined(ZT_GAME_FUNC_CLEANUP)
#			error You must define ZT_GAME_FUNC_CLEANUP
#		endif
#		if !defined(ZT_GAME_FUNC_LOOP)
#			error You must define ZT_GAME_FUNC_LOOP
#		endif
#	endif

#if defined(ZT_DLL)

ZT_DLLEXPORT ZT_FUNC_DLL_SET_GAME_GLOBALS(zt_dllSetGameGlobals)
{
	if (version == ZT_GAME_GLOBALS_VERSION) {
		zt_game = (ztGameGlobals *)memory;

#		if !defined(ZT_NO_PROFILE)
		// fix profiler strings
		zt_fize(zt_game->profiler->threads) {
			zt_fjz(ZT_PROFILER_FRAMES_KEPT) {
				zt_fkz(zt_game->profiler->threads[i].sections[j]) {
					zt_game->profiler->threads[i].allocations[j][k].system = "(dll reload string loss)";
					zt_game->profiler->threads[i].allocations[j][k].section = "(dll reload string loss)";
				}
			}
		}
#		endif
	}
}

#else

#if defined(ZT_OPENGL)

	void zt_dllSendGameGlobals(zt_dllSetGameGlobals_Func *set_globals, zt_dllSetOpenGLGlobals_Func *set_globals_opengl)
	{
		if (set_globals) {
			set_globals(zt_game, ZT_GAME_GLOBALS_VERSION);
		}
		if (set_globals_opengl) {
			zt_game->zt_dllSetOpenGLGlobals = set_globals_opengl;
		}
	}

#else

void zt_dllSendGameGlobals(zt_dllSetGameGlobals_Func *set_globals)
	{
		if (set_globals) {
			set_globals(zt_game, ZT_GAME_GLOBALS_VERSION);
		}
	}

#endif

#endif // ZT_DLL


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// stb images is embedded at the end of the file, but the functions we call need exposed beforehand
typedef unsigned char stbi_uc;

extern "C" {
	// stb image
	static stbi_uc     *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
	static float       *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
	static void         stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
	static void         stbi_image_free(void *retval_from_stbi_load);
	static const char  *stbi_failure_reason  (void);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal ZT_FUNC_THREAD_EXIT(_zt_threadJobJobExit)
{
	ztThreadJob *job = (ztThreadJob*)user_data;
	return zt_atomicBoolGet(&job->cancelled);
}

// ================================================================================================================================================================================================

ztInternal ZT_FUNC_THREAD(_zt_threadJobThread)
{
	zt_sleep(.25f); // we need to sleep here because profiling (in the zt_atomic* functions) accesses thread_ids that might not exist when this function starts

	ztThreadJobThreadData *thread_data = (ztThreadJobThreadData*)user_data;

	zt_atomicBoolSet(&thread_data->should_exit, false);
	zt_atomicBoolSet(&thread_data->processing, false);

	while (!zt_atomicBoolGet(&thread_data->should_exit)) {
		zt_threadMonitorWaitForSignal(thread_data->start); // sleep until we have a job to do or are exiting
		zt_threadMonitorReset(thread_data->start);

		if (zt_atomicBoolGet(&thread_data->should_exit)) {
			return 0;
		}

		ZT_PROFILE_GAME("Thread Main");

		while (thread_data->next_job && !zt_atomicBoolGet(&thread_data->should_exit)) {
			thread_data->next_job->thread_func(thread_data->thread_id, thread_data->next_job->thread_func_user_data, _zt_threadJobJobExit, thread_data->next_job);
			zt_atomicBoolSet(&thread_data->next_job->completed, true);
			thread_data->next_job = thread_data->next_job->next;
		}

		zt_atomicBoolSet(&thread_data->processing, false);

		if (zt_atomicBoolGet(&thread_data->should_exit)) {
			return 0;
		}

		zt_threadMonitorTriggerSignal(thread_data->finish);
	}

	return 0;
}

// ================================================================================================================================================================================================

ztInternal void _zt_threadJobQueueInit(int max_frame_threads, int max_background_threads)
{
	zt_assert(max_frame_threads + max_background_threads <= ZT_MAX_THREADS);

	ztThreadJobQueue *queue   = zt_game->thread_job_queue = zt_mallocStruct(ztThreadJobQueue);
	queue->threads_count      = max_frame_threads + max_background_threads;
	queue->threads            = zt_mallocStructArray(ztThreadJobThreadData, queue->threads_count);
	queue->frame_threads      = max_frame_threads;
	queue->background_threads = max_background_threads;

	zt_fiz(queue->threads_count) {
		queue->threads[i].start = zt_threadMonitorMake();
		queue->threads[i].finish = zt_threadMonitorMake();
		queue->threads[i].thread = zt_threadMake(_zt_threadJobThread, &queue->threads[i], nullptr, nullptr, &queue->threads[i].thread_id);
		queue->threads[i].type = i < max_frame_threads ? ztThreadJobType_Frame : ztThreadJobType_Background;
		zt_atomicBoolSet(&queue->threads[i].should_exit, false);
		zt_atomicBoolSet(&queue->threads[i].processing, false);
		queue->threads[i].next_job = nullptr;
	}

	zt_fize(queue->job_queue) {
		queue->job_queue[i].id                    = ztInvalidID;
		queue->job_queue[i].type                  = ztThreadJobType_MAX;
		queue->job_queue[i].thread_func           = nullptr;
		queue->job_queue[i].thread_func_user_data = nullptr;
		queue->job_queue[i].next                  = nullptr;
		zt_atomicBoolSet(&queue->job_queue[i].completed, true);
		zt_atomicBoolSet(&queue->job_queue[i].cancelled, false);
	}
}

// ================================================================================================================================================================================================

ztInternal void _zt_threadJobQueueFree()
{
	zt_threadJobQueueDllUnload();

	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(queue->threads_count) {
		zt_threadMonitorFree(queue->threads[i].start);
		zt_threadMonitorFree(queue->threads[i].finish);
	}

	zt_free(queue->threads);
	zt_free(queue);
}

// ================================================================================================================================================================================================

ztInternal void _zt_threadJobQueueUpdate()
{
	ZT_PROFILE_PLATFORM("_zt_threadJobQueueUpdate");
	if (zt_game->thread_job_queue == nullptr || zt_game->thread_job_queue->threads_count <= 0) {
		return;
	}

	zt_threadJobQueueWaitForFrameJobs();
}

// ================================================================================================================================================================================================

void zt_threadJobQueueDllLoad()
{
	ztThreadJobQueue *queue = zt_game->thread_job_queue;
	zt_fiz(queue->threads_count) {
		zt_atomicBoolSet(&queue->threads[i].should_exit, false);
		queue->threads[i].thread = zt_threadMake(_zt_threadJobThread, &queue->threads[i], nullptr, nullptr, &queue->threads[i].thread_id);
		zt_assert(queue->threads[i].next_job == nullptr);
	}
}

// ================================================================================================================================================================================================

void zt_threadJobQueueDllUnload()
{
	zt_threadJobQueueWaitForAllJobs();

	ztThreadJobQueue *queue = zt_game->thread_job_queue;
	zt_fiz(queue->threads_count) {
		zt_atomicBoolSet(&queue->threads[i].should_exit, true);
		zt_threadMonitorTriggerSignal(queue->threads[i].start);

		if (queue->threads[i].thread != nullptr) {
			zt_threadJoin(queue->threads[i].thread);
			zt_threadFree(queue->threads[i].thread);
			queue->threads[i].thread = nullptr;
		}

		zt_assert(queue->threads[i].next_job == nullptr);
	}
}

// ================================================================================================================================================================================================

ztInternal ztThreadJobID _zt_threadJobQueueFor(ztThread_Func thread_func, void *user_data, r32 anticipated_length, ztThreadJobType_Enum type)
{
	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	if (queue->threads_count <= 0) {
		thread_func(0, user_data, nullptr, nullptr);
		return -2;
	}

	r32 lowest_val = ztReal32Max;
	int lowest_idx = -1;

	zt_fiz(queue->threads_count) {
		if (queue->threads[i].type == type && !zt_atomicBoolGet(&queue->threads[i].processing)) {
			r32 val = 0;
			zt_flink(job, queue->threads[i].next_job) {
				val += job->anticipated_length;
			}
			if (val < lowest_val) {
				lowest_val = val;
				lowest_idx = i;
			}
		}
	}

	if (lowest_idx == -1) {
		// there are no waiting frame threads, so we need to wait
		if (type == ztThreadJobType_Frame) {
			zt_threadJobQueueWaitForFrameJobs();
		}
		else {
			// TODO: should maintain a separate queue so we aren't stalling here
			zt_threadJobQueueWaitForBackgroundJobs();
		}
		return _zt_threadJobQueueFor(thread_func, user_data, anticipated_length, type);
	}

	ztThreadJobThreadData *thread_data = &queue->threads[lowest_idx];

	ztThreadJob *job = nullptr;
	zt_fiz(ZT_THREAD_JOB_QUEUE_SIZE) {
		if (zt_atomicBoolGet(&queue->job_queue[i].completed)) {
			job = &queue->job_queue[i];
			break;
		}
	}
	if (job == nullptr) {
		// there are no free job slots, so we need to wait
		if (type == ztThreadJobType_Frame) {
			zt_threadJobQueueWaitForFrameJobs();
		}
		else {
			zt_threadJobQueueWaitForBackgroundJobs();
		}
		zt_threadJobQueueWaitForFrameJobs();
		return _zt_threadJobQueueFor(thread_func, user_data, anticipated_length, type);
	}

	job->id                     = ++queue->total_job_count;
	job->type                   = type;
	job->thread_func            = thread_func;
	job->thread_func_user_data  = user_data;
	job->anticipated_length     = anticipated_length;
	job->next                   = nullptr;
	job->frame_created          = zt_game->game_details.current_frame;

	zt_atomicBoolSet(&job->completed, false);
	zt_atomicBoolSet(&job->cancelled, false);

	zt_singleLinkAddToEnd(thread_data->next_job, job);

	if (type == ztThreadJobType_Background) {
		zt_threadMonitorTriggerSignal(thread_data->start);
	}

	return job->id;
}

// ================================================================================================================================================================================================

ztThreadJobID zt_threadJobQueueForFrame(ztThread_Func thread_func, void *user_data, r32 anticipated_length)
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueForFrame");
	return _zt_threadJobQueueFor(thread_func, user_data, anticipated_length, ztThreadJobType_Frame);
}

// ================================================================================================================================================================================================

ztThreadJobID zt_threadJobQueueForBackground(ztThread_Func thread_func, void *user_data, r32 anticipated_length)
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueForBackground");
	if (zt_game->thread_job_queue->background_threads == 0) {
		thread_func(0, user_data, nullptr, nullptr);
		return -2;
	}
	else {
		return _zt_threadJobQueueFor(thread_func, user_data, anticipated_length, ztThreadJobType_Background);
	}
}

// ================================================================================================================================================================================================

bool zt_threadJobIsComplete(ztThreadJobID job_id)
{
	ZT_PROFILE_PLATFORM("zt_threadJobIsComplete");
	if (job_id == -2) {
		return true;
	}

	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(ZT_THREAD_JOB_QUEUE_SIZE) {
		if (queue->job_queue[i].id == job_id) {
			return zt_atomicBoolGet(&queue->job_queue[i].completed);
		}
	}

	return true; // if the job isn't found, it's been pushed out of the queue
}

// ================================================================================================================================================================================================

void zt_threadJobCancel(ztThreadJobID job_id)
{
	ZT_PROFILE_PLATFORM("zt_threadJobCancel");
	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(ZT_THREAD_JOB_QUEUE_SIZE) {
		if (queue->job_queue[i].id == job_id) {
			zt_atomicBoolSet(&queue->job_queue[i].cancelled, true);
			break;
		}
	}
}

// ================================================================================================================================================================================================

void zt_threadJobQueueStartFrameJobs()
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueStartFrameJobs");
	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(queue->threads_count) {
		if (queue->threads[i].type == ztThreadJobType_Frame && !zt_atomicBoolGet(&queue->threads[i].processing)) {
			//zt_threadMonitorTriggerSignal(queue->threads[i].finish);
			zt_threadMonitorReset(queue->threads[i].finish);
			zt_atomicBoolSet(&queue->threads[i].processing, true);
			zt_threadMonitorTriggerSignal(queue->threads[i].start);
		}
	}
}

// ================================================================================================================================================================================================

void zt_threadJobQueueWaitForFrameJobs()
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueWaitForFrameJobs");
	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(queue->threads_count) {
		if (queue->threads[i].type == ztThreadJobType_Frame && zt_atomicBoolGet(&queue->threads[i].processing)) {
			zt_threadMonitorWaitForSignal(queue->threads[i].finish);
		}
	}
}

// ================================================================================================================================================================================================

void zt_threadJobQueueWaitForBackgroundJobs()
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueWaitForBackgroundJobs");
	ztThreadJobQueue *queue = zt_game->thread_job_queue;

	zt_fiz(queue->threads_count) {
		if (queue->threads[i].type == ztThreadJobType_Background && zt_atomicBoolGet(&queue->threads[i].processing)) {
			zt_threadMonitorWaitForSignal(queue->threads[i].finish);
		}
	}
}

// ================================================================================================================================================================================================

void zt_threadJobQueueWaitForAllJobs()
{
	ZT_PROFILE_PLATFORM("zt_threadJobQueueWaitForAllJobs");
	zt_threadJobQueueWaitForFrameJobs();
	zt_threadJobQueueWaitForBackgroundJobs();
}

// ================================================================================================================================================================================================

int zt_threadGetIndex()
{
	ztThreadID thread_id = zt_threadGetCurrentID();
	if (zt_game == nullptr || thread_id == zt_game->main_thread_id || zt_game->thread_job_queue == nullptr) {
		return 0;
	}

	zt_fiz(zt_game->thread_job_queue->threads_count) {
		if (zt_game->thread_job_queue->threads[i].thread_id == thread_id) {
			return i + 1;
		}
	}

	zt_assert(false);
	return -1;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal void _zt_profilerInit()
{
#	if !defined(ZT_NO_PROFILE)
	zt_game->profiler = zt_mallocStruct(ztProfiler);
	zt_game->profiler->paused = false;

	zt_fize(zt_game->profiler->threads) {
		zt_game->profiler->threads[i].allocations = (ztProfiledSection**)malloc(zt_sizeof(ztProfiledSection*) * ZT_PROFILER_FRAMES_KEPT);
		zt_game->profiler->threads[i].roots       = (ztProfiledSection**)malloc(zt_sizeof(ztProfiledSection*) * ZT_PROFILER_FRAMES_KEPT);
		zt_game->profiler->threads[i].sections    = (int*)malloc(zt_sizeof(int) * ZT_PROFILER_FRAMES_KEPT);

		zt_fjz(ZT_PROFILER_FRAMES_KEPT) {
			zt_game->profiler->threads[i].allocations[j] = (ztProfiledSection*)malloc(zt_sizeof(ztProfiledSection) * ZT_PROFILER_MAX_SECTIONS_PER_FRAME);
			zt_game->profiler->threads[i].roots      [j] = nullptr;
			zt_game->profiler->threads[i].sections   [j] = 0;
		}
		zt_game->profiler->threads[i].root                        = nullptr;
		zt_game->profiler->threads[i].current                     = nullptr;
		zt_game->profiler->threads[i].allocations_current_section = 0;
		zt_game->profiler->threads[i].allocations_current_frame   = -1;
	}
	
	zt_game->profiler->current_frame = -1;
#	endif
}

// ================================================================================================================================================================================================

ztInternal void _zt_profilerFree()
{
#	if !defined(ZT_NO_PROFILE)

	zt_fize(zt_game->profiler->threads) {
		zt_fjz(ZT_PROFILER_FRAMES_KEPT) {
			free(zt_game->profiler->threads[i].allocations[j]);
		}
		free(zt_game->profiler->threads[i].allocations);
		free(zt_game->profiler->threads[i].roots);
		free(zt_game->profiler->threads[i].sections);
	}

	free(zt_game->profiler);
	zt_game->profiler = nullptr;
#	endif
}

// ================================================================================================================================================================================================

void zt_profilerPause()
{
#	if !defined(ZT_NO_PROFILE)
	zt_game->profiler->paused = true;
#	endif
}

// ================================================================================================================================================================================================

void zt_profilerResume()
{
#	if !defined(ZT_NO_PROFILE)
	zt_game->profiler->paused = false;
#	endif
}

// ================================================================================================================================================================================================

bool zt_profilerIsPaused()
{
#	if !defined(ZT_NO_PROFILE)
	return zt_game->profiler->paused;
#	else
	return false;
#	endif
}

// ================================================================================================================================================================================================
void zt_profilerFrameBegin()
{
#	if !defined(ZT_NO_PROFILE)
	if (zt_game->profiler->paused) {
		return;
	}

	zt_game->profiler->current_frame = (zt_game->profiler->current_frame + 1) % ZT_PROFILER_FRAMES_KEPT;
#	endif
}

// ================================================================================================================================================================================================

void zt_profilerFrameEnd()
{
#	if !defined(ZT_NO_PROFILE)
#	endif
}

// ================================================================================================================================================================================================

void zt_profilerRender(ztDrawList *draw_list, const ztVec2 &pos, const ztVec2 &size, const ztVec2 &mouse_pos, bool mouse_clicked, ztProfilerRenderState *render_state)
{
#	if !defined(ZT_NO_PROFILE)

	r32 ppu = zt_pixelsPerUnit();

	zt_drawListPushShader(draw_list, zt_shaderGetDefault(ztShaderDefault_Unlit));
	zt_drawListPushTexture(draw_list, 0);

	zt_drawListPushColor(draw_list, zt_color(0, 0, 0, .95f));
	zt_drawListAddFilledRect2D(draw_list, pos, size, ztVec2::zero, ztVec2::one);
	zt_drawListPopColor(draw_list);

	ztVec2 timeline_size = zt_vec2(size.x - 10 / ppu, 30 / ppu);
	ztVec2 timeline_pos  = zt_vec2(pos.x, pos.y + ((size.y - timeline_size.y) / 2) - (5 / ppu));

	r32 pixel_size = 2 / ppu;
	r32 width_per_frame = (timeline_size.x - ((ZT_PROFILER_FRAMES_KEPT + 1) * pixel_size)) / ZT_PROFILER_FRAMES_KEPT;

	int display_frame = zt_game->profiler->current_frame - 1;
	if (display_frame < 0) {
		display_frame = ZT_PROFILER_FRAMES_KEPT - 1;
	}

	int display_thread = render_state ? zt_clamp(render_state->display_thread, 0, zt_elementsOf(zt_game->profiler->threads)) : 0;

	if (render_state) {
		if (render_state->display_frame >= 0 && render_state->display_frame < ZT_PROFILER_FRAMES_KEPT && render_state->display_frame != zt_game->profiler->current_frame) {
			display_frame = render_state->display_frame;
		}
	}

	{

		zt_drawListPushColor(draw_list, ztColor_Black);
		zt_drawListAddFilledRect2D(draw_list, timeline_pos, timeline_size, ztVec2::zero, ztVec2::one);
		zt_drawListPopColor(draw_list);

		zt_drawListPushColor(draw_list, ztColor_Gray);

		ztVec2 frame_size = zt_vec2(width_per_frame, timeline_size.y - (pixel_size * 2));
		r32 x = (timeline_pos.x - (timeline_size.x / 2)) + (width_per_frame / 2) + pixel_size;
		zt_fiz(ZT_PROFILER_FRAMES_KEPT) {
			ztVec2 fpos = zt_vec2(x, timeline_pos.y);
			if (mouse_clicked && render_state && i != zt_game->profiler->current_frame && zt_collisionPointInRect(mouse_pos, fpos, frame_size)) {
				if (render_state->display_frame == i) {
					render_state->display_frame = -1;
				}
				else {
					render_state->display_frame = i;
				}
			}

			if (i == zt_game->profiler->current_frame) {
				zt_drawListPushColor(draw_list, ztColor_Green);
			}
			else if (i == display_frame) {
				zt_drawListPushColor(draw_list, ztColor_Orange);
			}

			zt_drawListAddFilledRect2D(draw_list, fpos, frame_size, ztVec2::zero, ztVec2::one);
			x += width_per_frame + pixel_size;

			if (i == zt_game->profiler->current_frame || i == display_frame) {
				zt_drawListPopColor(draw_list);
			}
		}

		zt_drawListPopColor(draw_list);
	}

	ztVec2 timegraph_size = zt_vec2(size.x - 10 / ppu, 90 / ppu);
	ztVec2 timegraph_pos  = zt_vec2(pos.x, timeline_pos.y - (timeline_size.y / 2 + timegraph_size.y / 2 + 5 / ppu));
	{
		zt_drawListPushColor(draw_list, ztColor_Black);
		zt_drawListAddFilledRect2D(draw_list, timegraph_pos, timegraph_size, ztVec2::zero, ztVec2::one);
		zt_drawListPopColor(draw_list);

		r64 max = 0;
		zt_fiz(ZT_PROFILER_FRAMES_KEPT) {
			if (i == zt_game->profiler->current_frame || zt_game->profiler->threads[display_thread].roots[i] == nullptr) {
				continue;
			}

			max = zt_max(max, zt_game->profiler->threads[display_thread].roots[i]->time_accum);
		}

		max *= 1.1f;
		//max = 1000 / 60.f;

		if (max) {
			r32 x = (timegraph_pos.x - (timegraph_size.x / 2)) + (width_per_frame / 2) + pixel_size;
			zt_drawListPushColor(draw_list, ztColor_Green);
			ztVec2 frame_size = zt_vec2(width_per_frame, timegraph_size.y - (pixel_size * 2));
			zt_fiz(ZT_PROFILER_FRAMES_KEPT) {
				if (i == zt_game->profiler->current_frame || zt_game->profiler->threads[display_thread].roots[i] == nullptr) {
					x += width_per_frame + pixel_size;
					continue;
				}

				r32 pct = (r32)(zt_game->profiler->threads[display_thread].roots[i]->time_accum / max);

				zt_drawListAddFilledRect2D(draw_list, zt_vec2(x, timegraph_pos.y - ((frame_size.y * (1 - pct)) / 2)), zt_vec2(frame_size.x, zt_max(pixel_size, frame_size.y * pct)), ztVec2::zero, ztVec2::one);
				x += width_per_frame + pixel_size;
			}
			zt_drawListPopColor(draw_list);
		}
	}

	{
		r32 button_w = pixel_size * 50;
		r32 button_x = timegraph_pos.x - ((timegraph_size.x - button_w) / 2) + (pixel_size * 2);
		zt_fiz(zt_elementsOf(zt_game->profiler->threads) + 1) {
			ztVec2 button_pos = zt_vec2(button_x, timegraph_pos.y - (timegraph_size.y / 2) - pixel_size * 7);
			ztVec2 button_size = zt_vec2(button_w, pixel_size * 12);

			button_x += button_w + pixel_size * 10;

			ztColor button_clr = ztColor_Gray;
			
			if (i == 0 && zt_game->profiler->paused) {
				button_clr = ztColor_DarkRed;
			}
			else if (i - 1 == display_thread) {
				button_clr = ztColor_DarkGreen;
			}

			if (zt_collisionPointInRect(mouse_pos, button_pos, button_size)) {
				button_clr *= 1.25f;

				if (mouse_clicked) {
					if (i == 0) {
						zt_game->profiler->paused = !zt_game->profiler->paused;
					}
					else if (render_state) {
						render_state->display_thread = i - 1;
					}
				}
			}

			zt_drawListPushColor(draw_list, button_clr);
			zt_drawListAddFilledRect2D(draw_list, button_pos, button_size, ztVec2::zero, ztVec2::one);
			zt_drawListPopColor(draw_list);
			button_pos.y += pixel_size;
			if (i == 0) {
				zt_drawListAddText2D(draw_list, 0, zt_game->profiler->paused ? "Resume" : "Pause", button_pos);
			}
			else if (i == 1) {
				zt_drawListAddText2D(draw_list, 0, "Main Thread", button_pos);
			}
			else {
				zt_strMakePrintf(thread_name, 128, "Thread %d", i - 1);
				zt_drawListAddText2D(draw_list, 0, thread_name, button_pos);
			}
		}
	}

	ztProfiledSection *ps_details = nullptr;
	{
		ztProfiledSection *ps = zt_game->profiler->threads[display_thread].roots[display_frame];
		r32 x = (timegraph_pos.x - (timegraph_size.x / 2)) + (width_per_frame / 2) + pixel_size;
		r32 y = (timegraph_pos.y - (timegraph_size.y / 2)) - 15 * pixel_size;

		if (ps) {
			int sections = zt_game->profiler->threads[display_thread].sections[display_frame];

			r64 self_times[ZT_PROFILER_MAX_SECTIONS_PER_FRAME];

			zt_fiz(sections) {
				self_times[i] = zt_game->profiler->threads[display_thread].allocations[display_frame][i].time_accum;

				zt_flink(child, zt_game->profiler->threads[display_thread].allocations[display_frame][i].children) {
					self_times[i] -= child->time_accum;
				}
			}

			zt_fiz(sections) {
				r64 current = 0;
				int current_idx = 0;
				zt_fjz(sections) {
					if (self_times[j] >= current) {
						current = self_times[j];
						current_idx = j;
					}
				}
				r64 self_time = self_times[current_idx];
				self_times[current_idx] = 0;

				if (self_time == 0) break;

				ztProfiledSection *ps = &zt_game->profiler->threads[display_thread].allocations[display_frame][current_idx];

				zt_strMakePrintf(display, 512, "%10.4f . %s", (r32)self_time * 1000000, ps->section);

				ztVec2 text_pos = zt_vec2(x, y);
				ztVec2 text_size;

				zt_drawListAddText2D(draw_list, 0, display, zt_vec2(x, y), ztAlign_Top | ztAlign_Left, ztAnchor_Top | ztAnchor_Left, &text_size);

				text_pos.x += text_size.x / 2.f;
				text_pos.y -= text_size.y / 2.f;
				if (zt_collisionPointInRect(mouse_pos, text_pos, text_size)) {
					ps_details = ps;
				}

				y -= pixel_size * 10;

				if (y - pixel_size * 10 < pos.y - (size.y / 2.f)) break;
			}
		}

		x = pos.x + pixel_size;
		y = (timegraph_pos.y - (timegraph_size.y / 2)) - 15 * pixel_size;

		struct local
		{
			static int compare(const void *a, const void *b)
			{
				ztProfiledSection *pa = *(ztProfiledSection**)a;
				ztProfiledSection *pb = *(ztProfiledSection**)b;

				if (pa->time_accum > pb->time_accum) {
					return -1;
				}
				else if (pa->time_accum < pb->time_accum) {
					return 1;
				}
				return 0;
			}

			static void displaySection(ztDrawList *draw_list, ztProfiledSection *section, r32 x, r32 *y, r32 pixel_size, r32 right, r32 y_max, int indent)
			{
				if (section == nullptr || *y < y_max) {
					return;
				}

				ztVec2 ext_label;

				r64 tm_total = section->time_accum, tm_alone = section->time_accum;
				{
					zt_flink(child, section->children) {
						tm_alone -= child->time_accum;
					}
				}

				//if (tm_total * 1000000 < 10) return;

				ztVec2 pos = zt_vec2(x + (indent * pixel_size * 10), *y);

				zt_strMakePrintf(time, 512, " %10.4f %12.4f . ", tm_total * 1000000, tm_alone * 1000000);
				zt_drawListAddText2D(draw_list, 0, time, pos, ztAlign_Top|ztAlign_Left, ztAnchor_Top|ztAnchor_Left, &ext_label);

				zt_strMakePrintf(func, 512, "%s", section->section);
				zt_drawListAddText2D(draw_list, 0, func, zt_vec2(pos.x + ext_label.x, *y), ztAlign_Top|ztAlign_Left, ztAnchor_Top|ztAnchor_Left, &ext_label);

				if (indent > 0) {
					zt_drawListAddLine(draw_list, zt_vec3(x + ((indent - 1) * pixel_size * 10), *y - ext_label.y / 2, 0), zt_vec3(x + (indent * pixel_size * 10), *y - ext_label.y / 2, 0));
					zt_drawListAddLine(draw_list, zt_vec3(x + ((indent - 1) * pixel_size * 10), *y + ext_label.y / 2 + pixel_size * 2, 0), zt_vec3(x + ((indent - 1) * pixel_size * 10), *y - (ext_label.y + pixel_size) / 2, 0));
				}

				*y -= pixel_size * 10;

				ztProfiledSection *children[ZT_PROFILER_MAX_SECTIONS_PER_FRAME];
				{
					int idx = 0;
					zt_flink(child, section->children) {
						children[idx++] = child;
					}

					qsort(children, idx, zt_sizeof(ztProfiledSection*), compare);

					zt_fiz(idx) {
						displaySection(draw_list, children[i], x, y , pixel_size, right, y_max, indent + 1);
					}
				}

//				int idx = 0;
//				zt_flink(child, section->children) {
//					idx += 1;
//					displaySection(draw_list, child, x, y, pixel_size, right, y_max, indent + 1);
//				}
			}
		};

		if (ps_details) {
			local::displaySection(draw_list, ps_details, pos.x - pixel_size * 100, &y, pixel_size, (pos.x + size.x / 2) - pixel_size * 10, (pos.y - (size.y / 2.f)) + pixel_size * 10, 0);//pos.x + (size.x / 2) - 10 / ppu);
		}
	}

	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);
#	endif
}

// ================================================================================================================================================================================================

ztProfiledSection *zt_profiledSectionEnter(const char *section, i32 section_hash, const char *system, i32 system_hash, int thread_idx)
{
#	if !defined(ZT_NO_PROFILE)
	if (zt_game == nullptr || zt_game->profiler == nullptr || zt_game->profiler->paused) {
		return nullptr;
	}

	//if (zt_game->game_details.current_frame <= 1) return nullptr;

	ztProfiledThread *pt = &zt_game->profiler->threads[thread_idx];
	ztProfiledSection *ps = nullptr;
	bool ps_existing = false;

	if (pt->root == nullptr || pt->allocations_current_frame != zt_game->profiler->current_frame) {

		if (pt->allocations_current_frame < zt_game->profiler->current_frame) {
			for (int i = pt->allocations_current_frame + 1; i < zt_game->profiler->current_frame; ++i) {
				pt->roots[i] = nullptr;
				pt->sections[i] = 0;
			}
		}
		else {
			for (int i = pt->allocations_current_frame + 1; i < ZT_PROFILER_FRAMES_KEPT; ++i) {
				pt->roots[i] = nullptr;
				pt->sections[i] = 0;
			}
			for (int i = 0; i < zt_game->profiler->current_frame; ++i) {
				pt->roots[i] = nullptr;
				pt->sections[i] = 0;
			}
		}

		pt->allocations_current_frame   = zt_game->profiler->current_frame;
		pt->allocations_current_section = 0;

		ps = pt->root = &pt->allocations[pt->allocations_current_frame][pt->allocations_current_section++];

		pt->roots   [pt->allocations_current_frame] = pt->root;
		pt->sections[pt->allocations_current_frame] = 0;
		pt->current = nullptr;
	}
	else {
		zt_flink(child, pt->current->children) {
			if (child->section_hash == section_hash && child->system_hash == system_hash) {
				ps = child;
				ps_existing = true;
				break;
			}
		}
		if (ps == nullptr) {
			if (pt->allocations_current_section >= ZT_PROFILER_MAX_SECTIONS_PER_FRAME) {
				zt_debugOnly(zt_assert(false));
				return nullptr;
			}

			ps = &pt->allocations[pt->allocations_current_frame][pt->allocations_current_section++];
			pt->sections[pt->allocations_current_frame] = pt->allocations_current_section;

		}
	}

	if (ps) {
		ps->thread = pt;

		ps->parent = pt->current;
		ps->time_begin = zt_getTime();

		if (!ps_existing) {
			ps->time_accum   = 0;
			ps->called       = 0;
			ps->children     = nullptr;
			ps->next         = nullptr;
			ps->section      = section;
			ps->section_hash = section_hash;
			ps->system       = system;
			ps->system_hash  = system_hash;
		}

		if (pt->current && !ps_existing) {
			ztProfiledSection *last = pt->current->children;
			while(last && last->next) {
				last = last->next;
			}

			zt_singleLinkAddToEnd(pt->current->children, ps);
			zt_assert(pt->current->children != pt->current->parent);
		}

		pt->current = ps;

	}

	return ps;
#	else
	return nullptr;
#	endif
}

// ================================================================================================================================================================================================

void zt_profiledSectionExit(ztProfiledSection *section)
{
#	if !defined(ZT_NO_PROFILE)
	if (section == nullptr) {
		return;
	}

	//if (zt_game->game_details.current_frame <= 1) return;

	r64 time_end = zt_max(zt_getTime(), section->time_begin);

	section->time_accum += time_end - section->time_begin;
	section->called += 1;

	if (section->parent) {
		section->thread->current = section->parent;
	}
#	endif
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal ztDebugVarID _zt_debuggingAddVariable(const char *name, ztVariant val)
{
	ZT_PROFILE_PLATFORM("_zt_debuggingAddVariable");
	zt_assertReturnValOnFail(zt_game->debug_vars_count < zt_elementsOf(zt_game->debug_vars), ztInvalidID);

	ztDebugVar *debug_var = &zt_game->debug_vars[zt_game->debug_vars_count++];

	zt_strCpy(debug_var->name, zt_elementsOf(debug_var->name), name);
	debug_var->name_hash = zt_strHash(name);

	zt_variantAssignValue(&debug_var->variable, val);

	if (zt_game->debug_vars_file_size != 0) {

		ztSerial serial;
		if (zt_serialMakeReader(&serial, zt_game->debug_vars_file_data, zt_game->debug_vars_file_size, "zt.debugvars")) {
			int count = 0;
			if (zt_serialRead(&serial, &count)) {

				zt_fiz(count) {
					zt_serialGroupPush(&serial);
					{
						char var_name[128];
						i32 var_name_len = 0;
						if (zt_serialRead(&serial, var_name, zt_elementsOf(var_name), &var_name_len)) {
							if (zt_strEquals(name, var_name)) {
								zt_serialRead(&serial, &debug_var->variable);
								break;
							}
						}
					}
					zt_serialGroupPop(&serial);
				}
			}
		}
	}

	return zt_game->debug_vars_count - 1;
}

// ================================================================================================================================================================================================

void zt_debuggingInit(const char *settings_file_name, const char *alt_path)
{
	const char *path = alt_path ? alt_path : zt_game->game_details.user_path;
	zt_fileConcatFileToPath(zt_game->debug_vars_file, zt_elementsOf(zt_game->debug_vars_file), path, settings_file_name);

	zt_game->debug_vars_file_data = (char*)zt_readEntireFile(zt_game->debug_vars_file, &zt_game->debug_vars_file_size);
}

// ================================================================================================================================================================================================

ztInternal void _zt_debuggingCleanup()
{
	zt_free(zt_game->debug_vars_file_data);

	ztSerial serial;
	if (zt_serialMakeWriter(&serial, zt_game->debug_vars_file, "zt.debugvars", 1)) {
		zt_serialWrite(&serial, zt_game->debug_vars_count);

		zt_fiz(zt_game->debug_vars_count) {
			zt_serialGroupPush(&serial);
			{
				zt_serialWrite(&serial, zt_game->debug_vars[i].name, zt_strLen(zt_game->debug_vars[i].name));
				zt_serialWrite(&serial, &zt_game->debug_vars[i].variable);
			}
			zt_serialGroupPop(&serial);
		}

		zt_serialClose(&serial);
	}

	zt_debugDisplayCleanup();
}

// ================================================================================================================================================================================================

ztInternal ztDebugVarID _zt_debuggingRegisterVariable(const char *name, ztVariant val)
{
	ZT_PROFILE_PLATFORM("_zt_debuggingRegisterVariable");
	i32 hash = zt_strHash(name);
	zt_fiz(zt_game->debug_vars_count) {
		if (zt_game->debug_vars[i].name_hash == hash && zt_game->debug_vars[i].variable.type == val.type) {
			return i;
		}
	}

	int idx = _zt_debuggingAddVariable(name, val);
	if (idx >= 0) {
		return idx;
	}

	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztDebugVarID zt_debuggingRegisterVariable(const char *name, i8     val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_i8(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, i16    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_i16(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, i32    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_i32(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, i64    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_i64(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, u8     val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_u8(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, u16    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_u16(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, u32    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_u32(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, u64    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_u64(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, r32    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_r32(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, r64    val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_r64(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, ztVec2 val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_vec2(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, ztVec3 val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_vec3(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, ztVec4 val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_vec4(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, ztMat4 val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_mat4(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, ztQuat val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_quat(val)); }
ztDebugVarID zt_debuggingRegisterVariable(const char *name, bool   val) { return _zt_debuggingRegisterVariable(name, zt_variantMake_bool(val)); }

// ================================================================================================================================================================================================

i8     zt_debuggingGet_i8  (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_i8  (&zt_game->debug_vars[debug_var].variable); }
i16    zt_debuggingGet_i16 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_i16 (&zt_game->debug_vars[debug_var].variable); }
i32    zt_debuggingGet_i32 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_i32 (&zt_game->debug_vars[debug_var].variable); }
i64    zt_debuggingGet_i64 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_i64 (&zt_game->debug_vars[debug_var].variable); }
u8     zt_debuggingGet_u8  (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_u8  (&zt_game->debug_vars[debug_var].variable); }
u16    zt_debuggingGet_u16 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_u16 (&zt_game->debug_vars[debug_var].variable); }
u32    zt_debuggingGet_u32 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_u32 (&zt_game->debug_vars[debug_var].variable); }
u64    zt_debuggingGet_u64 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_u64 (&zt_game->debug_vars[debug_var].variable); }
r32    zt_debuggingGet_r32 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_r32 (&zt_game->debug_vars[debug_var].variable); }
r64    zt_debuggingGet_r64 (ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, 0               ); return zt_variantGetAs_r64 (&zt_game->debug_vars[debug_var].variable); }
ztVec2 zt_debuggingGet_vec2(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, ztVec2::zero    ); return zt_variantGetAs_vec2(&zt_game->debug_vars[debug_var].variable); }
ztVec3 zt_debuggingGet_vec3(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, ztVec3::zero    ); return zt_variantGetAs_vec3(&zt_game->debug_vars[debug_var].variable); }
ztVec4 zt_debuggingGet_vec4(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, ztVec4::zero    ); return zt_variantGetAs_vec4(&zt_game->debug_vars[debug_var].variable); }
ztMat4 zt_debuggingGet_mat4(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, ztMat4::zero    ); return zt_variantGetAs_mat4(&zt_game->debug_vars[debug_var].variable); }
ztQuat zt_debuggingGet_quat(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, ztQuat::identity); return zt_variantGetAs_quat(&zt_game->debug_vars[debug_var].variable); }
bool   zt_debuggingGet_bool(ztDebugVarID debug_var) { zt_assertReturnValOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count, false           ); return zt_variantGetAs_bool(&zt_game->debug_vars[debug_var].variable); }

// ================================================================================================================================================================================================

void zt_debuggingSet(ztDebugVarID debug_var, i8     val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_i8   = val; }
void zt_debuggingSet(ztDebugVarID debug_var, i16    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_i16  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, i32    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_i32  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, i64    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_i64  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, u8     val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_u8   = val; }
void zt_debuggingSet(ztDebugVarID debug_var, u16    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_u16  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, u32    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_u32  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, u64    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_u64  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, r32    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_r32  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, r64    val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_r64  = val; }
void zt_debuggingSet(ztDebugVarID debug_var, ztVec2 val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_vec2 = val; }
void zt_debuggingSet(ztDebugVarID debug_var, ztVec3 val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_vec3 = val; }
void zt_debuggingSet(ztDebugVarID debug_var, ztVec4 val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_vec4 = val; }
void zt_debuggingSet(ztDebugVarID debug_var, ztMat4 val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_mat4 = val; }
void zt_debuggingSet(ztDebugVarID debug_var, ztQuat val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_quat = val; }
void zt_debuggingSet(ztDebugVarID debug_var, bool   val) {  zt_assertReturnOnFail(debug_var >= 0 && debug_var < zt_game->debug_vars_count); zt_game->debug_vars[debug_var].variable.v_bool = val; }


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztAssetPackedFileHeader
{
	i32 magic_numbers[3];
	i32 file_count;
	i32 name_buffer_size;
	i32 file_start_pos;
};
#pragma pack(pop)

// ================================================================================================================================================================================================

#define ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_0    74813956
#define ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_1    18935478
#define ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_2    35489754

// ================================================================================================================================================================================================

#pragma pack(push, 1)
struct ztAssetPackedFileEntry
{
	i32 hash;
	i32 size;
	i32 type;
	i32 start; // from end of entry table
};
#pragma pack(pop)

// ================================================================================================================================================================================================

ztInternal ztAssetManagerType_Enum _zt_assetGetFileType(const char *file_name)
{
	     if (zt_striEndsWith(file_name, ".png")) return ztAssetManagerType_ImagePNG;
	else if (zt_striEndsWith(file_name, ".jpg")) return ztAssetManagerType_ImageJPG;
	else if (zt_striEndsWith(file_name, ".hdr")) return ztAssetManagerType_ImageHDR;
	else if (zt_striEndsWith(file_name, ".wav")) return ztAssetManagerType_AudioWAV;
	else if (zt_striEndsWith(file_name, ".zts")) return ztAssetManagerType_Shader;
	else if (zt_striEndsWith(file_name, ".ttf")) return ztAssetManagerType_Font;
	else if (zt_striEndsWith(file_name, ".fnt")) return ztAssetManagerType_Font;
	else if (zt_striEndsWith(file_name, ".obj")) return ztAssetManagerType_MeshOBJ;
	else if (zt_striEndsWith(file_name, ".fbx")) return ztAssetManagerType_MeshFBX;
	else if (zt_striEndsWith(file_name, ".mtl")) return ztAssetManagerType_Material;
	else if (zt_striEndsWith(file_name, ".ztm")) return ztAssetManagerType_ModelZTM;
	else if (zt_striEndsWith(file_name, ".xml")) return ztAssetManagerType_Xml;
	else return ztAssetManagerType_Unknown;
}

// ================================================================================================================================================================================================

bool zt_assetMakePackedFile(const char *directory, const char *packed_file_name, ztMemoryArena *arena, ztAssetMakePackedFileIgnore_Func *ignore_func, void *ignore_func_user_data)
{
	i32 buffer_size = zt_megabytes(8);
	char *buffer = zt_mallocStructArrayArena(char, buffer_size, arena);

	zt_getDirectoryFiles(directory, buffer, buffer_size, true);
	
	int tokens_count = zt_strTokenize(buffer, "\n", nullptr, 0);
	ztToken *tokens = zt_mallocStructArrayArena(ztToken, tokens_count, arena);
	zt_strTokenize(buffer, "\n", tokens, tokens_count);

	int dir_len = zt_strLen(directory);
	if(!zt_strEndsWith(directory, ztFilePathSeparatorStr)) {
		dir_len += 1;
	}

	bool failed = false;

	i32 name_buffer_size = zt_megabytes(1);
	char *name_buffer = zt_mallocStructArrayArena(char, name_buffer_size, arena);
	name_buffer[0] = 0;

	ztFile packed_file;
	if (zt_fileOpen(&packed_file, packed_file_name, ztFileOpenMethod_WriteOver, arena)) {
		ztAssetPackedFileHeader header = {};
		header.magic_numbers[0] = ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_0;
		header.magic_numbers[1] = ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_1;
		header.magic_numbers[2] = ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_2;
		header.file_count = tokens_count;
		header.name_buffer_size = 0;

		ztAssetPackedFileEntry *entries = zt_mallocStructArrayArena(ztAssetPackedFileEntry, header.file_count, arena);

		i32 start = 0;
		zt_fiz(tokens_count) {
			char entry_name[256];
			zt_strCpy(entry_name, zt_elementsOf(entry_name), buffer + tokens[i].beg + dir_len, tokens[i].len - dir_len);

			int pos_sl = zt_strFindPos(entry_name, "\\", 0);
			if (pos_sl != ztStrPosNotFound) {
				entry_name[pos_sl] = '/';
			}

			bool ignore = false;
			if (ignore_func && ignore_func(entry_name, ignore_func_user_data)) {
				zt_logDebug("ignoring file: %s", entry_name);
				entry_name[0] = ' ';
				entry_name[1] = 0;
				ignore = true;
			}
			else {
				zt_logDebug("processing file: %s", entry_name);
			}

			zt_strCat(name_buffer, name_buffer_size, entry_name);
			zt_strCat(name_buffer, name_buffer_size, "\n");
			header.name_buffer_size += zt_strLen(entry_name) + 1;

			char file_name[ztFileMaxPath];
			zt_strCpy(file_name, ztFileMaxPath, buffer + tokens[i].beg, tokens[i].len);

			entries[i].hash = zt_strHash(entry_name);
			entries[i].size = ignore ? 0 : zt_fileSize(file_name);
			entries[i].type = ignore ? 0 : _zt_assetGetFileType(file_name);
			entries[i].start = start;

			start += entries[i].size;
		}

		header.file_start_pos = zt_sizeof(header) + header.name_buffer_size + (zt_sizeof(ztAssetPackedFileEntry) * header.file_count);

		zt_fileWrite(&packed_file, &header, zt_sizeof(header));
		zt_fileWrite(&packed_file, name_buffer, header.name_buffer_size);
		zt_fileWrite(&packed_file, entries, zt_sizeof(ztAssetPackedFileEntry) * header.file_count);

		zt_fiz(tokens_count) {
			if (entries[i].size == 0) {
				continue;
			}

			char file_name[ztFileMaxPath];
			zt_strCpy(file_name, ztFileMaxPath, buffer + tokens[i].beg, tokens[i].len);

			byte *data = zt_mallocStructArrayArena(byte, entries[i].size, arena);
			i32 bytes_read = 0;

			ztFile entry_file;
			if (zt_fileOpen(&entry_file, file_name, ztFileOpenMethod_ReadOnly, arena)) {
				bytes_read = zt_fileRead(&entry_file, data, entries[i].size);
				zt_fileClose(&entry_file);

				if (bytes_read == entries[i].size) {
					zt_fileWrite(&packed_file, data, bytes_read);
				}
				else failed = true;
			}
			else failed = true;
			
			zt_freeArena(data, arena);

			if (failed) break;
		}

		zt_freeArena(entries, arena);
		zt_fileClose(&packed_file);
	}

	zt_freeArena(name_buffer, arena);
	zt_freeArena(tokens, arena);
	zt_freeArena(buffer, arena);

	return !failed;
}

// ================================================================================================================================================================================================

bool zt_assetManagerLoadDirectory(ztAssetManager *asset_mgr, const char *directory, ztMemoryArena *arena)
{
	ZT_PROFILE_ASSETS("zt_assetManagerLoadDirectory");

	zt_logDebug("asset_manager: loading directory: %s", directory);

	zt_memSet(asset_mgr, sizeof(ztAssetManager), 0);

	zt_memPushGlobalArena(arena);

	int buffer_size = 1024 * 128;
	char *buffer = zt_mallocStructArrayArena(char, buffer_size, arena);

	i32 len = zt_getDirectoryFiles(directory, buffer, buffer_size, true);
	if (len == 0) {
		zt_logInfo("Asset Manager: No assets found in directory: %s", directory);
		zt_memPopGlobalArena();
		zt_freeArena(buffer, arena);
		return true; // no reason to fail here, but there's nothing more to do
	}

	if (ztFilePathSeparator == '\\') {
		zt_fiz(len) {
			if (buffer[i] == '\\') {
				buffer[i] = '/';
			}
		}
	}

	int tokens_count = zt_strTokenize(buffer, "\n", nullptr, 0);
	if (tokens_count <= 0) {
		zt_logCritical("Asset Manager: Unable to parse directory list: %s", buffer);
		zt_memPopGlobalArena();
		zt_freeArena(buffer, arena);
		return false;
	}

	ztToken* tokens = zt_mallocStructArrayArena(ztToken, tokens_count, arena);
	tokens_count = zt_strTokenize(buffer, "\n", tokens, tokens_count);

	int dir_len = zt_strLen(directory) + 1;

	asset_mgr->source = ztAssetManagerSource_Directory;
	asset_mgr->directory = buffer;
	asset_mgr->directory_len = dir_len;
	asset_mgr->arena = arena;
	asset_mgr->asset_callbacks_count = 0;
	asset_mgr->asset_modified_check_last_idx = 0;

	if (tokens_count > ztAssetManagerMaxAssets) {
		zt_assert(false && "Too many assets in directory");
		tokens_count = ztAssetManagerMaxAssets;
	}

#	if defined(ZT_WINDOWS)
	ztFile asset_list_file;
	char asset_list_file_name[ztFileMaxPath];
	zt_fileConcatFileToPath(asset_list_file_name, ztFileMaxPath, directory, "asset_list");
	zt_fileOpen(&asset_list_file, asset_list_file_name, ztFileOpenMethod_WriteOver);
#	endif

	zt_fiz(tokens_count) {
		char* token = buffer + tokens[i].beg + dir_len;
		buffer[tokens[i].beg + tokens[i].len] = 0; // replace the \n with null

		asset_mgr->asset_name     [i] = token;
		asset_mgr->asset_name_hash[i] = zt_strHash(token);
		asset_mgr->asset_size     [i] = zt_fileSize(token - dir_len);
		asset_mgr->asset_modified [i] = 0;

		asset_mgr->asset_type[i] = _zt_assetGetFileType(token);

		asset_mgr->asset_data     [i] = nullptr;
		asset_mgr->asset_callbacks[i] = ZT_FUNCTION_POINTER_TO_VAR_NULL;

#		if defined(ZT_WINDOWS)
		zt_fileWrite(&asset_list_file, asset_mgr->asset_name[i]);
		zt_fileWrite(&asset_list_file, "\n");
#		endif
	}
	asset_mgr->asset_count = tokens_count;

#	if defined(ZT_WINDOWS)
	zt_fileClose(&asset_list_file);
	zt_directoryMonitor(&asset_mgr->directory_mon, directory, true, ztDirectoryMonitorFlags_Modify);
#	endif

	zt_freeArena(tokens, arena);

	zt_memPopGlobalArena();

	return true;
}

// ================================================================================================================================================================================================

bool zt_assetManagerLoadPackedFile(ztAssetManager *asset_mgr, const char *packed_file_name, ztMemoryArena *arena)
{
	ZT_PROFILE_ASSETS("zt_assetManagerLoadPackedFile");

	if (!zt_fileOpen(&asset_mgr->packed_file, packed_file_name, ztFileOpenMethod_ReadOnly, arena)) {
		zt_logCritical("Invalid pack file name: %s", packed_file_name);
		return false;
	}

	asset_mgr->source = ztAssetManagerSource_PackedFile;

	ztAssetPackedFileHeader header;
	if (zt_fileRead(&asset_mgr->packed_file, &header, zt_sizeof(header)) != zt_sizeof(header)) {
		zt_logCritical("Invalid pack file header: %s", packed_file_name);
		zt_fileClose(&asset_mgr->packed_file);
		return false;
	}

	if (header.magic_numbers[0] != ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_0 || header.magic_numbers[1] != ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_1 || header.magic_numbers[2] != ZT_ASSET_PACKED_FILE_MAGIC_NUMBER_2) {
		zt_logCritical("Invalid pack file: %s", packed_file_name);
		zt_fileClose(&asset_mgr->packed_file);
		return false;
	}

	asset_mgr->packed_file_names = zt_mallocStructArrayArena(char, header.name_buffer_size, arena);
	if (zt_fileRead(&asset_mgr->packed_file, asset_mgr->packed_file_names, header.name_buffer_size) != header.name_buffer_size) {
		zt_logCritical("Invalid pack file (names): %s", packed_file_name);
		zt_fileClose(&asset_mgr->packed_file);
		return false;
	}
	asset_mgr->packed_file_names[header.name_buffer_size] = 0;

	ztToken *tokens = zt_mallocStructArrayArena(ztToken, header.file_count, arena);
	zt_strTokenize(asset_mgr->packed_file_names, "\n", tokens, header.file_count);

	zt_fiz(header.file_count) {
		ztAssetPackedFileEntry entry;
		if (zt_fileRead(&asset_mgr->packed_file, &entry, zt_sizeof(entry)) != zt_sizeof(entry)) {
			zt_logCritical("Invalid pack file entry: %s (%d)", packed_file_name, i);
			zt_fileClose(&asset_mgr->packed_file);
			return false;
		}

		asset_mgr->packed_file_names[tokens[i].beg + tokens[i].len] = 0;

		asset_mgr->asset_name[i] = (const char*)&asset_mgr->packed_file_names[tokens[i].beg];
		asset_mgr->asset_name_hash[i] = zt_strHash(asset_mgr->asset_name[i]);
		asset_mgr->asset_size[i] = entry.size;
		asset_mgr->asset_type[i] = (ztAssetManagerType_Enum)entry.type;
		asset_mgr->packed_file_pos[i] = header.file_start_pos + entry.start;
	}

	asset_mgr->asset_count = header.file_count;

	return true;
}

// ================================================================================================================================================================================================

void zt_assetManagerFree(ztAssetManager *asset_mgr)
{
	if (asset_mgr == nullptr) {
		return;
	}

	if (asset_mgr->source == ztAssetManagerSource_Directory) {
		zt_fiz(asset_mgr->asset_count) {
			if (asset_mgr->asset_data[i]) {
				zt_freeArena(asset_mgr->asset_data[i], asset_mgr->arena);
			}
		}
		zt_freeArena(asset_mgr->directory, asset_mgr->arena);
	}
	else if (asset_mgr->source == ztAssetManagerSource_PackedFile) {
		zt_fileClose(&asset_mgr->packed_file);
	}

	zt_memSet(asset_mgr, sizeof(ztAssetManager), 0);
}

// ================================================================================================================================================================================================

bool zt_assetExists(ztAssetManager *asset_mgr, const char *asset)
{
	return zt_assetExists(asset_mgr, zt_strHash(asset));
}

// ================================================================================================================================================================================================

bool zt_assetExists(ztAssetManager *asset_mgr, i32 asset_hash)
{
	ZT_PROFILE_ASSETS("zt_assetExists");
	zt_returnValOnNull(asset_mgr, false);

	zt_fiz(asset_mgr->asset_count) {
		if (asset_mgr->asset_name_hash[i] == asset_hash) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_assetFileExistsAsAsset(ztAssetManager *asset_mgr, const char *file_name, i32 *asset_hash)
{
	ZT_PROFILE_ASSETS("zt_assetFileExistsAsAsset");
	zt_returnValOnNull(asset_mgr, false);
	zt_returnValOnNull(file_name, false);

	if (asset_mgr->source == ztAssetManagerSource_Directory) {
		const char *asset_name = nullptr;

		if (!zt_strStartsWith(file_name, asset_mgr->directory)) {
			asset_name = file_name;
		}
		else {
			asset_name = zt_strMoveForward(file_name, zt_strLen(asset_mgr->directory + 1));
		}

		if (!asset_name) {
			return false;
		}

		i32 hash = zt_strHash(asset_name);
		zt_fiz(asset_mgr->asset_count) {
			if (asset_mgr->asset_name_hash[i] == hash) {
				if (asset_hash) {
					*asset_hash = hash;
				}
				return true;
			}
		}

		return false;
	}
	else {
		if (!file_name) {
			return false;
		}

		i32 hash = zt_strHash(file_name);
		zt_fiz(asset_mgr->asset_count) {
			if (asset_mgr->asset_name_hash[i] == hash) {
				if (asset_hash) {
					*asset_hash = hash;
				}
				return true;
			}
		}

		return false;
	}
}

// ================================================================================================================================================================================================

ztAssetID zt_assetLoad(ztAssetManager *asset_mgr, const char *asset)
{
	ZT_PROFILE_ASSETS("zt_assetLoad(char*)");
	ztAssetID asset_id = zt_assetLoad(asset_mgr, zt_strHash(asset));
	
	if (asset_id == ztInvalidID) {
		zt_logInfo("Unable to load asset: %s", asset);
	}
	else {
		zt_logInfo("Loaded asset: %s (%d)", asset, asset_id);
	}

	return asset_id;
}

// ================================================================================================================================================================================================

ztAssetID zt_assetLoad(ztAssetManager *asset_mgr, i32 asset_hash)
{
	ZT_PROFILE_ASSETS("zt_assetLoad(i32)");
	zt_returnValOnNull(asset_mgr, ztInvalidID);

	zt_fiz(asset_mgr->asset_count) {
		if (asset_mgr->asset_name_hash[i] == asset_hash) {
			return i;
		}
	}

	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztAssetID zt_assetLoad(ztAssetManager *asset_mgr, const char *asset, ztAssetID same_location_as)
{
	ZT_PROFILE_ASSETS("zt_assetLoad(char*, ztAssetID)");
	zt_returnValOnNull(asset_mgr, ztInvalidID);

	if (same_location_as == ztInvalidID) {
		return zt_assetLoad(asset_mgr, asset);
	}
	int pos_path = zt_strFindLastPos(asset_mgr->asset_name[same_location_as], "/");
	if (pos_path == ztStrPosNotFound) {
		return zt_assetLoad(asset_mgr, asset);
	}

	char asset_path[1024];
	zt_strCpy(asset_path, zt_elementsOf(asset_path), asset_mgr->asset_name[same_location_as], pos_path);

	zt_strMakePrintf(asset_name, 2048, "%s/%s", asset_path, asset);
	return zt_assetLoad(asset_mgr, asset_name);
}

// ================================================================================================================================================================================================

i32 zt_assetSize(ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_ASSETS("zt_assetSize");
	zt_returnValOnNull(asset_mgr, 0);
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);
	return asset_mgr->asset_size[asset_id];
}

// ================================================================================================================================================================================================

bool zt_assetLoadData(ztAssetManager *asset_mgr, ztAssetID asset_id, void *data, i32 data_size, bool always_reload)
{
	ZT_PROFILE_ASSETS("zt_assetLoadData");
	zt_returnValOnNull(asset_mgr, false);
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	switch(asset_mgr->source)
	{
		case ztAssetManagerSource_Directory: {
			if (always_reload && asset_mgr->asset_data[asset_id] != nullptr) {
				zt_freeArena(asset_mgr->asset_data[asset_id], asset_mgr->arena);
				asset_mgr->asset_data[asset_id] = nullptr;
				asset_mgr->asset_size[asset_id] = 0;
			}

			if (asset_mgr->asset_data[asset_id] == nullptr) {
				i32 size = 0;
				asset_mgr->asset_data[asset_id] = zt_readEntireFile(asset_mgr->asset_name[asset_id] - asset_mgr->directory_len, &size, false, asset_mgr->arena);

				if (size != asset_mgr->asset_size[asset_id]) {
					asset_mgr->asset_size[asset_id] = size;
				}
			}

			if (data_size < asset_mgr->asset_size[asset_id]) {
				return false;
			}

			zt_memCpy(data, data_size, asset_mgr->asset_data[asset_id], asset_mgr->asset_size[asset_id]);

			return true;
		} break;

		case ztAssetManagerSource_PackedFile: {
			if (asset_mgr->packed_file_pos[asset_id] == 0) {
				return false;
			}

			if (data_size < asset_mgr->asset_size[asset_id]) {
				return false;
			}

			zt_fileSetReadPos(&asset_mgr->packed_file, asset_mgr->packed_file_pos[asset_id]);
			if (zt_fileRead(&asset_mgr->packed_file, data, asset_mgr->asset_size[asset_id]) != asset_mgr->asset_size[asset_id]) {
				return false;
			}

			return true;
		} break;

		default: {
			return false;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_assetClearCache(ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_ASSETS("zt_assetClearCache");
	zt_returnValOnNull(asset_mgr, false);
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	zt_fiz(asset_mgr->asset_count) {
		if (asset_mgr->asset_data[i]) {
			zt_freeArena(asset_mgr->asset_data[i], asset_mgr->arena);
			asset_mgr->asset_data[i] = nullptr;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_assetAddReloadCallback(ztAssetManager *asset_mgr, ztAssetID asset_id, ZT_FUNCTION_POINTER_VAR(function, zt_assetManagerAssetUpdated_Func), void *user_data)
{
#	if defined(ZT_WINDOWS)
	ZT_PROFILE_ASSETS("zt_assetAddReloadCallback");
	zt_returnOnNull(asset_mgr);
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);
	
	if (asset_mgr->source != ztAssetManagerSource_Directory) {
		return;
	}

	if (asset_mgr->asset_callbacks_count >= zt_elementsOf(asset_mgr->asset_callbacks)) {
		zt_assert(false && "Asset callback overflow");
		return;
	}

	int idx = asset_mgr->asset_callbacks_count++;
	asset_mgr->asset_callbacks         [idx] = function;
	asset_mgr->asset_callback_ids      [idx] = asset_id;
	asset_mgr->asset_callback_user_data[idx] = user_data;
	
	zt_fileModified(asset_mgr->asset_name[asset_id] - asset_mgr->directory_len, &asset_mgr->asset_modified[asset_id]);
#	endif
}

// ================================================================================================================================================================================================

void zt_assetRemoveReloadCallback(ztAssetManager *asset_mgr, ztAssetID asset_id, void *user_data)
{
#	if defined(ZT_WINDOWS)
	ZT_PROFILE_ASSETS("zt_assetRemoveReloadCallback");
	zt_returnOnNull(asset_mgr);
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	if (asset_mgr->source != ztAssetManagerSource_Directory) {
		return;
	}

	zt_fiz(asset_mgr->asset_callbacks_count) {
		if (asset_mgr->asset_callback_ids[i] == asset_id && asset_mgr->asset_callback_user_data[i] == user_data) {
			for (int j = i; j < asset_mgr->asset_callbacks_count - 1; ++j) {
				asset_mgr->asset_callbacks         [j] = asset_mgr->asset_callbacks[j+1];
				asset_mgr->asset_callback_user_data[j] = asset_mgr->asset_callback_user_data[j+1];
				asset_mgr->asset_callback_ids      [j] = asset_mgr->asset_callback_ids[j+1];
			}
			asset_mgr->asset_callbacks_count -= 1;

			int count = 0;
			zt_fjz(asset_mgr->asset_callbacks_count) {
				if (asset_mgr->asset_callback_ids[j] == asset_id) {
					count += 1;
					break;
				}
			}
			if (count == 0) {
				asset_mgr->asset_modified[asset_id] = 0; // so it doesn't get checked anymore
			}
			return;
		}
	}
#	endif
}

// ================================================================================================================================================================================================

void zt_assetManagerCheckForChanges(ztAssetManager *asset_mgr)
{
	ZT_PROFILE_ASSETS("zt_assetManagerCheckForChanges");
	zt_returnOnNull(asset_mgr);

	if (asset_mgr->source != ztAssetManagerSource_Directory || asset_mgr->asset_callbacks_count == 0 || asset_mgr->asset_count == 0) {
		return;
	}

	if (!zt_directoryMonitorHasChanged(&asset_mgr->directory_mon)) {
		return;
	}

	zt_fiz(asset_mgr->asset_count) {
		if (asset_mgr->asset_modified[i] != 0) {
			i64 modified = 0;
			i32 size = zt_fileSize(asset_mgr->asset_name[i] - asset_mgr->directory_len);

			if (size > 0 && zt_fileModified(asset_mgr->asset_name[i] - asset_mgr->directory_len, &modified)) {
				const i64 min_difference = 20000; // not sure why, but occassionally was seeing multiple rapid changes to a file when saving one time, so make sure we don't reload the same file twice in short order
				if (asset_mgr->asset_modified[i] != modified && modified - asset_mgr->asset_modified[i] > min_difference) {
					if (asset_mgr->asset_data[i]) {
						zt_freeArena(asset_mgr->asset_data[i], asset_mgr->arena);
						asset_mgr->asset_data[i] = nullptr;
					}
					asset_mgr->asset_size[i] = size;

					// TODO(josh): these memcpys might not be working as expected...

					// copy the callback data in case something changes within a function call
					int                     asset_callbacks_count = asset_mgr->asset_callbacks_count;
					void                   *asset_callback_user_data [ztAssetManagerMaxAssets];
					ztAssetID               asset_callback_ids       [ztAssetManagerMaxAssets];
					ZT_FUNCTION_POINTER_VAR(asset_callbacks          [ztAssetManagerMaxAssets], zt_assetManagerAssetUpdated_Func);

					zt_memCpy(asset_callback_user_data, zt_sizeof(asset_callback_user_data), asset_mgr->asset_callback_user_data, zt_sizeof(asset_mgr->asset_callback_user_data));
					zt_memCpy(asset_callback_ids,       zt_sizeof(asset_callback_ids),       asset_mgr->asset_callback_ids,       zt_sizeof(asset_mgr->asset_callback_ids));
					zt_memCpy(asset_callbacks,          zt_sizeof(asset_callbacks),          asset_mgr->asset_callbacks,          zt_sizeof(asset_mgr->asset_callbacks));

					zt_fjz(asset_callbacks_count) {
						if (asset_callback_ids[j] == i) {
							ZT_FUNCTION_POINTER_ACCESS_SAFE(asset_callbacks[j], zt_assetManagerAssetUpdated_Func)(asset_mgr, i, asset_callback_user_data[j]);
						}
					}
				}
				asset_mgr->asset_modified[i] = modified;
			}
		}
	}
}

// ================================================================================================================================================================================================
// verifies data type and loads data into allocated buffer.  free with _zt_assetFreeData()

ztInternal bool _zt_assetLoadData(ztAssetManager *asset_mgr, ztAssetID asset_id, ztAssetManagerType_Enum *type_verify, int type_verify_count, void **data, i32 *data_size)
{
	ZT_PROFILE_ASSETS("_zt_assetLoadData");
	zt_returnValOnNull(asset_mgr, false);
	if(asset_id == ztInvalidID) {
		return false;
	}
	zt_assertReturnValOnFail(asset_id >= 0 && asset_id < asset_mgr->asset_count, false);

	*data = nullptr;
	*data_size = 0;

	bool verified = type_verify_count == 0;
	zt_fiz(type_verify_count) {
		if (asset_mgr->asset_type[asset_id] == type_verify[i]) {
			verified = true;
			break;
		}
	}
	if (!verified) {
		return false;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return false;
	}

	(*data) = zt_mallocStructArrayArena(byte, size, asset_mgr->arena);
	if (!(*data)) {
		return false;
	}

	if (!zt_assetLoadData(asset_mgr, asset_id, *data, size)) {
		zt_freeArena(*data, asset_mgr->arena);
		*data = nullptr;
		return false;
	}

	*data_size = size;
	return true;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_assetLoadData(ztAssetManager *asset_mgr, ztAssetID asset_id, ztAssetManagerType_Enum valid_type, void **data, i32 *data_size)
{
	return _zt_assetLoadData(asset_mgr, asset_id, &valid_type, 1, data, data_size);
}

// ================================================================================================================================================================================================

ztInternal void _zt_assetFreeData(ztAssetManager *asset_mgr, void *data_ptr)
{
	zt_returnOnNull(asset_mgr);
	zt_returnOnNull(data_ptr);
	zt_freeArena(data_ptr, asset_mgr->arena);
}



// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal const char *_zt_default_shaders_names[] = {
	"shader-solid",
	"shader-unlit",
#	if !defined(ZT_SHADER_DEFAULT_NO_LIGHTING)
	"shader-lit",
	"shader-litshadow",
	"shader-shadowdirectional",
	"shader-shadowdirectionaltextured",
#	endif
	"shader-depth",
	"shader-depthtextured",
	"shader-skybox",
	"shader-signeddistancefield",
	"shader-bright",
	"shader-blur-vert",
	"shader-blur-horz",
};

ztInternal const char *_zt_default_shaders[] = {
	"// shader-solid\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 projection;\n	mat4 view;\n}\n\nprogram Solid\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n	\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, PixelOutput _output : output)\n	{\n		_output.color = vec4(_input.color.rgb, min(_input.color.a, 1.0));\n	}\n}",
	"// shader-unlit\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		_output.color = textureSample(textures.diffuse_tex, _input.uv) * _input.color;\n	}\n}",
#	if !defined(ZT_SHADER_DEFAULT_NO_LIGHTING)
	"// shader-lit\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n	vec4 tangent : 4;\n	vec4 bitangent : 5;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec3 frag_pos;\n	vec3 normal;\n	vec2 uv;\n	vec4 color;\n	vec4 frag_pos_light_space;\n	mat3 tbn;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n	texture2d specular_tex;\n	texture2d normal_tex;\n	texture2d directional_light_shadowmap;\n}\n\nstruct PointLight\n{\n	vec3 pos;\n	\n	float intensity;\n\n	vec3 ambient_color;\n	vec3 diffuse_color;\n	vec3 specular_color;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	mat4 light_matrix;\n\n	vec4 diffuse_color;\n	vec4 specular_color;\n	float shininess;\n	\n	vec3 view_pos;\n\n	vec3 light_pos;\n	float light_ambient;\n	float light_intensity;\n	vec4 light_color;\n	\n	PointLight point_lights[4];\n	int point_lights_count;\n}\n\nvec3 normalCalculation(PixelInput _input, Textures textures)\n{\n	vec3 normal = textureSample(textures.normal_tex, _input.uv).rgb;\n	if (normal.x == 1.0 && normal.y == 1.0 && normal.z == 1.0) {\n		return _input.normal;\n	}\n	normal = normalize(_input.normal * 2.0 - 1.0);\n	normal = normalize(_input.tbn * _input.normal);\n	return normal;\n}\n\nfloat shadowCalculation(vec3 light_dir, vec3 normal, PixelInput _input, Textures textures)\n{\n	return 0.0;\n}\n\nfloat specularCalculation(vec3 light_dir, vec3 normal, vec3 view_dir, PixelInput _input, Uniforms uniforms, Textures textures)\n{\n	vec3 halfway_dir = normalize(light_dir + view_dir);\n	float spec_value = textureSample(textures.specular_tex, _input.uv).r;\n	return pow(max(dot(normal, halfway_dir), 0.0), 256.0) * uniforms.shininess * 5.0 * spec_value;\n}\n\nvec4 directionalLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, PixelInput _input, Uniforms uniforms, Textures textures)\n{\n	vec4 light_clr = uniforms.light_color * uniforms.light_intensity;\n	\n	vec3 light_dir = normalize(uniforms.light_pos - _input.frag_pos);\n	float diff = max(dot(light_dir, normal), 0.0);\n	vec4 diffuse = diff * light_clr;\n \n	vec4 specular = specularCalculation(light_dir, normal, view_dir, _input, uniforms, textures) * light_clr * uniforms.specular_color;\n	float shadow = shadowCalculation(light_dir, normal, _input, textures);\n\n	vec4 ambient_clr = clr * uniforms.light_ambient;\n	return (ambient_clr + (1.0 - shadow) * (diffuse + specular)) * clr;\n}\n\nvec4 pointLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, PointLight light, PixelInput _input, Uniforms uniforms, Textures textures)\n{\n	vec4 light_clr = vec4(light.ambient_color, 1.0);\n	\n	vec3 light_dir = normalize(light.pos - _input.frag_pos);\n	float diff = max(dot(light_dir, normal), 0.0);\n	vec4 diffuse = diff * light_clr;\n \n	vec4 specular = specularCalculation(light_dir, normal, view_dir, _input, uniforms, textures) * light_clr;// * specular_color;\n	float shadow = 0.0;//shadowCalculation(light_dir, normal, _input, textures);\n\n	float distance = length(light.pos - _input.frag_pos);\n	float constant = 1.0;\n	float attenuation = 1.0 * light.intensity;\n	\n	return ((1.0 - shadow) * (diffuse + specular)) * clr * attenuation;\n}\n\nprogram DefaultLit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.frag_pos = vec3(uniforms.model * vec4(_input.position, 1.0));\n		_output.normal = normalize(transpose(mat3(uniforms.model)) * _input.normal);\n		_output.uv = _input.uv;\n		_output.color = _input.color;\n		_output.frag_pos_light_space = uniforms.light_matrix * vec4(_output.frag_pos, 1.0);\n		\n		vec3 t = normalize(vec3(uniforms.model * _input.tangent));\n		vec3 b = normalize(vec3(uniforms.model * _input.bitangent));\n		vec3 n = normalize(vec3(uniforms.model * vec4(_input.normal, 0)));\n		_output.tbn = mat3(t, b, n);\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 clr = textureSample(textures.diffuse_tex, _input.uv) * _input.color * uniforms.diffuse_color;\n		if(clr.a < .1) {\n			discard();\n		}\n		vec3 normal = normalCalculation(_input, textures);\n		vec3 view_dir = normalize(uniforms.view_pos - _input.frag_pos);\n		vec4 lighting = directionalLightCalculation(clr, normal, view_dir, _input, uniforms, textures);\n		\n		for(int i = 0; i < 4; ++i) {\n			if (i >= uniforms.point_lights_count) break;\n			lighting += pointLightCalculation(clr, normal, view_dir, uniforms.point_lights[i], _input, uniforms, textures);\n		}\n        \n		_output.color = vec4(lighting.xyz, clr.a);\n	}\n}",
	"// shader-litshadow\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n	vec4 tangent : 4;\n	vec4 bitangent : 5;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec3 normal;\n	vec2 uv;\n	vec4 color;\n	vec4 frag_pos_light_space;\n	vec3 tangent_light_pos;\n	vec3 tangent_view_pos;\n	vec3 tangent_frag_pos;\n	vec3 view_pos;\n	vec3 frag_pos;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n	texture2d specular_tex;\n	texture2d normal_tex;\n	texture2d height_tex;\n	texture2d directional_light_shadowmap;\n}\n\nstruct PointLight\n{\n	vec3 pos;\n	\n	float intensity;\n\n	vec3 ambient_color;\n	vec3 diffuse_color;\n	vec3 specular_color;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	mat4 light_matrix;\n\n	vec4 diffuse_color;\n	vec4 specular_color;\n	float shininess;\n	\n	vec3 view_pos;\n\n	vec3 light_pos;\n	float light_ambient;\n	float light_intensity;\n	vec4 light_color;\n	\n	PointLight point_lights[4];\n	int point_lights_count;\n}\n\nvec2 parallaxMapping(vec2 uv, vec3 view_dir, Textures textures)\n{\n	float height = textureSample(textures.height_tex, uv).r;\n	vec2 p = view_dir.xy * ((1.0 - height) * .25);\n	return uv - p;\n}\n\nvec3 normalCalculation(vec2 uv, vec3 vertex_normal, Textures textures)\n{\n	vec3 normal = textureSample(textures.normal_tex, uv).rgb;\n	\n	if (normal.x == 1.0 && normal.y == 1.0 && normal.z == 1.0) {\n		return vertex_normal;\n	}\n	normal = normalize((normal * 2.0) - 1.0);\n	return normal;\n}\n\nfloat shadowCalculation(vec3 light_dir, vec3 normal, PixelInput _input, Textures textures)\n{\n	vec3 proj_coords = _input.frag_pos_light_space.xyz / _input.frag_pos_light_space.w;\n	proj_coords = proj_coords * 0.5 + 0.5;\n	if (proj_coords.x < 0.0 || proj_coords.x > 1.0 || proj_coords.y < 0.0 || proj_coords.y > 1.0) {\n		return 0.0;\n	}\n	\n	float current_depth = proj_coords.z;\n	if(current_depth > 1.0 || current_depth < 0.0) {\n		return 0.0;\n	}\n	\n	float bias = 0.005;//max(0.005 * (1.0 - dot(normal, light_dir)), 0.0025);\n	\n	float shadow = 0.0;\n	vec2 texel_size = 1.0 / textureSize(textures.directional_light_shadowmap);// * .5;\n	\n	const int samples = 3;\n	for(int x = -samples; x <= samples; ++x) {\n		for(int y = -samples; y <= samples; ++y) {\n			float pcf_depth = textureSample(textures.directional_light_shadowmap, proj_coords.xy + vec2(x, y) * texel_size).r;\n			shadow += (current_depth - bias) > pcf_depth ? 1.0 : 0.0;\n		}\n	}\n	shadow /= (float(samples) * 2.0 + 1.0) * (float(samples) * 2.0 + 1.0);\n	return shadow;\n}\n\nfloat specularCalculation(vec3 light_dir, vec3 normal, vec3 view_dir, vec2 uv, Uniforms uniforms, Textures textures)\n{\n	vec3 halfway_dir = normalize(light_dir + view_dir);\n	float spec_value = textureSample(textures.specular_tex, uv).r;\n	return pow(max(dot(normal, halfway_dir), 0.0), 256.0) * uniforms.shininess * 5.0 * spec_value;\n}\n\nvec4 directionalLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, vec2 uv, PixelInput _input, Uniforms uniforms, Textures textures)\n{\n	vec4 light_clr = uniforms.light_color * uniforms.light_intensity;\n	\n	vec3 light_dir = normalize(_input.tangent_light_pos - _input.tangent_frag_pos);\n	float diff = max(dot(light_dir, normal), 0.0);\n	vec4 diffuse = diff * light_clr;\n \n	vec4 specular = specularCalculation(light_dir, normal, view_dir, uv, uniforms, textures) * light_clr * uniforms.specular_color;\n	float shadow = shadowCalculation(light_dir, normal, _input, textures);\n\n	vec4 ambient_clr = clr * uniforms.light_ambient;\n	return (ambient_clr + (1.0 - shadow) * (diffuse + specular)) * clr;\n}\n\nvec4 pointLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, vec2 uv, PointLight light, PixelInput _input, Uniforms uniforms, Textures textures)\n{\n	vec4 light_clr = vec4(light.ambient_color, 1);\n	\n	vec3 light_dir = normalize(light.pos - _input.tangent_frag_pos);\n	float diff = max(dot(light_dir, normal), 0.0);\n	vec4 diffuse = diff * light_clr;\n \n	vec4 specular = specularCalculation(light_dir, normal, view_dir, uv, uniforms, textures) * light_clr;// * specular_color;\n	float shadow = 0.0;//shadowCalculation(light_dir, normal, _input, textures);\n\n	float distance = length(light.pos - _input.tangent_frag_pos);\n	float constant = 1.0;\n	float attenuation = 1.0 * light.intensity;\n	\n	return ((1.0 - shadow) * (diffuse + specular)) * clr * attenuation;\n}\n\nprogram DefaultLit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.normal = normalize(vec3(uniforms.model * vec4(_input.normal, 0)));\n		_output.uv = _input.uv;\n		_output.color = _input.color;\n\n		vec3 frag_pos = vec3(uniforms.model * vec4(_input.position, 1.0));\n		_output.frag_pos_light_space = uniforms.light_matrix * vec4(frag_pos, 1.0);\n		_output.frag_pos = frag_pos;\n		\n		vec3 t = normalize(vec3(uniforms.model * _input.tangent));\n		vec3 b = normalize(vec3(uniforms.model * _input.bitangent));\n		mat3 tbn = transpose(mat3(t, b, _output.normal));\n		\n		_output.tangent_light_pos = tbn * uniforms.light_pos;\n		_output.tangent_view_pos  = tbn * uniforms.view_pos;\n		_output.tangent_frag_pos  = tbn * frag_pos;\n		_output.normal            = tbn * _output.normal;\n		_output.view_pos          = uniforms.view_pos;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 view_dir = normalize(_input.tangent_view_pos - _input.tangent_frag_pos);\n		vec2 uv = parallaxMapping(_input.uv, view_dir, textures);\n		if(uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0) {\n			discard();\n		}\n		\n		vec4 clr = textureSample(textures.diffuse_tex, uv) * _input.color * uniforms.diffuse_color;\n		if(clr.a < .1) {\n			discard();\n		}\n		\n		vec3 normal = normalCalculation(uv, _input.normal, textures);\n		\n		vec4 lighting = directionalLightCalculation(clr, normal, view_dir, uv, _input, uniforms, textures);\n		\n		for(int i = 0; i < 4; ++i) {\n			if (i >= uniforms.point_lights_count) break;\n			lighting += pointLightCalculation(clr, normal, view_dir, uv, uniforms.point_lights[i], _input, uniforms, textures);\n		}\n        \n		_output.color = vec4(lighting.xyz, clr.a);\n	}",
	"// shader-shadowdirectional\n\nstruct VertexInput\n{\n	vec3  position : 0;\n	ivec4 bones : 6;\n	vec4  weights : 7;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 light_matrix;\n\n	mat4 bones[200];\n	int  bones_count;\n}\n\nprogram DefaultShadowDirectional\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		mat4 model_mat = uniforms.model;\n\n		if (uniforms.bones_count > 0) {\n			mat4 bone_mat  = uniforms.bones[_input.bones.x] * _input.weights.x;\n			bone_mat      += uniforms.bones[_input.bones.y] * _input.weights.y;\n			bone_mat      += uniforms.bones[_input.bones.z] * _input.weights.z;\n			bone_mat      += uniforms.bones[_input.bones.w] * _input.weights.w;\n			\n			model_mat = uniforms.model * bone_mat;\n		}\n\n		_output.position = uniforms.light_matrix * model_mat * vec4(_input.position, 1.0);\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		_output.color = vec4(_input.position.z, _input.position.z, _input.position.z, 1);\n	}\n}",
	"// shader-shadowdirectionaltextured\n\nstruct VertexInput\n{\n	vec3  position : 0;\n	vec2  uv : 1;\n	ivec4 bones : 6;\n	vec4  weights : 7;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 light_matrix;\n\n	mat4 bones[200];\n	int  bones_count;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		mat4 model_mat = uniforms.model;\n\n		if (uniforms.bones_count > 0) {\n			mat4 bone_mat  = uniforms.bones[_input.bones.x] * _input.weights.x;\n			bone_mat      += uniforms.bones[_input.bones.y] * _input.weights.y;\n			bone_mat      += uniforms.bones[_input.bones.z] * _input.weights.z;\n			bone_mat      += uniforms.bones[_input.bones.w] * _input.weights.w;\n			\n			model_mat = uniforms.model * bone_mat;\n		}\n\n		_output.position = uniforms.light_matrix * model_mat * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 clr = textureSample(textures.diffuse_tex, _input.uv);\n		if (clr.a <= 0.1) {\n			discard();\n		}\n		else {\n			_output.color = vec4(_input.position.z, _input.position.z, _input.position.z, 1);\n		}\n	}\n}",
#	endif
	"// shader-depth\n\nstruct VertexInput\n{\n	vec3 position : 0;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Uniforms\n{\n	mat4 projection;\n	mat4 view;\n	mat4 model;\n}\n\nprogram DefaultDepth\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		_output.color = vec4(vec3(_input.position.z), 1.0);\n	}\n}",
	"// shader-depthtextured\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Uniforms\n{\n	mat4 projection;\n	mat4 view;\n	mat4 model;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 clr = textureSample(textures.diffuse_tex, _input.uv);\n		if (clr.a <= 0.1) {\n			discard();\n		}\n		else {\n			_output.color = vec4(1 - _input.position.z, 1 - _input.position.z, 1 - _input.position.z, 1);\n		}\n	}\n}",
	"// shader-skybox\n\nstruct VertexInput\n{\n	vec3 position : 0;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec3 uv;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	textureCube skybox_tex;\n}\n\nstruct Uniforms\n{\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		vec4 pos = uniforms.projection * uniforms.view * vec4(_input.position, 1.0);\n		_output.position = vec4(pos.x, pos.y, pos.w, pos.w);\n		_output.uv = _input.position;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		_output.color = vec4(textureSample(textures.skybox_tex, _input.uv).rgb, 1);\n	}\n}",
	"// shader-signeddistancefield\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		const float smoothing = 1.0 / 64.0;\n	\n		float distance = textureSample(textures.diffuse_tex, _input.uv).a;\n		float alpha = smoothstep(0.5 - smoothing, 0.5 + smoothing, distance) * _input.color.a;\n		_output.color = vec4(_input.color.rgb, alpha);\n	}\n}",
	//	"// shader-bright\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultBright\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color);\n		\n		if(length(color.rgb) < .5) {\n			color = vec4(0, 0, 0, 1);\n		}\n		\n		_output.color = color;\n	}\n}",
		"// shader-bright\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultBright\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color);\n		\n		if(color.r <= 1. && color.g <= 1 && color.b <= 1) {\n			color = vec4(0, 0, 0, 1);\n		}\n		\n		_output.color = color;\n	}\n}",
	//	"// shader-bright\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultBright\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color);\n		float brightness = (color.r * 0.2126) + (color.g * 0.7152) + (color.b * 0.0722);\n		_output.color = color * brightness * brightness * brightness;\n	}\n}",
	//"// shader-bright\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n}\n\nprogram DefaultBright\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color);\n		float brightness = (color.r * 0.2126) + (color.g * 0.7152) + (color.b * 0.0722);\n		if (brightness < 1.0) color = vec4(0,0,0,1);\n_output.color = vec4(color.rgb * brightness, 1);\n	}\n}",
	"// shader-blur-vert\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float texel_size;\n}\n\nvec4 colorNanCheck(vec4 color, vec4 replacement)\n{\n	if(isnan(color.r)) color.r = replacement.r;\n	if(isnan(color.g)) color.g = replacement.g;\n	if(isnan(color.b)) color.b = replacement.b;\n	return color;\n}\n\nprogram DefaultBlurHorz\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		float weights[] = {0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216};\n		vec4 color = textureSample(textures.diffuse_tex, _input.uv) * weights[0];\n		vec4 orig_color = color;\n		\n		for (int i = 1; i < 5; ++i) {\n			color += colorNanCheck(textureSample(textures.diffuse_tex, _input.uv + vec2(uniforms.texel_size * i, 0.0)) * weights[i], orig_color);\n			color += colorNanCheck(textureSample(textures.diffuse_tex, _input.uv - vec2(uniforms.texel_size * i, 0.0)) * weights[i], orig_color);\n		}\n	\n		_output.color = vec4(color.rgb, 1);\n	}\n}",
	"// shader-blur-horz\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float texel_size;\n}\n\nvec4 colorNanCheck(vec4 color, vec4 replacement)\n{\n	if(isnan(color.r)) color.r = replacement.r;\n	if(isnan(color.g)) color.g = replacement.g;\n	if(isnan(color.b)) color.b = replacement.b;\n	return color;\n}\n\nprogram DefaultBlurHorz\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		float weights[] = {0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216};\n		vec4 color = textureSample(textures.diffuse_tex, _input.uv) * weights[0];\n		vec4 orig_color = color;\n		\n		for (int i = 1; i < 5; ++i) {\n			color += colorNanCheck(textureSample(textures.diffuse_tex, _input.uv + vec2(0.0, uniforms.texel_size * i)) * weights[i], orig_color);\n			color += colorNanCheck(textureSample(textures.diffuse_tex, _input.uv - vec2(0.0, uniforms.texel_size * i)) * weights[i], orig_color);\n		}\n	\n		_output.color = vec4(color.rgb, 1);\n	}\n}",
};

// ================================================================================================================================================================================================

ztRenderer_Enum zt_currentRenderer()
{
	return zt_game->win_game_settings[0].renderer;
}

// ================================================================================================================================================================================================

r32 zt_pixelsPerUnit()
{
	return (r32)zt_game->win_game_settings[0].pixels_per_unit;
}

// ================================================================================================================================================================================================

void zt_requestQuit()
{
	zt_game->quit_requested = true;
}

// ================================================================================================================================================================================================

bool zt_appHasFocus()
{
	return zt_game->app_has_focus;
}

// ================================================================================================================================================================================================

ztInternal void (*_zt_rendererSwapBuffers)(ztWindowDetails*);
ztInternal bool (*_zt_rendererSetViewport)(ztWindowDetails*, ztGameSettings*, bool);
ztInternal bool (*_zt_rendererMakeContext)(ztWindowDetails*, ztGameSettings*, i32);
ztInternal bool (*_zt_rendererFreeContext)(ztWindowDetails*);
ztInternal bool (*_zt_rendererToggleFullscreen)(ztWindowDetails*, ztGameSettings*, bool);
ztInternal bool (*_zt_rendererChangeResolution)(ztWindowDetails*, ztGameSettings*, i32, i32);

ztInternal bool _zt_rendererSetRendererFuncs(ztRenderer_Enum renderer);

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererSetViewport(ztWindowDetails *win_details, ztGameSettings *game_settings, bool force);
ztInternal bool _ztdx_rendererMakeContext(ztWindowDetails *win_details, ztGameSettings *game_settings, i32 renderer_flags);
ztInternal bool _ztdx_rendererFreeContext(ztWindowDetails *win_details);
ztInternal void _ztdx_rendererSwapBuffers(ztWindowDetails *win_details);
ztInternal bool _ztdx_rendererToggleFullscreen(ztWindowDetails *win_details, ztGameSettings *game_settings, bool);
ztInternal bool _ztdx_rendererChangeResolution(ztWindowDetails *win_details, ztGameSettings *game_settings, i32 w, i32 h); 

// ================================================================================================================================================================================================

#if defined(ZT_WINDOWS)
bool _zt_winCreateWindow(ztGameSettings *game_settings, ztWindowDetails *window_details);
bool _zt_winCleanupWindow(ztWindowDetails *win_details, ztGameSettings *settings);
void _zt_winUpdateTitle(ztGameSettings *game_settings, ztWindowDetails *window_details);

void _zt_winProcessMessages();
void _zt_winHandleWindowSize(ztWindowDetails *window_details, ztGameSettings *game_settings);
void _zt_winLogSystemInfo();
void _zt_winControllerInputHapticFeedback(int idx, r32 strength_low, r32 strength_high);
void _zt_winControllerInputUpdate(r32 dt);
void _zt_winControllerInputCleanup();
void _zt_winControllerInputInit();

#elif defined(ZT_EMSCRIPTEN)
void _zt_emsProcessMessages();
void _zt_emsControllerInputHapticFeedback(int idx, r32 strength_low, r32 strength_high);
void _zt_emsControllerInputUpdate(r32 dt);
void _zt_emsControllerInputCleanup();
void _zt_emsControllerInputInit();
#endif

// ================================================================================================================================================================================================

ztInternal void _zt_setKeyDataActl(ztInputKeys *input_keys, ztInputKeys_Enum code, i32 flags, char *name, char display, char shift_display, i32 platform_mapping)
{
	input_keys->code             = code;
	input_keys->flags            = flags;
	input_keys->display          = display;
	input_keys->shift_display    = shift_display;
	input_keys->platform_mapping = platform_mapping;

	zt_strCpy(input_keys->name, zt_elementsOf(input_keys->name), name);
}

// ================================================================================================================================================================================================


//#define _zt_setKeyData(code, name, display, shift_display, mapping) zt_game->input_keys[idx++] = {code, (display == 0 ? ztInputKeyFlags_StateKey : 0), name, display, shift_display, mapping, 0}
#define _zt_setKeyData(code, name, display, shift_display, mapping) _zt_setKeyDataActl(&zt_game->input_keys[idx++], code, (display == 0 ? ztInputKeyFlags_StateKey : 0), name, display, shift_display, mapping)

ztInternal void _zt_inputSetupKeys()
{
#if defined(ZT_WINDOWS)
	int idx = 0;
	_zt_setKeyData(ztInputKeys_Invalid, "Invalid", 0, 0, 0);
	_zt_setKeyData(ztInputKeys_LeftButton,         "LeftButton",           0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_RightButton,        "RightButton",          0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_Cancel,             "Cancel",               0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_MiddleButton,       "MiddleButton",         0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_XButton1,           "XButton1",             0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_XButton2,           "XButton2",             0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_Back,               "Back",                 0,    0, VK_BACK);
	_zt_setKeyData(ztInputKeys_Tab,                "Tab",               '\t',    0, VK_TAB);
	_zt_setKeyData(ztInputKeys_Clear,              "Clear",                0,    0, VK_CLEAR);
	_zt_setKeyData(ztInputKeys_Return,             "Return",            '\n',    0, VK_RETURN);
	_zt_setKeyData(ztInputKeys_Shift,              "Shift",                0,    0, VK_SHIFT);
	_zt_setKeyData(ztInputKeys_Control,            "Control",              0,    0, VK_CONTROL);
	_zt_setKeyData(ztInputKeys_Menu,               "Menu",                 0,    0, VK_MENU);
	_zt_setKeyData(ztInputKeys_Pause,              "Pause",                0,    0, VK_PAUSE);
	_zt_setKeyData(ztInputKeys_Capital,            "Capital",              0,    0, VK_CAPITAL);
	_zt_setKeyData(ztInputKeys_Kana,               "Kana",                 0,    0, VK_KANA);
	_zt_setKeyData(ztInputKeys_Hangul,             "Hangul",               0,    0, VK_HANGUL);
	_zt_setKeyData(ztInputKeys_Junja,              "Junja",                0,    0, VK_JUNJA);
	_zt_setKeyData(ztInputKeys_Final,              "Final",                0,    0, VK_FINAL);
	_zt_setKeyData(ztInputKeys_Hanja,              "Hanja",                0,    0, VK_HANJA);
	_zt_setKeyData(ztInputKeys_Kanji,              "Kanji",                0,    0, VK_KANJI);
	_zt_setKeyData(ztInputKeys_Escape,             "Escape",               0,    0, VK_ESCAPE);
	_zt_setKeyData(ztInputKeys_Convert,            "Convert",              0,    0, VK_CONVERT);
	_zt_setKeyData(ztInputKeys_Nonconvert,         "Nonconvert",           0,    0, VK_NONCONVERT);
	_zt_setKeyData(ztInputKeys_Accept,             "Accept",               0,    0, VK_ACCEPT);
	_zt_setKeyData(ztInputKeys_ModeChange,         "ModeChange",           0,    0, VK_MODECHANGE);
	_zt_setKeyData(ztInputKeys_Space,              "Space",             ' ',   ' ', VK_SPACE);
	_zt_setKeyData(ztInputKeys_Prior,              "Prior",                0,    0, VK_PRIOR);
	_zt_setKeyData(ztInputKeys_Next,               "Next",                 0,    0, VK_NEXT);
	_zt_setKeyData(ztInputKeys_End,                "End",                  0,    0, VK_END);
	_zt_setKeyData(ztInputKeys_Home,               "Home",                 0,    0, VK_HOME);
	_zt_setKeyData(ztInputKeys_Left,               "Left",                 0,    0, VK_LEFT);
	_zt_setKeyData(ztInputKeys_Up,                 "Up",                   0,    0, VK_UP);
	_zt_setKeyData(ztInputKeys_Right,              "Right",                0,    0, VK_RIGHT);
	_zt_setKeyData(ztInputKeys_Down,               "Down",                 0,    0, VK_DOWN);
	_zt_setKeyData(ztInputKeys_Select,             "Select",               0,    0, VK_SELECT);
	_zt_setKeyData(ztInputKeys_Print,              "Print",                0,    0, VK_PRINT);
	_zt_setKeyData(ztInputKeys_Execute,            "Execute",              0,    0, VK_EXECUTE);
	_zt_setKeyData(ztInputKeys_Snapshot,           "Snapshot",             0,    0, VK_SNAPSHOT);
	_zt_setKeyData(ztInputKeys_Insert,             "Insert",               0,    0, VK_INSERT);
	_zt_setKeyData(ztInputKeys_Delete,             "Delete",               0,    0, VK_DELETE);
	_zt_setKeyData(ztInputKeys_Help,               "Help",                 0,    0, VK_HELP);
	_zt_setKeyData(ztInputKeys_0,                  "0",                  '0',  ')', '0');
	_zt_setKeyData(ztInputKeys_1,                  "1",                  '1',  '!', '1');
	_zt_setKeyData(ztInputKeys_2,                  "2",                  '2',  '@', '2');
	_zt_setKeyData(ztInputKeys_3,                  "3",                  '3',  '#', '3');
	_zt_setKeyData(ztInputKeys_4,                  "4",                  '4',  '$', '4');
	_zt_setKeyData(ztInputKeys_5,                  "5",                  '5',  '%', '5');
	_zt_setKeyData(ztInputKeys_6,                  "6",                  '6',  '^', '6');
	_zt_setKeyData(ztInputKeys_7,                  "7",                  '7',  '&', '7');
	_zt_setKeyData(ztInputKeys_8,                  "8",                  '8',  '*', '8');
	_zt_setKeyData(ztInputKeys_9,                  "9",                  '9',  '(', '9');
	_zt_setKeyData(ztInputKeys_A,                  "A",                  'a',  'A', 'A');
	_zt_setKeyData(ztInputKeys_B,                  "B",                  'b',  'B', 'B');
	_zt_setKeyData(ztInputKeys_C,                  "C",                  'c',  'C', 'C');
	_zt_setKeyData(ztInputKeys_D,                  "D",                  'd',  'D', 'D');
	_zt_setKeyData(ztInputKeys_E,                  "E",                  'e',  'E', 'E');
	_zt_setKeyData(ztInputKeys_F,                  "F",                  'f',  'F', 'F');
	_zt_setKeyData(ztInputKeys_G,                  "G",                  'g',  'G', 'G');
	_zt_setKeyData(ztInputKeys_H,                  "H",                  'h',  'H', 'H');
	_zt_setKeyData(ztInputKeys_I,                  "I",                  'i',  'I', 'I');
	_zt_setKeyData(ztInputKeys_J,                  "J",                  'j',  'J', 'J');
	_zt_setKeyData(ztInputKeys_K,                  "K",                  'k',  'K', 'K');
	_zt_setKeyData(ztInputKeys_L,                  "L",                  'l',  'L', 'L');
	_zt_setKeyData(ztInputKeys_M,                  "M",                  'm',  'M', 'M');
	_zt_setKeyData(ztInputKeys_N,                  "N",                  'n',  'N', 'N');
	_zt_setKeyData(ztInputKeys_O,                  "O",                  'o',  'O', 'O');
	_zt_setKeyData(ztInputKeys_P,                  "P",                  'p',  'P', 'P');
	_zt_setKeyData(ztInputKeys_Q,                  "Q",                  'q',  'Q', 'Q');
	_zt_setKeyData(ztInputKeys_R,                  "R",                  'r',  'R', 'R');
	_zt_setKeyData(ztInputKeys_S,                  "S",                  's',  'S', 'S');
	_zt_setKeyData(ztInputKeys_T,                  "T",                  't',  'T', 'T');
	_zt_setKeyData(ztInputKeys_U,                  "U",                  'u',  'U', 'U');
	_zt_setKeyData(ztInputKeys_V,                  "V",                  'v',  'V', 'V');
	_zt_setKeyData(ztInputKeys_W,                  "W",                  'w',  'W', 'W');
	_zt_setKeyData(ztInputKeys_X,                  "X",                  'x',  'X', 'X');
	_zt_setKeyData(ztInputKeys_Y,                  "Y",                  'y',  'Y', 'Y');
	_zt_setKeyData(ztInputKeys_Z,                  "Z",                  'z',  'Z', 'Z');
	_zt_setKeyData(ztInputKeys_LeftWin,            "LeftWin",              0,    0, VK_LWIN);
	_zt_setKeyData(ztInputKeys_RightWin,           "RightWin",             0,    0, VK_RWIN);
	_zt_setKeyData(ztInputKeys_Apps,               "Apps",                 0,    0, VK_APPS);
	_zt_setKeyData(ztInputKeys_Sleep,              "Sleep",                0,    0, VK_SLEEP);
	_zt_setKeyData(ztInputKeys_Numpad0,            "Numpad0",            '0',    0, VK_NUMPAD0);
	_zt_setKeyData(ztInputKeys_Numpad1,            "Numpad1",            '1',    0, VK_NUMPAD1);
	_zt_setKeyData(ztInputKeys_Numpad2,            "Numpad2",            '2',    0, VK_NUMPAD2);
	_zt_setKeyData(ztInputKeys_Numpad3,            "Numpad3",            '3',    0, VK_NUMPAD3);
	_zt_setKeyData(ztInputKeys_Numpad4,            "Numpad4",            '4',    0, VK_NUMPAD4);
	_zt_setKeyData(ztInputKeys_Numpad5,            "Numpad5",            '5',    0, VK_NUMPAD5);
	_zt_setKeyData(ztInputKeys_Numpad6,            "Numpad6",            '6',    0, VK_NUMPAD6);
	_zt_setKeyData(ztInputKeys_Numpad7,            "Numpad7",            '7',    0, VK_NUMPAD7);
	_zt_setKeyData(ztInputKeys_Numpad8,            "Numpad8",            '8',    0, VK_NUMPAD8);
	_zt_setKeyData(ztInputKeys_Numpad9,            "Numpad9",            '9',    0, VK_NUMPAD9);
	_zt_setKeyData(ztInputKeys_Multiply,           "Multiply",           '*',    0, VK_MULTIPLY);
	_zt_setKeyData(ztInputKeys_Add,                "Add",                '+',    0, VK_ADD);
	_zt_setKeyData(ztInputKeys_Separator,          "Separator",            0,    0, VK_SEPARATOR);
	_zt_setKeyData(ztInputKeys_Substract,          "Substract",          '-',    0, VK_SUBTRACT);
	_zt_setKeyData(ztInputKeys_Decimal,            "Decimal",            '.',    0, VK_DECIMAL);
	_zt_setKeyData(ztInputKeys_Divide,             "Divide",             '/',    0, VK_DIVIDE);
	_zt_setKeyData(ztInputKeys_F1,                 "F1",                   0,    0, VK_F1);
	_zt_setKeyData(ztInputKeys_F2,                 "F2",                   0,    0, VK_F2);
	_zt_setKeyData(ztInputKeys_F3,                 "F3",                   0,    0, VK_F3);
	_zt_setKeyData(ztInputKeys_F4,                 "F4",                   0,    0, VK_F4);
	_zt_setKeyData(ztInputKeys_F5,                 "F5",                   0,    0, VK_F5);
	_zt_setKeyData(ztInputKeys_F6,                 "F6",                   0,    0, VK_F6);
	_zt_setKeyData(ztInputKeys_F7,                 "F7",                   0,    0, VK_F7);
	_zt_setKeyData(ztInputKeys_F8,                 "F8",                   0,    0, VK_F8);
	_zt_setKeyData(ztInputKeys_F9,                 "F9",                   0,    0, VK_F9);
	_zt_setKeyData(ztInputKeys_F10,                "F10",                  0,    0, VK_F10);
	_zt_setKeyData(ztInputKeys_F11,                "F11",                  0,    0, VK_F11);
	_zt_setKeyData(ztInputKeys_F12,                "F12",                  0,    0, VK_F12);
	_zt_setKeyData(ztInputKeys_F13,                "F13",                  0,    0, VK_F13);
	_zt_setKeyData(ztInputKeys_F14,                "F14",                  0,    0, VK_F14);
	_zt_setKeyData(ztInputKeys_F15,                "F15",                  0,    0, VK_F15);
	_zt_setKeyData(ztInputKeys_F16,                "F16",                  0,    0, VK_F16);
	_zt_setKeyData(ztInputKeys_F17,                "F17",                  0,    0, VK_F17);
	_zt_setKeyData(ztInputKeys_F18,                "F18",                  0,    0, VK_F18);
	_zt_setKeyData(ztInputKeys_F19,                "F19",                  0,    0, VK_F19);
	_zt_setKeyData(ztInputKeys_F20,                "F20",                  0,    0, VK_F20);
	_zt_setKeyData(ztInputKeys_F21,                "F21",                  0,    0, VK_F21);
	_zt_setKeyData(ztInputKeys_F22,                "F22",                  0,    0, VK_F22);
	_zt_setKeyData(ztInputKeys_F23,                "F23",                  0,    0, VK_F23);
	_zt_setKeyData(ztInputKeys_F24,                "F24",                  0,    0, VK_F24);
	_zt_setKeyData(ztInputKeys_NumLock,            "NumLock",              0,    0, VK_NUMLOCK);
	_zt_setKeyData(ztInputKeys_Scroll,             "Scroll",               0,    0, VK_SCROLL);
	_zt_setKeyData(ztInputKeys_LeftShift,          "LeftShift",            0,    0, VK_LSHIFT);
	_zt_setKeyData(ztInputKeys_RightShift,         "RightShift",           0,    0, VK_RSHIFT);
	_zt_setKeyData(ztInputKeys_LeftControl,        "LeftControl",          0,    0, VK_LCONTROL);
	_zt_setKeyData(ztInputKeys_RightControl,       "RightControl",         0,    0, VK_RCONTROL);
	_zt_setKeyData(ztInputKeys_LeftMenu,           "LeftMenu",             0,    0, VK_LMENU);
	_zt_setKeyData(ztInputKeys_RightMenu,          "RightMenu",            0,    0, VK_RMENU);
	_zt_setKeyData(ztInputKeys_BrowserBack,        "BrowserBack",          0,    0, VK_BROWSER_BACK);
	_zt_setKeyData(ztInputKeys_BrowserForward,     "BrowserForward",       0,    0, VK_BROWSER_FORWARD);
	_zt_setKeyData(ztInputKeys_BrowserRefresh,     "BrowserRefresh",       0,    0, VK_BROWSER_REFRESH);
	_zt_setKeyData(ztInputKeys_BrowserStop,        "BrowserStop",          0,    0, VK_BROWSER_STOP);
	_zt_setKeyData(ztInputKeys_BrowserSearch,      "BrowserSearch",        0,    0, VK_BROWSER_SEARCH);
	_zt_setKeyData(ztInputKeys_BrowserFavorites,   "BrowserFavorites",     0,    0, VK_BROWSER_FAVORITES);
	_zt_setKeyData(ztInputKeys_BrowserHome,        "BrowserHome",          0,    0, VK_BROWSER_HOME);
	_zt_setKeyData(ztInputKeys_VolumeMute,         "VolumeMute",           0,    0, VK_VOLUME_MUTE);
	_zt_setKeyData(ztInputKeys_VolumeDown,         "VolumeDown",           0,    0, VK_VOLUME_DOWN);
	_zt_setKeyData(ztInputKeys_VolumeUp,           "VolumeUp",             0,    0, VK_VOLUME_UP);
	_zt_setKeyData(ztInputKeys_MediaNextTrack,     "MediaNextTrack",       0,    0, VK_MEDIA_NEXT_TRACK);
	_zt_setKeyData(ztInputKeys_MediaPrevTrack,     "MediaPrevTrack",       0,    0, VK_MEDIA_PREV_TRACK);
	_zt_setKeyData(ztInputKeys_MediaStop,          "MediaStop",            0,    0, VK_MEDIA_STOP);
	_zt_setKeyData(ztInputKeys_MediaPlayPause,     "MediaPlayPause",       0,    0, VK_MEDIA_PLAY_PAUSE);
	_zt_setKeyData(ztInputKeys_LaunchMail,         "LaunchMail",           0,    0, VK_LAUNCH_MAIL);
	_zt_setKeyData(ztInputKeys_LaunchMediaSelect,  "LaunchMediaSelect",    0,    0, VK_LAUNCH_MEDIA_SELECT);
	_zt_setKeyData(ztInputKeys_LaunchApp1,         "LaunchApp1",           0,    0, VK_LAUNCH_APP1);
	_zt_setKeyData(ztInputKeys_LaunchApp2,         "LaunchApp2",           0,    0, VK_LAUNCH_APP2);
	_zt_setKeyData(ztInputKeys_Semicolon,          "Semicolon",          ';',  ':', VK_OEM_1);
	_zt_setKeyData(ztInputKeys_Plus,               "Plus",               '=',  '+', VK_OEM_PLUS);
	_zt_setKeyData(ztInputKeys_Comma,              "Comma",              ',',  '<', VK_OEM_COMMA);
	_zt_setKeyData(ztInputKeys_Minus,              "Minus",              '-',  '_', VK_OEM_MINUS);
	_zt_setKeyData(ztInputKeys_Period,             "Period",             '.',  '>', VK_OEM_PERIOD);
	_zt_setKeyData(ztInputKeys_ForwardSlash,       "ForwardSlash",       '/',  '?', VK_OEM_2);
	_zt_setKeyData(ztInputKeys_Tilda,              "Tilda",              '`',  '~', VK_OEM_3);
	_zt_setKeyData(ztInputKeys_OpenBrace,          "OpenBrace",          '[',  '{', VK_OEM_4);
	_zt_setKeyData(ztInputKeys_BackSlash,          "BackSlash",         '\\',  '|', VK_OEM_5);
	_zt_setKeyData(ztInputKeys_CloseBrace,         "CloseBrace",         ']',  '}', VK_OEM_6);
	_zt_setKeyData(ztInputKeys_Apos,               "Apos",              '\'', '\"', VK_OEM_7);
	_zt_setKeyData(ztInputKeys_Oem_8,              "Oem_8",                0,    0, VK_OEM_8);
	_zt_setKeyData(ztInputKeys_Oem_102,            "Oem_102",              0,    0, VK_OEM_102);
	_zt_setKeyData(ztInputKeys_ProcessKey,         "ProcessKey",           0,    0, VK_PROCESSKEY);
	_zt_setKeyData(ztInputKeys_Packet,             "Packet",               0,    0, VK_PACKET);
	_zt_setKeyData(ztInputKeys_Attn,               "Attn",                 0,    0, VK_ATTN);
	_zt_setKeyData(ztInputKeys_Crsel,              "Crsel",                0,    0, VK_CRSEL);
	_zt_setKeyData(ztInputKeys_Exsel,              "Exsel",                0,    0, VK_EXSEL);
	_zt_setKeyData(ztInputKeys_Ereof,              "Ereof",                0,    0, VK_EREOF);
	_zt_setKeyData(ztInputKeys_Play,               "Play",                 0,    0, VK_PLAY);
	_zt_setKeyData(ztInputKeys_Zoom,               "Zoom",                 0,    0, VK_ZOOM);
	_zt_setKeyData(ztInputKeys_Pa1,                "Pa1",                  0,    0, VK_PA1);
	_zt_setKeyData(ztInputKeys_OemClear,           "OemClear",             0,    0, VK_OEM_CLEAR);

#elif defined(ZT_EMSCRIPTEN) // end ZT_WINDOWS
	int idx = 0;
	_zt_setKeyData(ztInputKeys_Invalid,            "Invalid",              0,    0, 0);
	_zt_setKeyData(ztInputKeys_LeftButton,         "LeftButton",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_RightButton,        "RightButton",          0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Cancel,             "Cancel",               0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_MiddleButton,       "MiddleButton",         0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_XButton1,           "XButton1",             0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_XButton2,           "XButton2",             0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Back,               "Back",                 0,    0, SDLK_BACKSPACE);
	_zt_setKeyData(ztInputKeys_Tab,                "Tab",               '\t',    0, SDLK_TAB);
	_zt_setKeyData(ztInputKeys_Clear,              "Clear",                0,    0, SDLK_CLEAR);
	_zt_setKeyData(ztInputKeys_Return,             "Return",            '\n',    0, SDLK_RETURN);
	_zt_setKeyData(ztInputKeys_Shift,              "Shift",                0,    0, SDLK_LSHIFT);
	_zt_setKeyData(ztInputKeys_Control,            "Control",              0,    0, SDLK_LCTRL);
	_zt_setKeyData(ztInputKeys_Menu,               "Menu",                 0,    0, SDLK_LALT);
	_zt_setKeyData(ztInputKeys_Pause,              "Pause",                0,    0, 19);//SDLK_PAUSE);
	_zt_setKeyData(ztInputKeys_Capital,            "Capital",              0,    0, SDLK_CAPSLOCK);
	_zt_setKeyData(ztInputKeys_Kana,               "Kana",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Hangul,             "Hangul",               0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Junja,              "Junja",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Final,              "Final",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Hanja,              "Hanja",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Kanji,              "Kanji",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Escape,             "Escape",               0,    0, SDLK_ESCAPE);
	_zt_setKeyData(ztInputKeys_Convert,            "Convert",              0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Nonconvert,         "Nonconvert",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Accept,             "Accept",               0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_ModeChange,         "ModeChange",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Space,              "Space",             ' ',   ' ', SDLK_SPACE);
	_zt_setKeyData(ztInputKeys_Prior,              "Prior",                0,    0, SDLK_PRIOR);
	_zt_setKeyData(ztInputKeys_Next,               "Next",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_End,                "End",                  0,    0, SDLK_END);
	_zt_setKeyData(ztInputKeys_Home,               "Home",                 0,    0, SDLK_HOME);
	_zt_setKeyData(ztInputKeys_Left,               "Left",                 0,    0, SDLK_LEFT);
	_zt_setKeyData(ztInputKeys_Up,                 "Up",                   0,    0, SDLK_UP);
	_zt_setKeyData(ztInputKeys_Right,              "Right",                0,    0, SDLK_RIGHT);
	_zt_setKeyData(ztInputKeys_Down,               "Down",                 0,    0, SDLK_DOWN);
	_zt_setKeyData(ztInputKeys_Select,             "Select",               0,    0, SDLK_SELECT);
	_zt_setKeyData(ztInputKeys_Print,              "Print",                0,    0, 316);//SDLK_PRINTSCREEN);
	_zt_setKeyData(ztInputKeys_Execute,            "Execute",              0,    0, SDLK_EXECUTE);
	_zt_setKeyData(ztInputKeys_Snapshot,           "Snapshot",             0,    0, SDLK_PAUSE);
	_zt_setKeyData(ztInputKeys_Insert,             "Insert",               0,    0, SDLK_INSERT);
	_zt_setKeyData(ztInputKeys_Delete,             "Delete",               0,    0, SDLK_DELETE);
	_zt_setKeyData(ztInputKeys_Help,               "Help",                 0,    0, SDLK_HELP);
	_zt_setKeyData(ztInputKeys_0,                  "0",                  '0',  ')', SDLK_0);
	_zt_setKeyData(ztInputKeys_1,                  "1",                  '1',  '!', SDLK_1);
	_zt_setKeyData(ztInputKeys_2,                  "2",                  '2',  '@', SDLK_2);
	_zt_setKeyData(ztInputKeys_3,                  "3",                  '3',  '#', SDLK_3);
	_zt_setKeyData(ztInputKeys_4,                  "4",                  '4',  '$', SDLK_4);
	_zt_setKeyData(ztInputKeys_5,                  "5",                  '5',  '%', SDLK_5);
	_zt_setKeyData(ztInputKeys_6,                  "6",                  '6',  '^', SDLK_6);
	_zt_setKeyData(ztInputKeys_7,                  "7",                  '7',  '&', SDLK_7);
	_zt_setKeyData(ztInputKeys_8,                  "8",                  '8',  '*', SDLK_8);
	_zt_setKeyData(ztInputKeys_9,                  "9",                  '9',  '(', SDLK_9);
	_zt_setKeyData(ztInputKeys_A,                  "A",                  'a',  'A', SDLK_a);
	_zt_setKeyData(ztInputKeys_B,                  "B",                  'b',  'B', SDLK_b);
	_zt_setKeyData(ztInputKeys_C,                  "C",                  'c',  'C', SDLK_c);
	_zt_setKeyData(ztInputKeys_D,                  "D",                  'd',  'D', SDLK_d);
	_zt_setKeyData(ztInputKeys_E,                  "E",                  'e',  'E', SDLK_e);
	_zt_setKeyData(ztInputKeys_F,                  "F",                  'f',  'F', SDLK_f);
	_zt_setKeyData(ztInputKeys_G,                  "G",                  'g',  'G', SDLK_g);
	_zt_setKeyData(ztInputKeys_H,                  "H",                  'h',  'H', SDLK_h);
	_zt_setKeyData(ztInputKeys_I,                  "I",                  'i',  'I', SDLK_i);
	_zt_setKeyData(ztInputKeys_J,                  "J",                  'j',  'J', SDLK_j);
	_zt_setKeyData(ztInputKeys_K,                  "K",                  'k',  'K', SDLK_k);
	_zt_setKeyData(ztInputKeys_L,                  "L",                  'l',  'L', SDLK_l);
	_zt_setKeyData(ztInputKeys_M,                  "M",                  'm',  'M', SDLK_m);
	_zt_setKeyData(ztInputKeys_N,                  "N",                  'n',  'N', SDLK_n);
	_zt_setKeyData(ztInputKeys_O,                  "O",                  'o',  'O', SDLK_o);
	_zt_setKeyData(ztInputKeys_P,                  "P",                  'p',  'P', SDLK_p);
	_zt_setKeyData(ztInputKeys_Q,                  "Q",                  'q',  'Q', SDLK_q);
	_zt_setKeyData(ztInputKeys_R,                  "R",                  'r',  'R', SDLK_r);
	_zt_setKeyData(ztInputKeys_S,                  "S",                  's',  'S', SDLK_s);
	_zt_setKeyData(ztInputKeys_T,                  "T",                  't',  'T', SDLK_t);
	_zt_setKeyData(ztInputKeys_U,                  "U",                  'u',  'U', SDLK_u);
	_zt_setKeyData(ztInputKeys_V,                  "V",                  'v',  'V', SDLK_v);
	_zt_setKeyData(ztInputKeys_W,                  "W",                  'w',  'W', SDLK_w);
	_zt_setKeyData(ztInputKeys_X,                  "X",                  'x',  'X', SDLK_x);
	_zt_setKeyData(ztInputKeys_Y,                  "Y",                  'y',  'Y', SDLK_y);
	_zt_setKeyData(ztInputKeys_Z,                  "Z",                  'z',  'Z', SDLK_z);
	_zt_setKeyData(ztInputKeys_LeftWin,            "LeftWin",              0,    0, SDLK_LGUI);
	_zt_setKeyData(ztInputKeys_RightWin,           "RightWin",             0,    0, SDLK_RGUI);
	_zt_setKeyData(ztInputKeys_Apps,               "Apps",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Sleep,              "Sleep",                0,    0, SDLK_SLEEP);
	_zt_setKeyData(ztInputKeys_Numpad0,            "Numpad0",            '0',    0, SDLK_KP_0);
	_zt_setKeyData(ztInputKeys_Numpad1,            "Numpad1",            '1',    0, SDLK_KP_1);
	_zt_setKeyData(ztInputKeys_Numpad2,            "Numpad2",            '2',    0, SDLK_KP_2);
	_zt_setKeyData(ztInputKeys_Numpad3,            "Numpad3",            '3',    0, SDLK_KP_3);
	_zt_setKeyData(ztInputKeys_Numpad4,            "Numpad4",            '4',    0, SDLK_KP_4);
	_zt_setKeyData(ztInputKeys_Numpad5,            "Numpad5",            '5',    0, SDLK_KP_5);
	_zt_setKeyData(ztInputKeys_Numpad6,            "Numpad6",            '6',    0, SDLK_KP_6);
	_zt_setKeyData(ztInputKeys_Numpad7,            "Numpad7",            '7',    0, SDLK_KP_7);
	_zt_setKeyData(ztInputKeys_Numpad8,            "Numpad8",            '8',    0, SDLK_KP_8);
	_zt_setKeyData(ztInputKeys_Numpad9,            "Numpad9",            '9',    0, SDLK_KP_9);
	_zt_setKeyData(ztInputKeys_Multiply,           "Multiply",           '*',    0, SDLK_KP_MULTIPLY);
	_zt_setKeyData(ztInputKeys_Add,                "Add",                '+',    0, SDLK_KP_PLUS);
	_zt_setKeyData(ztInputKeys_Separator,          "Separator",            0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Substract,          "Substract",          '-',    0, SDLK_KP_MINUS);
	_zt_setKeyData(ztInputKeys_Decimal,            "Decimal",            '.',    0, 1123);//SDLK_KP_DECIMAL);
	_zt_setKeyData(ztInputKeys_Divide,             "Divide",             '/',    0, SDLK_KP_DIVIDE);
	_zt_setKeyData(ztInputKeys_F1,                 "F1",                   0,    0, SDLK_F1);
	_zt_setKeyData(ztInputKeys_F2,                 "F2",                   0,    0, SDLK_F2);
	_zt_setKeyData(ztInputKeys_F3,                 "F3",                   0,    0, SDLK_F3);
	_zt_setKeyData(ztInputKeys_F4,                 "F4",                   0,    0, SDLK_F4);
	_zt_setKeyData(ztInputKeys_F5,                 "F5",                   0,    0, SDLK_F5);
	_zt_setKeyData(ztInputKeys_F6,                 "F6",                   0,    0, SDLK_F6);
	_zt_setKeyData(ztInputKeys_F7,                 "F7",                   0,    0, SDLK_F7);
	_zt_setKeyData(ztInputKeys_F8,                 "F8",                   0,    0, SDLK_F8);
	_zt_setKeyData(ztInputKeys_F9,                 "F9",                   0,    0, SDLK_F9);
	_zt_setKeyData(ztInputKeys_F10,                "F10",                  0,    0, SDLK_F10);
	_zt_setKeyData(ztInputKeys_F11,                "F11",                  0,    0, SDLK_F11);
	_zt_setKeyData(ztInputKeys_F12,                "F12",                  0,    0, SDLK_F12);
	_zt_setKeyData(ztInputKeys_F13,                "F13",                  0,    0, SDLK_F13);
	_zt_setKeyData(ztInputKeys_F14,                "F14",                  0,    0, SDLK_F14);
	_zt_setKeyData(ztInputKeys_F15,                "F15",                  0,    0, SDLK_F15);
	_zt_setKeyData(ztInputKeys_F16,                "F16",                  0,    0, SDLK_F16);
	_zt_setKeyData(ztInputKeys_F17,                "F17",                  0,    0, SDLK_F17);
	_zt_setKeyData(ztInputKeys_F18,                "F18",                  0,    0, SDLK_F18);
	_zt_setKeyData(ztInputKeys_F19,                "F19",                  0,    0, SDLK_F19);
	_zt_setKeyData(ztInputKeys_F20,                "F20",                  0,    0, SDLK_F20);
	_zt_setKeyData(ztInputKeys_F21,                "F21",                  0,    0, SDLK_F21);
	_zt_setKeyData(ztInputKeys_F22,                "F22",                  0,    0, SDLK_F22);
	_zt_setKeyData(ztInputKeys_F23,                "F23",                  0,    0, SDLK_F23);
	_zt_setKeyData(ztInputKeys_F24,                "F24",                  0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_NumLock,            "NumLock",              0,    0, SDLK_NUMLOCK);
	_zt_setKeyData(ztInputKeys_Scroll,             "Scroll",               0,    0, 145);//SDLK_SCROLLLOCK);
	_zt_setKeyData(ztInputKeys_LeftShift,          "LeftShift",            0,    0, SDLK_LSHIFT);
	_zt_setKeyData(ztInputKeys_RightShift,         "RightShift",           0,    0, SDLK_RSHIFT);
	_zt_setKeyData(ztInputKeys_LeftControl,        "LeftControl",          0,    0, SDLK_LCTRL);
	_zt_setKeyData(ztInputKeys_RightControl,       "RightControl",         0,    0, SDLK_RCTRL);
	_zt_setKeyData(ztInputKeys_LeftMenu,           "LeftMenu",             0,    0, SDLK_LALT);
	_zt_setKeyData(ztInputKeys_RightMenu,          "RightMenu",            0,    0, SDLK_RALT);
	_zt_setKeyData(ztInputKeys_BrowserBack,        "BrowserBack",          0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserForward,     "BrowserForward",       0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserRefresh,     "BrowserRefresh",       0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserStop,        "BrowserStop",          0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserSearch,      "BrowserSearch",        0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserFavorites,   "BrowserFavorites",     0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_BrowserHome,        "BrowserHome",          0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_VolumeMute,         "VolumeMute",           0,    0, SDLK_MUTE);
	_zt_setKeyData(ztInputKeys_VolumeDown,         "VolumeDown",           0,    0, SDLK_VOLUMEDOWN);
	_zt_setKeyData(ztInputKeys_VolumeUp,           "VolumeUp",             0,    0, SDLK_VOLUMEUP);
	_zt_setKeyData(ztInputKeys_MediaNextTrack,     "MediaNextTrack",       0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_MediaPrevTrack,     "MediaPrevTrack",       0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_MediaStop,          "MediaStop",            0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_MediaPlayPause,     "MediaPlayPause",       0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_LaunchMail,         "LaunchMail",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_LaunchMediaSelect,  "LaunchMediaSelect",    0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_LaunchApp1,         "LaunchApp1",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_LaunchApp2,         "LaunchApp2",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Semicolon,          "Semicolon",          ';',  ':', 186);//SDLK_SEMICOLON);
	_zt_setKeyData(ztInputKeys_Plus,               "Plus",               '=',  '+', 187);//SDLK_EQUALS);
	_zt_setKeyData(ztInputKeys_Comma,              "Comma",              ',',  '<', SDLK_COMMA);
	_zt_setKeyData(ztInputKeys_Minus,              "Minus",              '-',  '_', 189);//SDLK_MINUS);
	_zt_setKeyData(ztInputKeys_Period,             "Period",             '.',  '>', SDLK_PERIOD);
	_zt_setKeyData(ztInputKeys_ForwardSlash,       "ForwardSlash",       '/',  '?', SDLK_SLASH);
	_zt_setKeyData(ztInputKeys_Tilda,              "Tilda",              '`',  '~', SDLK_BACKQUOTE);
	_zt_setKeyData(ztInputKeys_OpenBrace,          "OpenBrace",          '[',  '{', SDLK_LEFTBRACKET);
	_zt_setKeyData(ztInputKeys_BackSlash,          "BackSlash",         '\\',  '|', SDLK_BACKSLASH);
	_zt_setKeyData(ztInputKeys_CloseBrace,         "CloseBrace",         ']',  '}', SDLK_RIGHTBRACKET);
	_zt_setKeyData(ztInputKeys_Apos,               "Apos",              '\'', '\"', SDLK_QUOTE);
	_zt_setKeyData(ztInputKeys_Oem_8,              "Oem_8",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Oem_102,            "Oem_102",              0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_ProcessKey,         "ProcessKey",           0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Packet,             "Packet",               0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Attn,               "Attn",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Crsel,              "Crsel",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Exsel,              "Exsel",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Ereof,              "Ereof",                0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Play,               "Play",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Zoom,               "Zoom",                 0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_Pa1,                "Pa1",                  0,    0, SDLK_F24);
	_zt_setKeyData(ztInputKeys_OemClear,           "OemClear",             0,    0, SDLK_F24);
	// end ZT_EMSCRIPTEN
#elif defined(ZT_ANDROID)

#endif // end ZT_EMSCRIPTEN
};

// ================================================================================================================================================================================================

bool zt_inputThisFrame()
{
	return zt_game->input_this_frame;
}

// ================================================================================================================================================================================================

ztInputKeys* zt_inputKeysAccessState()
{
	return zt_game->input_keys;
}

// ================================================================================================================================================================================================

void zt_inputKeysCopyState(ztInputKeys input_keys[ztInputKeys_MAX])
{
	ZT_PROFILE_INPUT("zt_inputKeysCopyState");
	int size = sizeof(ztInputKeys) * ztInputKeys_MAX;
	zt_memCpy(input_keys, size, zt_game->input_keys, size);
}

// ================================================================================================================================================================================================

void zt_inputGetKeyStrokes(ztInputKeys_Enum key_strokes[ZT_MAX_INPUT_KEYSTROKES])
{
	ZT_PROFILE_INPUT("zt_inputGetKeyStrokes");
	int size = sizeof(ztInputKeys_Enum) * ZT_MAX_INPUT_KEYSTROKES;
	zt_memCpy(key_strokes, size, zt_game->input_key_strokes, size);
}

// ================================================================================================================================================================================================

ztInputMouse* zt_inputMouseAccessState()
{
	return &zt_game->input_mouse;
}

// ================================================================================================================================================================================================

void zt_inputMouseCopyState(ztInputMouse *input_mouse)
{
	ZT_PROFILE_INPUT("zt_inputMouseCopyState");
	zt_memCpy(input_mouse, zt_sizeof(ztInputMouse), &zt_game->input_mouse, zt_sizeof(ztInputMouse));
}

// ================================================================================================================================================================================================

void zt_inputMouseLook(bool mouse_look)
{
	zt_game->input_mouse_look = mouse_look;
}

// ================================================================================================================================================================================================

bool zt_inputMouseIsLook()
{
	return zt_game->input_mouse_look;
}

// ================================================================================================================================================================================================

void zt_inputMouseSetCursor(ztInputMouseCursor_Enum cursor)
{
	ZT_PROFILE_INPUT("zt_inputMouseSetCursor");
#	if defined(ZT_WINDOWS)
	switch (cursor)
	{
	case ztInputMouseCursor_None:       SetCursor(NULL); break;
	case ztInputMouseCursor_Arrow:      SetCursor(LoadCursor(NULL, IDC_ARROW)); break;
	case ztInputMouseCursor_ResizeNS:   SetCursor(LoadCursor(NULL, IDC_SIZENS)); break;
	case ztInputMouseCursor_ResizeEW:   SetCursor(LoadCursor(NULL, IDC_SIZEWE)); break;
	case ztInputMouseCursor_ResizeNWSE:	SetCursor(LoadCursor(NULL, IDC_SIZENWSE)); break;
	case ztInputMouseCursor_ResizeSWNE:	SetCursor(LoadCursor(NULL, IDC_SIZENESW)); break;
	case ztInputMouseCursor_IBeam:      SetCursor(LoadCursor(NULL, IDC_IBEAM)); break;
	case ztInputMouseCursor_Wait:       SetCursor(LoadCursor(NULL, IDC_WAIT)); break;
	case ztInputMouseCursor_Cross:      SetCursor(LoadCursor(NULL, IDC_CROSS)); break;
	case ztInputMouseCursor_Stop:       SetCursor(LoadCursor(NULL, IDC_NO)); break;
	case ztInputMouseCursor_Hand:       SetCursor(LoadCursor(NULL, IDC_HAND)); break;
	case ztInputMouseCursor_Help:       SetCursor(LoadCursor(NULL, IDC_HELP)); break;
	}
#elif defined(ZT_EMSCRIPTEN)
//	switch (cursor)
//	{
//		case ztInputMouseCursor_None:       SDL_SetCursor(NULL); break;
//		case ztInputMouseCursor_Arrow:      SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW)); break;
//		case ztInputMouseCursor_ResizeNS:   SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENS)); break;
//		case ztInputMouseCursor_ResizeEW:   SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE)); break;
//		case ztInputMouseCursor_ResizeNWSE:	SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE)); break;
//		case ztInputMouseCursor_ResizeSWNE:	SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENESW)); break;
//		case ztInputMouseCursor_IBeam:      SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM)); break;
//		case ztInputMouseCursor_Wait:       SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT)); break;
//		case ztInputMouseCursor_Cross:      SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR)); break;
//		case ztInputMouseCursor_Stop:       SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_NO)); break;
//		case ztInputMouseCursor_Hand:       SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND)); break;
//		case ztInputMouseCursor_Help:       SDL_SetCursor(SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW)); break;
//	}

	SDL_ShowCursor(cursor != ztInputMouseCursor_None ? SDL_ENABLE : SDL_DISABLE);

	if (cursor == ztInputMouseCursor_None) {
		SDL_WM_GrabInput(SDL_GRAB_ON);
	}
	else {
		SDL_WM_GrabInput(SDL_GRAB_OFF);
	}

#endif

	zt_game->input_mouse.cursor = cursor;
}

// ================================================================================================================================================================================================

ztInputController* zt_inputControllerAccessState(int idx)
{
	zt_assertReturnValOnFail(idx >= 0 && idx < ZT_MAX_INPUT_CONTROLLERS, nullptr);
	return &zt_game->input_controllers[idx];
}

// ================================================================================================================================================================================================

void zt_inputControllerCopyState(ztInputController *input_controller, int idx)
{
	ZT_PROFILE_INPUT("zt_inputControllerCopyState");
	zt_assertReturnOnFail(idx >= 0 && idx < ZT_MAX_INPUT_CONTROLLERS);
	zt_memCpy(input_controller, zt_sizeof(ztInputController), &zt_game->input_controllers[idx], zt_sizeof(ztInputController));
}

// ================================================================================================================================================================================================

void zt_inputControllerTriggerHapticFeedback(int idx, r32 strength_low, r32 strength_high)
{
	ZT_PROFILE_INPUT("zt_inputControllerTriggerHapticFeedback");
	zt_winOnly(_zt_winControllerInputHapticFeedback(idx, strength_low, strength_high));
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

bool zt_inputReplayMakeWriter(ztInputReplayData *replay_data, const char *file_name)
{
	zt_returnValOnNull(replay_data, false);
	zt_memSet(replay_data, zt_sizeof(ztInputReplayData), 0);
	if (!zt_fileOpen(&replay_data->file, file_name, ztFileOpenMethod_WriteOver)) {
		return false;
	}

	replay_data->working_memory_size = zt_max(zt_sizeof(ztInputKeys) * ztInputKeys_MAX, zt_max(zt_sizeof(ztInputMouse), zt_sizeof(ztInputController))) * 2;
	replay_data->working_memory = zt_mallocStructArray(byte, replay_data->working_memory_size);

	return true;
}

// ================================================================================================================================================================================================

bool zt_inputReplayMakeReader(ztInputReplayData *replay_data, const char *file_name)
{
	zt_returnValOnNull(replay_data, false);
	zt_memSet(replay_data, zt_sizeof(ztInputReplayData), 0);
	if (!zt_fileOpen(&replay_data->file, file_name, ztFileOpenMethod_ReadOnly)) {
		return false;
	}

	replay_data->working_memory_size = zt_max(zt_sizeof(ztInputKeys) * ztInputKeys_MAX, zt_max(zt_sizeof(ztInputMouse), zt_sizeof(ztInputController))) * 2;
	replay_data->working_memory = zt_mallocStructArray(byte, replay_data->working_memory_size);

	return true;
}

// ================================================================================================================================================================================================

void zt_inputReplayFree(ztInputReplayData *replay_data)
{
	zt_returnOnNull(replay_data);
	zt_fileClose(&replay_data->file);

	zt_free(replay_data->working_memory);
}

// ================================================================================================================================================================================================

bool zt_inputReplayProcessFrame(ztInputReplayData *replay_data, i32 frame, bool *input_this_frame, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztInputController *input_controller, ztInputKeys_Enum input_keystrokes[ZT_MAX_INPUT_KEYSTROKES])
{
	ZT_PROFILE_INPUT("zt_inputReplayProcessFrame")

	zt_returnValOnNull(replay_data, false);
	zt_returnValOnNull(input_this_frame, false);
	zt_returnValOnNull(input_keys, false);
	zt_returnValOnNull(input_mouse, false);
	zt_returnValOnNull(input_controller, false);
	zt_returnValOnNull(input_keystrokes, false);

	i32  diff_size = 0;

	if (replay_data->file.open_method == ztFileOpenMethod_ReadOnly) {
		i32 read_frame = 0;
		if (!zt_fileRead(&replay_data->file, &read_frame)) {
			zt_fileClose(&replay_data->file);
			return false;
		}

		zt_assert(read_frame == frame);

		i8 read_bool = 0;
		if (!zt_fileRead(&replay_data->file, &read_bool)) {
			zt_fileClose(&replay_data->file);
			return false;
		}
		*input_this_frame = read_bool == 1;

		diff_size = 0;
		zt_fileRead(&replay_data->file, &diff_size);
		if (diff_size > 0) {
			zt_fileRead(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(replay_data->input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX, replay_data->working_memory, diff_size);
		}
		zt_memCpy(input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX, replay_data->input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX);

		diff_size = 0;
		zt_fileRead(&replay_data->file, &diff_size);
		if (diff_size > 0) {
			zt_fileRead(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(&replay_data->input_mouse, zt_sizeof(ztInputMouse), replay_data->working_memory, diff_size);
		}
		zt_memCpy(input_mouse, zt_sizeof(ztInputMouse), &replay_data->input_mouse, zt_sizeof(ztInputMouse));

		diff_size = 0;
		zt_fileRead(&replay_data->file, &diff_size);
		if (diff_size > 0) {
			zt_fileRead(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(&replay_data->input_controller, zt_sizeof(ztInputController), replay_data->working_memory, diff_size);
		}
		zt_memCpy(input_controller, zt_sizeof(ztInputController), &replay_data->input_controller, zt_sizeof(ztInputController));

		diff_size = 0;
		zt_fileRead(&replay_data->file, &diff_size);
		if (diff_size > 0) {
			zt_fileRead(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(replay_data->input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16, replay_data->working_memory, diff_size);
		}
		zt_memCpy(input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16, replay_data->input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16);
	}
	else if (replay_data->file.open_method == ztFileOpenMethod_WriteOver) {
		zt_fileWrite(&replay_data->file, frame);

		i8 write_bool = *input_this_frame ? 1 : 0;
		zt_fileWrite(&replay_data->file, write_bool);

		diff_size = zt_memoryDeltaGet(input_keys, replay_data->input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX, replay_data->working_memory, replay_data->working_memory_size);

		zt_fileWrite(&replay_data->file, diff_size);
		if (diff_size > 0) {
			zt_fileWrite(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(replay_data->input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX, replay_data->working_memory, diff_size);
			zt_assert(zt_memCmp(replay_data->input_keys, input_keys, zt_sizeof(ztInputKeys) * ztInputKeys_MAX) == 0);
		}

		diff_size = zt_memoryDeltaGet(input_mouse, &replay_data->input_mouse, zt_sizeof(ztInputMouse), replay_data->working_memory, replay_data->working_memory_size);
		zt_fileWrite(&replay_data->file, diff_size);
		if (diff_size > 0) {
			zt_fileWrite(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(&replay_data->input_mouse, zt_sizeof(ztInputMouse), replay_data->working_memory, diff_size);
			zt_assert(zt_memCmp(&replay_data->input_mouse, input_mouse, zt_sizeof(ztInputMouse)) == 0);
		}

		diff_size = zt_memoryDeltaGet(input_controller, &replay_data->input_controller, zt_sizeof(ztInputController), replay_data->working_memory, replay_data->working_memory_size);
		zt_fileWrite(&replay_data->file, diff_size);
		if (diff_size > 0) {
			zt_fileWrite(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(&replay_data->input_controller, zt_sizeof(ztInputController), replay_data->working_memory, diff_size);
			zt_assert(zt_memCmp(&replay_data->input_controller, input_controller, zt_sizeof(ztInputController)) == 0);
		}

		diff_size = zt_memoryDeltaGet(input_keystrokes, replay_data->input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16, replay_data->working_memory, replay_data->working_memory_size);
		zt_fileWrite(&replay_data->file, diff_size);
		if (diff_size > 0) {
			zt_fileWrite(&replay_data->file, replay_data->working_memory, diff_size);
			zt_memoryDeltaApply(replay_data->input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16, replay_data->working_memory, diff_size);
			zt_assert(zt_memCmp(replay_data->input_keystrokes, input_keystrokes, zt_sizeof(ztInputKeys_Enum) * 16) == 0);
		}
	}

	return true;
}

// ================================================================================================================================================================================================

void _zt_inputClearState( bool lost_focus )
{
	ZT_PROFILE_INPUT("_zt_inputClearState");
	zt_fiz(ztInputKeys_MAX) {
		zt_bitRemove(zt_game->input_keys[i].flags, ztInputKeyFlags_JustPressed);
		zt_bitRemove(zt_game->input_keys[i].flags, ztInputKeyFlags_JustReleased);
		zt_bitRemove(zt_game->input_keys[i].flags, ztInputKeyFlags_JustRepeated);
	}

	zt_fiz(zt_elementsOf(zt_game->input_key_strokes)) {
		zt_game->input_key_strokes[i] = ztInputKeys_Invalid;
	}
	zt_game->input_key_strokes_count = 0;

	zt_fiz(zt_elementsOf(zt_game->input_mouse.button_states)) {
		zt_bitRemove(zt_game->input_mouse.button_states[i], ztInputMouseFlags_JustPressed);
		zt_bitRemove(zt_game->input_mouse.button_states[i], ztInputMouseFlags_JustReleased);
	}

	zt_game->input_mouse.delta_x = zt_game->input_mouse.delta_y = 0;
	zt_game->input_mouse.wheel_delta = 0;

	zt_fiz(ZT_MAX_INPUT_CONTROLLERS) {
		zt_fjz(zt_elementsOf(zt_game->input_controllers[i].button_states)) {
			zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustPressed);
			zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustReleased);
		}
	}

	if (lost_focus) {
		zt_fiz(ztInputKeys_MAX) {
			if (zt_bitIsSet(zt_game->input_keys[i].flags, ztInputKeyFlags_Pressed)) {
				zt_game->input_keys[i].flags = ztInputKeyFlags_JustReleased;
			}
		}

		zt_fiz(zt_elementsOf(zt_game->input_mouse.button_states)) {
			if (zt_bitIsSet(zt_game->input_mouse.button_states[i], ztInputMouseFlags_Pressed)) {
				zt_game->input_mouse.button_states[i] = ztInputMouseFlags_JustReleased;
			}
		}

		zt_fiz(ZT_MAX_INPUT_CONTROLLERS) {
			zt_fjz(zt_elementsOf(zt_game->input_controllers[i].button_states)) {
				if (zt_bitIsSet(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_Pressed)) {
					zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustReleased);
					zt_game->input_controllers[i].button_times[j] = 0;
				}
			}
			zt_fjz(zt_elementsOf(zt_game->input_controllers[i].analog_values)) {
				zt_game->input_controllers[i].analog_values[j] = 0;
			}
		}
	}

	zt_game->input_this_frame = false;
}

// ================================================================================================================================================================================================

bool zt_rendererSupported(ztRenderer_Enum renderer)
{
	switch (renderer)
	{
	case ztRenderer_OpenGL: return zt_openGLSupport(true) zt_noOpenGLSupport(false);
	case ztRenderer_DirectX: return zt_directxSupport(true) zt_noDirectxSupport(false);
	}

	return false;
}

// ================================================================================================================================================================================================

int zt_rendererSupportedList(ztRenderer_Enum* renderers, int renderers_count)
{
	int idx = 0;
	zt_openGLSupport(if (idx < renderers_count) renderers[idx++] = ztRenderer_OpenGL);
	zt_directxSupport(if (idx < renderers_count) renderers[idx++] = ztRenderer_DirectX);
	return idx;
}

// ================================================================================================================================================================================================

bool zt_rendererVersionSupported(ztRenderer_Enum renderer, int v_major, int v_minor)
{
	if (renderer == ztRenderer_OpenGL) {
		zt_noOpenGLSupport(return false);

		// TODO(josh): this needs updated to check dlls
		switch (v_major)
		{
			case 4: return v_minor >= 0 && v_minor <= 5;
			case 3: return v_minor >= 0 && v_minor <= 3;
			case 2: return v_minor >= 0 && v_minor <= 1;
			case 1: return v_minor >= 0 && v_minor <= 5;
		}
	}
	else if (renderer == ztRenderer_DirectX) {
		zt_noDirectxSupport(return false);

		if (v_major == 11) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_drawListMake(ztDrawList *draw_list, i32 max_commands, i32 flags, ztMemoryArena *arena)
{
	ZT_PROFILE_RENDERING("zt_drawListMake");
	zt_returnValOnNull(draw_list, false);

	draw_list->commands = zt_mallocStructArrayArena(ztDrawCommand, max_commands, arena);
	if (!draw_list->commands) {
		return false;
	}

	draw_list->commands_size = max_commands;
	draw_list->commands_count = 0;
	draw_list->flags = flags;
	draw_list->current_clip = nullptr;
	draw_list->arena = arena;

	zt_debugOnly(draw_list->active_shaders = draw_list->active_textures = 0);

	return true;
}

// ================================================================================================================================================================================================

void zt_drawListFree(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListFree");
	if (draw_list == nullptr) {
		return;
	}

	if (draw_list->commands) {
		zt_freeArena(draw_list->commands, draw_list->arena);
	}

	zt_memSet(draw_list, sizeof(ztDrawList), 0);
}

// ================================================================================================================================================================================================

ztInternal i32 _zt_drawListDebugCount = 0;

#define _zt_drawListCheck(draw_list) \
            zt_returnValOnNull(draw_list, false);\
            if (draw_list->commands_count >= draw_list->commands_size) { \
                zt_assert(false && "ztDrawList command overflow"); \
                return false; \
            } \
            zt_debugOnly(draw_list->commands[draw_list->commands_count].debug_id = _zt_drawListDebugCount++);


#define _zt_drawListVerifyShader(draw_list) zt_debugOnly(zt_assert(draw_list->active_shaders > 0))
#define _zt_drawListVerifyTexture(draw_list) zt_debugOnly(zt_assert(draw_list->active_textures > 0))

// ================================================================================================================================================================================================

bool zt_drawListAddPoint(ztDrawList *draw_list, const ztVec3 &p)
{
	ZT_PROFILE_RENDERING("zt_drawListAddPoint");
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_Point;
	command->point = p;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2)
{
	ZT_PROFILE_RENDERING("zt_drawListAddLine");
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_Line;
	command->line[0] = p1;
	command->line[1] = p2;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec3 p[2])
{
	ZT_PROFILE_RENDERING("zt_drawListAddLine");
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_Line;
	command->line[0] = p[0];
	command->line[1] = p[1];

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec2 &p1, const ztVec2 &p2)
{
	return zt_drawListAddLine(draw_list, zt_vec3(p1, 0), zt_vec3(p2, 0));
}

// ================================================================================================================================================================================================

bool zt_drawListAddLine(ztDrawList *draw_list, const ztVec2 p[2])
{
	return zt_drawListAddLine(draw_list, p[0], p[1]);
}

// ================================================================================================================================================================================================

bool zt_drawListAddBezierCurve(ztDrawList *draw_list, ztVec2 beg, ztVec2 end, ztVec2 beg_cp, ztVec2 end_cp, int segments)
{
	return zt_drawListAddBezierCurve(draw_list, zt_vec3(beg, 0), zt_vec3(end, 0), zt_vec3(beg_cp, 0), zt_vec3(end_cp, 0), segments);
}

// ================================================================================================================================================================================================

bool zt_drawListAddBezierCurve(ztDrawList *draw_list, ztVec3 beg, ztVec3 end, ztVec3 beg_cp, ztVec3 end_cp, int segments)
{
	ztVec3 prev_pnt = beg;

	zt_fiz(segments + 1) {
		float pct = (i + 0) / (r32)segments;

		ztVec3 curr_pnt = zt_pow(1 - pct, 3) * beg + 3 * pct * zt_pow(1 - pct, 2) * beg_cp + 3 * zt_pow(pct, 2) * (1 - pct) * end_cp + zt_pow(pct, 3) * end;
		if (!zt_drawListAddLine(draw_list, prev_pnt, curr_pnt)) {
			return false;
		}
		prev_pnt = curr_pnt;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyTriangle(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyTriangle");
	if (!zt_drawListAddLine(draw_list, p1, p2)) return false;
	if (!zt_drawListAddLine(draw_list, p2, p3)) return false;
	if (!zt_drawListAddLine(draw_list, p3, p1)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyTriangle(ztDrawList *draw_list, const ztVec3 p[3])
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyTriangle");
	zt_fiz(3) {
		if (!zt_drawListAddLine(draw_list, p[i], p[(i + 1) % 3])) {
			return false;
		}
	}
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyQuad");
	if (!zt_drawListAddLine(draw_list, p1, p2)) return false;
	if (!zt_drawListAddLine(draw_list, p2, p3)) return false;
	if (!zt_drawListAddLine(draw_list, p3, p4)) return false;
	if (!zt_drawListAddLine(draw_list, p4, p1)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyQuad(ztDrawList *draw_list, const ztVec3 p[4])
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyQuad");
	zt_fiz(4) {
		if (!zt_drawListAddLine(draw_list, p[i], p[(i + 1) % 4])) {
			return false;
		}
	}
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyRect(ztDrawList *draw_list, const ztVec2 &pos, const ztVec2 &size)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyRect");
	return zt_drawListAddEmptyRect(draw_list, zt_vec3(pos, 0), size);
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyRect(ztDrawList *draw_list, const ztVec3 &pos, const ztVec2 &size)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyRect");
	r32 ppu = zt_pixelsPerUnit();
	r32 pix = 1 / ppu;
	r32 half_pix = .375f / ppu;

	ztVec3 p[4] = {
		zt_vec3(pos.x - size.x / 2.f + half_pix, pos.y + size.y / 2.f - half_pix, pos.z),  // upper left
		zt_vec3(pos.x - size.x / 2.f + half_pix, pos.y - size.y / 2.f + half_pix, pos.z),  // lower left
		zt_vec3(pos.x + size.x / 2.f - half_pix, pos.y - size.y / 2.f + half_pix, pos.z),  // lower right
		zt_vec3(pos.x + size.x / 2.f - half_pix, pos.y + size.y / 2.f - half_pix, pos.z)   // upper right
	};

	zt_fiz(4) {
		zt_fjz(2) {
			//zt_alignToPixel(&p[i].values[j], ppu); // ignore the z value
		}
	}

	zt_drawListAddLine(draw_list, p[0], zt_vec3(p[1].x, p[1].y - pix, p[1].z));
	zt_drawListAddLine(draw_list, p[1], p[2]);
	zt_drawListAddLine(draw_list, p[2], p[3]);
	zt_drawListAddLine(draw_list, p[3], p[0]);
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyCircle(ztDrawList *draw_list, const ztVec2 &pos, r32 radius, int points)
{
	return zt_drawListAddEmptyCircle(draw_list, zt_vec3(pos, 0), radius, points);
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyCircle(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyCircle");

	r32 theta = ztMathPi2 / points;

	r32 start_x = (zt_cos(0) * radius) + pos.x;
	r32 start_y = (zt_sin(0) * radius) + pos.y;
	r32 prev_x = start_x;
	r32 prev_y = start_y;

	for (int i = 1; i <= points; ++i) {
		r32 x = i != points ? pos.x + (zt_cos(i * theta) * radius) : start_x;
		r32 y = i != points ? pos.y + (zt_sin(i * theta) * radius) : start_y;

		zt_drawListAddLine(draw_list, zt_vec3(prev_x, prev_y, pos.z), zt_vec3(x, y, pos.z));

		prev_x = x;
		prev_y = y;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyCubeFromCenterSize(ztDrawList *draw_list, const ztVec3 &pos, const ztVec3 &size)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyCubeFromCenterSize");
	r32 half_x = size.x / 2.f;
	r32 half_y = size.y / 2.f;
	r32 half_z = size.z / 2.f;

	zt_drawListAddEmptyQuad(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z),
									   zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z),
									   zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z),
									   zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z)); // top face

	zt_drawListAddEmptyQuad(draw_list, zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z),
									   zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z),
									   zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z),
									   zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z)); // bottom face

	zt_drawListAddLine(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z), zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z), zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z), zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z), zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z));

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyCubeFromMinMax(ztDrawList *draw_list, const ztVec3 &min, const ztVec3 &max)
{
	ZT_PROFILE_RENDERING("zt_drawListAddEmptyCubeFromMinMax");
	ztVec3 size = zt_vec3((max.x - min.x), (max.y - min.y), (max.z - min.z));
	ztVec3 pos  = min + (size * .5f);
	return zt_drawListAddEmptyCubeFromCenterSize(draw_list, pos, size);
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptySimpleSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points)
{
	r32 theta = ztMathPi2 / points;

	r32 start_x = (zt_cos(0) * radius);
	r32 start_y = (zt_sin(0) * radius);
	r32 prev_x = start_x;
	r32 prev_y = start_y;

	for (int i = 1; i <= points; ++i) {
		r32 x = i != points ? (zt_cos(i * theta) * radius) : start_x;
		r32 y = i != points ? (zt_sin(i * theta) * radius) : start_y;

		zt_drawListAddLine(draw_list, zt_vec3(pos.x + prev_x, pos.y + prev_y, pos.z), zt_vec3(pos.x + x, pos.y + y, pos.z));
		zt_drawListAddLine(draw_list, zt_vec3(pos.x + prev_x, pos.y, pos.z + prev_y), zt_vec3(pos.x + x, pos.y, pos.z + y));
		zt_drawListAddLine(draw_list, zt_vec3(pos.x, pos.y + prev_x, pos.z + prev_y), zt_vec3(pos.x, pos.y + x, pos.z + y));

		prev_x = x;
		prev_y = y;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptySimpleSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points, int rings)
{
	r32 grid_size = radius * 2 / rings;
	
	r32 y_add_vert_2[6] = { -grid_size, 0, grid_size, 0, -grid_size, -grid_size };
	r32 z_add_vert_2[6] = { 0, -grid_size, 0, grid_size, 0, 0 };

	r32 x_add_vert_3[6] = { grid_size, grid_size, grid_size, grid_size, 0, 0 };
	r32 y_add_vert_3[6] = { -grid_size, 0, grid_size, 0, -grid_size, -grid_size };
	r32 z_add_vert_3[6] = { 0, -grid_size, 0, grid_size, grid_size, -grid_size };

	r32 x_add_vert_5[6] = { grid_size, grid_size, grid_size, grid_size, 0, 0 };
	r32 y_add_vert_5[6] = { -grid_size, 0, grid_size, 0, -grid_size, -grid_size };
	r32 z_add_vert_5[6] = { 0, -grid_size, 0, grid_size, grid_size, -grid_size };

	r32 x_add_vert_6[6] = { grid_size, grid_size, grid_size, grid_size, 0, 0 };
	r32 z_add_vert_6[6] = { 0, 0, 0, 0, grid_size, -grid_size };

	r32 x_start[6] = { -radius, -radius, -radius, -radius, -radius, radius };
	r32 y_start[6] = { radius, -radius, -radius, radius, radius, radius };
	r32 z_start[6] = { radius, radius, -radius, -radius, -radius, radius };

	r32 y_add_1[6] = { -grid_size, 0, grid_size, 0, -grid_size, -grid_size };
	r32 z_add_1[6] = { 0, -grid_size, 0, grid_size, 0, 0 };

	r32 x_add_2[6] = { grid_size, grid_size, grid_size, grid_size, 0, 0 };
	r32 y_add_2[6] = { radius * 2, 0, -radius * 2, 0, radius * 2, radius * 2 };
	r32 z_add_2[6] = { 0, radius * 2, 0, -radius * 2, grid_size, -grid_size };

	r32 uv_x_beg[6] = { .25f, .25f, .25f, .25f, .000f, .5f };
	r32 uv_y_beg[6] = { .000f, .25f, .5f, .75f, .000f, .000f };

	zt_fkz(6) {
		r32 x_pos = x_start[k];
		r32 y_pos = y_start[k];
		r32 z_pos = z_start[k];

		zt_fiz(rings) {
			zt_fjz(rings) {

				ztVec3 p0 = zt_vec3(x_pos, y_pos, z_pos).getNormal() * radius;
				ztVec3 p1 = zt_vec3(x_pos, y_pos + y_add_vert_2[k], z_pos + z_add_vert_2[k]).getNormal() * radius;
				ztVec3 p2 = zt_vec3(x_pos + x_add_vert_3[k], y_pos + y_add_vert_3[k], z_pos + z_add_vert_3[k]).getNormal() * radius;
				ztVec3 p3 = zt_vec3(x_pos + x_add_vert_6[k], y_pos, z_pos + z_add_vert_6[k]).getNormal() * radius;


				zt_drawListAddEmptyQuad(draw_list, p0 + pos, p1 + pos, p2 + pos, p3 + pos);

				y_pos += y_add_1[k];
				z_pos += z_add_1[k];
			}
			x_pos += x_add_2[k];
			y_pos += y_add_2[k];
			z_pos += z_add_2[k];
		}
	}	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptySimpleAxisSphere(ztDrawList *draw_list, const ztVec3 &pos, r32 radius, int points, const ztVec4 &color_x, const ztVec4 &color_y, const ztVec4 &color_z)
{
	r32 theta = ztMathPi2 / points;

	const ztVec4 *colors[3] = { &color_x, &color_y, &color_z };

	zt_fkz(3) {
		r32 start_x = (zt_cos(0) * radius);
		r32 start_y = (zt_sin(0) * radius);
		r32 prev_x = start_x;
		r32 prev_y = start_y;

		zt_drawListPushColor(draw_list, *colors[k]);
		for (int i = 1; i <= points; ++i) {
			r32 x = i != points ? (zt_cos(i * theta) * radius) : start_x;
			r32 y = i != points ? (zt_sin(i * theta) * radius) : start_y;

			switch (k)
			{
				case 0: zt_drawListAddLine(draw_list, zt_vec3(pos.x, pos.y + prev_x, pos.z + prev_y), zt_vec3(pos.x, pos.y + x, pos.z + y)); break;
				case 1: zt_drawListAddLine(draw_list, zt_vec3(pos.x + prev_x, pos.y, pos.z + prev_y), zt_vec3(pos.x + x, pos.y, pos.z + y)); break;
				case 2: zt_drawListAddLine(draw_list, zt_vec3(pos.x + prev_x, pos.y + prev_y, pos.z), zt_vec3(pos.x + x, pos.y + y, pos.z)); break;
			}

			prev_x = x;
			prev_y = y;
		}
		zt_drawListPopColor(draw_list);
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddEmptyBone(ztDrawList *draw_list, const ztVec3 &start, r32 size, r32 radius, r32 top)
{
	zt_drawListAddEmptySimpleSphere(draw_list, start, radius * .25f, 10);
	zt_drawListAddEmptySimpleSphere(draw_list, start + zt_vec3(0, size, 0), radius * .125f, 10);

	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z + radius), zt_vec3(start.x + radius, start.y + top, start.z - radius));
	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z - radius), zt_vec3(start.x - radius, start.y + top, start.z - radius));
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z - radius), zt_vec3(start.x - radius, start.y + top, start.z + radius));
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z + radius), zt_vec3(start.x + radius, start.y + top, start.z + radius));

	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z + radius), start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z - radius), start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z - radius), start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z + radius), start);

	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z + radius), zt_vec3(0, size, 0) + start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x + radius, start.y + top, start.z - radius), zt_vec3(0, size, 0) + start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z - radius), zt_vec3(0, size, 0) + start);
	zt_drawListAddLine(draw_list, zt_vec3(start.x - radius, start.y + top, start.z + radius), zt_vec3(0, size, 0) + start);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledTriangle(ztDrawList *draw_list, const ztVec3 p[3], const ztVec2 uvs[3], const ztVec3 normals[3])
{
	ztVec4 colors[3] = { ztColor_White, ztColor_White, ztColor_White };
	return zt_drawListAddFilledTriangle(draw_list, p, uvs, normals, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledTriangle(ztDrawList *draw_list, const ztVec3 p[3], const ztVec2 uvs[3], const ztVec3 normals[3], const ztVec4 colors[3])
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledTriangle");
	_zt_drawListCheck(draw_list);
	_zt_drawListVerifyTexture(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_Triangle;

	zt_fiz(3) command->tri_pos[i] = p[i];
	zt_fiz(3) command->tri_uv[i] = uvs[i];
	zt_fiz(3) command->tri_norm[i] = normals[i];
	zt_fiz(3) command->tri_color[i] = colors[i];

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4, const ztVec2 &uv1, const ztVec2 &uv2, const ztVec2 &uv3, const ztVec2 &uv4, const ztVec3 &n1, const ztVec3 &n2, const ztVec3 &n3, const ztVec3 &n4)
{
	return zt_drawListAddFilledQuad(draw_list, p1, p2, p3, p4, uv1, uv2, uv3, uv4, n1, n2, n3, n4, ztColor_White, ztColor_White, ztColor_White, ztColor_White);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &p4, const ztVec2 &uv1, const ztVec2 &uv2, const ztVec2 &uv3, const ztVec2 &uv4, const ztVec3 &n1, const ztVec3 &n2, const ztVec3 &n3, const ztVec3 &n4, const ztVec4 &c1, const ztVec4 &c2, const ztVec4 &c3, const ztVec4 &c4)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledQuad");
	_zt_drawListVerifyTexture(draw_list);

	{
		_zt_drawListCheck(draw_list);
		auto *command = &draw_list->commands[draw_list->commands_count++];

		command->type = ztDrawCommandType_Triangle;

		command->tri_pos[0] = p1;
		command->tri_pos[1] = p2;
		command->tri_pos[2] = p3;

		command->tri_uv[0] = uv1;
		command->tri_uv[1] = uv2;
		command->tri_uv[2] = uv3;

		command->tri_norm[0] = n1;
		command->tri_norm[1] = n2;
		command->tri_norm[2] = n3;

		command->tri_color[0] = c1;
		command->tri_color[1] = c2;
		command->tri_color[2] = c3;
	}
	{
		_zt_drawListCheck(draw_list);
		auto *command = &draw_list->commands[draw_list->commands_count++];

		command->type = ztDrawCommandType_Triangle;

		command->tri_pos[0] = p1;
		command->tri_pos[1] = p3;
		command->tri_pos[2] = p4;

		command->tri_uv[0] = uv1;
		command->tri_uv[1] = uv3;
		command->tri_uv[2] = uv4;

		command->tri_norm[0] = n1;
		command->tri_norm[1] = n3;
		command->tri_norm[2] = n4;

		command->tri_color[0] = c1;
		command->tri_color[1] = c3;
		command->tri_color[2] = c4;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 p[4], const ztVec2 uvs[4], const ztVec3 normals[4])
{
	ztVec4 colors[] = { ztColor_White, ztColor_White, ztColor_White, ztColor_White };
	return zt_drawListAddFilledQuad(draw_list, p, uvs, normals, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledQuad(ztDrawList *draw_list, const ztVec3 p[4], const ztVec2 uvs[4], const ztVec3 normals[4], const ztVec4 colors[4])
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledQuad");
	_zt_drawListVerifyTexture(draw_list);

	zt_fjz(2) {
		_zt_drawListCheck(draw_list);
		auto *command = & draw_list->commands[draw_list->commands_count++];

		command->type = ztDrawCommandType_Triangle;

		command->tri_pos[0] = p[0];
		command->tri_pos[1] = p[1 + j];
		command->tri_pos[2] = p[2 + j];

		command->tri_uv[0] = uvs[0];
		command->tri_uv[1] = uvs[1 + j];
		command->tri_uv[2] = uvs[2 + j];

		command->tri_norm[0] = normals[0];
		command->tri_norm[1] = normals[1 + j];
		command->tri_norm[2] = normals[2 + j];

		command->tri_color[0] = colors[0];
		command->tri_color[1] = colors[1 + j];
		command->tri_color[2] = colors[2 + j];
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec2 &p, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se)
{
	return zt_drawListAddFilledRect2D(draw_list, zt_vec3(p.x, p.y, 0), size, uv_nw, uv_se);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec2 &p, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, const ztVec4 colors[4])
{
	return zt_drawListAddFilledRect2D(draw_list, zt_vec3(p.x, p.y, 0), size, uv_nw, uv_se, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec3 &p, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se)
{
	ztVec4 colors[] = { ztColor_White, ztColor_White, ztColor_White, ztColor_White };
	return zt_drawListAddFilledRect2D(draw_list, p, size, uv_nw, uv_se, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledRect2D(ztDrawList *draw_list, const ztVec3 &p, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, const ztVec4 colors[4])
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledRect2D");
	r32 half_w = size.x / 2.f;
	r32 half_h = size.y / 2.f;

	return zt_drawListAddFilledQuad(draw_list, 
		zt_vec3(p.x - half_w, p.y + half_h, p.z),
		zt_vec3(p.x - half_w, p.y - half_h, p.z),
		zt_vec3(p.x + half_w, p.y - half_h, p.z),
		zt_vec3(p.x + half_w, p.y + half_h, p.z),
										
		zt_vec2(uv_nw.x, uv_nw.y),
		zt_vec2(uv_nw.x, uv_se.y),
		zt_vec2(uv_se.x, uv_se.y),
		zt_vec2(uv_se.x, uv_nw.y),
		
		ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero,
		
		colors[0], colors[1], colors[2], colors[3]
		);
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledCubeFromCenterSize(ztDrawList *draw_list, const ztVec3 &pos, const ztVec3 &size)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledCubeFromCenterSize");
	r32 half_x = size.x / 2.f;
	r32 half_y = size.y / 2.f;
	r32 half_z = size.z / 2.f;

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z),
										zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0)); // top face

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z),
										zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, -1, 0), zt_vec3(0, -1, 0), zt_vec3(0, -1, 0), zt_vec3(0, -1, 0)); // bottom face

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z),
										zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0)); // front face

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0)); // back face

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z),
										zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z),
										zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0)); // left face

	zt_drawListAddFilledQuad(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z),
										zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z),
										zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z),
										zt_vec2(0, 0), zt_vec2(0, 1), zt_vec2(1, 1), zt_vec2(1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0)); // right face


	zt_drawListAddLine(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z + half_z), zt_vec3(pos.x - half_x, pos.y - half_y, pos.z + half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x - half_x, pos.y + half_y, pos.z - half_z), zt_vec3(pos.x - half_x, pos.y - half_y, pos.z - half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z - half_z), zt_vec3(pos.x + half_x, pos.y - half_y, pos.z - half_z));
	zt_drawListAddLine(draw_list, zt_vec3(pos.x + half_x, pos.y + half_y, pos.z + half_z), zt_vec3(pos.x + half_x, pos.y - half_y, pos.z + half_z));

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledCubeFromMinMax(ztDrawList *draw_list, const ztVec3 &min, const ztVec3 &max)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledCubeFromMinMax");
	ztVec3 size = zt_vec3((max.x - min.x), (max.y - min.y), (max.z - min.z));
	ztVec3 pos  = min + (size * .5f);
	return zt_drawListAddFilledCubeFromCenterSize(draw_list, pos, size);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor& color)
{
	return zt_drawListAddSolidRect2D(draw_list, zt_vec3(pos_ctr, 0), size, color);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor colors[4])
{
	return zt_drawListAddSolidRect2D(draw_list, zt_vec3(pos_ctr, 0), size, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor& color)
{
	ztColor colors[] = { color, color, color, color };
	return zt_drawListAddSolidRect2D(draw_list, pos_ctr, size, colors);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor colors[4])
{
	ZT_PROFILE_RENDERING("zt_drawListAddSolidRect2D");
	zt_drawListPushTexture(draw_list, 0);
	zt_drawListAddFilledRect2D(draw_list, pos_ctr, size, ztVec2::zero, ztVec2::one, colors);
	zt_drawListPopTexture(draw_list);
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidCircle2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, r32 radius, int points, const ztColor& color, ztQuat *apply_rotation)
{
	return zt_drawListAddSolidCircle2D(draw_list, zt_vec3(pos_ctr, 0), radius, points, color, apply_rotation);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidCircle2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, r32 radius, int points, const ztColor& color, ztQuat *apply_rotation)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSolidCircle2D");

	zt_drawListPushTexture(draw_list, 0);
	zt_drawListPushColor(draw_list, color);

	ztVec3 p[512], n[512];
	ztVec2 u[512];
	points = zt_max(3, zt_min(points, zt_elementsOf(p) - 1));

	r32 theta = ztMathPi2 / points;

	for (int i = 0; i < points; ++i) {
		r32 x = (zt_cos(i * theta) * radius);
		r32 y = (zt_sin(i * theta) * radius);

		p[i] = zt_vec3(x, y, 0);
		u[i] = ztVec2::zero;
		n[i] = zt_vec3(0, 0, 1);
	}

	if (apply_rotation) {
		zt_fiz(points) {
			apply_rotation->rotatePosition(&p[i]);
		}
	}

	zt_fiz(points) {
		p[i] += pos_ctr;
	}

	zt_drawListAddFilledPoly(draw_list, p, u, n, points);
	zt_drawListPopColor(draw_list);
	zt_drawListPopTexture(draw_list);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidOutlinedRect2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, const ztVec2 &size, const ztColor& color, const ztColor& outline_color)
{
	return zt_drawListAddSolidOutlinedRect2D(draw_list, zt_vec3(pos_ctr, 0), size, color, outline_color);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidOutlinedRect2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztColor& color, const ztColor& outline_color)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSolidOutlinedRect2D");
	zt_drawListAddSolidRect2D(draw_list, pos_ctr, size, color);

	zt_drawListPushColor(draw_list, outline_color);
	zt_drawListAddEmptyRect(draw_list, pos_ctr, size);
	zt_drawListPopColor(draw_list);
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidOutlinedCircle2D(ztDrawList *draw_list, const ztVec2 &pos_ctr, r32 radius, int points, const ztColor& color, const ztColor& outline_color)
{
	return zt_drawListAddSolidOutlinedCircle2D(draw_list, zt_vec3(pos_ctr, 0), radius, points, color, outline_color);
}

// ================================================================================================================================================================================================

bool zt_drawListAddSolidOutlinedCircle2D(ztDrawList *draw_list, const ztVec3 &pos_ctr, r32 radius, int points, const ztColor& color, const ztColor& outline_color)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSolidOutlinedCircle2D");
	zt_drawListAddSolidCircle2D(draw_list, pos_ctr, radius, points, color);

	zt_drawListPushColor(draw_list, outline_color);
	zt_drawListAddEmptyCircle(draw_list, pos_ctr, radius, points);
	zt_drawListPopColor(draw_list);
	return false;
}

// ================================================================================================================================================================================================

bool zt_drawListAddBillboard(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, const ztVec2 &uv_nw, const ztVec2 &uv_se, i32 flags, ztVec3 up)
{
	return zt_drawListAddBillboard(draw_list, pos_ctr, size, 0, uv_nw, uv_se, flags, up);
}

// ================================================================================================================================================================================================

bool zt_drawListAddBillboard(ztDrawList *draw_list, const ztVec3 &pos_ctr, const ztVec2 &size, r32 rotation, const ztVec2 &uv_nw, const ztVec2 &uv_se, i32 flags, ztVec3 up)
{
	ZT_PROFILE_RENDERING("zt_drawListAddBillboard");
	_zt_drawListCheck(draw_list);
	_zt_drawListVerifyTexture(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_Billboard;

	command->billboard_center = pos_ctr;
	command->billboard_size = size;
	command->billboard_uv = zt_vec4(uv_nw, uv_se);
	command->billboard_flags = flags;
	command->billboard_rotation = rotation;
	command->billboard_up = up;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledPoly(ztDrawList *draw_list, const ztVec3 *p, const ztVec2 *uvs, const ztVec3 *normals, int count)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledPoly");
	_zt_drawListVerifyTexture(draw_list);

	zt_fjz(count - 2) {
		_zt_drawListCheck(draw_list);
		auto *command = &draw_list->commands[draw_list->commands_count++];

		command->type = ztDrawCommandType_Triangle;

		command->tri_pos[0] = p[0];
		command->tri_pos[1] = p[1 + j];
		command->tri_pos[2] = p[2 + j];

		command->tri_uv[0] = uvs[0];
		command->tri_uv[1] = uvs[1 + j];
		command->tri_uv[2] = uvs[2 + j];

		command->tri_norm[0] = normals[0];
		command->tri_norm[1] = normals[1 + j];
		command->tri_norm[2] = normals[2 + j];

		command->tri_color[0] = ztColor_White;
		command->tri_color[1] = ztColor_White;
		command->tri_color[2] = ztColor_White;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFilledPoly(ztDrawList *draw_list, const ztVec3 *p, const ztVec2 *uvs, const ztVec3 *normals, ztVec4 *colors, int count)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFilledPoly");
	_zt_drawListVerifyTexture(draw_list);

	zt_fjz(count - 2) {
		_zt_drawListCheck(draw_list);
		auto *command = &draw_list->commands[draw_list->commands_count++];

		command->type = ztDrawCommandType_Triangle;

		command->tri_pos[0] = p[0];
		command->tri_pos[1] = p[1 + j];
		command->tri_pos[2] = p[2 + j];

		command->tri_uv[0] = uvs[0];
		command->tri_uv[1] = uvs[1 + j];
		command->tri_uv[2] = uvs[2 + j];

		command->tri_norm[0] = normals[0];
		command->tri_norm[1] = normals[1 + j];
		command->tri_norm[2] = normals[2 + j];

		command->tri_color[0] = colors[0];
		command->tri_color[1] = colors[1 + j];
		command->tri_color[2] = colors[2 + j];
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddDrawList(ztDrawList *draw_list, ztDrawList *draw_list_to_add, const ztVec3 &offset)
{
	ZT_PROFILE_RENDERING("zt_drawListAddDrawList");
	if (draw_list->commands_size - draw_list->commands_count >= draw_list_to_add->commands_count) {
		i32 size = zt_sizeof(ztDrawCommand) * draw_list_to_add->commands_count;
		zt_memCpy(&draw_list->commands[draw_list->commands_count], size, draw_list_to_add->commands, size);
		//memcpy(&draw_list->commands[draw_list->commands_count], draw_list_to_add->commands, size);
		draw_list->commands_count += draw_list_to_add->commands_count;

		if (offset != ztVec3::zero) {
			int start = draw_list->commands_count - draw_list_to_add->commands_count;
			for (int i = start; i < start + draw_list_to_add->commands_count; ++i) {
				ztDrawCommand *command = &draw_list->commands[i];
				switch (command->type)
				{
					case ztDrawCommandType_Point: {
						command->point.x += offset.x;
						command->point.y += offset.y;
						command->point.z += offset.z;
					} break;

					case ztDrawCommandType_Line: {
						zt_fiz(2) zt_fjz(3) command->line[i].values[j] += offset.values[j];
					} break;

					case ztDrawCommandType_Triangle: {
						zt_fiz(3) zt_fjz(3) command->tri_pos[i].values[j] += offset.values[j];
					} break;

					case ztDrawCommandType_ChangeClipping: {
						zt_fjz(2) command->clip_center.values[j] += offset.values[j];
					} break;

					case ztDrawCommandType_Billboard: {
						zt_fjz(3) command->billboard_center.values[j] += offset.values[j];
					} break;
				}
			}
		}
		return true;
	}
	else {
		zt_assert(false);
		return false;
	}
}

// ================================================================================================================================================================================================

bool zt_drawListAddFrustum(ztDrawList *draw_list, ztFrustum *frustum)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFrustum");

	if (!zt_drawListAddLine(draw_list, frustum->near_nw, frustum->near_se)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_ne, frustum->near_sw)) return false;
	if (!zt_drawListAddLine(draw_list, (frustum->near_ne + frustum->near_sw) * .5f, (frustum->near_nw + frustum->near_ne) * .5f)) return false;

	if (!zt_drawListAddLine(draw_list, frustum->near_nw, frustum->near_ne)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_ne, frustum->near_se)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_se, frustum->near_sw)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_sw, frustum->near_nw)) return false;

	if (!zt_drawListAddLine(draw_list, frustum->far_nw, frustum->far_ne)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->far_ne, frustum->far_se)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->far_se, frustum->far_sw)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->far_sw, frustum->far_nw)) return false;

	if (!zt_drawListAddLine(draw_list, frustum->near_nw, frustum->far_nw)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_ne, frustum->far_ne)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_se, frustum->far_se)) return false;
	if (!zt_drawListAddLine(draw_list, frustum->near_sw, frustum->far_sw)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddFloorGrid(ztDrawList *draw_list, const ztVec3 &center, r32 width, r32 depth, r32 grid_w, r32 grid_d)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFloorGrid");

	r32 width_units = width * grid_w;
	r32 depth_units = depth * grid_d;

	const r32 adjust = .00001f; // make sure we get that last line in the grid

	r32 max_x = center.x + width_units / 2.f + adjust;
	r32 max_z = center.z + depth_units / 2.f + adjust;

	r32 x = center.x - width_units / 2.f;
	r32 z = center.z - depth_units / 2.f;

	while (z <= max_z) {
		if (!zt_drawListAddLine(draw_list, zt_vec3(x, center.y, z), zt_vec3(x + width_units, center.y, z))) {
			return false;
		}
		z += grid_d;
	}

	x = center.x - width_units / 2.f;
	z = center.z - depth_units / 2.f;

	while (x <= max_x) {
		if (!zt_drawListAddLine(draw_list, zt_vec3(x, center.y, z), zt_vec3(x, center.y, z + depth_units))) {
			return false;
		}
		x += grid_w;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddVertexArray(ztDrawList *draw_list, ztVertexArrayID vertex_array_id, ztVertexArrayDrawType_Enum draw_type)
{
	ZT_PROFILE_RENDERING("zt_drawListAddVertexArray");
	_zt_drawListCheck(draw_list);
	zt_assert(vertex_array_id != ztInvalidID);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_VertexArray;
	command->vertex_array = vertex_array_id;
	command->vertex_array_draw_type = draw_type;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddAxis(ztDrawList *draw_list, r32 size, const ztVec3 &center, const ztVec4 &color_x, const ztVec4 &color_y, const ztVec4 &color_z)
{
	ZT_PROFILE_RENDERING("zt_drawListAddAxis");
	zt_drawListPushColor(draw_list, color_x);
	zt_drawListAddLine(draw_list, center, center + zt_vec3(size, 0, 0));
	zt_drawListPopColor(draw_list);

	zt_drawListPushColor(draw_list, color_y);
	zt_drawListAddLine(draw_list, center, center + zt_vec3(0, size, 0));
	zt_drawListPopColor(draw_list);

	zt_drawListPushColor(draw_list, color_z);
	zt_drawListAddLine(draw_list, center, center + zt_vec3(0, 0, size));
	zt_drawListPopColor(draw_list);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddAxis(ztDrawList *draw_list, const ztMat4& mat, r32 size, const ztVec3 &center, const ztVec4 &color_x, const ztVec4 &color_y, const ztVec4 &color_z)
{
	ZT_PROFILE_RENDERING("zt_drawListAddAxis");
	ztVec3 t_center = mat * center;

	zt_drawListPushColor(draw_list, color_x);
	zt_drawListAddLine(draw_list, t_center, mat * (center + zt_vec3(size, 0, 0)));
	zt_drawListPopColor(draw_list);

	zt_drawListPushColor(draw_list, color_y);
	zt_drawListAddLine(draw_list, t_center, mat * (center + zt_vec3(0, size, 0)));
	zt_drawListPopColor(draw_list);

	zt_drawListPushColor(draw_list, color_z);
	zt_drawListAddLine(draw_list, t_center, mat * (center + zt_vec3(0, 0, size)));
	zt_drawListPopColor(draw_list);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddPointMarker(ztDrawList *draw_list, const ztVec3 &pos, r32 size, bool color_axis)
{
	ZT_PROFILE_RENDERING("zt_drawListAddPointMarker");
	if (color_axis) {
		zt_drawListPushColor(draw_list, ztColor_Red  ); zt_drawListAddLine(draw_list, pos - zt_vec3(size / 2.f, 0, 0), pos + zt_vec3(size / 2.f, 0, 0)); zt_drawListPopColor(draw_list);
		zt_drawListPushColor(draw_list, ztColor_Green); zt_drawListAddLine(draw_list, pos - zt_vec3(0, size / 2.f, 0), pos + zt_vec3(0, size / 2.f, 0)); zt_drawListPopColor(draw_list);
		zt_drawListPushColor(draw_list, ztColor_Blue ); zt_drawListAddLine(draw_list, pos - zt_vec3(0, 0, size / 2.f), pos + zt_vec3(0, 0, size / 2.f)); zt_drawListPopColor(draw_list);
	}
	else {
		zt_drawListAddLine(draw_list, pos - zt_vec3(size / 2.f, 0, 0), pos + zt_vec3(size / 2.f, 0, 0));
		zt_drawListAddLine(draw_list, pos - zt_vec3(0, size / 2.f, 0), pos + zt_vec3(0, size / 2.f, 0));
		zt_drawListAddLine(draw_list, pos - zt_vec3(0, 0, size / 2.f), pos + zt_vec3(0, 0, size / 2.f));
	}
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddScreenRenderTexture(ztDrawList *draw_list, ztTextureID tex, ztCamera *camera, r32 scale, ztShaderID shader)
{
	zt_drawListPushShader(draw_list, shader == ztInvalidID ? zt_shaderGetDefault(ztShaderDefault_Unlit) : shader);
	zt_drawListPushTexture(draw_list, tex);

	r32 tex_aspect_ratio = zt_game->textures[tex].height / (r32)zt_game->textures[tex].width;

	ztVec2 cam_ext = zt_cameraOrthoGetViewportSize(camera);
	if (scale != 1) {
		cam_ext *= scale;
	}

	r32 cam_aspect_ratio = cam_ext.y / cam_ext.x;

	if (!zt_real32Eq(cam_aspect_ratio, tex_aspect_ratio)) {
		if (cam_aspect_ratio > tex_aspect_ratio) {
			cam_ext.y = cam_ext.x * tex_aspect_ratio;
		}
		else {
			cam_ext.x = cam_ext.y * ((r32)zt_game->textures[tex].width / (r32)zt_game->textures[tex].height);
		}
	}

	zt_drawListPushBlendMode(draw_list, ztRendererBlendMode_One, ztRendererBlendMode_Zero);
	if (zt_rendererUvsFlipYRenderTarget()) {
		zt_drawListAddFilledRect2D(draw_list, ztVec3::zero, cam_ext, zt_vec2(0, 1), zt_vec2(1, 0));
	}
	else {
		zt_drawListAddFilledRect2D(draw_list, ztVec3::zero, cam_ext, ztVec2::zero, ztVec2::one);
	}
	zt_drawListPopBlendMode(draw_list);
	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPushShader(ztDrawList *draw_list, ztShaderID shader)
{
	ZT_PROFILE_RENDERING("zt_drawListPushShader");
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_ChangeShader;
	command->shader = shader;

	zt_debugOnly(draw_list->active_shaders++);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopShader(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopShader");
	int pops = 1;
	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeShader) {
			if (draw_list->commands[i].shader_pop) {
				pops += 1;
			}
			else if (pops-- == 0) {
				auto *command = &draw_list->commands[draw_list->commands_count++];
				command->type = ztDrawCommandType_ChangeShader;
				command->shader = draw_list->commands[i].shader;
				command->shader_pop = true;
				return true;
			}
		}
	}

	return false;
}

// ================================================================================================================================================================================================

ztShaderID zt_drawListGetCurrentShader(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListGetCurrentShader");
	_zt_drawListVerifyShader(draw_list);

	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeShader) {
			return draw_list->commands[i].shader;
		}
	}

	return ztInvalidID;
}

// ================================================================================================================================================================================================

bool zt_drawListPushColor(ztDrawList *draw_list, const ztColor& color)
{
	ZT_PROFILE_RENDERING("zt_drawListPushColor");
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_ChangeColor;
	command->color = color;
	command->color_pop = false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopColor(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopColor");
	_zt_drawListCheck(draw_list);

#if 1
	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type = ztDrawCommandType_ChangeColor;
	command->color_pop = true;
#else
	int pops = 1;
	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeColor) {
			if (draw_list->commands[i].color_pop) {
				pops += 1;
			}
			else if (pops-- == 0) {
				auto *command = &draw_list->commands[draw_list->commands_count++];
				command->type = ztDrawCommandType_ChangeColor;
				command->color = draw_list->commands[i].color;
				command->color_pop = true;
				return true;
			}
		}
	}

	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type = ztDrawCommandType_ChangeColor;
	command->color = zt_color(1,1,1,1);
	command->color_pop = true;
#endif
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPushTexture(ztDrawList *draw_list, ztTextureID tex_id)
{
	ZT_PROFILE_RENDERING("zt_drawListPushTexture");

	_zt_drawListCheck(draw_list);
	//_zt_drawListVerifyShader(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_ChangeTexture;
	command->texture[0] = tex_id;
	command->texture_count = 1;
	command->texture_pop = false;

	//zt_assert(zt_game->textures[tex_id].renderer != ztRenderer_Invalid);

	zt_debugOnly(draw_list->active_textures++);

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPushTexture(ztDrawList *draw_list, ztTextureID *tex_ids, int tex_count)
{
	ZT_PROFILE_RENDERING("zt_drawListPushTexture");
	_zt_drawListCheck(draw_list);
	//_zt_drawListVerifyShader(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];
	command->type = ztDrawCommandType_ChangeTexture;

	if (tex_count > zt_elementsOf(command->texture)) {
		zt_assert(false && "Too many textures for a single draw list command");
		tex_count = zt_elementsOf(command->texture);
	}
	zt_fiz(tex_count) {
		command->texture[i] = tex_ids[i];
	}
	command->texture_count = tex_count;
	command->texture_pop = false;

	zt_debugOnly(draw_list->active_textures++);
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopTexture(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopTexture");
#	if 1
	_zt_drawListCheck(draw_list);
	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type = ztDrawCommandType_ChangeTexture;
	command->texture_pop = true;
#	else
	int pops = 1;
	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeTexture) {
			if (draw_list->commands[i].texture_pop) {
				pops += 1;
			}
			else if (pops-- == 0) {
				auto *command = &draw_list->commands[draw_list->commands_count++];
				command->type = ztDrawCommandType_ChangeTexture;
				zt_fjz(draw_list->commands[i].texture_count) command->texture[j] = draw_list->commands[i].texture[j];
				command->texture_count = draw_list->commands[i].texture_count;
				command->texture_pop = true;

				zt_debugOnly(draw_list->active_textures--);
				return true;
			}
		}
	}

	// if we're here, we need to set an empty texture command
	_zt_drawListCheck(draw_list);

	auto *command = & draw_list->commands[draw_list->commands_count++];

	command->type          = ztDrawCommandType_ChangeTexture;
	command->texture[0]    = 0;
	command->texture_count = 1;
	command->texture_pop   = false;
#	endif

	zt_debugOnly(draw_list->active_textures--);

	return false;
}

// ================================================================================================================================================================================================

bool zt_drawListPushClipRegion(ztDrawList *draw_list, ztVec2 center, ztVec2 size)
{
	ZT_PROFILE_RENDERING("zt_drawListPushClipRegion");
	_zt_drawListCheck(draw_list);
	zt_assert(size != ztVec2::zero);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	if (draw_list->current_clip) {
		// clip the given rect to the current clip area

		ztVec2 curr_ext_min = zt_vec2(draw_list->current_clip->clip_center.x - draw_list->current_clip->clip_size.x / 2, draw_list->current_clip->clip_center.y - draw_list->current_clip->clip_size.y / 2);
		ztVec2 curr_ext_max = zt_vec2(draw_list->current_clip->clip_center.x + draw_list->current_clip->clip_size.x / 2, draw_list->current_clip->clip_center.y + draw_list->current_clip->clip_size.y / 2);

		r32 left = zt_max(curr_ext_min.x, center.x + size.x / -2);
		r32 right = zt_min(curr_ext_max.x, center.x + size.x / 2);
		r32 bottom = zt_max(curr_ext_min.y, center.y + size.y / -2);
		r32 top = zt_min(curr_ext_max.y, center.y + size.y / 2);

		size.x = right - left;
		size.y = top - bottom;

		center.x = left + size.x / 2;
		center.y = bottom + size.y / 2;

		if(size.x <= 0 || size.y <= 0) {
			center = draw_list->current_clip->clip_center;
			size = draw_list->current_clip->clip_size;
		}
	}

	command->type = ztDrawCommandType_ChangeClipping;
	command->clip_center = center;
	command->clip_size = size;
	command->clip_idx = 0;
	command->clip_prev = draw_list->current_clip;
	command->clip_pop = false;

	zt_assert(command->clip_size.x > 0 && command->clip_size.y > 0);

	draw_list->current_clip = command;

	r32 ppu = zt_pixelsPerUnit();

	zt_alignToPixel(&command->clip_size, ppu);
	//zt_alignToPixel(&command->clip_center, ppu);

	//command->clip_size.x += 2 / ppu;
	//command->clip_size.y += 2 / ppu;
	//command->clip_center.x -= 1 / ppu;


	//if (command->clip_center.y - command->clip_size.y / 2.f < 0) {
	//	command->clip_center.y -= 1 / ppu;
	//}
	//else{
	//	command->clip_center.y += 1 / ppu;
	//}

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopClipRegion(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopClipRegion");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_ChangeClipping;
	command->clip_center = ztVec2::zero;
	command->clip_size = ztVec2::zero;
	command->clip_idx = 0;
	command->clip_prev = nullptr;
	command->clip_pop = true;

	zt_assertReturnValOnFail(draw_list->current_clip != nullptr, false);
	if (draw_list->current_clip->clip_prev != nullptr) {
		command->clip_center = draw_list->current_clip->clip_prev->clip_center;
		command->clip_size = draw_list->current_clip->clip_prev->clip_size;
	}
	draw_list->current_clip = draw_list->current_clip->clip_prev;

#	if 0
	zt_fizr(draw_list->commands_count - 2) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeClipping) {
			zt_drawListPushColor(draw_list, ztColor_Green);
			zt_drawListAddEmptyRect(draw_list, draw_list->commands[i].clip_center, draw_list->commands[i].clip_size);
			zt_drawListPopColor(draw_list);
			break;
		}
	}
#	endif

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPushOffset(ztDrawList *draw_list, const ztVec3 &offset)
{
	ZT_PROFILE_RENDERING("zt_drawListPushOffset");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type       = ztDrawCommandType_ChangeOffset;
	command->offset     = offset;
	command->offset_pop = false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopOffset(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopOffset");

#	if 1
	_zt_drawListCheck(draw_list);
	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type       = ztDrawCommandType_ChangeOffset;
	command->offset_pop = true;
#	else
	int pops = 1;
	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeOffset) {
			if (draw_list->commands[i].offset_pop) {
				pops += 1;
			}
			else if (pops-- == 0) {
				auto *command = &draw_list->commands[draw_list->commands_count++];
				command->type       = ztDrawCommandType_ChangeOffset;
				command->offset     = draw_list->commands[i].offset;
				command->offset_pop = true;
				return true;
			}
		}
	}

	// if we're here, we need to set an empty offset command
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type       = ztDrawCommandType_ChangeOffset;
	command->offset     = ztVec3::zero;
	command->offset_pop = true;
#	endif
	return false;
}

// ================================================================================================================================================================================================

bool zt_drawListPushTransform(ztDrawList *draw_list, const ztMat4& transform)
{
	ZT_PROFILE_RENDERING("zt_drawListPushTransform");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type          = ztDrawCommandType_ChangeTransform;
	command->transform     = transform;
	command->transform_pop = false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopTransform(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopTransform");

#	if 1
	_zt_drawListCheck(draw_list);
	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type          = ztDrawCommandType_ChangeTransform;
	command->transform_pop = true;
#	else
	int pops = 1;
	zt_fizr(draw_list->commands_count - 1) {
		if (draw_list->commands[i].type == ztDrawCommandType_ChangeTransform) {
			if (draw_list->commands[i].transform_pop) {
				pops += 1;
			}
			else if (pops-- == 0) {
				auto *command = &draw_list->commands[draw_list->commands_count++];
				command->type          = ztDrawCommandType_ChangeTransform;
				command->transform     = draw_list->commands[i].transform;
				command->transform_pop = true;
				return true;
			}
		}
	}

	// if we're here, we need to set an empty offset command
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type          = ztDrawCommandType_ChangeTransform;
	command->transform     = ztMat4::identity;
	command->transform_pop = true;
#	endif
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPushBlendMode(ztDrawList *draw_list, ztRendererBlendMode_Enum src, ztRendererBlendMode_Enum dest)
{
	ZT_PROFILE_RENDERING("zt_drawListPushBlendMode");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_ChangeBlendMode;
	command->blend_src = src;
	command->blend_dest = dest;
	command->blend_pop = false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListPopBlendMode(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListPopBlendMode");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];
	command->type = ztDrawCommandType_ChangeBlendMode;
	command->blend_pop = true;
	return true;
}

// ================================================================================================================================================================================================

bool zt_drawListAddDebugItem(ztDrawList *draw_list, const char *debug)
{
	ZT_PROFILE_RENDERING("zt_drawListAddDebugItem");
	_zt_drawListCheck(draw_list);

	auto *command = &draw_list->commands[draw_list->commands_count++];

	command->type = ztDrawCommandType_DebugItem;
	zt_strCpy(command->debug, zt_elementsOf(command->debug), debug);

	return true;
}

// ================================================================================================================================================================================================

void zt_drawListReset(ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_drawListReset");
	draw_list->commands_count = 0;
	zt_debugOnly(draw_list->active_shaders = draw_list->active_textures = 0);
}

// ================================================================================================================================================================================================

#undef 	_zt_drawListCheck

// ================================================================================================================================================================================================

void zt_renderDrawList(ztCamera *camera, ztDrawList *draw_list, const ztColor& clear, i32 flags, ztTextureID render_target_id)
{
	zt_returnOnNull(draw_list);

	ztDrawList *draw_lists_arr[1] = {draw_list};
	zt_renderDrawLists(camera, draw_lists_arr, 1, clear, flags, render_target_id);
}

// ================================================================================================================================================================================================

#define ztRenderDrawListVertexArraySize	3 * 1024 * 64
#define ztRenderDrawListVertexByteSize (ztRenderDrawListVertexArraySize * 48)

// ================================================================================================================================================================================================

ztInternal void _zt_rendererCheckToResetStats()
{	
	if (zt_game->last_drawn_frame != zt_game->game_details.current_frame) {
		zt_game->game_details.prev_frame = zt_game->game_details.curr_frame;
		zt_game->game_details.curr_frame.shader_switches = zt_game->game_details.curr_frame.texture_switches = zt_game->game_details.curr_frame.triangles_drawn = zt_game->game_details.curr_frame.draw_calls = 0;
		zt_game->last_drawn_frame = zt_game->game_details.current_frame;
	}
}

// ================================================================================================================================================================================================

void zt_renderDrawLists(ztCamera *camera, ztDrawList **draw_lists, int draw_lists_count, const ztColor& clear, i32 flags, ztTextureID render_target_id)
{
	ZT_PROFILE_RENDERING("zt_renderDrawLists");
	_zt_rendererCheckToResetStats();

	zt_returnOnNull(camera);
	zt_returnOnNull(draw_lists);

	if (draw_lists_count == 0) {
		return;
	}

	if (!zt_bitIsSet(flags, ztRenderDrawListFlags_NoClear) && render_target_id == ztInvalidID) {
		zt_rendererClear(clear);
	}

	byte *mem = zt_game->renderer_memory;
	i32 mem_left = zt_game->renderer_memory_size;

	struct ztCompileClipRegion
	{
		ztDrawCommand *command;
	};

	struct ztCompileItem
	{
		ztDrawCommand *command;
		ztCompileItem *next;

		ztCompileClipRegion *clip_region;
	};

	struct ztCompileTexture
	{
		ztCompileItem *item;
		ztCompileItem *last_item;
		int cnt_display_items;

		ztDrawCommand *command;
		ztCompileTexture *next;
	};

	struct ztCompileShader
	{
		ztShaderID shader;
		ztCompileTexture *texture;
	};

	ztCompileShader *shaders[1024];
	i32 shaders_count = 0;

	int clip_regions_count = 0;
	zt_fiz(draw_lists_count) {
		ztDrawList *draw_list = draw_lists[i];
		zt_assert(draw_list);
		zt_fjz(draw_list->commands_count) {
			if (draw_list->commands[j].type == ztDrawCommandType_ChangeClipping && draw_list->commands[j].clip_pop == false) {
				clip_regions_count += 1;
			}
		}
	}

	ztCompileClipRegion* clip_regions = clip_regions_count == 0 ? nullptr : (ztCompileClipRegion*)mem;

	mem += zt_sizeof(ztCompileClipRegion) * clip_regions_count;
	mem_left -= zt_sizeof(ztCompileClipRegion) * clip_regions_count;
	zt_assert(mem_left >= 0);

	{
		int clip_stack[512];
		int clip_stack_idx = -1;

		clip_regions_count = 0;
		zt_fiz(draw_lists_count) {
			ztDrawList *draw_list = draw_lists[i];
			zt_assert(draw_list);
			zt_fjz(draw_list->commands_count) {
				if (draw_list->commands[j].type == ztDrawCommandType_ChangeClipping) {
					if (draw_list->commands[j].clip_pop != true) {
						clip_stack[++clip_stack_idx] = clip_regions_count;
						clip_regions[clip_regions_count].command = &draw_list->commands[j];
						clip_regions_count += 1;
					}
					else {
						clip_stack_idx--;
					}
					draw_list->commands[j].clip_idx = clip_stack_idx >= 0 ? clip_stack[clip_stack_idx] : -1;
				}
			}
		}

		zt_assert(clip_stack_idx == -1); // if you're here, you have mismatching push/pop clip regions
	}

	{
		// calculate various push/pop pairs
		ztDrawCommand *stack_textures   [512]; int stack_textures_idx    = -1;
		ztDrawCommand *stack_colors     [512]; int stack_colors_idx      = -1;
		ztDrawCommand *stack_offsets    [512]; int stack_offsets_idx     = -1;
		ztDrawCommand *stack_transforms [512]; int stack_transforms_idx  = -1;
		ztDrawCommand *stack_blend_modes[512]; int stack_blend_modes_idx = -1;

		zt_fiz(draw_lists_count) {
			ztDrawList *draw_list = draw_lists[i];
			zt_fjz(draw_list->commands_count) {
				if(draw_list->commands[j].type == ztDrawCommandType_ChangeTexture) {
					if(draw_list->commands[j].texture_pop) {
						if (--stack_textures_idx >= 0) {
							zt_memCpy(&draw_list->commands[j], zt_sizeof(ztDrawCommand), stack_textures[stack_textures_idx], zt_sizeof(ztDrawCommand));
						}
						else {
							draw_list->commands[j].texture_count = 0;
						}
					}
					else {
						stack_textures[++stack_textures_idx] = &draw_list->commands[j];
					}
				}
				if(draw_list->commands[j].type == ztDrawCommandType_ChangeColor) {
					if(draw_list->commands[j].color_pop) {
						if (--stack_colors_idx >= 0) {
							zt_memCpy(&draw_list->commands[j], zt_sizeof(ztDrawCommand), stack_colors[stack_colors_idx], zt_sizeof(ztDrawCommand));
						}
						else {
							draw_list->commands[j].color = ztColor_White;
						}
					}
					else {
						stack_colors[++stack_colors_idx] = &draw_list->commands[j];
					}
				}
				if(draw_list->commands[j].type == ztDrawCommandType_ChangeOffset) {
					if(draw_list->commands[j].offset_pop) {
						if (--stack_offsets_idx >= 0) {
							zt_memCpy(&draw_list->commands[j], zt_sizeof(ztDrawCommand), stack_offsets[stack_offsets_idx], zt_sizeof(ztDrawCommand));
						}
						else {
							draw_list->commands[j].offset = ztVec3::zero;
						}
					}
					else {
						stack_offsets[++stack_offsets_idx] = &draw_list->commands[j];
					}
				}
				if (draw_list->commands[j].type == ztDrawCommandType_ChangeTransform) {
					if (draw_list->commands[j].transform_pop) {
						if (--stack_transforms_idx >= 0) {
							zt_memCpy(&draw_list->commands[j], zt_sizeof(ztDrawCommand), stack_transforms[stack_transforms_idx], zt_sizeof(ztDrawCommand));
						}
						else {
							draw_list->commands[j].transform = ztMat4::identity;
						}
					}
					else {
						stack_transforms[++stack_transforms_idx] = &draw_list->commands[j];
					}
				}
				if (draw_list->commands[j].type == ztDrawCommandType_ChangeBlendMode) {
					if (draw_list->commands[j].blend_pop) {
						if (--stack_blend_modes_idx >= 0) {
							zt_memCpy(&draw_list->commands[j], zt_sizeof(ztDrawCommand), stack_blend_modes[stack_blend_modes_idx], zt_sizeof(ztDrawCommand));
						}
						else {
							draw_list->commands[j].blend_src = ztRendererBlendMode_SourceAlpha;
							draw_list->commands[j].blend_dest = ztRendererBlendMode_OneMinusSourceAlpha;
						}
					}
					else {
						stack_blend_modes[++stack_blend_modes_idx] = &draw_list->commands[j];
					}
				}
			}
		}
	}

#	define _zt_castMem(type) (type*)mem; mem += zt_sizeof(type); mem_left -= zt_sizeof(type); zt_assert(mem_left >= 0); // if you assert here, you need more ztGameSettings::renderer_memory

	struct local
	{
		static bool texturesMatch(ztDrawCommand *cmd1, ztDrawCommand *cmd2)
		{
			ZT_PROFILE_RENDERING("zt_renderDrawLists::local::texturesMatch");

			if (cmd1 == nullptr ) {
				return cmd2->texture_count == 0;
			}
			if (cmd1->texture_count != cmd2->texture_count) {
				return false;
			}
			zt_fiz(cmd1->texture_count) {
				if (cmd1->texture[i] != cmd2->texture[i]) {
					return false;
				}
			}
			return true;
		}

		static byte *processForShader(ztCamera *camera, ztDrawList **draw_lists, int draw_lists_count, i32 flags, ztShaderID shader_id, byte *mem, i32 &mem_left, ztCompileShader **shader, ztCompileClipRegion *clip_regions)
		{
			ZT_PROFILE_RENDERING("zt_renderDrawLists::local::processForShader");

			ztCompileShader *cmp_shader = _zt_castMem(ztCompileShader);
			cmp_shader->shader = shader_id;
			cmp_shader->texture = nullptr;

			ztCompileTexture *cmp_texture = nullptr;
			ztCompileClipRegion *cmp_clip_region = nullptr;

			if (shader_id == ztInvalidID) {
				cmp_texture = _zt_castMem(ztCompileTexture);
				cmp_texture->command = nullptr;
				cmp_texture->next = nullptr;
				cmp_texture->item = nullptr;
				cmp_texture->last_item = nullptr;
				cmp_texture->cnt_display_items = 0;
				cmp_shader->texture = cmp_texture;

				// all lines and points go here
				zt_fiz(draw_lists_count) {
					ztDrawList *draw_list = draw_lists[i];
					zt_assert(draw_list != nullptr);

					ztCompileItem *cmp_item_last = nullptr;

					int points = 0;
					int lines = 0;

					zt_fjz(draw_list->commands_count) {
						if (draw_list->commands[j].type == ztDrawCommandType_Point) {
							points += 1;
						}
						if (draw_list->commands[j].type == ztDrawCommandType_Line) {
							lines += 1;
						}
					}

					// extract points next
					if (points > 0) {
						zt_fjz(draw_list->commands_count) {
							ztDrawCommand *command = &draw_list->commands[j];
							//if (command->type == ztDrawCommandType_ChangeColor || command->type == ztDrawCommandType_ChangeTransform || command->type == ztDrawCommandType_ChangeOffset || command->type == ztDrawCommandType_Point) {
							if (command->type >= ztDrawCommandType_ChangeShader || command->type == ztDrawCommandType_Point) {
								ztCompileItem *cmp_item = _zt_castMem(ztCompileItem);
								cmp_item->command = command;
								cmp_item->clip_region = nullptr;
								zt_singleLinkAddToEnd(cmp_texture->item, cmp_item);
								cmp_texture->cnt_display_items += 1;
							}
						}
					}

					// extract lines next
					if (lines > 0) {
						zt_fjz(draw_list->commands_count) {
							ztDrawCommand *command = &draw_list->commands[j];
							//if (command->type == ztDrawCommandType_ChangeColor || command->type == ztDrawCommandType_ChangeTransform || command->type == ztDrawCommandType_ChangeOffset || command->type == ztDrawCommandType_Line) {
							if (command->type >= ztDrawCommandType_ChangeShader || command->type == ztDrawCommandType_Line) {
								ztCompileItem *cmp_item = _zt_castMem(ztCompileItem);
								cmp_item->command = command;
								cmp_item->clip_region = nullptr;
	//							zt_singleLinkAddToEnd(cmp_texture->item, cmp_item);
	//							cmp_texture->cnt_display_items += 1;
								if (cmp_item_last == nullptr) {
									cmp_texture->last_item = cmp_item_last = cmp_item;
									zt_singleLinkAddToEnd(cmp_texture->item, cmp_item);
								}
								else {
									cmp_item_last->next = cmp_item;
									cmp_item_last = cmp_item;
									cmp_item_last->next = nullptr;
									cmp_texture->last_item = cmp_item_last;
								}
								cmp_texture->cnt_display_items += 1;
							}
						}
					}
				}
			}
			else {
				cmp_texture = _zt_castMem(ztCompileTexture);
				cmp_texture->command = nullptr;
				cmp_texture->item = nullptr;
				cmp_texture->last_item = nullptr;
				cmp_texture->cnt_display_items = 0;
				cmp_texture->next = nullptr;
				cmp_shader->texture = cmp_texture;

				zt_fiz(draw_lists_count) {
					ztDrawList *draw_list = draw_lists[i];
					zt_assert(draw_list != nullptr);

					bool ignore_shader = true;

					// extract all textures
					zt_fjz(draw_list->commands_count) {
						ztDrawCommand *command = &draw_list->commands[j];
						if (command->type == ztDrawCommandType_ChangeShader) {
							ignore_shader = command->shader != shader_id;
						}
						if (!ignore_shader) {
							if (command->type == ztDrawCommandType_ChangeTexture) {
								zt_linkFind(cmp_shader->texture, cmp_texture, texturesMatch(cmp_texture->command, command));
								if (cmp_texture == nullptr) {
									cmp_texture = _zt_castMem(ztCompileTexture);
									cmp_texture->command = command;
									cmp_texture->item = nullptr;
									cmp_texture->last_item = nullptr;
									cmp_texture->cnt_display_items = 0;
									cmp_texture->next = nullptr;
									zt_singleLinkAddToEnd(cmp_shader->texture, cmp_texture);
								}
							}
						}
					}

					// extract display elements.  we sort them out so that things can be batched efficiently
					ztDrawCommandType_Enum extract[] = { ztDrawCommandType_Triangle, ztDrawCommandType_Billboard, ztDrawCommandType_VertexArray };

					zt_fkz(zt_elementsOf(extract)) {
						cmp_texture = cmp_shader->texture;

						cmp_clip_region = nullptr;
						ztCompileItem *cmp_item_last = nullptr;

						ignore_shader = true;
						zt_fjz(draw_list->commands_count) {
							ztDrawCommand *command = &draw_list->commands[j];

							if (command->type == ztDrawCommandType_ChangeShader) {
								ignore_shader = command->shader != shader_id;
							}
							if (command->type == ztDrawCommandType_ChangeClipping) {
								cmp_clip_region = command->clip_idx < 0 ? nullptr : &clip_regions[command->clip_idx];
							}
							if (!ignore_shader) {
								if (command->type == ztDrawCommandType_ChangeTexture) {
									zt_linkFind(cmp_shader->texture, cmp_texture, texturesMatch(cmp_texture->command, command));
									zt_assert(cmp_texture != nullptr);
									cmp_item_last = cmp_texture->last_item;

								}
								//if (command->type == extract[k] || command->type == ztDrawCommandType_ChangeColor || command->type == ztDrawCommandType_ChangeTransform || command->type == ztDrawCommandType_ChangeOffset) {
								if (command->type == extract[k] || command->type >= ztDrawCommandType_ChangeColor) {
									ztCompileItem *cmp_item = _zt_castMem(ztCompileItem);
									cmp_item->command = command;
									cmp_item->clip_region = cmp_clip_region;
									if (cmp_item_last == nullptr) {
										cmp_texture->last_item = cmp_item_last = cmp_item;
										zt_singleLinkAddToEnd(cmp_texture->item, cmp_item);
									}
									else {
										cmp_item_last->next = cmp_item;
										cmp_item_last = cmp_item;
										cmp_item_last->next = nullptr;
										cmp_texture->last_item = cmp_item_last;
									}
									cmp_texture->cnt_display_items += command->type == ztDrawCommandType_ChangeColor ? 0 : 1;
								}
							}
						}
					}
				}
			}

			*shader = cmp_shader;


			return mem;
		}

		static bool processedShader(ztShaderID shader_id, ztCompileShader **shaders, i32 shaders_count)
		{
			ZT_PROFILE_RENDERING("zt_renderDrawLists::local::processShader");

			zt_fiz(shaders_count) {
				if (shaders[i]->shader == shader_id) {
					return true;
				}
			}
			return false;
		}
	};

	if (!zt_bitIsSet(flags, ztRenderDrawListFlags_NoDepthTest)) {
		// process non-shader commands first
		mem = local::processForShader(camera, draw_lists, draw_lists_count, flags, ztInvalidID, mem, mem_left, &shaders[shaders_count++], clip_regions);

		zt_fiz(draw_lists_count) {
			ztDrawList *draw_list = draw_lists[i];
			zt_assert(draw_list != nullptr);

			zt_fjz(draw_list->commands_count) {
				ztDrawCommand *command = &draw_list->commands[j];

				switch (command->type)
				{
					case ztDrawCommandType_ChangeShader: {
						if (!local::processedShader(command->shader, shaders, shaders_count)) {
							zt_assert(shaders_count < zt_elementsOf(shaders));
							mem = local::processForShader(camera, draw_lists, draw_lists_count, flags, command->shader, mem, mem_left, &shaders[shaders_count++], clip_regions);
						}
					} break;
				}
			}
		}
	}
	else {
		// there's no depth testing, so we just display everything as it came in
		ZT_PROFILE_RENDERING("zt_renderDrawLists::no depth");

		ztCompileShader *cmp_shader = shaders[shaders_count++] = _zt_castMem(ztCompileShader);
		ztShaderID current_shader = cmp_shader->shader = ztInvalidID;

		ztCompileTexture *cmp_texture = cmp_shader->texture = _zt_castMem(ztCompileTexture);
		cmp_texture->command = nullptr;
		cmp_texture->item = nullptr;
		cmp_texture->last_item = nullptr;
		cmp_texture->cnt_display_items = 0;
		cmp_texture->next = nullptr;
		int current_textures_count = 0;
		ztTextureID current_textures[ZT_DRAW_COMMAND_MAX_TEXTURES];
		zt_fiz(zt_elementsOf(current_textures)) {
			current_textures[i] = ztInvalidID;
		}

		ztCompileClipRegion *cmp_clip_region = nullptr;
		ztCompileItem *cmp_item_last = nullptr;

		zt_fiz(draw_lists_count) {
			ztDrawList *draw_list = draw_lists[i];
			zt_assert(draw_list != nullptr);

			zt_fjz(draw_list->commands_count) {
				ztDrawCommand *command = &draw_list->commands[j];

				switch (command->type)
				{
					case ztDrawCommandType_ChangeShader: {
						if (command->shader != current_shader) {
							zt_assertReturnOnFail(shaders_count < zt_elementsOf(shaders));
							cmp_shader = shaders[shaders_count++] = _zt_castMem(ztCompileShader);
							cmp_shader->shader = command->shader;
							cmp_texture = cmp_shader->texture = _zt_castMem(ztCompileTexture);
							cmp_texture->command = nullptr;
							cmp_texture->item = nullptr;
							cmp_texture->last_item = nullptr;
							cmp_texture->cnt_display_items = 0;
							cmp_texture->next = nullptr;
							cmp_item_last = nullptr;
							current_shader = command->shader;

							zt_fiz(zt_elementsOf(current_textures)) {
								current_textures[i] = ztInvalidID;
							}
						}
					} break;

					case ztDrawCommandType_ChangeTexture: {
						if (command->texture_count > 0) {
							{
								// make sure the last texture used actually has items, otherwise, remove it from the list
								ztCompileTexture *cmp_tex = cmp_shader->texture;
								ztCompileTexture *cmp_prev = nullptr;

								while (cmp_tex) {
									if (cmp_tex->next) {
										cmp_prev = cmp_tex;
										cmp_tex = cmp_tex->next;
									}
									else break;
								}

								if (cmp_tex) {
									int cnt_display_items = cmp_tex->cnt_display_items;
									int cnt_visual = 0;
									zt_flink(di, cmp_tex->item) {
										if (di->command->type >= ztDrawCommandType_ChangeShader) {
											cnt_display_items -= 1;
											cnt_visual += 1;
										}
									}

									if (cnt_display_items == 0) {
										if (cmp_prev) { 
											if (cnt_visual > 0) {
												if (cmp_prev->last_item) {
													cmp_prev->last_item->next = cmp_tex->item;
													cmp_prev->last_item = cmp_tex->last_item;
												}
												else {
													cmp_prev->item = cmp_tex->item;
													cmp_prev->last_item = cmp_tex->last_item;
												}
												cmp_prev->cnt_display_items += cmp_tex->cnt_display_items;
												//zt_flink(di, cmp_tex->item) {
												//	if (di->command->type >= ztDrawCommandType_ChangeShader) {
												//		//if (!(di->command->type == ztDrawCommandType_ChangeColor && di == cmp_tex->item && di->command->color == ztColor_White)) {
												//			zt_singleLinkAddToEnd(cmp_prev->item, di);
												//			cmp_prev->last_item->next = di;
												//			cmp_prev->last_item = di;
												//			cmp_prev->cnt_display_items += 1;
												//		//}
												//	}
												//}
											}
											cmp_prev->next = nullptr;
											current_textures_count = cmp_prev->command ? cmp_prev->command->texture_count : 0;
											zt_fiz(current_textures_count) {
												current_textures[i] = cmp_prev->command->texture[i];
											}
											cmp_item_last = cmp_prev->last_item;
											cmp_texture = cmp_prev;

										}
									}
								}
							}

							bool is_same = command->texture_count == current_textures_count;
							if (is_same) {
								zt_fiz(command->texture_count) {
									if (current_textures[i] != command->texture[i]) {
										is_same = false;
										break;
									}
								}
							}
							if (!is_same) {
								cmp_texture = _zt_castMem(ztCompileTexture);
								cmp_texture->command = command;
								cmp_texture->item = nullptr;
								cmp_texture->last_item = nullptr;
								cmp_texture->cnt_display_items = 0;
								cmp_texture->next = nullptr;
								cmp_item_last = nullptr;
								zt_singleLinkAddToEnd(cmp_shader->texture, cmp_texture);

								current_textures_count = command->texture_count;
								zt_fiz(current_textures_count) {
									current_textures[i] = command->texture[i];
								}
							}
						}
					} break;

					case ztDrawCommandType_ChangeClipping: {
						cmp_clip_region = command->clip_idx < 0 ? nullptr : &clip_regions[command->clip_idx];
					} break;

					default: {
						ztCompileItem *cmp_item = _zt_castMem(ztCompileItem);
						cmp_item->command = command;
						cmp_item->clip_region = cmp_clip_region;
						if (cmp_item_last == nullptr) {
							cmp_texture->last_item = cmp_item_last = cmp_item;
							zt_singleLinkAddToEnd(cmp_texture->item, cmp_item);
						}
						else {
							cmp_item_last->next = cmp_item;
							cmp_item_last = cmp_item;
							cmp_item_last->next = nullptr;
							cmp_texture->last_item = cmp_item_last;
						}
						cmp_texture->cnt_display_items += 1;// command->type == ztDrawCommandType_ChangeColor ? 0 : 1;
					} break;
				}
			}
		}
	}

#	undef _zt_castMem

	zt_fiz(draw_lists_count) {
		ztDrawList *draw_list = draw_lists[i];
		if (!zt_bitIsSet(draw_list->flags, ztDrawListFlags_NoReset)) {
			zt_drawListReset(draw_list);
		}
	}

#	pragma pack(push, 1)
	struct ztVertex
	{
		ztVec3 pos;
		ztVec2 uv;
		ztVec3 norm;
		ztVec4 color;
	};
#	pragma pack(pop)

	struct ztBuffer
	{
		ztVertex vertices[ztRenderDrawListVertexArraySize];
		i32 vertices_count;
	};

	zt_assert(sizeof(ztVertex) == 48);
	zt_assert(sizeof(ztBuffer) == ztRenderDrawListVertexByteSize + 4);

	static ztBuffer buffer;
	buffer.vertices_count = 0;

	ztVec3 offset = ztVec3::zero;
	bool has_offset = false;

	r32 ppu = zt_pixelsPerUnit();
	r32 clip_scale_w = 1;
	r32 clip_scale_h = 1;

	ztCamera rt_cam;
	if (render_target_id != ztInvalidID) {
		if (camera->type == ztCameraType_Orthographic) {
			r32 cws = zt_game->textures[render_target_id].width / (r32)zt_game->textures[render_target_id].width_actual;
			r32 chs = zt_game->textures[render_target_id].height / (r32)zt_game->textures[render_target_id].height_actual;

			i32 cw = zt_convertToi32Floor(zt_game->textures[render_target_id].width * zt_game->textures[render_target_id].render_texture_scale);
			i32 ch = zt_convertToi32Floor(zt_game->textures[render_target_id].height * zt_game->textures[render_target_id].render_texture_scale);

			if (zt_bitIsSet(zt_game->textures[render_target_id].flags, ztTextureFlags_RenderTargetScreen)) {
				r32 to_nw = camera->native_w / (r32)camera->width;
				r32 to_nh = camera->native_h / (r32)camera->height;
				zt_cameraMakeOrtho(&rt_cam, cw, ch, zt_convertToi32Floor(cw * to_nw), zt_convertToi32Floor(ch * to_nh), camera->near_z, camera->far_z);
			}
			else {
				zt_cameraMakeOrtho(&rt_cam, cw, ch, cw, ch, camera->near_z, camera->far_z);
			}

			rt_cam.zoom = camera->zoom;
			rt_cam.position = camera->position;

			//ppu *= zt_game->textures[render_target_id].render_texture_scale;
			clip_scale_w = (clip_scale_w /zt_game->textures[render_target_id].render_texture_scale) / (cws);
			clip_scale_h = (clip_scale_h /zt_game->textures[render_target_id].render_texture_scale) / (chs);

		}
		else {
			zt_cameraMakePersp(&rt_cam, zt_game->textures[render_target_id].width, zt_game->textures[render_target_id].height, camera->fov, camera->near_z, camera->far_z);
			rt_cam.position = camera->position;
			rt_cam.rotation = camera->rotation;
			rt_cam.direction = camera->direction;
		}

		zt_cameraRecalcMatrices(&rt_cam);
		camera = &rt_cam;
	}

#if defined(ZT_DEBUG)
	if (zt_bitIsSet(flags, ztRenderDrawListFlags_DebugDump)) {
		zt_logDebug("DrawList debug dump for frame %d:", zt_game->game_details.current_frame);
		zt_logDebug("  Total shaders accessed: %d", shaders_count);

		zt_fiz(shaders_count) {
			zt_logDebug("  Shader %d.  ID: %d", i + 1, shaders[i]->shader);

			{
				int tex_count = 0;
				ztCompileTexture *cmp_tex = shaders[i]->texture;
				while (cmp_tex) {
					tex_count += 1;
					cmp_tex = cmp_tex->next;
				}
				zt_logDebug("    Total textures for this shader: %d", tex_count);
			}
			{
				int tex_count = 0;
				ztCompileTexture *cmp_tex = shaders[i]->texture;
				while (cmp_tex) {
					zt_logDebug("    Texture %d. Count: %d", ++tex_count, cmp_tex->command ? cmp_tex->command->texture_count : 0);
					if (cmp_tex->command) {
						zt_fjz(cmp_tex->command->texture_count) {
							zt_logDebug("      ID: %d (%d x %d)", cmp_tex->command->texture[j], zt_game->textures[cmp_tex->command->texture[j]].width, zt_game->textures[cmp_tex->command->texture[j]].height);
						}
					}

					{
						int item_count = 0;
						ztCompileItem *item = cmp_tex->item;
						while (item) {
							item_count += 1;
							item = item->next;
						}
						zt_logDebug("      Texture has %d items", item_count);
					}

					{
						int item_count = 0;
						int tab_count = 0;

						ztCompileItem *item = cmp_tex->item;
						while (item) {
							char info[1024];
							switch (item->command->type)
							{
								case ztDrawCommandType_Point:          zt_strPrintf(info, zt_elementsOf(info), "Point: %.2f, %.2f, %.2f", item->command->point.x, item->command->point.y, item->command->point.z); break;
								case ztDrawCommandType_Line:           zt_strPrintf(info, zt_elementsOf(info), "Line: start: %.2f, %.2f, %.2f; end: %.2f, %.2f, %.2f", item->command->line[0].x, item->command->line[0].y, item->command->line[0].z, item->command->line[1].x, item->command->line[1].y, item->command->line[1].z); break;
								case ztDrawCommandType_Triangle:       zt_strPrintf(info, zt_elementsOf(info), "Triangle: [p1] %.2f, %.2f, %.2f; [p2] %.2f, %.2f, %.2f; [p3] %.2f, %.2f, %.2f; [u1] %.2f, %.2f; [u2] %.2f, %.2f; [u3] %.2f, %.2f; [n1] %.2f, %.2f, %.2f; [n2] %.2f, %.2f, %.2f; [n3] %.2f, %.2f, %.2f; ", item->command->tri_pos[0].x, item->command->tri_pos[0].y, item->command->tri_pos[0].z, item->command->tri_pos[1].x, item->command->tri_pos[1].y, item->command->tri_pos[1].z, item->command->tri_pos[2].x, item->command->tri_pos[2].y, item->command->tri_pos[2].z, item->command->tri_uv[0].x, item->command->tri_uv[0].y, item->command->tri_uv[1].x, item->command->tri_uv[1].y, item->command->tri_uv[2].x, item->command->tri_uv[2].y, item->command->tri_norm[0].x, item->command->tri_norm[0].y, item->command->tri_norm[0].z, item->command->tri_norm[1].x, item->command->tri_norm[1].y, item->command->tri_norm[1].z, item->command->tri_norm[2].x, item->command->tri_norm[2].y, item->command->tri_norm[2].z); break;
								case ztDrawCommandType_ChangeColor:    zt_strPrintf(info, zt_elementsOf(info), "Color Change: %.2f, %.2f, %.2f, %.2f", item->command->color.r, item->command->color.g, item->command->color.b, item->command->color.a); if (item->command->color_pop) tab_count -= 1; break;
								case ztDrawCommandType_ChangeClipping: zt_strPrintf(info, zt_elementsOf(info), "Clip: center: %.2f, %.2f; size: %.2f, %.2f", item->command->clip_center.x, item->command->clip_center.y, item->command->clip_size.x, item->command->clip_size.y); break;
								case ztDrawCommandType_ChangeFlags:    zt_strPrintf(info, zt_elementsOf(info), "Flags: %d", item->command->flags); break;
								case ztDrawCommandType_ChangeOffset:   zt_strPrintf(info, zt_elementsOf(info), "Offset: %.2f, %.2f, %.2f", item->command->offset.x, item->command->offset.y, item->command->offset.z); if (item->command->offset_pop) tab_count -= 1; break;
								case ztDrawCommandType_ChangeTransform:zt_strPrintf(info, zt_elementsOf(info), "Transform: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f", item->command->transform.values[0], item->command->transform.values[1], item->command->transform.values[2], item->command->transform.values[3], item->command->transform.values[4], item->command->transform.values[5], item->command->transform.values[6], item->command->transform.values[7], item->command->transform.values[8], item->command->transform.values[9], item->command->transform.values[10], item->command->transform.values[11], item->command->transform.values[12], item->command->transform.values[13], item->command->transform.values[14], item->command->transform.values[15] ); if (item->command->transform_pop) tab_count -= 1; break;
								case ztDrawCommandType_Skybox:         zt_strPrintf(info, zt_elementsOf(info), "Skybox"); break;
								case ztDrawCommandType_Billboard:      zt_strPrintf(info, zt_elementsOf(info), "Billboard: center: %.2f, %.2f, %.2f; size: %.2f, %.2f; uv: %.2f, %.2f, %.2f, %.2f; flags: %d", item->command->billboard_center.x, item->command->billboard_center.y, item->command->billboard_center.z, item->command->billboard_size.x, item->command->billboard_size.x, item->command->billboard_uv.x, item->command->billboard_uv.y, item->command->billboard_uv.z, item->command->billboard_uv.w, item->command->billboard_flags); break;
								case ztDrawCommandType_VertexArray:    zt_strPrintf(info, zt_elementsOf(info), "Vertex Array: ID: %d; draw type: %d", item->command->vertex_array, item->command->vertex_array_draw_type); break;
								case ztDrawCommandType_DebugItem:      zt_strPrintf(info, zt_elementsOf(info), "Debug: %s", item->command->debug); break;
							}

							char tabs[128] = { 0 };
							zt_fiz(zt_min(zt_elementsOf(tabs) - 1, tab_count)) {
								tabs[i] = '\t';
								tabs[i + 1] = 0;
							}

							switch (item->command->type)
							{
								case ztDrawCommandType_ChangeColor:    if (!item->command->color_pop) tab_count += 1; break;
								case ztDrawCommandType_ChangeOffset:   if (!item->command->offset_pop) tab_count += 1; break;
							}

							zt_logDebug("        Item %d: %s %s", ++item_count, tabs, info);
							item = item->next;
						}
					}
					cmp_tex = cmp_tex->next;
				}
			}
		}
	}
#endif // defined(ZT_DEBUG)

	if (zt_game->win_game_settings[0].renderer == ztRenderer_OpenGL) {
#if defined(ZT_OPENGL)
		if (render_target_id != ztInvalidID) {
			zt_textureRenderTargetPrepare(render_target_id, !zt_bitIsSet(flags, ztRenderDrawListFlags_NoClear));
			if (!zt_bitIsSet(flags, ztRenderDrawListFlags_NoClear)) {
				zt_rendererClear(clear);
			}
		}

		if (!zt_bitIsSet(flags, ztRenderDrawListFlags_NoDepthTest)) {
			ztgl_depthTestLessEqual();
		}
		else {
			ztgl_depthTestOff();
		}

		if (zt_game->textures_active_render_target) {
			ztgl_blendMode(ztGLBlendMode_SourceAlpha, ztGLBlendMode_OneMinusSourceAlpha);
		}
		else {
			ztgl_blendMode(ztGLBlendMode_SourceAlpha, ztGLBlendMode_OneMinusSourceAlpha);
		}

		ztCompileItem *blend = nullptr;

		ztMat4 mat2d;

		if (clip_regions_count > 0) {
			ztgl_clipReset();
		}

		ztCompileClipRegion *curr_clip_region = nullptr;

		ztVec4 active_color = ztVec4::one;
		ztMat4 *transform = nullptr;

		zt_fiz(shaders_count) {
			ZT_PROFILE_RENDERING("zt_renderDrawLists::shader loop");

			ztShaderID shader_id = shaders[i]->shader;

			static u32 model_hash = zt_strHash("model");

			if (shaders[i]->shader != ztInvalidID) {
				zt_game->game_details.curr_frame.shader_switches += 1;
				zt_shaderBegin(shader_id);
				zt_shaderSetVariableMat4(shader_id, model_hash, ztMat4::identity);
				zt_shaderSetCameraMatrices(shader_id, camera->mat_proj, camera->mat_view);
			}
			else {
				zt_game->game_details.curr_frame.shader_switches += 1;
				ztShaderID sid = zt_shaderGetDefault(ztShaderDefault_Solid);
				zt_shaderBegin(sid);
				zt_shaderSetVariableMat4(sid, model_hash, ztMat4::identity);
				zt_shaderSetCameraMatrices(sid, camera->mat_proj, camera->mat_view);
				ztgl_textureBind(zt_game->textures[0].gl_texture, 0);

				mat2d = camera->mat_proj * camera->mat_view;
			}

			ztCompileTexture *cmp_tex = shaders[i]->texture;
			while (cmp_tex) {

				if (cmp_tex->cnt_display_items == 0) {
					cmp_tex = cmp_tex->next;
					continue;
				}

				if (curr_clip_region) {
					curr_clip_region = nullptr;
					ztgl_clipReset();
				}

				if (cmp_tex->command && shader_id != ztInvalidID) {
					ZT_PROFILE_RENDERING("zt_renderDrawLists::texture binding");

					//ztgl_textureBindReset(zt_game->shaders[shader_id].gl_shader);
					zt_game->game_details.curr_frame.texture_switches += 1;
					zt_fiz(cmp_tex->command->texture_count) {
						static u32 diffuse_tex_hash = zt_strHash("diffuse_tex");
						zt_shaderSetVariableTex(shader_id, diffuse_tex_hash, cmp_tex->command->texture[i]);
//						if (zt_game->textures[cmp_tex->command->texture[i]].renderer == ztRenderer_OpenGL) {
//							ztgl_shaderVariableTex(zt_game->shaders[shader_id].gl_shader, diffuse_tex_hash, zt_game->textures[cmp_tex->command->texture[i]].gl_texture);
//						}
					}
					if (cmp_tex->command->texture_count > 0) {
						zt_shaderApplyVariables(shader_id);
					}
				}

				if (curr_clip_region) {
					curr_clip_region = nullptr;
					ztgl_clipReset();
				}

				if (blend) {
					zt_rendererSetBlendMode(blend->command->blend_src, blend->command->blend_dest);
				}

				ztCompileItem *cmp_item = cmp_tex->item;

				ztDrawCommandType_Enum last_command = ztDrawCommandType_Invalid;

				struct OpenGL
				{
					static ztInline void processLastCommand(ztCamera *cam, ztMat4 *mat, ztVec4 &active_color, ztDrawCommandType_Enum this_command, ztDrawCommandType_Enum last_command, ztBuffer *buffer)
					{
						ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand");
						switch (last_command)
						{
							case ztDrawCommandType_Billboard:
							case ztDrawCommandType_Triangle: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::v");
								if (buffer->vertices_count > 0) {
									ztVertexEntryGL entries[] = {
										{ GL_FLOAT, 3 * sizeof(GLfloat) },
										{ GL_FLOAT, 2 * sizeof(GLfloat) },
										{ GL_FLOAT, 3 * sizeof(GLfloat) },
										{ GL_FLOAT, 4 * sizeof(GLfloat) },
									};

									ztgl_vertexArrayUpdate(&zt_game->win_details[0].gl_tri_verts_array, entries, zt_elementsOf(entries), buffer->vertices, buffer->vertices_count);
									ztgl_vertexArrayDraw(&zt_game->win_details[0].gl_tri_verts_array, GL_TRIANGLES);
									//zt_game->win_details[0].gl_tri_verts_array.vert_count = 0;

									zt_game->game_details.curr_frame.draw_calls += 1;
								}
							} break;

							case ztDrawCommandType_Line: {
								if (buffer->vertices_count > 0) {
									ztVertexEntryGL entries[] = {
										{ GL_FLOAT, 3 * sizeof(GLfloat) },
										{ GL_FLOAT, 2 * sizeof(GLfloat) },
										{ GL_FLOAT, 3 * sizeof(GLfloat) },
										{ GL_FLOAT, 4 * sizeof(GLfloat) },
									};

									ztgl_vertexArrayUpdate(&zt_game->win_details[0].gl_tri_verts_array, entries, zt_elementsOf(entries), buffer->vertices, buffer->vertices_count);
									ztgl_vertexArrayDraw(&zt_game->win_details[0].gl_tri_verts_array, GL_LINES);
									//zt_game->win_details[0].gl_tri_verts_array.vert_count = 0;

									zt_game->game_details.curr_frame.draw_calls += 1;
								}
							} break;

							case ztDrawCommandType_Point: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::l/p");
								ztVertexEntryGL entries[] = {
									{ GL_FLOAT, 3 * sizeof(GLfloat) },
									{ GL_FLOAT, 2 * sizeof(GLfloat) },
									{ GL_FLOAT, 3 * sizeof(GLfloat) },
									{ GL_FLOAT, 4 * sizeof(GLfloat) },
								};

								ztgl_vertexArrayUpdate(&zt_game->win_details[0].gl_tri_verts_array, entries, zt_elementsOf(entries), buffer->vertices, buffer->vertices_count);
								ztgl_vertexArrayDraw(&zt_game->win_details[0].gl_tri_verts_array, GL_POINTS);
								//zt_game->win_details[0].gl_tri_verts_array.vert_count = 0;

								zt_game->game_details.curr_frame.draw_calls += 1;
							} break;
						}

						switch (this_command)
						{
							case ztDrawCommandType_Billboard:
							case ztDrawCommandType_Triangle: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::t");
								buffer->vertices_count = 0;
							} break;

							case ztDrawCommandType_Line: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::l");
								buffer->vertices_count = 0;
							} break;

							case ztDrawCommandType_Point: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::p");
								buffer->vertices_count = 0; 
							} break;
						}
					}
				};

				while (cmp_item) {
					if (cmp_item->clip_region != curr_clip_region && camera->type == ztCameraType_Orthographic) {
						ZT_PROFILE_RENDERING("zt_renderDrawLists::clip regions");
						OpenGL::processLastCommand(nullptr, nullptr, active_color, ztDrawCommandType_Invalid, last_command, &buffer);
						last_command = ztDrawCommandType_Invalid;

						curr_clip_region = cmp_item->clip_region;

						if (curr_clip_region) {
							if(camera->width == camera->native_w && camera->height == camera->native_h) {
								ztVec2i pos = zt_cameraOrthoWorldToScreen(camera, curr_clip_region->command->clip_center - curr_clip_region->command->clip_size * zt_vec2(.5f, .5f));
								int w = zt_convertToi32Ceil(curr_clip_region->command->clip_size.x * ppu);
								int h = zt_convertToi32Ceil(curr_clip_region->command->clip_size.y * ppu);

								ztgl_clipViewport(zt_convertToi32Floor(pos.x * clip_scale_w), zt_convertToi32Floor(pos.y * clip_scale_h), zt_convertToi32Floor(w * clip_scale_w), zt_convertToi32Floor(h * clip_scale_h));
							}
							else {
								/// need to properly adjust the clip rectangle
								// x, y is lower left corner of the screen, in pixels

								ztVec2i pos = zt_cameraOrthoWorldToScreen(camera, curr_clip_region->command->clip_center - curr_clip_region->command->clip_size * zt_vec2(.5f, .5f));
								int w = zt_convertToi32Ceil(curr_clip_region->command->clip_size.x * ppu);
								int h = zt_convertToi32Ceil(curr_clip_region->command->clip_size.y * ppu);

								r32 w_pct = camera->width / (r32)camera->native_w;
								r32 h_pct = camera->height / (r32)camera->native_h;

								pos.x = zt_convertToi32Ceil(pos.x * w_pct);
								pos.y = zt_convertToi32Ceil(pos.y * h_pct);
								w     = zt_convertToi32Ceil(    w * w_pct);
								h     = zt_convertToi32Ceil(    h * w_pct);

								ztgl_clipViewport(zt_convertToi32Floor(pos.x * clip_scale_w), zt_convertToi32Floor(pos.y * clip_scale_h), zt_convertToi32Floor(w * clip_scale_w), zt_convertToi32Floor(h * clip_scale_h));
							}
						}
						else {
							ztgl_clipReset();
						}
					}

					if (cmp_item->command->type != last_command) {
						bool skipProcess = false;
						switch (cmp_item->command->type)
						{
							case ztDrawCommandType_ChangeColor:
							case ztDrawCommandType_ChangeOffset:
							case ztDrawCommandType_ChangeTransform:
							case ztDrawCommandType_DebugItem:
								skipProcess = true;
								break;
						}

						if (!skipProcess) {
							OpenGL::processLastCommand(camera, &mat2d, active_color, cmp_item->command->type, last_command, &buffer);
							last_command = cmp_item->command->type;
						}
					}

					switch (cmp_item->command->type)
					{
						case ztDrawCommandType_Triangle: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::triangle");
							++zt_game->game_details.curr_frame.triangles_drawn;

							zt_fkz(3) {
								int idx = buffer.vertices_count++;
								zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
								if (has_offset) {
									buffer.vertices[idx].pos = cmp_item->command->tri_pos[k] + offset;
								}
								else {
									buffer.vertices[idx].pos = cmp_item->command->tri_pos[k];
								}
								buffer.vertices[idx].uv = cmp_item->command->tri_uv[k];
								buffer.vertices[idx].norm = cmp_item->command->tri_norm[k];
								buffer.vertices[idx].color = cmp_item->command->tri_color[k] * active_color;
								buffer.vertices[idx].uv.y = 1 - buffer.vertices[idx].uv.y;


								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}

							if(ztRenderDrawListVertexArraySize - buffer.vertices_count < 32) {
								OpenGL::processLastCommand(camera, &mat2d, active_color, cmp_item->command->type, last_command, &buffer);
								last_command = cmp_item->command->type;
							}
						} break;

						case ztDrawCommandType_Billboard: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::billboard");
							zt_game->game_details.curr_frame.triangles_drawn += 2;

							ztVec3 p[4] = {
								zt_vec3(-cmp_item->command->billboard_size.x / 2.f + offset.x, +cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(-cmp_item->command->billboard_size.x / 2.f + offset.x, -cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(+cmp_item->command->billboard_size.x / 2.f + offset.x, -cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(+cmp_item->command->billboard_size.x / 2.f + offset.x, +cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
							};

							ztVec2 uv[4] = {
								zt_vec2(cmp_item->command->billboard_uv.x, 1 - cmp_item->command->billboard_uv.y),
								zt_vec2(cmp_item->command->billboard_uv.x, 1 - cmp_item->command->billboard_uv.w),
								zt_vec2(cmp_item->command->billboard_uv.z, 1 - cmp_item->command->billboard_uv.w),
								zt_vec2(cmp_item->command->billboard_uv.z, 1 - cmp_item->command->billboard_uv.y),
							};

							ztVec3 pos_lookat = camera->position;

							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisX)) pos_lookat.x = cmp_item->command->billboard_center.x;
							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisY)) pos_lookat.y = cmp_item->command->billboard_center.y;
							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisZ)) pos_lookat.z = cmp_item->command->billboard_center.z;

							ztMat4 mat = ztMat4::identity.getLookAt(pos_lookat, cmp_item->command->billboard_center, cmp_item->command->billboard_up).getInverse();
							mat.values[ztMat4_Col3Row0] = mat.values[ztMat4_Col3Row1] = mat.values[ztMat4_Col3Row2] = 0; // remove translation

							if (cmp_item->command->billboard_rotation != 0) {
								ztQuat quat = ztQuat::makeFromEuler(0, 0, cmp_item->command->billboard_rotation);
								zt_fiz(4) {
									quat.rotatePosition(&p[i]);
								}
							}

							zt_fiz(4) {
								p[i] = cmp_item->command->billboard_center + (mat * p[i]);
							}

							zt_fiz(2) {
								int idx = buffer.vertices_count++;
								zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
								buffer.vertices[idx].pos = p[0];
								buffer.vertices[idx].uv = uv[0];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}

								idx = buffer.vertices_count++;
								zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
								buffer.vertices[idx].pos = p[1 + i];
								buffer.vertices[idx].uv = uv[1 + i];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}

								idx = buffer.vertices_count++;
								zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
								buffer.vertices[idx].pos = p[2 + i];
								buffer.vertices[idx].uv = uv[2 + i];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}

								if(ztRenderDrawListVertexArraySize - buffer.vertices_count < 32) {
									OpenGL::processLastCommand(camera, &mat2d, active_color, cmp_item->command->type, last_command, &buffer);
									last_command = cmp_item->command->type;
								}
							}
						} break;

						case ztDrawCommandType_Line: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::line");
							zt_assert((cmp_tex->command && cmp_tex->command->texture_count > 0) || shader_id == ztInvalidID); // you need to push a texture before adding the line

							zt_fkz(2) {
								int idx = buffer.vertices_count++;
								zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
								if (has_offset) {
									buffer.vertices[idx].pos = cmp_item->command->line[k] + offset;
								}
								else {
									buffer.vertices[idx].pos = cmp_item->command->line[k];
								}
								buffer.vertices[idx].uv = ztVec2::one;
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;

								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}

							if (ztRenderDrawListVertexArraySize - buffer.vertices_count < 32) {
								OpenGL::processLastCommand(camera, &mat2d, active_color, cmp_item->command->type, last_command, &buffer);
								last_command = cmp_item->command->type;
							}

						} break;

						case ztDrawCommandType_Point: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::point");
							int idx = buffer.vertices_count++;
							zt_assert(buffer.vertices_count < ztRenderDrawListVertexArraySize);
							if (has_offset) {
								buffer.vertices[idx].pos = cmp_item->command->point + offset;
							}
							else {
								buffer.vertices[idx].pos = cmp_item->command->point;
							}
							buffer.vertices[idx].uv = ztVec2::one;
							buffer.vertices[idx].norm = ztVec3::zero;
							buffer.vertices[idx].color = active_color;

							if (transform) {
								buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
							}

							if (ztRenderDrawListVertexArraySize - buffer.vertices_count < 32) {
								OpenGL::processLastCommand(camera, &mat2d, active_color, cmp_item->command->type, last_command, &buffer);
								last_command = cmp_item->command->type;
							}
						} break;

						case ztDrawCommandType_ChangeColor: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change color");
							active_color = cmp_item->command->color;
						} break;

						case ztDrawCommandType_ChangeOffset: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change offset");
							offset = cmp_item->command->offset;
							has_offset = offset != ztVec3::zero;
						} break;

						case ztDrawCommandType_ChangeTransform: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change transform");
							if (cmp_item->command->transform == ztMat4::identity) {
								transform = nullptr;
							}
							else {
								transform = &cmp_item->command->transform;
							}
						} break;

						case ztDrawCommandType_ChangeBlendMode: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change blend mode");
							zt_rendererSetBlendMode(cmp_item->command->blend_src, cmp_item->command->blend_dest);
							blend = cmp_item;
						} break;

						case ztDrawCommandType_VertexArray: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::vertex array");
							zt_vertexArrayDraw(cmp_item->command->vertex_array, cmp_item->command->vertex_array_draw_type);

						} break;
					};

					cmp_item = cmp_item->next;
				}
				OpenGL::processLastCommand(nullptr, nullptr, active_color, ztDrawCommandType_Invalid, last_command, &buffer);

				if (curr_clip_region) {
					curr_clip_region = nullptr;
					ztgl_clipReset();
				}

				if (cmp_tex->command && shader_id != ztInvalidID) {
					ZT_PROFILE_RENDERING("zt_renderDrawLists::resetting texture");
					ztgl_textureBindReset(zt_game->shaders[shader_id].gl_shader);
				}

				cmp_tex = cmp_tex->next;
			}

			if (curr_clip_region) {
				curr_clip_region = nullptr;
				ztgl_clipReset();
			}

			if (shader_id != ztInvalidID) {
				zt_shaderEnd(shader_id);
			}
			else {
				ztgl_callAndReportOnErrorFast(glBindTexture(GL_TEXTURE_2D, 0));
				ztgl_callAndReportOnErrorFast(glUseProgram(0));
			}
		}

		if (clip_regions_count > 0) {
			ztgl_clipReset();
		}

		if (render_target_id != ztInvalidID) {
			zt_textureRenderTargetCommit(render_target_id);
		}

#endif // ZT_OPENGL
	}
	else if (zt_game->win_game_settings[0].renderer == ztRenderer_DirectX) {
#if defined(ZT_DIRECTX)

		if (render_target_id != ztInvalidID) {
			zt_textureRenderTargetPrepare(render_target_id, !zt_bitIsSet(flags, ztRenderDrawListFlags_NoClear));
		}

		if (!zt_bitIsSet(flags, ztRenderDrawListFlags_NoDepthTest)) {
			ztdx_depthTestLess(zt_game->win_details[0].dx_context);
		}
		else {
			ztdx_depthTestOff(zt_game->win_details[0].dx_context);
		}

		ztCompileClipRegion *curr_clip_region = nullptr;

		static u32 model_hash = zt_strHash("model");
		static u32 view_hash = zt_strHash("view");
		static u32 projection_hash = zt_strHash("projection");

		zt_fiz(shaders_count) {
			ZT_PROFILE_RENDERING("zt_renderDrawLists::shader loop");

			ztShaderID shader_id = shaders[i]->shader;
			if (shaders[i]->shader != ztInvalidID) {
				zt_game->game_details.curr_frame.shader_switches += 1;
				ztdx_shaderBegin(zt_game->win_details[0].dx_context, zt_game->shaders[shader_id].dx_shader);

				ztMat4 dxMod = ztMat4::identity;
				ztMat4 dxView = camera->mat_view;
				ztMat4 dxProj = camera->mat_proj;

				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, model_hash, dxMod);
				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, view_hash, dxView);
				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, projection_hash, dxProj);
				zt_shaderApplyVariables(shader_id);
			}
			else {
				shader_id = zt_shaderGetDefault(ztShaderDefault_Solid);

				zt_game->game_details.curr_frame.shader_switches += 1;
				ztdx_shaderBegin(zt_game->win_details[0].dx_context, zt_game->shaders[shader_id].dx_shader);

				ztMat4 dxMod = ztMat4::identity;
				ztMat4 dxView = camera->mat_view;
				ztMat4 dxProj = camera->mat_proj;

				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, model_hash, dxMod);
				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, view_hash, dxView);
				zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, projection_hash, dxProj);
				zt_shaderApplyVariables(shader_id);
				// set color
			}

			ztVec4 active_color = ztVec4::one;
			ztMat4 *transform = nullptr;

			ztCompileTexture *cmp_tex = shaders[i]->texture;
			while (cmp_tex) {
				if (cmp_tex->cnt_display_items == 0) {
					cmp_tex = cmp_tex->next;
					continue;
				}

				if (cmp_tex->command && shader_id != ztInvalidID) {
					ZT_PROFILE_RENDERING("zt_renderDrawLists::texture binding");
					zt_game->game_details.curr_frame.texture_switches += 1;
					static u32 tex_diffuse_hash = zt_strHash("diffuse_tex");
					if (zt_game->textures[cmp_tex->command->texture[0]].renderer == ztRenderer_DirectX) {
						zt_shaderSetVariableTex(shader_id, tex_diffuse_hash, cmp_tex->command->texture[0]);
					}
					zt_shaderApplyVariables(shader_id);
				}

				ztCompileItem *cmp_item = cmp_tex->item;

				ztDrawCommandType_Enum last_command = ztDrawCommandType_Invalid;

				struct DirectX
				{
					static void processLastCommand(ztShaderID active_shader, ztDrawCommandType_Enum this_command, ztDrawCommandType_Enum last_command, ztBuffer *buffer)
					{
						ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand");
						switch (last_command)
						{
							case ztDrawCommandType_Billboard:
							case ztDrawCommandType_Triangle: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::v");
								//zt_shaderApplyVariables(active_shader);

								ztdx_vertexArrayUpdate(zt_game->win_details[0].dx_context, zt_game->win_details[0].dx_tri_verts_array, buffer->vertices, buffer->vertices_count);
								ztdx_vertexArrayDraw(zt_game->win_details[0].dx_context, zt_game->win_details[0].dx_tri_verts_array);
								buffer->vertices_count = 0;

								zt_game->game_details.curr_frame.draw_calls += 1;
							} break;

							case ztDrawCommandType_Line:
							case ztDrawCommandType_Point: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::l/p");
								//zt_shaderApplyVariables(active_shader);

								ztdx_vertexArrayUpdate(zt_game->win_details[0].dx_context, zt_game->win_details[0].dx_tri_verts_array, buffer->vertices, buffer->vertices_count);
								ztdx_vertexArrayDraw(zt_game->win_details[0].dx_context, zt_game->win_details[0].dx_tri_verts_array, D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
								buffer->vertices_count = 0;

								zt_game->game_details.curr_frame.draw_calls += 1;
							} break;
						}

						switch (this_command)
						{
							case ztDrawCommandType_Billboard:
							case ztDrawCommandType_Triangle: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::t");
								buffer->vertices_count = 0;
								ztdx_cullBack(zt_game->win_details[0].dx_context);
							} break;

							case ztDrawCommandType_Line:
							case ztDrawCommandType_Point: {
								ZT_PROFILE_RENDERING("zt_renderDrawLists::lastCommand::lp");
								buffer->vertices_count = 0;
								ztdx_cullNone(zt_game->win_details[0].dx_context);
							} break;
						}
					}
				};

				while (cmp_item) {

					if (cmp_item->clip_region != curr_clip_region && camera->type == ztCameraType_Orthographic) {
						ZT_PROFILE_RENDERING("zt_renderDrawLists::clip regions");
						DirectX::processLastCommand(shader_id, ztDrawCommandType_Invalid, last_command, &buffer);
						last_command = ztDrawCommandType_Invalid;

						curr_clip_region = cmp_item->clip_region;

						if (curr_clip_region) {
							ztVec2i pos = zt_cameraOrthoWorldToScreen(camera, (curr_clip_region->command->clip_center * zt_vec2(1, -1)) - curr_clip_region->command->clip_size * zt_vec2(.5f, .5f));

							int w = zt_convertToi32Floor(curr_clip_region->command->clip_size.x * ppu);
							int h = zt_convertToi32Floor(curr_clip_region->command->clip_size.y * ppu);

							ztdx_clipRegionSet(zt_game->win_details[0].dx_context, pos.x, pos.y, pos.x + w, pos.y + h);
						}
						else {
							ztdx_clipRegionRemove(zt_game->win_details[0].dx_context);
						}
					}

					if (cmp_item->command->type != last_command) {
						bool skipProcess = false;
						switch (cmp_item->command->type)
						{
							case ztDrawCommandType_ChangeColor:
							case ztDrawCommandType_ChangeOffset:
							case ztDrawCommandType_ChangeTransform:
							case ztDrawCommandType_DebugItem:
								skipProcess = true;
								break;
						}

						if (!skipProcess) {
							DirectX::processLastCommand(shader_id, cmp_item->command->type, last_command, &buffer);
							last_command = cmp_item->command->type;
						}
					}

					switch (cmp_item->command->type)
					{
						case ztDrawCommandType_Triangle: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::triangle");
							++zt_game->game_details.curr_frame.triangles_drawn;

							if (buffer.vertices_count >= zt_elementsOf(buffer.vertices)) {
								DirectX::processLastCommand(shader_id, ztDrawCommandType_Invalid, ztDrawCommandType_Triangle, &buffer);
							}

							zt_fkz(3) {
								int idx = buffer.vertices_count++;
								zt_fjz(3) buffer.vertices[idx].pos.values[j] = cmp_item->command->tri_pos[k].values[j] + offset.values[j];
								zt_fjz(2) buffer.vertices[idx].uv.values[j] = cmp_item->command->tri_uv[k].values[j];
								zt_fjz(3) buffer.vertices[idx].norm.values[j] = cmp_item->command->tri_norm[k].values[j];
								zt_fjz(4) buffer.vertices[idx].color.values[j] = cmp_item->command->tri_color[k].values[j] * active_color.values[j];
								buffer.vertices[idx].uv.y = 1 - buffer.vertices[idx].uv.y;

								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}

						} break;

						case ztDrawCommandType_Billboard: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::billboard");
							zt_game->game_details.curr_frame.triangles_drawn += 2;

							ztVec3 p[4] = {
								zt_vec3(-cmp_item->command->billboard_size.x / 2.f + offset.x, +cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(-cmp_item->command->billboard_size.x / 2.f + offset.x, -cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(+cmp_item->command->billboard_size.x / 2.f + offset.x, -cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
								zt_vec3(+cmp_item->command->billboard_size.x / 2.f + offset.x, +cmp_item->command->billboard_size.y / 2.f + offset.y, offset.z),
							};

							ztVec2 uv[4] = {
								zt_vec2(cmp_item->command->billboard_uv.x, cmp_item->command->billboard_uv.y),
								zt_vec2(cmp_item->command->billboard_uv.x, cmp_item->command->billboard_uv.w),
								zt_vec2(cmp_item->command->billboard_uv.z, cmp_item->command->billboard_uv.w),
								zt_vec2(cmp_item->command->billboard_uv.z, cmp_item->command->billboard_uv.y),
							};

							ztVec3 pos_lookat = camera->position;

							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisX)) pos_lookat.x = cmp_item->command->billboard_center.x;
							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisY)) pos_lookat.y = cmp_item->command->billboard_center.y;
							if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisZ)) pos_lookat.z = cmp_item->command->billboard_center.z;

							ztMat4 mat = ztMat4::identity.getLookAt(pos_lookat, cmp_item->command->billboard_center).getInverse();
							mat.values[ztMat4_Col3Row0] = mat.values[ztMat4_Col3Row1] = mat.values[ztMat4_Col3Row2] = 0; // remove translation

							zt_fiz(4) {
								p[i] = cmp_item->command->billboard_center + (mat * p[i]);
							}

							zt_fiz(2) {
								int idx = buffer.vertices_count++;
								buffer.vertices[idx].pos = p[0];
								buffer.vertices[idx].uv = uv[0];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}

								idx = buffer.vertices_count++;
								buffer.vertices[idx].pos = p[1 + i];
								buffer.vertices[idx].uv = uv[1 + i];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}

								idx = buffer.vertices_count++;
								buffer.vertices[idx].pos = p[2 + i];
								buffer.vertices[idx].uv = uv[2 + i];
								buffer.vertices[idx].norm = ztVec3::zero;
								buffer.vertices[idx].color = active_color;
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}
						} break;

						case ztDrawCommandType_Line: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::line");
							if (buffer.vertices_count >= zt_elementsOf(buffer.vertices)) {
								DirectX::processLastCommand(shader_id, ztDrawCommandType_Invalid, ztDrawCommandType_Line, &buffer);
							}

							zt_fkz(2) {
								int idx = buffer.vertices_count++;
								zt_fjz(3) buffer.vertices[idx].pos.values[j] = cmp_item->command->line[k].values[j] + offset.values[j];
								zt_fjz(2) buffer.vertices[idx].uv.values[j] = (r32)k;
								zt_fjz(3) buffer.vertices[idx].norm.values[j] = 1.f;
								zt_fjz(4) buffer.vertices[idx].color.values[j] = active_color.values[j];
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}
						} break;

						case ztDrawCommandType_Point: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::point");
							zt_fkz(2) {
								int idx = buffer.vertices_count++;
								zt_fjz(3) buffer.vertices[idx].pos.values[j] = cmp_item->command->line[k].values[j] + (k * 0.001f) + offset.values[j];
								zt_fjz(2) buffer.vertices[idx].uv.values[j] = (r32)k;
								zt_fjz(3) buffer.vertices[idx].norm.values[j] = 1.f;
								zt_fjz(4) buffer.vertices[idx].color.values[j] = active_color.values[j];
								if (transform) {
									buffer.vertices[idx].pos = (*transform) * buffer.vertices[idx].pos;
								}
							}
						} break;

						case ztDrawCommandType_ChangeColor: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change color");
							active_color = cmp_item->command->color;
						} break;

						case ztDrawCommandType_ChangeOffset: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change offset");
							offset = cmp_item->command->offset;
						} break;

						case ztDrawCommandType_ChangeTransform: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::change transform");
							if (cmp_item->command->transform == ztMat4::identity) {
								transform = nullptr;
							}
							else {
								transform = &cmp_item->command->transform;
							}
						} break;

						case ztDrawCommandType_VertexArray: {
							ZT_PROFILE_RENDERING("zt_renderDrawLists::vertex array");
							zt_vertexArrayDraw(cmp_item->command->vertex_array, cmp_item->command->vertex_array_draw_type);
						} break;
					};

					cmp_item = cmp_item->next;
				}
				DirectX::processLastCommand(shader_id, ztDrawCommandType_Invalid, last_command, &buffer);

				if (curr_clip_region) {
					curr_clip_region = nullptr;
					ztdx_clipRegionRemove(zt_game->win_details[0].dx_context);
				}

				cmp_tex = cmp_tex->next;
			}

			if (curr_clip_region) {
				curr_clip_region = nullptr;
				ztdx_clipRegionRemove(zt_game->win_details[0].dx_context);
			}
			// unbind shader?
		}

		if (render_target_id != ztInvalidID) {
			zt_textureRenderTargetCommit(render_target_id);
		}
#endif // ZT_DIRECTX
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal ztDebugDisplayItem _zt_debugDisplayItemDummy;

#define _zt_debugDisplayCheck(display_type) \
			if (zt_game->debug_display == nullptr || zt_game->debug_display->display_entries_count >= zt_game->debug_display->display_entries_size) { \
				zt_memSet(&_zt_debugDisplayItemDummy, zt_sizeof(ztDebugDisplayItem), 0); \
				return &_zt_debugDisplayItemDummy; \
						} \
			ztDebugDisplayEntry *display_entry = &zt_game->debug_display->display_entries[zt_game->debug_display->display_entries_count++]; \
			display_entry->type = display_type; \
			display_entry->color = color; \
			display_entry->persist_time = 0; \
			display_entry->item.time_to_persist = 0; \
			display_entry->item.guid = zt_guidMake(0, 0, 0, 0);

// ================================================================================================================================================================================================

ztInternal ztInline ztMat4 _zt_debugDisplayPosToMat(const ztVec2 &pos)
{
	ztTransform transform;
	transform.position = zt_vec3(pos, 0);
	transform.rotation = ztQuat::identity;
	transform.scale    = ztVec3::one;
	return zt_transformToMat4(&transform);
}

// ================================================================================================================================================================================================

ztInternal ztInline ztMat4 _zt_debugDisplayPosToMat(const ztVec3 &pos)
{
	ztTransform transform;
	transform.position = pos;
	transform.rotation = ztQuat::identity;
	transform.scale    = ztVec3::one;
	return zt_transformToMat4(&transform);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayGuiLine(const ztVec3 &p0, const ztVec3 &p1, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_GuiLine);

	display_entry->transform = ztMat4::identity;
	display_entry->line.p0 = p0;
	display_entry->line.p1 = p1;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayGuiCircle(r32 radius, i32 points, const ztVec2 &pos, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_GuiCircle);

	display_entry->transform = _zt_debugDisplayPosToMat(pos);
	display_entry->circle.radius = radius;
	display_entry->circle.points = points;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayGuiRect(const ztVec2 &size, const ztVec2 &pos, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_GuiRect);

	display_entry->transform = _zt_debugDisplayPosToMat(pos);
	display_entry->rect.size = size;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayGuiText(const char *text, const ztVec2 &pos, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_GuiText);

	display_entry->transform = _zt_debugDisplayPosToMat(pos);
	display_entry->text.text = zt_stringMakeFrom(&zt_game->debug_display->string_pool, text);

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayGuiTextList(const char *text)
{
	ztColor color = ztColor_White;;
	_zt_debugDisplayCheck(ztDebugDisplayType_GuiTextList);

	display_entry->transform = ztMat4::identity;
	display_entry->text.text = zt_stringMakeFrom(&zt_game->debug_display->string_pool, text);
	display_entry->item.time_to_persist = 3.f;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayLine(const ztVec3 &p0, const ztVec3 &p1, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Line);

	display_entry->transform = ztMat4::identity;
	display_entry->line.p0 = p0;
	display_entry->line.p1 = p1;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayCircle(r32 radius, i32 points, const ztVec2 &pos, const ztColor &color)
{
	ztMat4 mat = _zt_debugDisplayPosToMat(pos);
	return zt_debugDisplayCircle(radius, points, mat, color);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayCircle(r32 radius, i32 points, const ztMat4 &transform, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Circle);

	display_entry->transform = transform;
	display_entry->circle.radius = radius;
	display_entry->circle.points = points;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayRect(const ztVec2 &size, const ztVec2 &pos, const ztColor &color)
{
	ztMat4 mat = _zt_debugDisplayPosToMat(pos);
	return zt_debugDisplayRect(size, mat, color);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayRect(const ztVec2 &size, const ztMat4 &transform, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Rect);

	display_entry->transform = transform;
	display_entry->rect.size = size;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplaySphere(r32 radius, i32 points, i32 rings, const ztVec3 &pos, const ztColor &color)
{
	ztMat4 mat = _zt_debugDisplayPosToMat(pos);
	return zt_debugDisplaySphere(radius, points, rings, mat, color);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplaySphere(r32 radius, i32 points, i32 rings, const ztMat4 &transform, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Sphere);

	display_entry->transform = transform;
	display_entry->sphere.radius = radius;
	display_entry->sphere.points = points;
	display_entry->sphere.rings  = rings;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayCube(const ztVec3 &size, const ztVec3 &pos, const ztColor &color)
{
	ztMat4 mat = _zt_debugDisplayPosToMat(pos);
	return zt_debugDisplayCube(size, mat, color);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayCube(const ztVec3 &size, const ztMat4 &transform, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Cube);

	display_entry->transform = transform;
	display_entry->cube.size = size;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayText(const char *text, const ztVec2 &pos, const ztColor &color)
{
	ztMat4 mat = _zt_debugDisplayPosToMat(pos);
	return zt_debugDisplayText(text, mat, color);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayText(const char *text, const ztMat4 &transform, const ztColor &color)
{
	_zt_debugDisplayCheck(ztDebugDisplayType_Text);

	display_entry->transform = transform;
	display_entry->text.text = zt_stringMakeFrom(&zt_game->debug_display->string_pool, text);

	return &display_entry->item;
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayAxis(r32 size, const ztVec3 &pos, const ztQuat &rot)
{
	ztTransform transform;
	transform.position = pos;
	transform.rotation = rot;
	transform.scale    = ztVec3::one;
	ztMat4 mat = zt_transformToMat4(&transform);
	return zt_debugDisplayAxis(size, mat);
}

// ================================================================================================================================================================================================

ztDebugDisplayItem *zt_debugDisplayAxis(r32 size, const ztMat4 &transform)
{
	ztColor color = ztColor_White;
	_zt_debugDisplayCheck(ztDebugDisplayType_Axis);

	display_entry->transform = transform;
	display_entry->axis.size = size;

	return &display_entry->item;
}

// ================================================================================================================================================================================================

void zt_debugDisplayInit(i32 max_items, i32 string_pool_size)
{
	if (zt_game->debug_display != nullptr) {
		zt_debugDisplayCleanup();
	}

	zt_game->debug_display = zt_mallocStruct(ztDebugDisplay);

	zt_game->debug_display->display_entries = zt_mallocStructArray(ztDebugDisplayEntry, max_items);
	zt_game->debug_display->display_entries_count = 0;
	zt_game->debug_display->display_entries_size = max_items;

	int sizes[] = {16, 32, 64, 128, 256};
	int props[] = { 6,  6,  3,   1,   1};

	int strings = 0;
	zt_fize(sizes) {
		strings += props[i];
	}

	int bytes_per = zt_stringPoolBytesNeeded(strings, sizes, props, zt_elementsOf(sizes));
	int per_size = zt_convertToi32Floor(string_pool_size / (r32)bytes_per);

	zt_game->debug_display->string_pool = zt_stringPoolMake(per_size * strings, sizes, props, zt_elementsOf(sizes));
}

// ================================================================================================================================================================================================

void zt_debugDisplayCleanup()
{
	if (zt_game->debug_display == nullptr) {
		return;
	}

	zt_stringPoolFree(&zt_game->debug_display->string_pool);
	zt_free(zt_game->debug_display->display_entries);
	zt_free(zt_game->debug_display);
	zt_game->debug_display = nullptr;
}

// ================================================================================================================================================================================================

void zt_debugDisplayRemoveGuidItems(const ztGuid &guid)
{
	if (zt_game->debug_display == nullptr) {
		return;
	}

	zt_fizr(zt_game->debug_display->display_entries_count - 1) {
		if (zt_game->debug_display->display_entries[i].item.guid == guid) {
			if (zt_game->debug_display->display_entries[i].type == ztDebugDisplayType_GuiText || zt_game->debug_display->display_entries[i].type == ztDebugDisplayType_GuiTextList || zt_game->debug_display->display_entries[i].type == ztDebugDisplayType_Text) {
				zt_stringFree(&zt_game->debug_display->string_pool, zt_game->debug_display->display_entries[i].text.text);
			}

			for (int j = i; j < zt_game->debug_display->display_entries_count - 1; ++j) {
				zt_memCpy(&zt_game->debug_display->display_entries[j], zt_sizeof(ztDebugDisplayEntry), &zt_game->debug_display->display_entries[j + 1], zt_sizeof(ztDebugDisplayEntry));
			}
			zt_game->debug_display->display_entries_count -= 1;
		}
	}
}

// ================================================================================================================================================================================================

void zt_debugDisplayRenderWorld(ztDrawList *draw_list, ztCamera *camera)
{
	if (zt_game->debug_display == nullptr) {
		return;
	}

	ztColor prev_color = ztVec4::min;

	zt_drawListPushShader(draw_list, zt_shaderGetDefault(ztShaderDefault_Unlit));
	zt_drawListPushTexture(draw_list, ztTextureDefault);

	zt_fiz(zt_game->debug_display->display_entries_count) {

		ztDebugDisplayEntry *entry = &zt_game->debug_display->display_entries[i];

		bool need_continue = false;
		switch(entry->type)
		{
			case ztDebugDisplayType_GuiLine:
			case ztDebugDisplayType_GuiCircle:
			case ztDebugDisplayType_GuiRect:
			case ztDebugDisplayType_GuiText:
			case ztDebugDisplayType_GuiTextList:
				need_continue = true;
				break;
		}
		if (need_continue) {
			continue;
		}
		
		if(entry->color != prev_color) {
			if (prev_color != ztVec4::min) {
				zt_drawListPopColor(draw_list);
			}
			prev_color = entry->color;
			zt_drawListPushColor(draw_list, prev_color);
		}

		if (entry->transform != ztMat4::identity) {
			zt_drawListPushTransform(draw_list, entry->transform);
		}

		switch(entry->type)
		{
			case ztDebugDisplayType_Line: {
				zt_drawListAddLine(draw_list, entry->line.p0, entry->line.p1);
			} break;

			case ztDebugDisplayType_Circle: {
				zt_drawListAddEmptyCircle(draw_list, ztVec3::zero, entry->circle.radius, entry->circle.points);
			} break;

			case ztDebugDisplayType_Rect: {
				zt_drawListAddEmptyRect(draw_list, ztVec3::zero, entry->rect.size);
			} break;

			case ztDebugDisplayType_Sphere: {
				zt_drawListAddEmptySimpleSphere(draw_list, ztVec3::zero, entry->sphere.radius, entry->sphere.points, entry->sphere.rings);
			} break;

			case ztDebugDisplayType_Cube: {
				zt_drawListAddEmptyCubeFromCenterSize(draw_list, ztVec3::zero, entry->cube.size);
			} break;

			case ztDebugDisplayType_Text: {
				zt_drawListAddFancyText2D(draw_list, ztFontDefault, entry->text.text, ztVec2::zero, ztAlign_Default, ztAnchor_Default, nullptr, entry->color, &entry->transform);
			} break;

			case ztDebugDisplayType_Axis: {
				zt_drawListAddAxis(draw_list, entry->axis.size);
			} break;
		}

		if (entry->transform != ztMat4::identity) {
			zt_drawListPopTransform(draw_list);
		}
	}

	if (prev_color != ztVec4::min) {
		zt_drawListPopColor(draw_list);
	}

	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);
}

// ================================================================================================================================================================================================

void zt_debugDisplayRenderGui(ztDrawList *draw_list, ztCamera *camera, bool clear_for_next_frame)
{
	if (zt_game->debug_display == nullptr) {
		return;
	}

	zt_drawListPushShader(draw_list, zt_shaderGetDefault(ztShaderDefault_Unlit));
	zt_drawListPushTexture(draw_list, ztTextureDefault);

	ztColor prev_color = ztVec4::min;

	ztVec2 cam_min = zt_cameraOrthoGetMinExtent(camera);
	ztVec2 gui_list_pos = cam_min + zt_vec2(1, 1);

	i32 gui_list_count = 0;
	zt_fiz(zt_game->debug_display->display_entries_count) {
		if (zt_game->debug_display->display_entries[i].type == ztDebugDisplayType_GuiTextList) {
			gui_list_count += 1;
		}
	}

	ztVec2 text_ext = ztVec2::zero;
	if (gui_list_count > 1) {
		text_ext = zt_fontGetExtents(ztFontDefault, "[ABC],");
		gui_list_pos.y += text_ext.y * gui_list_count;
	}

	zt_fiz(zt_game->debug_display->display_entries_count) {

		ztDebugDisplayEntry *entry = &zt_game->debug_display->display_entries[i];

		bool need_continue = false;
		switch(entry->type)
		{
			case ztDebugDisplayType_Line:
			case ztDebugDisplayType_Circle:
			case ztDebugDisplayType_Rect:
			case ztDebugDisplayType_Text:
			case ztDebugDisplayType_Sphere:
			case ztDebugDisplayType_Cube:
			case ztDebugDisplayType_Axis:
				need_continue = true;
				break;
		}
		if (need_continue) {
			continue;
		}

		if(entry->color != prev_color) {
			if (prev_color != ztVec4::min) {
				zt_drawListPopColor(draw_list);
			}
			prev_color = entry->color;
			zt_drawListPushColor(draw_list, prev_color);
		}

		zt_drawListPushTransform(draw_list, entry->transform);

		switch(entry->type)
		{
			case ztDebugDisplayType_GuiLine: {
				zt_drawListAddLine(draw_list, entry->line.p0, entry->line.p1);
			} break;

			case ztDebugDisplayType_GuiCircle: {
				zt_drawListAddEmptyCircle(draw_list, ztVec3::zero, entry->circle.radius, entry->circle.points);
			} break;

			case ztDebugDisplayType_GuiRect: {
				zt_drawListAddEmptyRect(draw_list, ztVec3::zero, entry->rect.size);
			} break;

			case ztDebugDisplayType_GuiText: {
				zt_drawListAddFancyText2D(draw_list, ztFontDefault, entry->text.text, ztVec2::zero);
			} break;

			case ztDebugDisplayType_GuiTextList: {

				ztColor color = ztColor_White;
				
				r32 percent = entry->persist_time / entry->item.time_to_persist;
				if (percent > .8f) {
					color = ztVec4::lerp(ztColor_White, ztVec4::zero, zt_linearRemap(percent, .8f, 1, 0.f, 1.f));
				}

				zt_drawListAddFancyText2D(draw_list, ztFontDefault, entry->text.text, gui_list_pos, ztAlign_Left, ztAnchor_Left, nullptr, color);

				gui_list_pos.y -= text_ext.y;
			} break;
		}

		zt_drawListPopTransform(draw_list);
	}

	if (prev_color != ztVec4::min) {
		zt_drawListPopColor(draw_list);
	}

	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);

	ztGuid guid_zero = zt_guidMake(0, 0, 0, 0);

	zt_fizr(zt_game->debug_display->display_entries_count - 1) {
		ztDebugDisplayEntry *entry = &zt_game->debug_display->display_entries[i];

		bool should_remove = clear_for_next_frame;
		if (entry->item.time_to_persist > 0) {
			entry->persist_time += zt_game->game_details.current_dt;
			if (entry->persist_time <= entry->item.time_to_persist) {
				should_remove = false;
			}
		}
		if (entry->item.guid != guid_zero) {
			should_remove = false;
		}

		if (should_remove) {
			if (entry->type == ztDebugDisplayType_GuiText || entry->type == ztDebugDisplayType_Text) {
				zt_stringFree(&zt_game->debug_display->string_pool, entry->text.text);
			}

			for (int j = i; j < zt_game->debug_display->display_entries_count - 1; ++j) {
				zt_memCpy(&zt_game->debug_display->display_entries[j], zt_sizeof(ztDebugDisplayEntry), &zt_game->debug_display->display_entries[j + 1], zt_sizeof(ztDebugDisplayEntry));
			}
			zt_game->debug_display->display_entries_count -= 1;
		}
	}
}

// ================================================================================================================================================================================================

void zt_debugDisplayManualClear()
{
	ztGuid guid_zero = zt_guidMake(0, 0, 0, 0);

	zt_fizr(zt_game->debug_display->display_entries_count - 1) {
		ztDebugDisplayEntry *entry = &zt_game->debug_display->display_entries[i];

		bool should_remove = true;
		if (entry->item.time_to_persist > 0) {
			if (entry->persist_time <= entry->item.time_to_persist) {
				should_remove = false;
			}
		}
		if (entry->item.guid != guid_zero) {
			should_remove = false;
		}

		if (should_remove) {
			if (entry->type == ztDebugDisplayType_GuiText || entry->type == ztDebugDisplayType_Text) {
				zt_stringFree(&zt_game->debug_display->string_pool, entry->text.text);
			}

			for (int j = i; j < zt_game->debug_display->display_entries_count - 1; ++j) {
				zt_memCpy(&zt_game->debug_display->display_entries[j], zt_sizeof(ztDebugDisplayEntry), &zt_game->debug_display->display_entries[j + 1], zt_sizeof(ztDebugDisplayEntry));
			}
			zt_game->debug_display->display_entries_count -= 1;
		}
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMake(ztVertexArrayEntry *entries, int entries_count, void *vert_data, int vert_count)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayMake");
	zt_returnValOnNull(entries, ztInvalidID);
	zt_assertReturnValOnFail(zt_game->vertex_arrays_count < zt_elementsOf(zt_game->vertex_arrays), ztInvalidID);

	struct local
	{
		static ztVertexArrayID getNextID()
		{
			if (zt_game->vertex_arrays_count < zt_elementsOf(zt_game->vertex_arrays) - 1) {
				return zt_game->vertex_arrays_count++;
			}

			zt_fize(zt_game->vertex_arrays) {
				if (zt_game->vertex_arrays[i].renderer == ztRenderer_Invalid) {
					return i;
				}
			}

			return ztInvalidID;
		}
	};

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztVertexEntryGL gl_entries[64];
			zt_assert(entries_count < zt_elementsOf(gl_entries));
			zt_fiz(entries_count) {
				switch (entries[i].type)
				{
					case ztVertexArrayDataType_Float: {
						gl_entries[i].type = GL_FLOAT;
						gl_entries[i].size = sizeof(float) * entries[i].count;
					} break;

					case ztVertexArrayDataType_Int: {
						gl_entries[i].type = GL_INT;
						gl_entries[i].size = sizeof(int) * entries[i].count;
					} break;

					default: zt_assert(false);
				}
			}
			ztVertexArrayID va_id = local::getNextID();
			if (va_id == ztInvalidID) return ztInvalidID;

			if (!ztgl_vertexArrayMake(&zt_game->vertex_arrays[va_id].gl_va, gl_entries, entries_count, vert_data, vert_count)) {
				return ztInvalidID;
			}

			zt_game->vertex_arrays[va_id].vertices = vert_count;
			zt_game->vertex_arrays[va_id].renderer = ztRenderer_OpenGL;
			return va_id;
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			ztVertexEntryDX dx_entries[64];
			zt_assert(entries_count < zt_elementsOf(dx_entries));
			zt_fiz(entries_count) {
				dx_entries[i].size = entries[i].count * zt_vertexArrayDataSize(entries[i].type);
				// DirectX doesn't care about data types here
			}
			ztVertexArrayDX *dx_va = ztdx_vertexArrayMake(zt_game->win_details[0].dx_context, dx_entries, entries_count, vert_data, vert_count);

			if (dx_va == nullptr) {
				return ztInvalidID;
			}

			ztVertexArrayID va_id = local::getNextID();
			if (va_id == ztInvalidID) return ztInvalidID;
			zt_game->vertex_arrays[va_id].dx_va = dx_va;
			zt_game->vertex_arrays[va_id].vertices = vert_count;
			zt_game->vertex_arrays[va_id].renderer = ztRenderer_DirectX;

			return va_id;
#			endif
		} break;
	}

	return ztInvalidID;
}

// ================================================================================================================================================================================================

void zt_vertexArrayFree(ztVertexArrayID vertex_array_id)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayFree");
	if (vertex_array_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(vertex_array_id >= 0 && vertex_array_id < zt_game->vertex_arrays_count);

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztgl_vertexArrayFree(&zt_game->vertex_arrays[vertex_array_id].gl_va);
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			ztdx_vertexArrayFree(zt_game->vertex_arrays[vertex_array_id].dx_va);
			zt_game->vertex_arrays[vertex_array_id].dx_va = nullptr;
#			endif
		} break;
	}

	zt_game->vertex_arrays[vertex_array_id].renderer = ztRenderer_Invalid;
}

// ================================================================================================================================================================================================

bool zt_vertexArrayUpdate(ztVertexArrayID vertex_array_id, ztVertexArrayEntry *entries, int entries_count, void *vert_data, int vert_count)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayUpdate");
	zt_assertReturnValOnFail(vertex_array_id >= 0 && vertex_array_id < zt_game->vertex_arrays_count, false);

	zt_game->vertex_arrays[vertex_array_id].vertices = vert_count;

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztVertexEntryGL gl_entries[64];
			zt_assert(entries_count < zt_elementsOf(gl_entries));
			zt_fiz(entries_count) {
				switch (entries[i].type)
				{
					case ztVertexArrayDataType_Float: {
						gl_entries[i].type = GL_FLOAT;
						gl_entries[i].size = sizeof(float) * entries[i].count;
					} break;

					case ztVertexArrayDataType_Int: {
						gl_entries[i].type = GL_INT;
						gl_entries[i].size = sizeof(int) * entries[i].count;
					} break;

					default: zt_assert(false);
				}
			}

			return ztgl_vertexArrayUpdate(&zt_game->vertex_arrays[vertex_array_id].gl_va, gl_entries, entries_count, vert_data, vert_count);
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			return ztdx_vertexArrayUpdate(zt_game->win_details[0].dx_context, zt_game->vertex_arrays[vertex_array_id].dx_va, vert_data, vert_count);
#			endif
		} break;
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_vertexArrayDraw(ztVertexArrayID vertex_array_id, ztVertexArrayDrawType_Enum draw_type)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayDraw");
	zt_assertReturnOnFail(vertex_array_id >= 0 && vertex_array_id < zt_game->vertex_arrays_count);

	if (zt_game->vertex_arrays[vertex_array_id].vertices <= 0) {
		return;
	}

	_zt_rendererCheckToResetStats();
	zt_game->game_details.curr_frame.draw_calls += 1;

	if (draw_type == ztVertexArrayDrawType_Triangles) {
		zt_game->game_details.curr_frame.triangles_drawn += zt_game->vertex_arrays[vertex_array_id].vertices / 3;
	}

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			GLenum gl_draw_type = GL_TRIANGLES;
			switch (draw_type)
			{
				case ztVertexArrayDrawType_Triangles: {
					gl_draw_type = GL_TRIANGLES;
				} break;

				case ztVertexArrayDrawType_Lines: {
					gl_draw_type = GL_LINES;
				} break;

				case ztVertexArrayDrawType_Points: {
					gl_draw_type = GL_POINTS;
				} break;
			}
			return ztgl_vertexArrayDraw(&zt_game->vertex_arrays[vertex_array_id].gl_va, gl_draw_type);
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			D3D11_PRIMITIVE_TOPOLOGY dx_draw_type = D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
			switch (draw_type)
			{
				case ztVertexArrayDrawType_Triangles: {
					dx_draw_type = D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
				} break;

				case ztVertexArrayDrawType_Lines: {
					dx_draw_type = D3D11_PRIMITIVE_TOPOLOGY_LINELIST;
				} break;

				case ztVertexArrayDrawType_Points: {
					dx_draw_type = D3D11_PRIMITIVE_TOPOLOGY_POINTLIST;
				} break;
			}
			return ztdx_vertexArrayDraw(zt_game->win_details[0].dx_context, zt_game->vertex_arrays[vertex_array_id].dx_va, dx_draw_type);
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

int zt_vertexArrayVertexCount(ztVertexArrayID vertex_array_id)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayVertexCount");
	zt_assertReturnValOnFail(vertex_array_id >= 0 && vertex_array_id < zt_game->vertex_arrays_count, 0);

	return zt_game->vertex_arrays[vertex_array_id].vertices;
}

// ================================================================================================================================================================================================

int zt_vertexArrayDataSize(ztVertexArrayDataType_Enum type)
{
	switch(type)
	{
		case ztVertexArrayDataType_Float: return zt_sizeof(r32);
		case ztVertexArrayDataType_Int:   return zt_sizeof(i32);
	}

	zt_assert(false);
	return 0;
}

// ================================================================================================================================================================================================

i32 zt_vertexArrayGetVertices(ztVertexArrayID vertex_array_id, ztVec3 *vertices, i32 vertices_size)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayVertexCount");
	zt_assertReturnValOnFail(vertex_array_id >= 0 && vertex_array_id < zt_game->vertex_arrays_count, 0);

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(return ztgl_vertexArrayGetVertices(&zt_game->vertex_arrays[vertex_array_id].gl_va, vertices, vertices_size));
		} break;

		case ztRenderer_DirectX: {
			zt_assert(false);
		} break;
	}

	return 0;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMakeDefault(ztVertexDefault *vertices, int vertices_count)
{
	ztVertexArrayEntry entries[] = {
		{ ztVertexArrayDataType_Float, 3 }, // position
		{ ztVertexArrayDataType_Float, 2 }, // uv
		{ ztVertexArrayDataType_Float, 3 }, // normal
		{ ztVertexArrayDataType_Float, 4 }, // color
	};

	return zt_vertexArrayMake(entries, zt_elementsOf(entries), vertices, vertices_count);
}

// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayUpdateDefault(ztVertexArrayID vertex_array_id, ztVertexDefault *vertices, int vertices_count)
{
	ztVertexArrayEntry entries[] = {
		{ ztVertexArrayDataType_Float, 3 }, // position
		{ ztVertexArrayDataType_Float, 2 }, // uv
		{ ztVertexArrayDataType_Float, 3 }, // normal
		{ ztVertexArrayDataType_Float, 4 }, // color
	};

	return zt_vertexArrayUpdate(vertex_array_id, entries, zt_elementsOf(entries), vertices, vertices_count);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayMakeDefaultLit(ztVertexDefaultLit *vertices, int vertices_count)
{
	ztVertexArrayEntry entries[] = {
		{ ztVertexArrayDataType_Float, 3 }, // position
		{ ztVertexArrayDataType_Float, 2 }, // uv
		{ ztVertexArrayDataType_Float, 3 }, // normal
		{ ztVertexArrayDataType_Float, 4 }, // color
		{ ztVertexArrayDataType_Float, 4 }, // tangent
		{ ztVertexArrayDataType_Float, 4 }, // bitangent
	};

	return zt_vertexArrayMake(entries, zt_elementsOf(entries), vertices, vertices_count);
}

// ================================================================================================================================================================================================

ztVertexArrayID zt_vertexArrayUpdateDefaultLit(ztVertexArrayID vertex_array_id, ztVertexDefaultLit *vertices, int vertices_count)
{
	ztVertexArrayEntry entries[] = {
		{ ztVertexArrayDataType_Float, 3 }, // position
		{ ztVertexArrayDataType_Float, 2 }, // uv
		{ ztVertexArrayDataType_Float, 3 }, // normal
		{ ztVertexArrayDataType_Float, 4 }, // color
		{ ztVertexArrayDataType_Float, 4 }, // tangent
		{ ztVertexArrayDataType_Float, 4 }, // bitangent
	};

	return zt_vertexArrayUpdate(vertex_array_id, entries, zt_elementsOf(entries), vertices, vertices_count);
}

// ================================================================================================================================================================================================

void zt_vertexArrayDefaultCalculateTangentBitangent(const ztVertexDefaultLit& v1, const ztVertexDefaultLit& v2, const ztVertexDefaultLit& v3, ztVec4 *tangent, ztVec4 *bitangent)
{
	ZT_PROFILE_RENDERING("zt_vertexArrayDefaultCalculateTangentBitangent");

	ztVec3 edge1 = v2.position - v1.position;
	ztVec3 edge2 = v3.position - v1.position;
	ztVec2 duv1 = v2.uv - v1.uv;
	ztVec2 duv2 = v3.uv - v1.uv;

	r32 f = 1.f / (duv1.x * duv2.y - duv2.x * duv1.y);

	*tangent = zt_vec4(f * (duv2.y * edge1.x - duv1.y * edge2.x), f * (duv2.y * edge1.y - duv1.y * edge2.y), f * (duv2.y * edge1.z - duv1.y * edge2.z), 0);
	*bitangent = zt_vec4(f * (-duv2.x * edge1.x + duv1.x * edge2.x), f * (-duv2.x * edge1.y + duv1.x * edge2.y), f * (-duv2.x * edge1.z + duv1.x * edge2.z), 0);

	tangent->xyz.normalize();
	bitangent->xyz.normalize();
}

// ================================================================================================================================================================================================

void zt_triangleCalculateNormal(const ztVec3& v1, const ztVec3& v2, const ztVec3& v3, ztVec3 *normal)
{
	ztVec3 u = v2 - v1;
	ztVec3 v = v3 - v1;

	normal->x = u.y * v.z - u.z * v.y;
	normal->y = u.z * v.x - u.x * v.z;
	normal->z = u.x * v.y - u.y * v.x;

	normal->normalize();
}

// ================================================================================================================================================================================================

void zt_triangleCalculateTangentBitangent(const ztVec3& v1, const ztVec3& v2, const ztVec3& v3, const ztVec2& uv1, const ztVec2& uv2, const ztVec2& uv3, ztVec4 *tangent, ztVec4 *bitangent)
{
	ZT_PROFILE_RENDERING("zt_triangleCalculateTangentBitangent");

	ztVec3 edge1 = v2 - v1;
	ztVec3 edge2 = v3 - v1;
	ztVec2 duv1 = uv2 - uv1;
	ztVec2 duv2 = uv3 - uv1;

	r32 f = 1.f / (duv1.x * duv2.y - duv2.x * duv1.y);

	*tangent = zt_vec4(f * (duv2.y * edge1.x - duv1.y * edge2.x), f * (duv2.y * edge1.y - duv1.y * edge2.y), f * (duv2.y * edge1.z - duv1.y * edge2.z), 0);
	*bitangent = zt_vec4(f * (-duv2.x * edge1.x + duv1.x * edge2.x), f * (-duv2.x * edge1.y + duv1.x * edge2.y), f * (-duv2.x * edge1.z + duv1.x * edge2.z), 0);

	tangent->xyz.normalize();
	bitangent->xyz.normalize();
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_postProcessingEffectMake(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, ztShaderID *shaders, i32 shaders_count, ztTextureID *render_textures, i32 render_textures_count, void *user_data, ZT_FUNCTION_POINTER_VAR(render_func, ztPostProcessingEffectRender_Func), ZT_FUNCTION_POINTER_VAR(screen_change_func, ztPostProcessingEffectScreenChange_Func))
{
	zt_returnOnNull(effect);
	zt_returnOnNull(shaders);
	zt_assertReturnOnFail(shaders_count > 0);

	effect->shaders_count = shaders_count;
	effect->shaders = zt_mallocStructArray(ztShaderID, shaders_count);
	zt_memCpy(effect->shaders, zt_sizeof(ztShaderID) * shaders_count, shaders, zt_sizeof(ztShaderID) * shaders_count);

	if (render_textures_count > 0) {
		effect->render_textures_count = render_textures_count;
		effect->render_textures = zt_mallocStructArray(ztTextureID, render_textures_count);
		zt_memCpy(effect->render_textures, zt_sizeof(ztTextureID) * render_textures_count, render_textures, zt_sizeof(ztTextureID) * render_textures_count);
	}
	else {
		effect->render_textures = nullptr;
		effect->render_textures_count = 0;
	}

	effect->user_data = user_data;
	effect->render_func = render_func;
	effect->screen_change_func = screen_change_func;

	effect->screen_width = screen_w;
	effect->screen_height = screen_h;
}

// ================================================================================================================================================================================================

void zt_postProcessingEffectFree(ztPostProcessingEffect *effect)
{
	zt_returnOnNull(effect);

	zt_fiz(effect->shaders_count) {
		zt_shaderFree(effect->shaders[i]);
	}

	zt_free(effect->shaders);

	zt_fiz(effect->render_textures_count) {
		zt_textureFree(effect->render_textures[i]);
	}

	zt_free(effect->render_textures);

	if (effect->user_data) {
		zt_free(effect->user_data);
	}

	zt_memSet(effect, zt_sizeof(ztPostProcessingEffect), 0);
}

// ================================================================================================================================================================================================

void zt_postProcessingEffectUpdateScreen(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h)
{
	zt_returnOnNull(effect);
	zt_assertReturnOnFail(screen_w > 0 && screen_h > 0);

	if (effect->screen_width == screen_w && effect->screen_height == screen_h) {
		return;
	}

	ZT_FUNCTION_POINTER_ACCESS_SAFE(effect->screen_change_func, ztPostProcessingEffectScreenChange_Func)(effect, screen_w, screen_h);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessGaussianBlurDetails
{
	enum Shader_Enum
	{
		Shader_BlurHorz,
		Shader_BlurVert,

		Shader_MAX,
	};

	ztPostProcessGaussianBlur settings;
};

// ================================================================================================================================================================================================

ztInternal i32 _zt_postProcessingEffectGaussianBlurMakeTextures(ztTextureID *textures, i32 screen_w, i32 screen_h, ztPostProcessGaussianBlurDetails *details)
{
	if (textures[0] != ztInvalidID) {
		zt_textureFree(textures[0]);
	}

	textures[0] = zt_textureMakeRenderTarget(screen_w, screen_h, ztTextureFlags_HDR);
	zt_textureSetName(textures[0], "Gaussian Blur Horz");

	return 1;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectGaussianBlurRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectGaussianBlurRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectGaussianBlurRender");

	ztPostProcessGaussianBlurDetails *details = (ztPostProcessGaussianBlurDetails*)effect->user_data;

	static u32 texel_size_hash = zt_strHash("texel_size");
	ztVec2i texture_size = zt_textureGetSize(effect->render_textures[0]);
	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessGaussianBlurDetails::Shader_BlurHorz], texel_size_hash, 1.f / texture_size.x * 1.f);
	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessGaussianBlurDetails::Shader_BlurVert], texel_size_hash, 1.f / texture_size.x * 1.f);

	zt_fjz(details->settings.blur_passes) {
		zt_drawListAddScreenRenderTexture(draw_list, j == 0 ? screen_texture : target_texture, camera, 1.f, effect->shaders[ztPostProcessGaussianBlurDetails::Shader_BlurHorz]);
		zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, effect->render_textures[0]);

		zt_drawListAddScreenRenderTexture(draw_list, effect->render_textures[0], camera, 1.f, effect->shaders[ztPostProcessGaussianBlurDetails::Shader_BlurVert]);
		zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
	}
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectGaussianScreenChange, FUNC_POST_PROCESSING_EFFECT_SCREEN_CHANGE(_zt_postProcessEffectGaussianScreenChange))
{
	zt_assert(effect->render_textures_count == _zt_postProcessingEffectGaussianBlurMakeTextures(effect->render_textures, screen_w, screen_h, (ztPostProcessGaussianBlurDetails*)effect->user_data));
}

// ================================================================================================================================================================================================

ztPostProcessGaussianBlur *zt_postProcessingEffectMakeGaussianBlur(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, i32 blur_passes)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	ztShaderID shaders[2] = {
		zt_shaderGetDefault(ztShaderDefault_BlurHorz),
		zt_shaderGetDefault(ztShaderDefault_BlurVert),
	};

	ztTextureID textures[1];
	i32 textures_count = 0;

	zt_fize(textures) textures[i] = ztInvalidID;

	ztPostProcessGaussianBlurDetails *details = zt_mallocStruct(ztPostProcessGaussianBlurDetails);
	details->settings.blur_passes = blur_passes;

	textures_count = _zt_postProcessingEffectGaussianBlurMakeTextures(textures, screen_w, screen_h, details);

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), textures, textures_count, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectGaussianBlurRender), ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectGaussianScreenChange));

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessBloomDetails
{
	enum Shader_Enum
	{
		Shader_Bright,
		Shader_BlurHorz,
		Shader_BlurVert,
		Shader_BloomOut,

		Shader_MAX,
	};

	ztPostProcessBloom settings;

	r32 percentages[32];
	i32 percentages_count;
};

// ================================================================================================================================================================================================

ztInternal i32 _zt_postProcessingEffectBloomMakeTextures(ztTextureID *textures, i32 screen_w, i32 screen_h, ztPostProcessBloomDetails *details)
{
	i32 textures_count = 0;
	zt_fiz(details->percentages_count * 2 + 1) {
		if (textures[i] != ztInvalidID) {
			zt_textureFree(textures[i]);
		}
	}

	textures[textures_count++] = zt_textureMakeRenderTarget(screen_w, screen_h, ztTextureFlags_HDR);
	zt_textureSetName(textures[textures_count - 1], "Bloom Bright");

	zt_fiz(details->percentages_count) {
		textures[textures_count++] = zt_textureMakeRenderTarget(zt_convertToi32Floor(screen_w * details->percentages[i]), zt_convertToi32Floor(screen_h * details->percentages[i]), ztTextureFlags_HDR);
		zt_textureSetName(textures[textures_count - 1], "Bloom Blur Horz");
		textures[textures_count++] = zt_textureMakeRenderTarget(zt_convertToi32Floor(screen_w * details->percentages[i]), zt_convertToi32Floor(screen_h * details->percentages[i]), ztTextureFlags_HDR);
		zt_textureSetName(textures[textures_count - 1], "Bloom Blur Vert");
	}

	zt_assert(textures_count == details->percentages_count * 2 + 1);

	return textures_count;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectBloomRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectBloomRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectBloomRender");

	// render the bright areas
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[ztPostProcessBloomDetails::Shader_Bright]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, effect->render_textures[0]);

	static u32 texel_size_hash = zt_strHash("texel_size");
	ztVec2i texture_size = zt_textureGetSize(effect->render_textures[0]);
	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessBloomDetails::Shader_BlurHorz], texel_size_hash, 1.f / texture_size.x * 1.f);
	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessBloomDetails::Shader_BlurVert], texel_size_hash, 1.f / texture_size.x * 1.f);

	ztPostProcessBloomDetails *details = (ztPostProcessBloomDetails*)effect->user_data;

	// render the blurred textures
	zt_fiz(details->percentages_count) {
		i32 tex_idx = i * 2 + 1;

		zt_fjz(details->settings.blur_passes) {
			zt_drawListAddScreenRenderTexture(draw_list, j == 0 ? effect->render_textures[0] : effect->render_textures[tex_idx + 1], camera, details->percentages[i], effect->shaders[ztPostProcessBloomDetails::Shader_BlurHorz]);
			zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, effect->render_textures[tex_idx]);

			zt_drawListAddScreenRenderTexture(draw_list, effect->render_textures[tex_idx], camera, details->percentages[i], effect->shaders[ztPostProcessBloomDetails::Shader_BlurVert]);
			zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, effect->render_textures[tex_idx + 1]);
		}
	}

	// render final
	static u32 diffuse_tex_hash = zt_strHash("diffuse_tex");
	static u32 bloom_tex_count_hash = zt_strHash("bloom_tex_count");

	static u32 bloom_tex_hash[32] = { 0 };
	if (bloom_tex_hash[0] == 0) {
		zt_fize(bloom_tex_hash) {
			zt_strMakePrintf(bloom_tex, 128, "bloom_tex[%d]", i);
			bloom_tex_hash[i] = zt_strHash(bloom_tex);
		}
	}

	zt_shaderSetVariableTex(effect->shaders[ztPostProcessBloomDetails::Shader_BloomOut], diffuse_tex_hash, screen_texture);
	zt_shaderSetVariableInt(effect->shaders[ztPostProcessBloomDetails::Shader_BloomOut], bloom_tex_count_hash, (effect->render_textures_count - 1) / 2);

	i32 texture_idx = 0;
	for (int i = 2; i < effect->render_textures_count; i += 2) {
		zt_shaderSetVariableTex(effect->shaders[ztPostProcessBloomDetails::Shader_BloomOut], bloom_tex_hash[texture_idx++], effect->render_textures[i]);
	}

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[ztPostProcessBloomDetails::Shader_BloomOut]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectBloomScreenChange, FUNC_POST_PROCESSING_EFFECT_SCREEN_CHANGE(_zt_postProcessEffectBloomScreenChange))
{
	zt_assert(effect->render_textures_count == _zt_postProcessingEffectBloomMakeTextures(effect->render_textures, screen_w, screen_h, (ztPostProcessBloomDetails*)effect->user_data));
}

// ================================================================================================================================================================================================

ztPostProcessBloom *zt_postProcessingEffectMakeBloom(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, i32 blur_passes, r32 *percentages, i32 percentages_count)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	r32 local_percentages[] = { 1, 1 / 2.f, 1 / 4.f, 1 / 8.f };

	if (percentages == nullptr) {
		percentages = local_percentages;
		percentages_count = zt_elementsOf(local_percentages);
	}

	zt_strMakePrintf(bloom_out_shader, 4096, "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n	texture2d bloom_tex[%d];\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	int bloom_tex_count;\n}\n\n\nprogram Bloom\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n		\n		for(int i = 0; i < uniforms.bloom_tex_count; ++i) {\n			vec3 bloom_color = (textureSample(textures.bloom_tex[i], _input.uv) * _input.color).rgb;\n\n			bloom_color.r = max(0, min(1, bloom_color.r)); // somehow bloom_color is going negative...\n			bloom_color.g = max(0, min(1, bloom_color.g));\n			bloom_color.b = max(0, min(1, bloom_color.b));\n\n			color += bloom_color;\n		}\n		\n		_output.color = vec4(color, 1);\n	}\n}\n", percentages_count);

	ztShaderID shaders[ztPostProcessBloomDetails::Shader_MAX] = {
		zt_shaderGetDefault(ztShaderDefault_Bright),
		zt_shaderGetDefault(ztShaderDefault_BlurHorz),
		zt_shaderGetDefault(ztShaderDefault_BlurVert),
		zt_shaderMake("Bloom Out", bloom_out_shader, zt_strLen(bloom_out_shader)),
	};

	ztTextureID textures[32];
	i32 textures_count = 0;

	zt_fize(textures) textures[i] = ztInvalidID;

	zt_assertReturnValOnFail(percentages_count * 2 + 1 < zt_elementsOf(textures), false);

	ztPostProcessBloomDetails *bloom_details = zt_mallocStruct(ztPostProcessBloomDetails);
	zt_memCpy(bloom_details->percentages, zt_sizeof(r32) * zt_elementsOf(bloom_details->percentages), percentages, zt_sizeof(r32) * zt_elementsOf(bloom_details->percentages));
	bloom_details->percentages_count = percentages_count;
	bloom_details->settings.blur_passes = blur_passes;

	textures_count = _zt_postProcessingEffectBloomMakeTextures(textures, screen_w, screen_h, bloom_details);

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), textures, textures_count, bloom_details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectBloomRender), ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectBloomScreenChange));

	return &bloom_details->settings;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessColorLUTDetails
{
	ztPostProcessColorLUT settings;
};

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectColorLUTRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectColorLUTRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectColorLUTRender");

	ztPostProcessColorLUTDetails *details = (ztPostProcessColorLUTDetails*)effect->user_data;


	static u32 color_lut_one_tex_hash = zt_strHash("color_lut_one_tex");
	static u32 color_lut_two_tex_hash = zt_strHash("color_lut_two_tex");
	static u32 percentage_hash = zt_strHash("percentage");

	zt_shaderSetVariableFloat(effect->shaders[0], percentage_hash, details->settings.percentage);
	zt_shaderSetVariableTex(effect->shaders[0], color_lut_one_tex_hash, details->settings.texture_one);
	zt_shaderSetVariableTex(effect->shaders[0], color_lut_two_tex_hash, details->settings.texture_two);

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[0]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ztPostProcessColorLUT *zt_postProcessingEffectMakeColorLUT(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, ztTextureID texture_one, ztTextureID texture_two, r32 percentage)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	const char *shader = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n	texture2d color_lut_one_tex;\n	texture2d color_lut_two_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float percentage;\n}\n\nvec3 textureSample3D(vec3 uv, float width, texture2d lut_tex)\n{\n	float inner_width = width - 1.0;\n	float slice_size = 1.0 / width; // space of 1 slice\n	float slice_pixel_size = slice_size / width; // space of 1 pixel\n	float slice_inner_size = slice_pixel_size * inner_width; // space of width pixels\n	float z_slice0 = min(floor(uv.z * inner_width), inner_width);\n	float z_slice1 = min(z_slice0 + 1.0, inner_width);\n	float x_offset = slice_pixel_size * 0.5 + uv.x * slice_inner_size;\n	float s0 = x_offset + (z_slice0 * slice_size);\n	float s1 = x_offset + (z_slice1 * slice_size);\n	float y_pixel_size = slice_size;\n	float y_offset = (y_pixel_size * 0.5 + (1 - uv.y) * (1.0 - y_pixel_size));\n	vec3 slice0_color = textureSample(lut_tex, vec2(s0, y_offset)).rgb;\n	vec3 slice1_color = textureSample(lut_tex, vec2(s1, y_offset)).rgb;\n	float z_offset = fract(uv.z * inner_width);\n	vec3 result = lerp(slice0_color, slice1_color, z_offset);\n	return result;\n}\n\nprogram ColorLUT\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n		\n		vec3 lut_one = textureSample3D(color, 32, textures.color_lut_one_tex);\n		\n		if (uniforms.percentage > 0) {\n			vec3 lut_two = textureSample3D(color, 32, textures.color_lut_two_tex);\n			lut_one = lerp(lut_one, lut_two, uniforms.percentage);\n		}\n		\n		_output.color = vec4(lut_one, 1);\n	}\n}";

	ztShaderID shaders[1] = {
		zt_shaderMake("Color LUT", shader, zt_strLen(shader)),
	};

	if (shaders[0] == ztInvalidID) {
		return nullptr;
	}

	ztPostProcessColorLUTDetails *details = zt_mallocStruct(ztPostProcessColorLUTDetails);
	details->settings.texture_one = texture_one;
	details->settings.texture_two = texture_two;
	details->settings.percentage = percentage;

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), nullptr, 0, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectColorLUTRender), ZT_FUNCTION_POINTER_TO_VAR_NULL);

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessSSAODetails
{
	enum Shaders_Enum
	{
		Shaders_GenerateSSAO,
		Shaders_ApplySSAO,
	};

	ztPostProcessSSAO settings;
};

// ================================================================================================================================================================================================

ztInternal i32 _zt_postProcessingEffectSSAOMakeTextures(ztTextureID *textures, i32 screen_w, i32 screen_h, ztPostProcessSSAODetails *details)
{
	if (textures[0] != ztInvalidID) {
		zt_textureFree(textures[0]);
	}

	textures[0] = zt_textureMakeRenderTarget(screen_w, screen_h, ztTextureFlags_HDR);
	zt_textureSetName(textures[0], "SSAO");

	return 1;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectSSAORender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectSSAORender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectSSAORender");

	ztPostProcessSSAODetails *details = (ztPostProcessSSAODetails*)effect->user_data;


	static u32 position_tex_hash = zt_strHash("position_tex");
	static u32 normal_tex_hash = zt_strHash("normal_tex");
	static u32 noise_tex_hash = zt_strHash("noise_tex");
	static u32 cam_proj_hash = zt_strHash("cam_proj");
	static u32 radius_hash = zt_strHash("radius");
	static u32 bias_hash = zt_strHash("bias");
	static u32 samples_hash = zt_strHash("samples");

	zt_shaderSetVariableTex(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], position_tex_hash, details->settings.position_tex);
	zt_shaderSetVariableTex(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], normal_tex_hash, details->settings.normal_tex);
	zt_shaderSetVariableTex(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], noise_tex_hash, details->settings.noise_tex);

	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], radius_hash, details->settings.radius);
	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], bias_hash, details->settings.bias);
	zt_shaderSetVariableInt(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], samples_hash, details->settings.samples);

	zt_shaderSetVariableMat4(effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO], cam_proj_hash, details->settings.camera->mat_proj);

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[ztPostProcessSSAODetails::Shaders_GenerateSSAO]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, effect->render_textures[0]);

	static u32 intensity_hash = zt_strHash("intensity");
	static u32 ao_tex_hash = zt_strHash("ao_tex");

	zt_shaderSetVariableTex(effect->shaders[ztPostProcessSSAODetails::Shaders_ApplySSAO], ao_tex_hash, effect->render_textures[0]);

	zt_shaderSetVariableFloat(effect->shaders[ztPostProcessSSAODetails::Shaders_ApplySSAO], intensity_hash, details->settings.intensity);

	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[ztPostProcessSSAODetails::Shaders_ApplySSAO]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectSSAOScreenChange, FUNC_POST_PROCESSING_EFFECT_SCREEN_CHANGE(_zt_postProcessEffectSSAOScreenChange))
{
	zt_assert(effect->render_textures_count == _zt_postProcessingEffectSSAOMakeTextures(effect->render_textures, screen_w, screen_h, (ztPostProcessSSAODetails*)effect->user_data));
}

// ================================================================================================================================================================================================

ztPostProcessSSAO *zt_postProcessingEffectMakeSSAO(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, ztCamera *camera, ztTextureID position_tex, ztTextureID normal_tex, ztTextureID noise_tex, r32 radius, r32 bias, int samples, r32 intensity)
{
	zt_returnValOnNull(effect, nullptr);
	zt_returnValOnNull(camera, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	const char *shader_gen = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	mat4 proj;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d position_tex;\n	texture2d normal_tex;\n	texture2d noise_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	mat4 cam_proj;\n	float radius;\n	float bias;\n	int samples;\n}\n\n\nprogram AmbientOcclusion\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.proj = uniforms.cam_proj;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec2 noise_scale = textureSize(textures.position_tex) / vec2(4.0, 4.0);\n		\n		vec3 kernels[] = { vec3(-0.002653, -0.002754, 0.001899), vec3(-0.087793, -0.039482, 0.017967), vec3(-0.015935, 0.034456, 0.038461), vec3(0.016084, 0.012467, 0.003128), vec3(-0.036631, 0.008479, 0.050961), vec3(0.029393, -0.020169, 0.003774), vec3(-0.054996, 0.042855, 0.022173), vec3(-0.027956, -0.019687, 0.004943), vec3(0.004512, 0.016531, 0.012118), vec3(-0.013076, 0.000412, 0.015548), vec3(0.002620, 0.003538, 0.009588), vec3(0.044101, 0.023600, 0.000938), vec3(-0.042423, -0.002516, 0.031865), vec3(0.010303, -0.021516, 0.083335), vec3(-0.006624, -0.009561, 0.011636), vec3(0.098235, -0.085460, 0.046724), vec3(0.008439, 0.013164, 0.026478), vec3(0.006236, 0.072253, 0.056957), vec3(0.029851, 0.005779, 0.025764), vec3(-0.000024, -0.000100, 0.000855), vec3(0.021803, -0.036413, 0.027307), vec3(-0.022628, -0.100774, 0.077730), vec3(-0.140845, -0.064150, 0.055073), vec3(0.160229, 0.014875, 0.131890), vec3(-0.162901, 0.067310, 0.089489), vec3(0.009212, -0.012979, 0.019421), vec3(0.207777, 0.095488, 0.023471), vec3(-0.030307, 0.163340, 0.099766), vec3(0.012027, 0.081427, 0.076049), vec3(0.008256, -0.009202, 0.004746), vec3(-0.174059, -0.125532, 0.013659), vec3(-0.123190, -0.162086, 0.192199), vec3(0.079728, 0.045446, 0.083276), vec3(0.068169, 0.134876, 0.071926), vec3(0.011139, -0.011122, 0.001227), vec3(0.062146, -0.048333, 0.040802), vec3(0.318199, -0.194238, 0.005388), vec3(0.085928, -0.167529, 0.121446), vec3(0.035744, 0.264612, 0.218551), vec3(0.010980, 0.014685, 0.020474), vec3(-0.070881, 0.053770, 0.085137), vec3(0.190247, -0.205307, 0.058195), vec3(-0.128107, 0.048930, 0.050913), vec3(-0.414316, -0.126764, 0.022860), vec3(0.292767, -0.146901, 0.030233), vec3(0.011273, -0.010657, 0.008202), vec3(-0.331935, 0.039829, 0.017697), vec3(-0.152039, 0.111405, 0.150835), vec3(0.248028, -0.295074, 0.067144), vec3(-0.399653, 0.387673, 0.115775), vec3(0.095395, 0.077728, 0.078634), vec3(0.138522, 0.058387, 0.446292), vec3(-0.139391, 0.238982, 0.141845), vec3(0.291221, -0.412218, 0.372597), vec3(-0.057277, -0.063076, 0.079478), vec3(-0.468079, -0.235645, 0.473576), vec3(0.506897, -0.572697, 0.095597), vec3(-0.140104, 0.033207, 0.067720), vec3(0.002089, -0.006361, 0.002204), vec3(0.002283, 0.577194, 0.518092), vec3(-0.028116, 0.030414, 0.011354), vec3(0.325228, -0.451638, 0.287153), vec3(-0.515316, -0.485945, 0.523195), vec3(-0.004302, 0.027282, 0.024530) };\n\n		vec3 frag_pos   = textureSample(textures.position_tex, _input.uv).rgb;\n		vec3 normal     = textureSample(textures.normal_tex, _input.uv).rgb;\n		vec3 random_vec = vec3(textureSample(textures.noise_tex, _input.uv * noise_scale).xy, 0);\n\n		vec3 tangent = normalize(random_vec - normal * dot(random_vec, normal));\n		vec3 bitangent = cross(normal, tangent);\n		mat3 TBN = mat3(tangent, bitangent, normal);\n\n		float occlusion = 0;\n		for(int s = 0; s < uniforms.samples; ++s) {\n			vec3 sample = TBN * kernels[s]; // from tangent to view-space\n			sample = frag_pos + sample * uniforms.radius; \n\n			vec4 offset = vec4(sample, 1.0);\n			offset = uniforms.cam_proj * offset; // from view to clip-space\n			offset.xyz /= offset.w; // perspective divide\n			offset.xyz = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0\n\n			float sample_depth = textureSample(textures.position_tex, offset.xy).z;\n\n			if (sample_depth >= sample.z + uniforms.bias) {\n				float range_check = smoothstep(0.0, 1.0, uniforms.radius / abs(frag_pos.z - sample_depth));\n				occlusion += range_check;\n			}\n		}\n		\n		occlusion /= uniforms.samples;\n		_output.color = vec4(vec3(1 - occlusion), 1);\n	}\n}";
	const char *shader_apply = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n	texture2d ao_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float intensity;\n}\n\n\nprogram Tonemap\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n	\n		vec3 ao_color = textureSample(textures.ao_tex, _input.uv).rgb;\n		color *= pow(ao_color.r, uniforms.intensity);\n	\n		_output.color = vec4(color, 1);\n	}\n}\n";

	ztShaderID shaders[2] = {
		zt_shaderMake("SSAO Generate", shader_gen, zt_strLen(shader_gen)),
		zt_shaderMake("SSAO Apply", shader_apply, zt_strLen(shader_apply)),
	};

	if (shaders[0] == ztInvalidID || shaders[1] == ztInvalidID) {
		return nullptr;
	}

	ztPostProcessSSAODetails *details = zt_mallocStruct(ztPostProcessSSAODetails);
	details->settings.position_tex = position_tex;
	details->settings.normal_tex = normal_tex;
	details->settings.noise_tex = noise_tex;
	details->settings.camera = camera;
	details->settings.radius = radius;
	details->settings.bias = bias;
	details->settings.samples = samples;
	details->settings.intensity = intensity;

	ztTextureID textures[1];
	i32 textures_count = 0;
	zt_fize(textures) textures[i] = ztInvalidID;
	textures_count = _zt_postProcessingEffectSSAOMakeTextures(textures, screen_w, screen_h, details);

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), textures, textures_count, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectSSAORender), ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectSSAOScreenChange));

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessBrightnessContrastDetails
{
	ztPostProcessBrightnessContrast settings;
};

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectBrightnessContrastRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectBrightnessContrastRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectTonemapRender");

	ztPostProcessBrightnessContrastDetails *details = (ztPostProcessBrightnessContrastDetails*)effect->user_data;


	static u32 brightness_hash = zt_strHash("brightness");
	static u32 contrast_hash = zt_strHash("contrast");

	zt_shaderSetVariableFloat(effect->shaders[0], brightness_hash, details->settings.brightness);
	zt_shaderSetVariableFloat(effect->shaders[0], contrast_hash, details->settings.contrast);

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[0]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ztPostProcessBrightnessContrast *zt_postProcessingEffectMakeBrightnessContrast(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 brightness, r32 contrast)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	const char *shader = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float brightness;\n	float contrast;\n}\n\n\nprogram Tonemap\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec4 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color);\n		color.rgb /= color.a;\n		\n		color.rgb = ((color.rgb - vec3(-0.5)) * max(uniforms.contrast, 0)) + vec3(0.5);\n		color.rgb += vec3(uniforms.brightness);\n		\n		color.rgb *= color.a;\n		\n		_output.color = color;\n	}\n}";

	ztShaderID shaders[1] = {
		zt_shaderMake("Brightness/Contrast", shader, zt_strLen(shader)),
	};

	if (shaders[0] == ztInvalidID) {
		return nullptr;
	}

	ztPostProcessBrightnessContrastDetails *details = zt_mallocStruct(ztPostProcessBrightnessContrastDetails);
	details->settings.brightness = brightness;
	details->settings.contrast = contrast;

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), nullptr, 0, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectBrightnessContrastRender), ZT_FUNCTION_POINTER_TO_VAR_NULL);

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessTonemapDetails
{
	ztPostProcessTonemap settings;
};

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectTonemapRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectTonemapRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectTonemapRender");

	ztPostProcessTonemapDetails *details = (ztPostProcessTonemapDetails*)effect->user_data;


	static u32 gamma_hash = zt_strHash("gamma");
	static u32 exposure_hash = zt_strHash("exposure");

	zt_shaderSetVariableFloat(effect->shaders[0], gamma_hash, details->settings.gamma);
	zt_shaderSetVariableFloat(effect->shaders[0], exposure_hash, details->settings.exposure);

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[0]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ztPostProcessTonemap *zt_postProcessingEffectMakeTonemap(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 gamma, r32 exposure)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	const char *shader = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float gamma;\n	float exposure;\n}\n\n\nprogram Tonemap\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n		\n		vec3 mapped = vec3(1.0) - exp(-color * uniforms.exposure);\n		mapped = pow(mapped, vec3(1.0 / uniforms.gamma));\n		\n		_output.color = vec4(mapped, 1);\n	}\n}";

	ztShaderID shaders[1] = {
		zt_shaderMake("Tonemap", shader, zt_strLen(shader)),
	};

	if (shaders[0] == ztInvalidID) {
		return nullptr;
	}

	ztPostProcessTonemapDetails *details = zt_mallocStruct(ztPostProcessTonemapDetails);
	details->settings.gamma = gamma;
	details->settings.exposure = exposure;

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), nullptr, 0, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectTonemapRender), ZT_FUNCTION_POINTER_TO_VAR_NULL);

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

struct ztPostProcessVignetteDetails
{
	ztPostProcessVignette settings;
};

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_postProcessEffectVignetteRender, FUNC_POST_PROCESSING_EFFECT_RENDER(_zt_postProcessEffectVignetteRender))
{
	ZT_PROFILE_RENDERING("_zt_postProcessEffectVignetteRender");

	ztPostProcessVignetteDetails *details = (ztPostProcessVignetteDetails*)effect->user_data;


	static u32 radius_hash = zt_strHash("radius");
	static u32 softness_hash = zt_strHash("softness");
	static u32 opacity_hash = zt_strHash("opacity");

	zt_shaderSetVariableFloat(effect->shaders[0], radius_hash, details->settings.radius);
	zt_shaderSetVariableFloat(effect->shaders[0], softness_hash, details->settings.softness);
	zt_shaderSetVariableFloat(effect->shaders[0], opacity_hash, details->settings.opacity);

	// render to target
	zt_drawListAddScreenRenderTexture(draw_list, screen_texture, camera, 1, effect->shaders[0]);
	zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, target_texture);
}

// ================================================================================================================================================================================================

ztPostProcessVignette *zt_postProcessingEffectMakeVignette(ztPostProcessingEffect *effect, i32 screen_w, i32 screen_h, r32 radius, r32 softness, r32 opacity)
{
	zt_returnValOnNull(effect, nullptr);
	zt_assertReturnValOnFail(screen_w > 0 && screen_h > 0, nullptr);

	const char *shader = "struct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n	vec3 normal : 2;\n	vec4 color : 3;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n	vec3 normal;\n	vec4 color;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	texture2d diffuse_tex;\n}\n\nstruct Uniforms\n{\n	mat4 model;\n	mat4 view;\n	mat4 projection;\n	\n	float radius;\n	float softness;\n	float opacity;\n}\n\nprogram Vignette\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n		_output.uv = _input.uv;\n		_output.normal = _input.normal;\n		_output.color = _input.color;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n\n		vec2 position = (_input.uv / 1.0) - vec2(0.5);\n		float len = length(position);\n		float vignette = smoothstep(uniforms.radius, uniforms.radius - uniforms.softness, len);\n		color = lerp(color, color * vignette, uniforms.opacity);\n		\n		_output.color = vec4(color, 1);\n	}\n}\n";

	ztShaderID shaders[1] = {
		zt_shaderMake("Vignette", shader, zt_strLen(shader)),
	};

	if (shaders[0] == ztInvalidID) {
		return nullptr;
	}

	ztPostProcessVignetteDetails *details = zt_mallocStruct(ztPostProcessVignetteDetails);
	details->settings.radius = radius;
	details->settings.softness = softness;
	details->settings.opacity = opacity;

	zt_postProcessingEffectMake(effect, screen_w, screen_h, shaders, zt_elementsOf(shaders), nullptr, 0, details, ZT_FUNCTION_POINTER_TO_VAR(_zt_postProcessEffectVignetteRender), ZT_FUNCTION_POINTER_TO_VAR_NULL);

	return &details->settings;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_postProcessingStackMake(ztPostProcessingStack *stack, i32 screen_w, i32 screen_h, ztPostProcessingEffect *effects, i32 effects_count)
{
	zt_returnOnNull(stack);
	zt_returnOnNull(effects);
	zt_assertReturnOnFail(screen_w > 0 && screen_h > 0);

	stack->effects_count = zt_max(0, effects_count);

	if (effects_count == 0) {
		stack->effects = nullptr;
		stack->buffer_tex = ztInvalidID;
	}
	else {
		stack->effects = zt_mallocStructArray(ztPostProcessingEffect, effects_count);
		zt_memCpy(stack->effects, zt_sizeof(ztPostProcessingEffect) * effects_count, effects, zt_sizeof(ztPostProcessingEffect) * effects_count);

		stack->buffer_tex = zt_textureMakeRenderTarget(screen_w, screen_h, ztTextureFlags_HDR);
		zt_textureSetName(stack->buffer_tex, "PostProcessing Stack Buffer");
	}
}

// ================================================================================================================================================================================================

void zt_postProcessingStackFree(ztPostProcessingStack *stack)
{
	zt_returnOnNull(stack);

	zt_fiz(stack->effects_count) {
		zt_postProcessingEffectFree(&stack->effects[i]);
	}
	if (stack->effects) {
		zt_free(stack->effects);
	}

	if (stack->buffer_tex != ztInvalidID) {
		zt_textureFree(stack->buffer_tex);
	}

	zt_memSet(stack, zt_sizeof(ztPostProcessingStack), 0);
}

// ================================================================================================================================================================================================

void zt_postProcessingStackRender(ztPostProcessingStack *stack, ztTextureID scene_texture, ztDrawList *draw_list, ztCamera *camera)
{
	zt_returnOnNull(stack);

	ztTextureID render_tex[2] = { scene_texture, stack->buffer_tex };

	zt_fiz(stack->effects_count) {

		if (ZT_FUNCTION_POINTER_IS_VALID(stack->effects[i].render_func)) {
			ZT_FUNCTION_POINTER_ACCESS(stack->effects[i].render_func, ztPostProcessingEffectRender_Func)(&stack->effects[i], draw_list, camera, render_tex[0], render_tex[1]);
		}
		else {
			zt_drawListAddScreenRenderTexture(draw_list, render_tex[0], camera, 1, stack->effects[i].shaders[0]);
			zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, render_tex[1]);
		}
		zt_swap(render_tex[0], render_tex[1]);
	}

	if (render_tex[0] != scene_texture) {
		zt_drawListAddScreenRenderTexture(draw_list, render_tex[0], camera, 1, zt_shaderGetDefault(ztShaderDefault_Unlit));
		zt_renderDrawList(camera, draw_list, ztVec4::zero, ztRenderDrawListFlags_NoDepthTest, scene_texture);
	}
}

// ================================================================================================================================================================================================

void zt_postProcessingStackUpdateScreen(ztPostProcessingStack *stack, i32 screen_w, i32 screen_h)
{
	zt_fiz(stack->effects_count) {
		ZT_FUNCTION_POINTER_ACCESS_SAFE(stack->effects[i].screen_change_func, ztPostProcessingEffectScreenChange_Func)(&stack->effects[i], screen_w, screen_h);
	}

	if (stack->buffer_tex != ztInvalidID) {
		zt_textureFree(stack->buffer_tex);
		stack->buffer_tex = zt_textureMakeRenderTarget(screen_w, screen_h, ztTextureFlags_HDR);
		zt_textureSetName(stack->buffer_tex, "PostProcessing Stack Buffer");
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztSprite zt_spriteMake(ztTextureID tex, int x, int y, int w, int h, int anchor_x, int anchor_y)
{
	ZT_PROFILE_RENDERING("zt_spriteMake");
	zt_assert(tex != ztInvalidID);
	zt_assert(x >= 0 && y >= 0 && w != 0 && h != 0);

	r32 tex_w = (r32)zt_game->textures[tex].width;
	r32 tex_h = (r32)zt_game->textures[tex].height;

	ztSprite result;
	result.tex = tex;
	result.tex_uv.x = x / tex_w;
	result.tex_uv.y = y / tex_h;
	result.tex_uv.z = result.tex_uv.x + w / tex_w;
	result.tex_uv.w = result.tex_uv.y + h / tex_h;

	r32 ppu = zt_pixelsPerUnit();
	result.half_size.x = w / ppu / 2.f;
	result.half_size.y = h / ppu / 2.f;
	result.anchor.x = anchor_x / ppu;
	result.anchor.y = anchor_y / ppu;

	return result;
}

// ================================================================================================================================================================================================

ztSprite zt_spriteMake(ztTextureID tex, ztVec2i pos, ztVec2i size, ztVec2i anchor)
{
	return zt_spriteMake(tex, pos.x, pos.y, size.x, size.y, anchor.x, anchor.y);
}

// ================================================================================================================================================================================================

ztSprite zt_spriteMakeFromGrid(ztTextureID tex, int x, int y, int w, int h, int anchor_x, int anchor_y, int pixel_border)
{
	if (pixel_border != 0) {
		x = (x * w) + pixel_border;
		y = (y * h) + pixel_border;
		w -= pixel_border * 2;
		h -= pixel_border * 2;
		return zt_spriteMake(tex, x, y, w, h, anchor_x, anchor_y);
	}
	else {
		return zt_spriteMake(tex, x * w, y * h, w, h, anchor_x, anchor_y);
	}
}

// ================================================================================================================================================================================================

ztSprite zt_spriteMakeFromGrid(ztTextureID tex, ztVec2i pos, ztVec2i size, ztVec2i anchor, int pixel_border)
{
	if (pixel_border != 0) {
		pos.x = (pos.x * size.x) + pixel_border;
		pos.y = (pos.y * size.y) + pixel_border;
		size.x -= pixel_border * 2;
		size.y -= pixel_border * 2;
		return zt_spriteMake(tex, pos.x, pos.y, size.x, size.y, anchor.x, anchor.y);
	}
	else {
		return zt_spriteMake(tex, pos.x * size.x, pos.y * size.y, size.x, size.y, anchor.x, anchor.y);
	}
}

// ================================================================================================================================================================================================

void zt_spriteGetTriangles(ztSprite *sprite, const ztVec3 &at_pos, ztVec3 _pos[6], ztVec2 _uvs[6])
{
	ZT_PROFILE_RENDERING("zt_spriteGetTriangles");

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	r32 ppu = zt_pixelsPerUnit();

	zt_fiz(4) {
		pos[i].x += at_pos.x;
		pos[i].y += at_pos.y;

		zt_alignToPixel(&pos[i].x, ppu);
		zt_alignToPixel(&pos[i].y, ppu);
	}

	_pos[0] = pos[0];
	_pos[1] = pos[1];
	_pos[2] = pos[2];
	_pos[3] = pos[0];
	_pos[4] = pos[2];
	_pos[5] = pos[3];

	_uvs[0] = uvs[0];
	_uvs[1] = uvs[1];
	_uvs[2] = uvs[2];
	_uvs[3] = uvs[0];
	_uvs[4] = uvs[2];
	_uvs[5] = uvs[3];
}

// ================================================================================================================================================================================================

void zt_spriteGetTriangles(ztSprite *sprite, const ztVec3 &at_pos, const ztVec3 &rotation, const ztVec3 &scale, ztVec3 _pos[6], ztVec2 _uvs[6])
{
	ZT_PROFILE_RENDERING("zt_spriteGetTriangles");

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	if (rotation != ztVec3::zero) {
		if (zt_real32Eq(rotation.x, 0) && zt_real32Eq(rotation.y, 0)) {
			r32 val_cos = zt_cos(zt_degreesToRadians(rotation.z));
			r32 val_sin = zt_sin(zt_degreesToRadians(rotation.z));

			zt_fiz(4) {
				r32 tpos_x = pos[i].x;
				pos[i].x = val_cos * tpos_x - val_sin * pos[i].y;
				pos[i].y = val_sin * tpos_x + val_cos * pos[i].y;
			}
		}
		else {
			ztQuat rotation_quat = ztQuat::makeFromEuler(rotation);

			zt_fiz(4) {
				rotation_quat.rotatePosition(&pos[i]);
			}
		}
	}

	if (scale != ztVec3::one) {
		zt_fize(pos) pos[i] *= scale;
	}

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	r32 ppu = zt_pixelsPerUnit();

	zt_fiz(4) {
		pos[i].x += at_pos.x;
		pos[i].y += at_pos.y;

		zt_alignToPixel(&pos[i].x, ppu);
		zt_alignToPixel(&pos[i].y, ppu);
	}

	_pos[0] = pos[0];
	_pos[1] = pos[1];
	_pos[2] = pos[2];
	_pos[3] = pos[0];
	_pos[4] = pos[2];
	_pos[5] = pos[3];

	_uvs[0] = uvs[0];
	_uvs[1] = uvs[1];
	_uvs[2] = uvs[2];
	_uvs[3] = uvs[0];
	_uvs[4] = uvs[2];
	_uvs[5] = uvs[3];
}

// ================================================================================================================================================================================================

void zt_spriteGetTrianglesFast(ztSprite *sprite, const ztVec3 &at_pos, ztVec3 _pos[6], ztVec2 _uvs[6])
{
	ZT_PROFILE_RENDERING("zt_spriteGetTrianglesFast");

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	zt_fiz(4) {
		pos[i].x += at_pos.x;
		pos[i].y += at_pos.y;
	}

	_pos[0] = pos[0];
	_pos[1] = pos[1];
	_pos[2] = pos[2];
	_pos[3] = pos[0];
	_pos[4] = pos[2];
	_pos[5] = pos[3];

	_uvs[0] = uvs[0];
	_uvs[1] = uvs[1];
	_uvs[2] = uvs[2];
	_uvs[3] = uvs[0];
	_uvs[4] = uvs[2];
	_uvs[5] = uvs[3];
}

// ================================================================================================================================================================================================

void zt_spriteGetTrianglesFast(ztSprite *sprite, const ztVec3 &at_pos, const ztVec3 &rotation, const ztVec3 &scale, ztVec3 _pos[6], ztVec2 _uvs[6])
{
	ZT_PROFILE_RENDERING("zt_spriteGetTrianglesFast");

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	if (rotation != ztVec3::zero) {
		if (zt_real32Eq(rotation.x, 0) && zt_real32Eq(rotation.y, 0)) {
			r32 val_cos = zt_cos(zt_degreesToRadians(rotation.z));
			r32 val_sin = zt_sin(zt_degreesToRadians(rotation.z));

			zt_fiz(4) {
				r32 tpos_x = pos[i].x;
				pos[i].x = val_cos * tpos_x - val_sin * pos[i].y;
				pos[i].y = val_sin * tpos_x + val_cos * pos[i].y;
			}
		}
		else {
			ztQuat rotation_quat = ztQuat::makeFromEuler(rotation);

			zt_fiz(4) {
				rotation_quat.rotatePosition(&pos[i]);
			}
		}
	}

	if (scale != ztVec3::one) {
		zt_fize(pos) pos[i] *= scale;
	}

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	zt_fiz(4) {
		pos[i].x += at_pos.x;
		pos[i].y += at_pos.y;
	}

	_pos[0] = pos[0];
	_pos[1] = pos[1];
	_pos[2] = pos[2];
	_pos[3] = pos[0];
	_pos[4] = pos[2];
	_pos[5] = pos[3];

	_uvs[0] = uvs[0];
	_uvs[1] = uvs[1];
	_uvs[2] = uvs[2];
	_uvs[3] = uvs[0];
	_uvs[4] = uvs[2];
	_uvs[5] = uvs[3];
}

// ================================================================================================================================================================================================

void zt_drawListAddSprite(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &position)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSprite");

	if (sprite->tex < 0 || zt_game->textures[sprite->tex].renderer == ztRenderer_Invalid) {
		return;
	}

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	static ztVec3 nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

	r32 ppu = zt_pixelsPerUnit();

	zt_fiz(4) {
		pos[i].x += position.x;
		pos[i].y += position.y;

		zt_alignToPixel(&pos[i].x, ppu);
		zt_alignToPixel(&pos[i].y, ppu);
	}

	zt_drawListPushTexture(draw_list, sprite->tex);
	zt_drawListAddFilledQuad(draw_list, pos, uvs, nml);
	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================

void zt_drawListAddSprite(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &position, const ztVec3 &rot, const ztVec3 &scale)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSprite");
	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	static ztVec3 nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

	if (rot.x != 0 || rot.y != 0 || rot.z != 0) {
		ztMat4 rotation_mat = ztMat4::identity.getRotateEuler(rot);

		zt_fiz(4) {
			pos[i] = rotation_mat * pos[i];
		}
	}

	if (scale.x != 1 || scale.y != 1) {
		zt_fiz(4) {
			pos[i].x *= scale.x;
			pos[i].y *= scale.y;
		}
	}

	r32 pos_x = position.x, pos_y = position.y, ppu = zt_pixelsPerUnit();
	zt_alignToPixel(&pos_x, ppu);
	zt_alignToPixel(&pos_y, ppu);

	zt_fiz(4) {
		pos[i].x += pos_x;
		pos[i].y += pos_y;
	}

	zt_drawListPushTexture(draw_list, sprite->tex);
	zt_drawListAddFilledQuad(draw_list, pos, uvs, nml);
	zt_drawListPopTexture(draw_list);
}


// ================================================================================================================================================================================================

void zt_drawListAddSpriteFast(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &position)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSpriteFast");

	if (sprite->tex < 0 || zt_game->textures[sprite->tex].renderer == ztRenderer_Invalid) {
		return;
	}

	ztVec3 pos[4] = {
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top left
		zt_vec3(-sprite->anchor.x + -sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-sprite->anchor.x + sprite->half_size.x, -sprite->anchor.y + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	static ztVec3 nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

	zt_fiz(4) {
		pos[i].x += position.x;
		pos[i].y += position.y;
	}

	zt_drawListPushTexture(draw_list, sprite->tex);
	zt_drawListAddFilledQuad(draw_list, pos, uvs, nml);
	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================

void zt_drawListAddSpriteFast(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &position, const ztVec3 &rot, const ztVec3 &scale)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSpriteFast");

	r32 anchor_scale_x = scale.x < 0 ? -1.f : 1.f;
	r32 anchor_scale_y = scale.y < 0 ? -1.f : 1.f;

	ztVec3 pos[4] = {
		zt_vec3(-(sprite->anchor.x * anchor_scale_x) + -sprite->half_size.x, -(sprite->anchor.y * anchor_scale_y) + sprite->half_size.y, 0), // top left
		zt_vec3(-(sprite->anchor.x * anchor_scale_x) + -sprite->half_size.x, -(sprite->anchor.y * anchor_scale_y) + -sprite->half_size.y, 0), // bottom left
		zt_vec3(-(sprite->anchor.x * anchor_scale_x) + sprite->half_size.x, -(sprite->anchor.y * anchor_scale_y) + -sprite->half_size.y, 0), // bottom right
		zt_vec3(-(sprite->anchor.x * anchor_scale_x) + sprite->half_size.x, -(sprite->anchor.y * anchor_scale_y) + sprite->half_size.y, 0), // top right
	};

	ztVec2 uvs[4] = {
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
		zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
		zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y),
	};

	static ztVec3 nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

	if (rot.x != 0 || rot.y != 0 || rot.z != 0) {
		ztMat4 rotation_mat = ztMat4::identity.getRotateEuler(rot);

		zt_fiz(4) {
			pos[i] = rotation_mat * pos[i];
		}
	}

	if (scale.x != 1 || scale.y != 1) {
		bool flip_x = scale.x < 0;
		bool flip_y = scale.y < 0;

		zt_fiz(4) {
			pos[i].x *= zt_abs(scale.x);
			pos[i].y *= zt_abs(scale.y);
		}

		if (flip_x) {
			zt_swap(uvs[0].x, uvs[2].x);
			zt_swap(uvs[1].x, uvs[3].x);
		}
		if (flip_y) {
			zt_swap(uvs[0].y, uvs[1].y);
			zt_swap(uvs[2].y, uvs[3].y);
		}
	}

	r32 pos_x = position.x, pos_y = position.y;
	zt_fiz(4) {
		pos[i].x += pos_x;
		pos[i].y += pos_y;
	}

	zt_drawListPushTexture(draw_list, sprite->tex);
	zt_drawListAddFilledQuad(draw_list, pos, uvs, nml);
	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================

void zt_drawListAddSpriteTiled(ztDrawList *draw_list, ztSprite *sprite, const ztVec3 &pos, const ztVec2 &area)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSpriteTiled");

	ztVec2 size_per = sprite->half_size * 2;

	int tiles_x = zt_convertToi32Floor(area.x / size_per.x) + 1;
	int tiles_y = zt_convertToi32Floor(area.y / size_per.y) + 1;

	ztVec2 max_ext = zt_vec2(pos.x + area.x / 2, pos.y - area.y / 2);

	ztVec3 start_pos = zt_vec3((pos.x - (area.x / 2)) + sprite->half_size.x, (pos.y + (area.y / 2)) - sprite->half_size.y, 0);

	zt_drawListPushTexture(draw_list, sprite->tex);
	zt_fyz(tiles_y) {
		zt_fxz(tiles_x) {
			ztVec3 pos = start_pos + zt_vec3(x * size_per.x, -y * size_per.y, 0);

			ztVec3 spos[6];
			ztVec2 suvs[6];

			zt_spriteGetTriangles(sprite, pos, spos, suvs);

			if (spos[2].x > max_ext.x) {
				r32 diff_x = spos[2].x - max_ext.x;
				r32 diff_x_pct = diff_x / size_per.x;

				r32 uv_x = suvs[2].x - suvs[0].x;
				suvs[2].x -= uv_x * (diff_x_pct);
				suvs[4].x = suvs[2].x;
				suvs[5].x = suvs[2].x;

				spos[2].x -= diff_x;
				spos[4].x -= diff_x;
				spos[5].x -= diff_x;
			}
			if (spos[1].y < max_ext.y) {
				r32 diff_y = max_ext.y - spos[1].y;
				r32 diff_y_pct = diff_y / size_per.y;

				r32 uv_y = suvs[1].y - suvs[0].y;
				suvs[1].y -= uv_y * (diff_y_pct);
				suvs[2].y = suvs[1].y;
				suvs[4].y = suvs[1].y;
				spos[1].y += diff_y;
				spos[2].y += diff_y;
				spos[4].y += diff_y;
			}

			ztVec3 nml[3] = { ztVec3::zero, ztVec3::zero, ztVec3::zero };

			ztVec3 pos1[3] = { spos[0], spos[1], spos[2] };
			ztVec2 uvs1[3] = { suvs[0], suvs[1], suvs[2] };
			zt_drawListAddFilledTriangle(draw_list, pos1, uvs1, nml);

			ztVec3 pos2[3] = { spos[3], spos[4], spos[5] };
			ztVec2 uvs2[3] = { suvs[3], suvs[4], suvs[5] };
			zt_drawListAddFilledTriangle(draw_list, pos2, uvs2, nml);
		}
	}
	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztSpriteNineSlice zt_spriteNineSliceMake(ztTextureID tex, int tex_x, int tex_y, int tex_w, int tex_h, int nw_interior_x, int nw_interior_y, int se_interior_x, int se_interior_y, int offset_l, int offset_t, int offset_r, int offset_b)
{
	ZT_PROFILE_RENDERING("zt_spriteNineSliceMake");
	zt_assert(tex != ztInvalidID);
	zt_assert(tex_x >= 0 && tex_y >= 0 && tex_w != 0 && tex_h != 0 && nw_interior_x > tex_x && nw_interior_y > tex_y && se_interior_x < tex_x + tex_w && se_interior_y < tex_y + tex_h);

	r32 tex_atl_w = (r32)zt_game->textures[tex].width;
	r32 tex_atl_h = (r32)zt_game->textures[tex].height;

	//  0, 1,  2, 3, 4, 5,  6, 7,  8
	// nw, n, ne, w, c, e, sw, s, se

	ztSpriteNineSlice result;

	r32 x = tex_x / tex_atl_w;
	r32 y = tex_y / tex_atl_h;
	r32 w = ((r32)tex_w) / tex_atl_w;
	r32 h = ((r32)tex_h) / tex_atl_h;
	r32 nwx = ((r32)nw_interior_x) / tex_atl_w;
	r32 nwy = ((r32)nw_interior_y) / tex_atl_h;
	r32 sex = ((r32)se_interior_x) / tex_atl_w;
	r32 sey = ((r32)se_interior_y) / tex_atl_h;

	result.tex = tex;
	result.sp_nw = zt_vec4(x, y, nwx, nwy); // nw
	result.sp_n = zt_vec4(nwx, y, sex, nwy); // n
	result.sp_ne = zt_vec4(sex, y, x + w, nwy); // ne
	result.sp_w = zt_vec4(x, nwy, nwx, sey); // w
	result.sp_c = zt_vec4(nwx, nwy, sex, sey); // c
	result.sp_e = zt_vec4(sex, nwy, x + w, sey); // e
	result.sp_sw = zt_vec4(x, sey, nwx, y + h); // sw
	result.sp_s = zt_vec4(nwx, sey, sex, y + h); // s
	result.sp_se = zt_vec4(sex, sey, x + w, y + h); // se

	r32 ppu = zt_pixelsPerUnit();
	result.sz_n = (nw_interior_y - tex_y) / ppu;
	result.sz_s = ((tex_y + tex_h) - se_interior_y) / ppu;
	result.sz_w = (nw_interior_x - tex_x) / ppu;
	result.sz_e = ((tex_x + tex_w) - se_interior_x) / ppu;
	result.sz_cw = (se_interior_x - nw_interior_x) / ppu;
	result.sz_ch = (se_interior_y - nw_interior_y) / ppu;

	result.offset.x = offset_l / ppu; //tex_atl_w;
	result.offset.y = offset_t / ppu; //tex_atl_h;
	result.offset.z = offset_r / ppu; //tex_atl_w;
	result.offset.w = offset_b / ppu; //tex_atl_h;

	return result;
}

// ================================================================================================================================================================================================

ztSpriteNineSlice zt_spriteNineSliceMake(ztTextureID tex, ztVec2i tex_pos, ztVec2i tex_size, ztVec2i nw_interior, ztVec2i se_interior, int offset_l, int offset_t, int offset_r, int offset_b)
{
	return zt_spriteNineSliceMake(tex, tex_pos.x, tex_pos.y, tex_size.x, tex_size.y, nw_interior.x, nw_interior.y, se_interior.x, se_interior.y, offset_l, offset_t, offset_r, offset_b);
}

// ================================================================================================================================================================================================

void zt_drawListAddSpriteNineSlice(ztDrawList *draw_list, ztSpriteNineSlice *sns, const ztVec2 &cpos, const ztVec2 &csize)
{
	ZT_PROFILE_RENDERING("zt_drawListAddSpriteNineSlice");
	r32 ppu = zt_pixelsPerUnit();

	ztVec2 pos = cpos;
	//	zt_alignToPixel(&pos, ppu);
	ztVec2 size = csize;
	//	zt_alignToPixel(&size, ppu);

	r32 x_diff = sns->offset.z - sns->offset.x;
	r32 y_diff = sns->offset.y - sns->offset.w;

	pos.x += x_diff / 2.f;
	pos.y += y_diff / 2.f;

	size.x += sns->offset.x + sns->offset.z;
	size.y += sns->offset.y + sns->offset.w;

	ztVec2 upper_left = zt_vec2(pos.x - size.x / 2.f, pos.y + size.y / 2.f);
	ztVec2 upper_right = zt_vec2(pos.x + size.x / 2.f, pos.y + size.y / 2.f);
	ztVec2 lower_left = zt_vec2(pos.x - size.x / 2.f, pos.y - size.y / 2.f);
	ztVec2 lower_right = zt_vec2(pos.x + size.x / 2.f, pos.y - size.y / 2.f);

	upper_right.y = upper_left.y;
	lower_right.y = lower_left.y;
	lower_left.x  = upper_left.x;
	lower_right.x = upper_right.x;

	ztVec3 scale_corners = ztVec3::one;
	if (size.x < sns->sz_e + sns->sz_w) { scale_corners.x = size.x / (sns->sz_e + sns->sz_w); }
	if (size.y < sns->sz_n + sns->sz_s) { scale_corners.y = size.y / (sns->sz_n + sns->sz_s); }

	ztVec3 pos_nw[] = {
		zt_vec3(upper_left.x, upper_left.y, 0),
		zt_vec3(upper_left.x, upper_left.y - sns->sz_n * scale_corners.y, 0),
		zt_vec3(upper_left.x + sns->sz_w * scale_corners.x, upper_left.y - sns->sz_n * scale_corners.y, 0),
		zt_vec3(upper_left.x + sns->sz_w * scale_corners.x, upper_left.y, 0)
	};
	ztVec3 pos_ne[] = {
		zt_vec3(upper_right.x - sns->sz_e * scale_corners.x, upper_right.y, 0),
		zt_vec3(upper_right.x - sns->sz_e * scale_corners.x, upper_right.y - sns->sz_n * scale_corners.y, 0),
		zt_vec3(upper_right.x, upper_right.y - sns->sz_n * scale_corners.y, 0),
		zt_vec3(upper_right.x, upper_right.y, 0)
	};
	ztVec3 pos_sw[] = {
		zt_vec3(lower_left.x, lower_left.y + sns->sz_s * scale_corners.y, 0),
		zt_vec3(lower_left.x, lower_left.y, 0),
		zt_vec3(lower_left.x + sns->sz_w * scale_corners.x, lower_left.y, 0),
		zt_vec3(lower_left.x + sns->sz_w * scale_corners.x, lower_left.y + sns->sz_s * scale_corners.y, 0)
	};
	ztVec3 pos_se[] = {
		zt_vec3(lower_right.x - sns->sz_e * scale_corners.x, lower_right.y + sns->sz_s * scale_corners.y, 0),
		zt_vec3(lower_right.x - sns->sz_e * scale_corners.x, lower_right.y, 0),
		zt_vec3(lower_right.x, lower_right.y, 0),
		zt_vec3(lower_right.x, lower_right.y + sns->sz_s * scale_corners.y, 0)
	};

	// these alignments seem necessary to eliminate the occasional tile offset problem
	// not sure why two filled quads with a shared corner (exact same variable) would be off one pixel from each other on screen though
	zt_fiz(4) {
		zt_alignToPixel(&pos_nw[i], ppu);
		zt_alignToPixel(&pos_ne[i], ppu);
		zt_alignToPixel(&pos_sw[i], ppu);
		zt_alignToPixel(&pos_se[i], ppu);
	}

	zt_drawListPushTexture(draw_list, sns->tex);
	/* center     */ zt_drawListAddFilledQuad(draw_list, pos_nw[2], pos_sw[3], pos_se[0], pos_ne[1], sns->sp_c.xy, zt_vec2(sns->sp_c.x, sns->sp_c.w), sns->sp_c.zw, zt_vec2(sns->sp_c.z, sns->sp_c.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* west       */ zt_drawListAddFilledQuad(draw_list, pos_nw[1], pos_sw[0], pos_sw[3], pos_nw[2], sns->sp_w.xy, zt_vec2(sns->sp_w.x, sns->sp_w.w), sns->sp_w.zw, zt_vec2(sns->sp_w.z, sns->sp_w.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* east       */ zt_drawListAddFilledQuad(draw_list, pos_ne[1], pos_se[0], pos_se[3], pos_ne[2], sns->sp_e.xy, zt_vec2(sns->sp_e.x, sns->sp_e.w), sns->sp_e.zw, zt_vec2(sns->sp_e.z, sns->sp_e.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* north      */ zt_drawListAddFilledQuad(draw_list, pos_nw[3], pos_nw[2], pos_ne[1], pos_ne[0], sns->sp_n.xy, zt_vec2(sns->sp_n.x, sns->sp_n.w), sns->sp_n.zw, zt_vec2(sns->sp_n.z, sns->sp_n.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* south      */ zt_drawListAddFilledQuad(draw_list, pos_sw[3], pos_sw[2], pos_se[1], pos_se[0], sns->sp_s.xy, zt_vec2(sns->sp_s.x, sns->sp_s.w), sns->sp_s.zw, zt_vec2(sns->sp_s.z, sns->sp_s.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);

	/* north west */ zt_drawListAddFilledQuad(draw_list, pos_nw[0], pos_nw[1], pos_nw[2], pos_nw[3], sns->sp_nw.xy, zt_vec2(sns->sp_nw.x, sns->sp_nw.w), sns->sp_nw.zw, zt_vec2(sns->sp_nw.z, sns->sp_nw.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* north east */ zt_drawListAddFilledQuad(draw_list, pos_ne[0], pos_ne[1], pos_ne[2], pos_ne[3], sns->sp_ne.xy, zt_vec2(sns->sp_ne.x, sns->sp_ne.w), sns->sp_ne.zw, zt_vec2(sns->sp_ne.z, sns->sp_ne.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* south west */ zt_drawListAddFilledQuad(draw_list, pos_sw[0], pos_sw[1], pos_sw[2], pos_sw[3], sns->sp_sw.xy, zt_vec2(sns->sp_sw.x, sns->sp_sw.w), sns->sp_sw.zw, zt_vec2(sns->sp_sw.z, sns->sp_sw.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	/* south east */ zt_drawListAddFilledQuad(draw_list, pos_se[0], pos_se[1], pos_se[2], pos_se[3], sns->sp_se.xy, zt_vec2(sns->sp_se.x, sns->sp_se.w), sns->sp_se.zw, zt_vec2(sns->sp_se.z, sns->sp_se.y), ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero);
	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================
#if 1
void zt_spriteNineSliceGetTriangles(ztSpriteNineSlice *sns, const ztVec2 &at_pos, const ztVec2 &csize, ztVec2 pos_arr[54], ztVec2 uvs_arr[54])
{
	ZT_PROFILE_RENDERING("zt_spriteNineSliceGetTriangles");
	//r32 ppu = zt_pixelsPerUnit();

	ztVec2 pos = at_pos;
	ztVec2 size = csize;

	r32 x_diff = sns->offset.z - sns->offset.x;
	r32 y_diff = sns->offset.y - sns->offset.w;

	pos.x += x_diff / 2.f;
	pos.y += y_diff / 2.f;

	size.x += sns->offset.x + sns->offset.z;
	size.y += sns->offset.y + sns->offset.w;

	ztVec2 upper_left = zt_vec2(pos.x - size.x / 2.f, pos.y + size.y / 2.f);
	ztVec2 upper_right = zt_vec2(pos.x + size.x / 2.f, pos.y + size.y / 2.f);
	ztVec2 lower_left = zt_vec2(pos.x - size.x / 2.f, pos.y - size.y / 2.f);
	ztVec2 lower_right = zt_vec2(pos.x + size.x / 2.f, pos.y - size.y / 2.f);
	//ztVec2 center = zt_vec2(pos.x + (sns->sz_w - sns->sz_e) / 2.f, pos.y - (sns->sz_n - sns->sz_s) / 2.f);

	ztVec2 scale_corners = ztVec2::one;
	if (size.x < sns->sz_e + sns->sz_w) { scale_corners.x = size.x / (sns->sz_e + sns->sz_w); }
	if (size.y < sns->sz_n + sns->sz_s) { scale_corners.y = size.y / (sns->sz_n + sns->sz_s); }

	ztVec2 pos_nw[] = {
		zt_vec2(upper_left.x, upper_left.y),
		zt_vec2(upper_left.x, upper_left.y - sns->sz_n * scale_corners.y),
		zt_vec2(upper_left.x + sns->sz_w * scale_corners.x, upper_left.y - sns->sz_n * scale_corners.y),
		zt_vec2(upper_left.x + sns->sz_w * scale_corners.x, upper_left.y)
	};
	ztVec2 pos_ne[] = {
		zt_vec2(upper_right.x - sns->sz_e * scale_corners.x, upper_right.y),
		zt_vec2(upper_right.x - sns->sz_e * scale_corners.x, upper_right.y - sns->sz_n * scale_corners.y),
		zt_vec2(upper_right.x, upper_right.y - sns->sz_n * scale_corners.y),
		zt_vec2(upper_right.x, upper_right.y)
	};
	ztVec2 pos_sw[] = {
		zt_vec2(lower_left.x, lower_left.y + sns->sz_s * scale_corners.y),
		zt_vec2(lower_left.x, lower_left.y),
		zt_vec2(lower_left.x + sns->sz_w * scale_corners.x, lower_left.y),
		zt_vec2(lower_left.x + sns->sz_w * scale_corners.x, lower_left.y + sns->sz_s * scale_corners.y)
	};
	ztVec2 pos_se[] = {
		zt_vec2(lower_right.x - sns->sz_e * scale_corners.x, lower_right.y + sns->sz_s * scale_corners.y),
		zt_vec2(lower_right.x - sns->sz_e * scale_corners.x, lower_right.y),
		zt_vec2(lower_right.x, lower_right.y),
		zt_vec2(lower_right.x, lower_right.y + sns->sz_s * scale_corners.y)
	};

	zt_fiz(4) {
		//zt_alignToPixel(&pos_nw[i], ppu);
		//zt_alignToPixel(&pos_ne[i], ppu);
		//zt_alignToPixel(&pos_sw[i], ppu);
		//zt_alignToPixel(&pos_se[i], ppu);
	}

	struct local
	{
		static void process(ztVec2 *pos, ztVec2 *uvs, int &idx, const ztVec2 &p1, const ztVec2 &p2, const ztVec2 &p3, const ztVec2 &p4, const ztVec2 &uv1, const ztVec2 &uv2, const ztVec2 &uv3, const ztVec2 &uv4)
		{
			{
				pos[idx + 0] = p1;
				pos[idx + 1] = p2;
				pos[idx + 2] = p3;

				uvs[idx + 0] = uv1;
				uvs[idx + 1] = uv2;
				uvs[idx + 2] = uv3;

				idx += 3;
			}
			{
				pos[idx + 0] = p1;
				pos[idx + 1] = p3;
				pos[idx + 2] = p4;

				uvs[idx + 0] = uv1;
				uvs[idx + 1] = uv3;
				uvs[idx + 2] = uv4;

				idx += 3;
			}
		}
	};

	int idx = 0;
	/* center     */ local::process(pos_arr, uvs_arr, idx, pos_nw[2], pos_sw[3], pos_se[0], pos_ne[1], sns->sp_c.xy, zt_vec2(sns->sp_c.x, sns->sp_c.w), sns->sp_c.zw, zt_vec2(sns->sp_c.z, sns->sp_c.y));
	/* west       */ local::process(pos_arr, uvs_arr, idx, pos_nw[1], pos_sw[0], pos_sw[3], pos_nw[2], sns->sp_w.xy, zt_vec2(sns->sp_w.x, sns->sp_w.w), sns->sp_w.zw, zt_vec2(sns->sp_w.z, sns->sp_w.y));
	/* east       */ local::process(pos_arr, uvs_arr, idx, pos_ne[1], pos_se[0], pos_se[3], pos_ne[2], sns->sp_e.xy, zt_vec2(sns->sp_e.x, sns->sp_e.w), sns->sp_e.zw, zt_vec2(sns->sp_e.z, sns->sp_e.y));
	/* north      */ local::process(pos_arr, uvs_arr, idx, pos_nw[3], pos_nw[2], pos_ne[1], pos_ne[0], sns->sp_n.xy, zt_vec2(sns->sp_n.x, sns->sp_n.w), sns->sp_n.zw, zt_vec2(sns->sp_n.z, sns->sp_n.y));
	/* south      */ local::process(pos_arr, uvs_arr, idx, pos_sw[3], pos_sw[2], pos_se[1], pos_se[0], sns->sp_s.xy, zt_vec2(sns->sp_s.x, sns->sp_s.w), sns->sp_s.zw, zt_vec2(sns->sp_s.z, sns->sp_s.y));

	/* north west */ local::process(pos_arr, uvs_arr, idx, pos_nw[0], pos_nw[1], pos_nw[2], pos_nw[3], sns->sp_nw.xy, zt_vec2(sns->sp_nw.x, sns->sp_nw.w), sns->sp_nw.zw, zt_vec2(sns->sp_nw.z, sns->sp_nw.y));
	/* north east */ local::process(pos_arr, uvs_arr, idx, pos_ne[0], pos_ne[1], pos_ne[2], pos_ne[3], sns->sp_ne.xy, zt_vec2(sns->sp_ne.x, sns->sp_ne.w), sns->sp_ne.zw, zt_vec2(sns->sp_ne.z, sns->sp_ne.y));
	/* south west */ local::process(pos_arr, uvs_arr, idx, pos_sw[0], pos_sw[1], pos_sw[2], pos_sw[3], sns->sp_sw.xy, zt_vec2(sns->sp_sw.x, sns->sp_sw.w), sns->sp_sw.zw, zt_vec2(sns->sp_sw.z, sns->sp_sw.y));
	/* south east */ local::process(pos_arr, uvs_arr, idx, pos_se[0], pos_se[1], pos_se[2], pos_se[3], sns->sp_se.xy, zt_vec2(sns->sp_se.x, sns->sp_se.w), sns->sp_se.zw, zt_vec2(sns->sp_se.z, sns->sp_se.y));
}
#endif
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_spriteManagerMake(ztSpriteManager *sprite_manager, int max_sprites)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerMake");
	zt_returnOnNull(sprite_manager);
	zt_assertReturnOnFail(max_sprites > 0);

	sprite_manager->sprites = zt_mallocStructArray(ztSpriteManager::Entry, max_sprites);
	sprite_manager->sprites_count = max_sprites;

	zt_fiz(max_sprites) {
		sprite_manager->sprites[i].hash = 0;
		sprite_manager->sprites[i].type = ztSpriteType_Invalid;
	}
}

// ================================================================================================================================================================================================

bool zt_spriteManagerLoad(ztSpriteManager *sprite_manager, ztAssetManager *asset_mgr, ztAssetID asset_id, ztTextureID tex)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerLoad");
	zt_returnValOnNull(asset_mgr, false);
	if (asset_id == ztInvalidID) {
		zt_logCritical("sprite manager: invalid asset id");
		return false;
	}
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	zt_logDebug("sprite manager: loading: %s (%d)", asset_mgr->asset_name[asset_id], asset_id);

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		zt_logCritical("sprite manager: cannot load empty asset");
		return false;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		zt_logCritical("sprite manager unable to allocate memory");
		return false;
	}

	const char *error = nullptr;

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size, true)) {
		error = "sprite manager: unable to load asset contents";
		goto on_error;
	}

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, data, size, ZT_SPRITE_FILE_GUID)) {
		error = "sprite manager: unable to serialize file";
		goto on_error;
	}

	if (!zt_spriteManagerLoad(sprite_manager, &serial, tex)) {
		error = "sprite manager: unable to load file data";
		zt_serialClose(&serial);
		goto on_error;
	}

	zt_serialClose(&serial);
	zt_freeArena(data, asset_mgr->arena);
	return true;

on_error:
	zt_logCritical(error);
	zt_freeArena(data, asset_mgr->arena);
	return false;
}

// ================================================================================================================================================================================================

bool zt_spriteManagerLoadAll(ztSpriteManager *sprite_manager)
{
	char path[ztFileMaxPath];
	zt_fileConcatFileToPath(path, zt_elementsOf(path), zt_game->game_details.data_path, "textures");
	char files[ztFileMaxPath];
	zt_getDirectoryFiles(path, files, zt_elementsOf(files), false);

	ztToken tokens[128];
	int tokens_count = zt_min(zt_elementsOf(tokens), zt_strTokenize(files, "\n", tokens, zt_elementsOf(tokens), ztStrTokenizeFlags_TrimWhitespace));

	zt_fiz(tokens_count) {
		char file[ztFileMaxPath];
		zt_strCpy(file, zt_elementsOf(file), files + tokens[i].beg, tokens[i].len);

		if (zt_striEndsWith(file, ".spr")) {
			ztTextureID tex = ztInvalidID;
			zt_fjz(tokens_count) {
				char tex_file[ztFileMaxPath];
				zt_strCpy(tex_file, zt_elementsOf(tex_file), files + tokens[j].beg, tokens[j].len);

				if (j != i && zt_striStartsWith(tex_file, zt_strLen(tex_file), file, zt_strLen(file) - 3)) {
					tex = zt_textureMakeFromFile(tex_file);
					break;
				}
			}

			ztSerial serial;
			if (zt_serialMakeReader(&serial, file, ZT_SPRITE_FILE_GUID)) {
				zt_spriteManagerLoad(sprite_manager, &serial, tex);
				zt_serialClose(&serial);
			}
		}
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_spriteManagerLoad(ztSpriteManager *sprite_manager, ztSerial *serial, ztTextureID tex)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerLoad");
	zt_returnValOnNull(sprite_manager, false);
	zt_returnValOnNull(serial, false);

#	define _serialCheck(CODE) if(!CODE) { zt_logCritical("call failed: " #CODE); return false; }

	_serialCheck(zt_serialGroupPush(serial));
	{
		int idx = 0;
		zt_fiz(sprite_manager->sprites_count) {
			if (sprite_manager->sprites[i].hash == 0) {
				idx = i;
				break;
			}
		}

		while (true) {
			_serialCheck(zt_serialGroupPush(serial));
			{
				i32 hash = 0;
				_serialCheck(zt_serialRead(serial, &hash));

				if (hash == 0) {
					_serialCheck(zt_serialGroupPop(serial));
					break;
				}
				if (idx >= sprite_manager->sprites_count) {
					_serialCheck(zt_serialGroupPop(serial));
					break;
				}

				_serialCheck(zt_serialRead(serial, sprite_manager->sprites[idx].name, zt_elementsOf(sprite_manager->sprites[idx].name), nullptr));
				//sprite_manager->sprites[idx].hash = zt_strHash(sprite_manager->sprites[idx].name);
				sprite_manager->sprites[idx].hash = hash;

				i32 type = 0;
				_serialCheck(zt_serialRead(serial, &type));

				sprite_manager->sprites[idx].type = (ztSpriteType_Enum)type;

				_serialCheck(zt_serialGroupPush(serial));
				{
					if (sprite_manager->sprites[idx].type == ztSpriteType_Sprite) {
						sprite_manager->sprites[idx].s.tex = tex;
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].s.tex_uv));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].s.half_size));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].s.anchor));
					}
					else if (sprite_manager->sprites[idx].type == ztSpriteType_SpriteNineSlice) {
						sprite_manager->sprites[idx].sns.tex = tex;
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_nw));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_n));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_ne));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_w));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_c));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_e));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_sw));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_s));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sp_se));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_n));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_s));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_e));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_w));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_cw));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.sz_ch));
						_serialCheck(zt_serialRead(serial, &sprite_manager->sprites[idx].sns.offset));
					}
					else zt_assert(false);
				}
				_serialCheck(zt_serialGroupPop(serial));

				idx += 1;
			}
			_serialCheck(zt_serialGroupPop(serial));
		}
	}
	_serialCheck(zt_serialGroupPop(serial));

#	undef _serialCheck

	return true;
}

// ================================================================================================================================================================================================

bool zt_spriteManagerSave(ztSpriteManager *sprite_manager, ztSerial *serial)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerSave");
	zt_returnValOnNull(sprite_manager, false);
	zt_returnValOnNull(serial, false);

#	define _serialCheck(CODE) if(!CODE) return false;

	_serialCheck(zt_serialGroupPush(serial));
	{
		zt_fiz(sprite_manager->sprites_count) {
			if (sprite_manager->sprites[i].hash != 0) {
				_serialCheck(zt_serialGroupPush(serial));
				{
					_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].hash));
					_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].name, zt_elementsOf(sprite_manager->sprites[i].name)));
					_serialCheck(zt_serialWrite(serial, (i32)sprite_manager->sprites[i].type));

					_serialCheck(zt_serialGroupPush(serial));
					{
						if (sprite_manager->sprites[i].type == ztSpriteType_Sprite) {
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].s.tex_uv));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].s.half_size));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].s.anchor));
						}
						else if (sprite_manager->sprites[i].type == ztSpriteType_SpriteNineSlice) {
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_nw));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_n));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_ne));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_w));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_c));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_e));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_sw));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_s));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sp_se));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_n));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_s));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_e));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_w));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_cw));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.sz_ch));
							_serialCheck(zt_serialWrite(serial, sprite_manager->sprites[i].sns.offset));
						}
						else zt_assert(false);
					}
					_serialCheck(zt_serialGroupPop(serial));
				}
				_serialCheck(zt_serialGroupPop(serial));
			}
		}

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, 0)); // indicates end of file
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));

#	undef _serialCheck

	return true;
}

// ================================================================================================================================================================================================

void zt_spriteManagerFree(ztSpriteManager *sprite_manager, bool should_free_textures)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerFree");
	if (sprite_manager == nullptr || sprite_manager->sprites == nullptr) {
		return;
	}

	if (should_free_textures) {
		zt_fiz(sprite_manager->sprites_count) {
			ztTextureID tex = ztInvalidID;

			if (sprite_manager->sprites[i].type == ztSpriteType_Sprite) {
				tex = sprite_manager->sprites[i].s.tex;
			}
			else if (sprite_manager->sprites[i].type == ztSpriteType_SpriteNineSlice) {
				tex = sprite_manager->sprites[i].sns.tex;
			}

			if (tex != ztInvalidID) {
				zt_textureFree(tex);

				for (int j = i + 1; j < sprite_manager->sprites_count; ++j) {
					if (sprite_manager->sprites[i].type == ztSpriteType_Sprite) {
						if (sprite_manager->sprites[i].s.tex == tex) {
							sprite_manager->sprites[i].s.tex = ztInvalidID;
						}
					}
					else if (sprite_manager->sprites[i].type == ztSpriteType_SpriteNineSlice) {
						if (sprite_manager->sprites[i].sns.tex == tex) {
							sprite_manager->sprites[i].sns.tex = ztInvalidID;
						}
					}
				}
			}
		}
	}

	zt_free(sprite_manager->sprites);
	sprite_manager->sprites = nullptr;
	sprite_manager->sprites_count = 0;
}

// ================================================================================================================================================================================================

void zt_spriteManagerAddSprite(ztSpriteManager *sprite_manager, ztSprite *s, char *name)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerAddSprite");
	zt_returnOnNull(sprite_manager);
	zt_returnOnNull(s);
	zt_assertReturnOnFail(name != nullptr);

	i32 sprite_hash = zt_strHash(name);

	int idx = -1;
	zt_fiz(sprite_manager->sprites_count) {
		if (idx < 0 && sprite_manager->sprites[i].hash == 0) {
			idx = i;
		}
		if (sprite_manager->sprites[i].hash == sprite_hash) {
			idx = i;
			break;
		}
	}

	if (idx < 0) {
		zt_assert(false);
		return;
	}

	zt_strCpy(sprite_manager->sprites[idx].name, zt_elementsOf(sprite_manager->sprites[idx].name), name);
	sprite_manager->sprites[idx].hash = sprite_hash;
	sprite_manager->sprites[idx].type = ztSpriteType_Sprite;
	sprite_manager->sprites[idx].s = *s;
}

// ================================================================================================================================================================================================

void zt_spriteManagerAddSpriteNineSlice(ztSpriteManager *sprite_manager, ztSpriteNineSlice *sns, char *name)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerAddSpriteNineSlice");
	zt_returnOnNull(sprite_manager);
	zt_returnOnNull(sns);
	zt_assertReturnOnFail(name != nullptr);

	i32 sprite_hash = zt_strHash(name);

	int idx = -1;
	zt_fiz(sprite_manager->sprites_count) {
		if (idx < 0 && sprite_manager->sprites[i].hash == 0) {
			idx = i;
		}
		if (sprite_manager->sprites[i].hash == sprite_hash) {
			idx = i;
			break;
		}
	}

	if (idx < 0) {
		zt_assert(false);
		return;
	}

	zt_strCpy(sprite_manager->sprites[idx].name, zt_elementsOf(sprite_manager->sprites[idx].name), name);
	sprite_manager->sprites[idx].hash = sprite_hash;
	sprite_manager->sprites[idx].type = ztSpriteType_SpriteNineSlice;
	sprite_manager->sprites[idx].sns = *sns;
}

// ================================================================================================================================================================================================

ztSprite *zt_spriteManagerGetSprite(ztSpriteManager *sprite_manager, const char *name)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerGetSprite");
	return zt_spriteManagerGetSprite(sprite_manager, zt_strHash(name));
}

// ================================================================================================================================================================================================

ztSprite *zt_spriteManagerGetSprite(ztSpriteManager *sprite_manager, i32 sprite_hash)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerGetSprite");
	zt_returnValOnNull(sprite_manager, nullptr);

	if (sprite_hash == 0) {
		return nullptr;
	}

	zt_fiz(sprite_manager->sprites_count) {
		if (sprite_manager->sprites[i].hash == sprite_hash) {
			zt_assertReturnValOnFail(sprite_manager->sprites[i].type == ztSpriteType_Sprite, nullptr);
			return &sprite_manager->sprites[i].s;
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

ztSpriteNineSlice *zt_spriteManagerGetSpriteNineSlice(ztSpriteManager *sprite_manager, const char *name)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerGetSpriteNineSlice");
	return zt_spriteManagerGetSpriteNineSlice(sprite_manager, zt_strHash(name));
}

// ================================================================================================================================================================================================

ztSpriteNineSlice *zt_spriteManagerGetSpriteNineSlice(ztSpriteManager *sprite_manager, i32 sprite_hash)
{
	ZT_PROFILE_RENDERING("zt_spriteManagerGetSpriteNineSlice");
	zt_returnValOnNull(sprite_manager, nullptr);

	if (sprite_hash == 0) {
		return nullptr;
	}

	zt_fiz(sprite_manager->sprites_count) {
		if (sprite_manager->sprites[i].hash == sprite_hash) {
			zt_assertReturnValOnFail(sprite_manager->sprites[i].type == ztSpriteType_SpriteNineSlice, nullptr);
			return &sprite_manager->sprites[i].sns;
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

i32 zt_spriteManagerFindSpriteHash(ztSpriteManager *sprite_manager, ztSprite *sprite)
{
	zt_returnValOnNull(sprite_manager, 0);
	zt_returnValOnNull(sprite, 0);

	zt_fiz(sprite_manager->sprites_count) {
		if (sprite_manager->sprites[i].type == ztSpriteType_Sprite &&
			sprite_manager->sprites[i].s.tex == sprite->tex &&
			sprite_manager->sprites[i].s.half_size == sprite->half_size &&
			sprite_manager->sprites[i].s.tex_uv == sprite->tex_uv &&
			sprite_manager->sprites[i].s.anchor == sprite->anchor) {

			return sprite_manager->sprites[i].hash;
		}
	}

	return 0;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztLight zt_lightMakeDirectional(const ztVec3 &pos, const ztVec3 &dir, r32 intensity, r32 ambient, bool casts_shadows, const ztColor& color)
{
	ZT_PROFILE_RENDERING("zt_lightMakeDirectional");
	ztLight result;
	result.type          = ztLightType_Directional;
	result.position      = pos;
	result.direction     = dir;
	result.intensity     = intensity;
	result.ambient       = ambient;
	result.casts_shadows = casts_shadows;
	result.color         = color;
	result.cutoff_in     = 0;
	result.cutoff_out    = 0;
	return result;
}

// ================================================================================================================================================================================================

ztLight zt_lightMakeSpot(const ztVec3 &pos, const ztVec3 &dir, r32 intensity, r32 cutoff_in, r32 cutoff_out, bool casts_shadows, const ztColor& color)
{
	ZT_PROFILE_RENDERING("zt_lightMakeSpot");
	ztLight result;
	result.type          = ztLightType_Spot;
	result.position      = pos;
	result.direction     = dir;
	result.intensity     = intensity;
	result.ambient       = 0;
	result.casts_shadows = casts_shadows;
	result.color         = color;
	result.cutoff_in     = cutoff_in;
	result.cutoff_out    = cutoff_out;

	return result;
}

// ================================================================================================================================================================================================

ztLight zt_lightMakeArea(const ztVec3 &pos, r32 intensity, bool casts_shadows, const ztColor& color)
{
	ZT_PROFILE_RENDERING("zt_lightMakeArea");
	ztLight result;
	result.type          = ztLightType_Point;
	result.position      = pos;
	result.direction     = ztVec3::zero;
	result.intensity     = intensity;
	result.ambient       = 0;
	result.casts_shadows = casts_shadows;
	result.color         = color;
	result.cutoff_in     = 0;
	result.cutoff_out    = 0;
	return result;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal bool _zt_modelMakeBase(ztModel *model, ztMeshID mesh_id, ztVertexArrayID va_id, ztSprite *sprite, ztSpriteAnimController *sprite_anim_controller, ztModelSpriteFacing_Enum sprite_facing, ztParticleEmitter *emitter, ztMaterial *material, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("_zt_modelMakeBase");
	zt_returnValOnNull(model, false);
	zt_assertReturnValOnFail(shader >= 0 && shader < zt_game->shaders_count, false);

	static u32 diffuse_tex_hash  = zt_strHash("diffuse_tex");
	static u32 specular_tex_hash = zt_strHash("specular_tex");
	static u32 normal_tex_hash   = zt_strHash("normal_tex");
	static u32 height_tex_hash   = zt_strHash("height_tex");

	if (material && !zt_bitIsSet(flags, ztModelFlags_ShaderSupportsDiffuse ) && zt_shaderHasVariable(shader, material->diffuse_tex_override  ? material->diffuse_tex_override  : diffuse_tex_hash , nullptr)) flags |= ztModelFlags_ShaderSupportsDiffuse;
	if (material && !zt_bitIsSet(flags, ztModelFlags_ShaderSupportsSpecular) && zt_shaderHasVariable(shader, material->specular_tex_override ? material->specular_tex_override : specular_tex_hash, nullptr)) flags |= ztModelFlags_ShaderSupportsSpecular;
	if (material && !zt_bitIsSet(flags, ztModelFlags_ShaderSupportsNormal  ) && zt_shaderHasVariable(shader, material->normal_tex_override   ? material->normal_tex_override   : normal_tex_hash  , nullptr)) flags |= ztModelFlags_ShaderSupportsNormal;
	if (material && !zt_bitIsSet(flags, ztModelFlags_ShaderSupportsHeight  ) && zt_shaderHasVariable(shader, material->height_tex_override   ? material->height_tex_override   : height_tex_hash  , nullptr)) flags |= ztModelFlags_ShaderSupportsHeight;

	if (!zt_bitIsSet(flags, ztModelFlags_ShaderSupportsDirectionalLight) && shader < ztShaderDefault_MAX && zt_shaderHasVariable(shader, "light_pos", nullptr)) flags |= ztModelFlags_ShaderSupportsDirectionalLight;

	zt_memSet(model, zt_sizeof(ztModel), 0);

	model->name = nullptr;

	if (mesh_id != ztInvalidID) {
		model->type = ztModelType_Mesh;
		model->mesh_id = mesh_id;
	}
	else if (va_id != ztInvalidID) {
		model->type = ztModelType_VertexArray;
		model->vertex_array_id = va_id;
	}
	else if(sprite != nullptr) {
		model->type = ztModelType_Sprite;
		model->sprite = *sprite;
		model->sprite_facing = sprite_facing;
	}
	else if(sprite_anim_controller != nullptr) {
		model->type = ztModelType_SpriteAnimation;
		model->sprite_anim_controller = sprite_anim_controller;
		model->sprite_anim_facing = sprite_facing;
	}
	else if (emitter != nullptr) {
		model->type = ztModelType_ParticleSystem;
		model->particle_emitter = emitter;
	}
	else {
		model->type = ztModelType_Empty; // we'll just be an empty model (perhaps a non-visible root node)
	}

	model->flags              = flags | ztModelFlags_Initialized;
	model->shader             = shader;
	model->shader_vars        = shader_vars;
	model->material           = material ? *material : zt_materialMake();
	model->transform.position = ztVec3::zero;
	model->transform.rotation = ztQuat::identity;
	model->transform.scale    = ztVec3::one;
	model->next               = nullptr;
	model->first_child        = nullptr;
	model->parent             = parent;
	model->calculated_mat     = ztMat4::identity;
	model->aabb_size          = model->aabb_center = ztVec3::min;
	model->obb_size           = model->obb_center = ztVec3::min;
	model->anim_controller    = nullptr;

	if (parent != nullptr) {
		zt_singleLinkAddToEnd(parent->first_child, model);
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromMesh(ztModel *model, ztMeshID mesh_id, ztMaterial *material, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromMesh");
	return _zt_modelMakeBase(model, mesh_id, ztInvalidID, nullptr, nullptr, ztModelSpriteFacing_MAX, nullptr, material, shader, shader_vars, flags, parent);
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromVertexArray(ztModel *model, ztVertexArrayID va_id, ztMaterial *material, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromVertexArray");
	return _zt_modelMakeBase(model, ztInvalidID, va_id, nullptr, nullptr, ztModelSpriteFacing_MAX, nullptr, material, shader, shader_vars, flags, parent);
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromSprite(ztModel *model, ztSprite *sprite, ztModelSpriteFacing_Enum sprite_facing, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromSprite");
	ztMaterial mat = zt_materialMake(sprite->tex);
	return _zt_modelMakeBase(model, ztInvalidID, ztInvalidID, sprite, nullptr, sprite_facing, nullptr, &mat, shader, shader_vars, flags, parent);
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromSpriteAnimController(ztModel *model, ztSpriteAnimController *sprite_anim_controller, ztModelSpriteFacing_Enum sprite_facing, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromSpriteAnimController");
	ztMaterial mat = zt_materialMake();
	return _zt_modelMakeBase(model, ztInvalidID, ztInvalidID, nullptr, sprite_anim_controller, sprite_facing, nullptr, &mat, shader, shader_vars, flags, parent);
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromParticleEmitter(ztModel *model, ztParticleEmitter *emitter, ztMaterial *materials, ztShaderID shader, ztShaderVariableValues *shader_vars, i32 flags, ztModel *parent)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromParticleEmitter");
	if (emitter->system->system_rendering.type == ztParticleRenderingType_Mesh) {
		return _zt_modelMakeBase(model, ztInvalidID, ztInvalidID, nullptr, nullptr, ztModelSpriteFacing_MAX, emitter, materials, shader, shader_vars, flags, parent);
	}
	else {
		ztMaterial mat = zt_materialMake(emitter->system->system_rendering.type == ztParticleRenderingType_BillBoard ? emitter->system->system_rendering.billboard.sprite.tex : emitter->system->system_rendering.facing.sprite.tex);
		return _zt_modelMakeBase(model, ztInvalidID, ztInvalidID, nullptr, nullptr, ztModelSpriteFacing_MAX, emitter, &mat, shader, shader_vars, flags, parent);
	}
}

// ================================================================================================================================================================================================

void zt_modelFree(ztModel *model)
{
	ZT_PROFILE_RENDERING("zt_modelFree");
	if (model == nullptr) {
		return;
	}

	if (!zt_bitIsSet(model->flags, ztModelFlags_Initialized)) {
		return;
	}

	if (model->name != nullptr) {
		zt_stringFree(model->name);
	}

	ztModel *child = model->first_child;
	while (child) {
		zt_modelFree(child);
		child = child->next;
	}

	if (zt_bitIsSet(model->flags, ztModelFlags_OwnsMaterials)) {
		zt_materialFree(&model->material);
	}
	if (model->type == ztModelType_Mesh && model->mesh_id != ztInvalidID && zt_bitIsSet(model->flags, ztModelFlags_OwnsMesh)) {
		zt_meshFree(model->mesh_id);
	}

	if (model->anim_controller) {
		zt_animControllerFree(model->anim_controller);
	}

	zt_memSet(model, zt_sizeof(ztModel), 0);

	// todo: this needs changed, possibly a new flag ztModelFlags_OwnsBones?
	//if (model->bones) {
	//	zt_freeArena(model->bones, model->arena);
	//}
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromZtmFile(ztModelLoaderInput *input, ztAssetManager *asset_mgr, ztAssetID asset_id, ztShaderID shader, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromZtmFile");
	ztBlockProfiler bp("zt_modelMakeFromZtmFile (from asset)");

	void *data = nullptr;
	i32   data_size = 0;

	if (!_zt_assetLoadData(asset_mgr, asset_id, ztAssetManagerType_ModelZTM, &data, &data_size)) {
		return false;
	}

	bool result = zt_modelMakeFromZtmFile(input, data, data_size, shader, flags);

	_zt_assetFreeData(asset_mgr, data);

	return result;
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromZtmFile(ztModelLoaderInput *input, const char *file_name, ztShaderID shader, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromZtmFile");
	ztBlockProfiler bp("zt_modelMakeFromZtmFile (from file)");

	zt_returnValOnNull(input, false);

	if (!zt_fileExists(file_name)) {
		zt_logCritical("model file does not exist: %s", file_name);
		return false;
	}

	i32 file_size = 0;
	void *file_data = zt_readEntireFile(file_name, &file_size);

	if (file_data == nullptr) {
		zt_logCritical("model file could not be read: %s", file_name);
		return false;
	}

	bool result = zt_modelMakeFromZtmFile(input, file_data, file_size, shader, flags);

	zt_free(file_data);

	return result;
}

// ================================================================================================================================================================================================

bool zt_modelMakeFromZtmFile(ztModelLoaderInput *input, void *data, i32 data_size, ztShaderID shader, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_modelMakeFromZtmFile");
	ztBlockProfiler bp("zt_modelMakeFromZtmFile (from data)");

	zt_returnValOnNull(input, false);
	zt_returnValOnNull(data, false);
	zt_assertReturnValOnFail(data_size > 0, false);

	input->models_used = input->bones_used = 0;

	zt_memSet(input->models, zt_sizeof(ztModel) * input->models_size, 0);
	zt_memSet(input->bones, zt_sizeof(ztBone) * input->bones_size, 0);

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, data, data_size, ZT_MODEL_FILE_IDENTIFIER)) {
		zt_logCritical("model file is invalid or corrupt");
		return false;
	}

#	define serialCheck(code) if(!code) { zt_serialClose(&serial); zt_logCritical("model file serialization failed"); return false; }
#	define serialError(error) { zt_serialClose(&serial); zt_logCritical("model file serialization failed (%s)", error); return false; }

	// read header
	serialCheck(zt_serialGroupPush(&serial));
	{
		ztGuid file_guid;
		serialCheck(zt_serialRead(&serial, &file_guid));
		if (file_guid != ZT_MODEL_FILE_GUID) {
			serialError("File GUID mismatch");
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	const char *error_msg = nullptr;
	int *model_material_indexes = zt_mallocStructArray(int, input->models_size);

	zt_fiz(input->models_size) {
		model_material_indexes[i] = -1;
	}

	ztMaterial  *materials = nullptr;
	i32          materials_count = 0;

	ztTextureID *textures = nullptr;
	i32          textures_count = 0;

	ztMeshID    *mesh_ids = nullptr;
	ztMaterial  *mesh_materials = nullptr;
	i32         *mesh_references = nullptr;
	i32          mesh_count = 0;

	i32 root_bone_idx = -1;

	// read bones
	zt_serialGroupPush(&serial);
	{
		zt_serialGroupPush(&serial);
		{
			ztGuid guid;
			serialCheck(zt_serialRead(&serial, &guid));
			if (guid != ZT_MODEL_FILE_GUID_BONES) {
				error_msg = "Bones GUID mismatch"; goto end_processing;
			}
			i32 bones_count;
			serialCheck(zt_serialRead(&serial, &bones_count));

			zt_assert(bones_count <= input->bones_size);
			if (bones_count > input->bones_size) {
				error_msg = "Model import insufficient bone cache size"; goto end_processing;
			}
			if (bones_count > ZT_MAX_BONES) {
				error_msg = "Model has more bones than is supported"; goto end_processing;
			}

			zt_serialGroupPush(&serial);
			{
				zt_fiz(bones_count) {
					zt_serialGroupPush(&serial);
					{
						char bone_name[256] = { 0 };
						i32 bone_name_len = 0;

						serialCheck(zt_serialRead(&serial, bone_name, zt_elementsOf(bone_name), &bone_name_len));

						input->bones[i].name = zt_stringMakeFrom(bone_name);
						input->bones[i].index = i;

						ztTransform transform;
						serialCheck(zt_serialRead(&serial, &transform.position));
						serialCheck(zt_serialRead(&serial, &transform.rotation));
						serialCheck(zt_serialRead(&serial, &transform.scale));
						transform.scale = ztVec3::one;

						input->bones[i].mat_inverse_bind_transform = zt_transformToMat4(&transform);

						i32 parent_idx = -1;
						serialCheck(zt_serialRead(&serial, &parent_idx));

						zt_assert(parent_idx < i);

						if (parent_idx != -1) {
							ztBone *parent = &input->bones[parent_idx];
							ztBone *child = &input->bones[i];
							zt_singleLinkAddToEnd(parent->first_child, child);
							child->parent = parent;
						}
						else {
							zt_assert(root_bone_idx == -1);
							root_bone_idx = i;
						}
					}
					zt_serialGroupPop(&serial);
				}
			}
			zt_serialGroupPop(&serial);

			input->bones_used = bones_count;

			if (bones_count > 0) {
				struct BoneCalcs
				{
					static void calcInverseBindTransform(ztBone *bone)
					{
						bone->mat_model = bone->mat_inverse_bind_transform.getInverse();
						{
							ztTransform transform = zt_transformFromMat4(&bone->mat_model);
							transform.rotation = ztQuat::makeFromEuler(transform.rotation.euler());
							//transform.scale = ztVec3::one;
							bone->mat_model = zt_transformToMat4(&transform);
						}

						bone->mat_local_bind_transform = bone->mat_model;
						bone->mat_inverse_bind_transform = bone->mat_local_bind_transform.getInverse();

						ztMat4 mat_local = bone->parent ? bone->parent->mat_model.getInverse() * bone->mat_model : bone->mat_model;
						bone->transform = zt_transformFromMat4(&mat_local);
						bone->transform.rotation = ztQuat::makeFromEuler(bone->transform.rotation.euler());
						//bone->transform.scale = ztVec3::one;

						zt_flink(child, bone->first_child) {
							calcInverseBindTransform(child);
						}
					}
				};

				BoneCalcs::calcInverseBindTransform(&input->bones[root_bone_idx]);
			}
		}
		zt_serialGroupPop(&serial);
	}
	zt_serialGroupPop(&serial);

	// read meshes
	serialCheck(zt_serialGroupPush(&serial));
	{
		serialCheck(zt_serialGroupPush(&serial));
		{
			serialCheck(zt_serialRead(&serial, &mesh_count));
		}
		serialCheck(zt_serialGroupPop(&serial));

		if (mesh_count > 0) {
			mesh_ids = zt_mallocStructArray(ztMeshID, mesh_count);
			mesh_materials = zt_mallocStructArray(ztMaterial, mesh_count);
			mesh_references = zt_mallocStructArray(i32, mesh_count);
		}

		zt_fiz(mesh_count) {
			serialCheck(zt_serialGroupPush(&serial));
			{
				ztGuid guid;
				serialCheck(zt_serialRead(&serial, &guid));
				if (guid != ZT_MODEL_FILE_GUID_MESH) {
					error_msg = "Mesh GUID mismatch"; goto end_processing;
				}

				char mesh_name[128];
				i32 mesh_name_len = 0;
				serialCheck(zt_serialRead(&serial, mesh_name, zt_elementsOf(mesh_name), &mesh_name_len));

				i32 material_idx  = 0; serialCheck(zt_serialRead(&serial, &material_idx));
				i32 vert_count    = 0; serialCheck(zt_serialRead(&serial, &vert_count));
				i32 uv_count      = 0; serialCheck(zt_serialRead(&serial, &uv_count));
				i32 norm_count    = 0; serialCheck(zt_serialRead(&serial, &norm_count));
				i32 color_count   = 0; serialCheck(zt_serialRead(&serial, &color_count));
				i32 tangent_count = 0; serialCheck(zt_serialRead(&serial, &tangent_count));
				i32 indices_count = 0; serialCheck(zt_serialRead(&serial, &indices_count));
				i32 bone_count    = 0; serialCheck(zt_serialRead(&serial, &bone_count));

				ztVec3 *verts    = zt_mallocStructArray(ztVec3, vert_count);
				ztVec2 *uvs      = uv_count      != 0 ? zt_mallocStructArray(ztVec2, uv_count) : nullptr;
				ztVec3 *norms    = norm_count    != 0 ? zt_mallocStructArray(ztVec3, norm_count) : nullptr;
				ztVec4 *colors   = color_count   != 0 ? zt_mallocStructArray(ztVec4, color_count) : nullptr;
				ztVec3 *tangents = tangent_count != 0 ? zt_mallocStructArray(ztVec3, tangent_count) : nullptr;
				u32    *indices  = indices_count != 0 ? zt_mallocStructArray(u32, indices_count) : nullptr;

#				pragma pack(push, 1)
				struct ztBoneInfo
				{
					ztVec4i bones;
					ztVec4  weights;
				};
#				pragma pack(pop)

				ztBoneInfo *vert_bones = bone_count != 0 ? zt_mallocStructArray(ztBoneInfo, vert_count) : nullptr;
				ztBone* root_bone = nullptr;
				i32 bone_start_idx = input->bones_used;
				i32 bone_root_idx = 0;

				serialCheck(zt_serialGroupPush(&serial));
				{
					serialCheck(zt_serialGroupPush(&serial));
					{
						ztGuid guid_verts;
						serialCheck(zt_serialRead(&serial, &guid_verts));
						if (guid_verts != ZT_MODEL_FILE_GUID_MESH_VERTICES) {
							error_msg = "Mesh vertices GUID mismatch"; goto end_processing;
						}

						zt_fxz(vert_count) {
							serialCheck(zt_serialRead(&serial, &verts[x]));
						}
					}
					serialCheck(zt_serialGroupPop(&serial));

					if (uv_count > 0) {
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_uvs;
							serialCheck(zt_serialRead(&serial, &guid_uvs));
							if (guid_uvs != ZT_MODEL_FILE_GUID_MESH_UVS) {
								error_msg = "Mesh uvs GUID mismatch"; goto end_processing;
							}

							zt_fxz(uv_count) {
								serialCheck(zt_serialRead(&serial, &uvs[x]));
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}

					if (norm_count > 0) {
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_norms;
							serialCheck(zt_serialRead(&serial, &guid_norms));
							if (guid_norms != ZT_MODEL_FILE_GUID_MESH_NORMALS) {
								error_msg = "Mesh normals GUID mismatch"; goto end_processing;
							}

							zt_fxz(norm_count) {
								serialCheck(zt_serialRead(&serial, &norms[x]));
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}

					if (color_count > 0) {
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_color;
							serialCheck(zt_serialRead(&serial, &guid_color));
							if (guid_color != ZT_MODEL_FILE_GUID_MESH_COLORS) {
								error_msg = "Mesh colors GUID mismatch"; goto end_processing;
							}

							zt_fxz(color_count) {
								serialCheck(zt_serialRead(&serial, &colors[x]));
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}

					if (tangent_count > 0) {
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_tang;
							serialCheck(zt_serialRead(&serial, &guid_tang));
							if (guid_tang != ZT_MODEL_FILE_GUID_MESH_TANGENTS) {
								error_msg = "Mesh tangents GUID mismatch"; goto end_processing;
							}

							zt_fxz(tangent_count) {
								serialCheck(zt_serialRead(&serial, &tangents[x]));
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}

					if (indices_count > 0) {
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_tang;
							serialCheck(zt_serialRead(&serial, &guid_tang));
							if (guid_tang != ZT_MODEL_FILE_GUID_MESH_INDICES) {
								error_msg = "Mesh indices GUID mismatch"; goto end_processing;
							}

							zt_fxz(indices_count) {
								serialCheck(zt_serialRead(&serial, &indices[x]))
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}

					if (bone_count > 0) {
						zt_memSet(vert_bones, zt_sizeof(ztBoneInfo) * vert_count, 0);
						serialCheck(zt_serialGroupPush(&serial));
						{
							ztGuid guid_bone;
							serialCheck(zt_serialRead(&serial, &guid_bone));
							if (guid_bone != ZT_MODEL_FILE_GUID_MESH_BONES) {
								error_msg = "Mesh bones GUID mismatch"; goto end_processing;
							}

							zt_fkz(bone_count) {
								serialCheck(zt_serialGroupPush(&serial));
								{
									char bone_name[128];
									i32 bone_name_len = 0;
									serialCheck(zt_serialRead(&serial, bone_name, zt_elementsOf(bone_name), &bone_name_len));

									i32 bone_idx = -1;
									zt_fiz(input->bones_used) {
										if (zt_strEquals(input->bones[i].name, bone_name)) {
											bone_idx = i;
											break;
										}
									}
									zt_assert(bone_idx >= 0 && bone_idx < input->bones_used);

									i32 weights = 0;
									serialCheck(zt_serialRead(&serial, &weights));

									zt_fiz(weights) {
										i32 vertex_idx;
										r32 weight;
										serialCheck(zt_serialRead(&serial, &vertex_idx));
										serialCheck(zt_serialRead(&serial, &weight));

										if (vertex_idx >= 0 && vertex_idx < vert_count) {
											bool found = false;
											zt_fxze(vert_bones[vertex_idx].bones.values) {
												if (vert_bones[vertex_idx].bones.values[x] == 0) {
													vert_bones[vertex_idx].bones.values[x] = zt_max(0, bone_idx);
													vert_bones[vertex_idx].weights.values[x] = weight;
													found = true;
													break;
												}
											}
											zt_assert(found);
										}
										else zt_assert(false);
									}
								}
								serialCheck(zt_serialGroupPop(&serial));
							}

							zt_fkz(vert_count) {
#								if 0
								int total_bones = 0;
								r32 total_weights = 0;

								zt_fize(vert_bones[k].bones.values) {
									if (vert_bones[k].bones.values[i] == 0 && vert_bones[k].weights.values[i] != 0) {
										zt_assert(false);
									}
									if (vert_bones[k].bones.values[i] != 0 && vert_bones[k].weights.values[i] == 0) {
										zt_assert(false);
									}
									total_bones += vert_bones[k].bones.values[i];
									total_weights += vert_bones[k].weights.values[i];
								}

								if (total_bones == 0 || total_weights == 0) {
									zt_assert(false);
								}
#								endif

								r32 weight_total = 0;
								zt_fize(vert_bones[k].weights.values) {
									weight_total += vert_bones[k].weights.values[i];
								}

								if (!zt_real32Eq(weight_total, 1)) {
									zt_fize(vert_bones[k].weights.values) {
										vert_bones[k].weights.values[i] = vert_bones[k].weights.values[i] / weight_total;
									}
								}
							}
						}
						serialCheck(zt_serialGroupPop(&serial));
					}
				}
				serialCheck(zt_serialGroupPop(&serial));

				if (input->models_used >= input->models_size) {
					zt_assert(false);
					error_msg = "Input models array not large enough"; goto end_processing;
				}

				// todo(josh): need to support colors in zt_meshMake...

				ztMeshID mesh_id = ztInvalidID;
				
				if (bone_count > 0) {
					ztVertexArrayEntry bones_entries[] = {
						{ ztVertexArrayDataType_Int, 4 },
						{ ztVertexArrayDataType_Float, 4 },
					};

					mesh_id = zt_meshMake(verts, uvs, norms, vert_count, indices, indices_count, vert_bones, bones_entries, zt_elementsOf(bones_entries), ztColor_White);
				}
				else {
					mesh_id = zt_meshMake(verts, uvs, norms, vert_count, indices, indices_count, ztColor_White);
				}

				model_material_indexes[input->models_used] = material_idx;
				mesh_ids[i]        = mesh_id;
				mesh_materials[i]  = zt_materialMake();
				mesh_references[i] = 0;

				if (indices)    zt_free(indices);
				if (tangents)   zt_free(tangents);
				if (colors)     zt_free(colors);
				if (norms)      zt_free(norms);
				if (uvs)        zt_free(uvs);
				if (verts)      zt_free(verts);
				if (vert_bones) zt_free(vert_bones);
			}
			serialCheck(zt_serialGroupPop(&serial));
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	// read model hierarchy
	serialCheck(zt_serialGroupPush(&serial));
	{
		i32 models_that_can_have_bones = input->models_used;

		struct ModelHierarchy
		{
			static bool process(ztModelLoaderInput *input, ztMeshID *mesh_ids, i32 *mesh_references, i32 mesh_count, ztSerial *serial, ztShaderID shader, i32 flags, ztModel *parent)
			{
				if (!zt_serialGroupPush(serial)) return false;
				{
					ztTransform transform;
					i32         meshes = 0;
					i32         children = 0;
					char        name[128];
					int         name_len = 0;

					if (!zt_serialGroupPush(serial)) return false;
					{
						if (!zt_serialRead(serial, &transform.position)) return false;
						if (!zt_serialRead(serial, &transform.rotation)) return false;
						if (!zt_serialRead(serial, &transform.scale)) return false;

						if (!zt_serialRead(serial, &meshes)) return false;
						if (!zt_serialRead(serial, &children)) return false;
						if (!zt_serialRead(serial, name, zt_elementsOf(name), &name_len)) return false;
					}
					if (!zt_serialGroupPop(serial)) return false;

					ztModel *this_model = nullptr;

					if (meshes > 1 || children > 1) {
						if (input->models_used >= input->models_size) {
							zt_assert(false);
							zt_logCritical("model input cache overflow");
							return false;
						}

						this_model = &input->models[input->models_used++];
						zt_modelMakeFromMesh(this_model, ztInvalidID, nullptr, shader, nullptr, flags, parent);
						this_model->transform = transform;
					}

					if (!zt_serialGroupPush(serial)) return false;
					{
						zt_fiz(meshes) {
							if (!zt_serialGroupPush(serial)) return false;
							{
								i32 mesh_idx = -1;
								if (!zt_serialRead(serial, &mesh_idx)) return false;
								if(mesh_idx < 0 || mesh_idx > mesh_count) return false;

								if (input->models_used >= input->models_size) {
									zt_assert(false);
									zt_logCritical("model input cache overflow");
									return false;
								}

								mesh_references[mesh_idx] += 1;

								ztModel *model = &input->models[input->models_used++];
								zt_modelMakeFromMesh(model, mesh_ids[mesh_idx], nullptr, shader, nullptr, flags | (mesh_references[mesh_idx] == 1 ? ztModelFlags_OwnsMesh : 0), this_model);

								if (this_model == nullptr) {
									this_model = model;
									this_model->transform = transform;

									if (parent) {
										zt_modelChildAdd(parent, this_model);
									}
								}
							}
							if (!zt_serialGroupPop(serial)) return false;
						}
					}
					if (!zt_serialGroupPop(serial)) return false;

					if (!zt_serialGroupPush(serial)) return false;
					{
						if (this_model == nullptr) {
							if (input->models_used >= input->models_size) {
								zt_assert(false);
								zt_logCritical("model input cache overflow");
								return false;
							}

							this_model = &input->models[input->models_used++];
							zt_modelMakeFromMesh(this_model, ztInvalidID, nullptr, shader, nullptr, flags, parent);
							this_model->transform = transform;
						}

						zt_fiz(children) {
							if (!process(input, mesh_ids, mesh_references, mesh_count, serial, shader, flags, this_model)) {
								return false;
							}
						}
					}
					if (!zt_serialGroupPop(serial)) return false;

					if (name_len > 0) {
						if (this_model->name == nullptr) {
							this_model->name = zt_stringMakeFrom(name);
						}
					}

					if (parent == nullptr) {
						input->root_model = this_model;
					}
				}
				if (!zt_serialGroupPop(serial)) return false;

				return true;
			}
		};

		ztGuid guid_hier;
		serialCheck(zt_serialRead(&serial, &guid_hier));
		if (guid_hier != ZT_MODEL_FILE_GUID_HIERARCHY) {
			error_msg = "Model hierarchy GUID mismatch"; goto end_processing;
		}

		if (!ModelHierarchy::process(input, mesh_ids, mesh_references, mesh_count, &serial, shader, flags, nullptr)) {
			error_msg = "Model hierarchy read error"; goto end_processing;
		}

		if (input->bones_used > 0) {
			zt_assert(input->root_model);

			zt_fiz(input->models_used) {
				input->models[i].bones           = &input->bones[0];
				input->models[i].bones_count     = input->bones_used;
				input->models[i].bones_root_idx  = root_bone_idx;
				input->models[i].flags           = input->root_model == &input->models[i] ? 0 : ztModelFlags_NoCalcBones;
			}
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	// read materials
	serialCheck(zt_serialGroupPush(&serial));
	{
		serialCheck(zt_serialGroupPush(&serial));
		{
			serialCheck(zt_serialRead(&serial, &materials_count));
		}
		serialCheck(zt_serialGroupPop(&serial));

		if (materials_count > 0) {
			materials = zt_mallocStructArray(ztMaterial, materials_count);

			zt_fiz(materials_count) {
				materials[i] = zt_materialMake();

				serialCheck(zt_serialGroupPush(&serial));
				{
					ztGuid guid;
					serialCheck(zt_serialRead(&serial, &guid));
					if (guid != ZT_MODEL_FILE_GUID_MATERIAL) {
						error_msg = "Material GUID mismatch"; goto end_processing;
					}

					serialCheck(zt_serialRead(&serial, &materials[i].diffuse_color));
					serialCheck(zt_serialRead(&serial, &materials[i].specular_color));
					serialCheck(zt_serialRead(&serial, &materials[i].shininess));

					i32 textures_count = 0;
					serialCheck(zt_serialRead(&serial, &textures_count));

					serialCheck(zt_serialGroupPush(&serial));
					{
						zt_fxz(textures_count) {
							i32 tex_type = 0, tex_idx = 0;
							serialCheck(zt_serialGroupPush(&serial));
							serialCheck(zt_serialRead(&serial, &tex_type));
							serialCheck(zt_serialRead(&serial, &tex_idx));
							serialCheck(zt_serialGroupPop(&serial));

							switch(tex_type)
							{
								case ZT_MODEL_FILE_MATTEXTYPE_DIFFUSE:    materials[i].diffuse_tex   = tex_idx; break;
								case ZT_MODEL_FILE_MATTEXTYPE_NORMALS:    materials[i].normal_tex    = tex_idx; break;
								case ZT_MODEL_FILE_MATTEXTYPE_SPECULAR:   materials[i].specular_tex  = tex_idx; break;
								case ZT_MODEL_FILE_MATTEXTYPE_HEIGHT:     materials[i].height_tex    = tex_idx; break;
								case ZT_MODEL_FILE_MATTEXTYPE_REFLECTION: materials[i].roughness_tex = tex_idx; break; //!
								case ZT_MODEL_FILE_MATTEXTYPE_EMISSIVE:   break; // todo
								default: zt_assert(false);
							}
						}
					}
					serialCheck(zt_serialGroupPop(&serial));
				}
				serialCheck(zt_serialGroupPop(&serial));
			}
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	// read textures
	serialCheck(zt_serialGroupPush(&serial));
	{
		serialCheck(zt_serialGroupPush(&serial));
		{
			serialCheck(zt_serialRead(&serial, &textures_count));
		}
		serialCheck(zt_serialGroupPop(&serial));

		textures = textures_count == 0 ? nullptr : zt_mallocStructArray(ztTextureID, textures_count);

		zt_fiz(textures_count) {
			textures[i] = ztInvalidID;

			serialCheck(zt_serialGroupPush(&serial));
			{
				ztGuid guid;
				serialCheck(zt_serialRead(&serial, &guid));
				if (guid != ZT_MODEL_FILE_GUID_TEXTURE) {
					error_msg = "Texture GUID mismatch"; goto end_processing;
				}

				i32 texture_type = 0;
				serialCheck(zt_serialRead(&serial, &texture_type));

				if (texture_type == ZT_MODEL_FILE_TEXTURE_IMAGE_FILE) {
					char format[32]; i32 format_len = 0;
					serialCheck(zt_serialRead(&serial, format, zt_elementsOf(format), &format_len));

					i32 data_size = 0;
					serialCheck(zt_serialRead(&serial, &data_size));

					if (data_size > 0) {
						byte *data = zt_mallocStructArray(byte, data_size);
						i32 data_read = 0;
						serialCheck(zt_serialRead(&serial, data, data_size, &data_read));

						if (data_read != data_size) {
							zt_free(data);
							error_msg = "Texture size mismatch"; goto end_processing;
						}

						ztTextureID tex_id = zt_textureMakeFromFileData(data, data_read); // todo: texture flags
						textures[i] = tex_id;

						zt_free(data);
					}
				}
				else if (texture_type == ZT_MODEL_FILE_TEXTURE_IMAGE_PIXELS) {
					i32 width = 0, height = 0;
					serialCheck(zt_serialRead(&serial, &width));
					serialCheck(zt_serialRead(&serial, &height));

					i32 data_size = width * height * 4;
					if(data_size > 0) {
						byte *data = zt_mallocStructArray(byte, data_size);
						i32 data_read = 0;
						serialCheck(zt_serialRead(&serial, data, data_size, &data_read));

						if (data_read != data_size) {
							zt_free(data);
							error_msg = "Texture size mismatch"; goto end_processing;
						}

						ztTextureID tex_id = zt_textureMakeFromPixelData(data, width, height); // todo: texture flags
						textures[i] = tex_id;

						zt_free(data);
					}
				}
			}
			serialCheck(zt_serialGroupPop(&serial));
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	// animations
	serialCheck(zt_serialGroupPush(&serial));
	{
		i32 animations_count = 0;
		serialCheck(zt_serialGroupPush(&serial));
		{
			serialCheck(zt_serialRead(&serial, &animations_count));

			if (animations_count > 0) {
				input->root_model->anim_controller = zt_animControllerMake(animations_count + 1); // +1 to always include a "TPose" animation which positions the model in the default vertex position

				struct BoneAnim
				{
					static void addStaticLayer(ztAnimLayer *layers, int layers_size, int *layers_count, ztBone *bone)
					{
						if(*layers_count + 3 >= layers_size) {
							return;
						}

						ztAnimKey keys[1];

						zt_debugOnly(zt_strMakePrintf(layer_name_pos, 128, "%s.position", bone->name)) zt_releaseOnly(const char *layer_name_pos = nullptr);
						keys[0] = zt_animKeyMake(zt_variantMake_vec3(bone->transform.position), 0);
						layers[(*layers_count)++] = zt_animLayerMake(zt_variantPointerMake_vec3(&bone->transform.position), keys, 1, layer_name_pos);

						zt_debugOnly(zt_strMakePrintf(layer_name_rot, 128, "%s.rotation", bone->name)) zt_releaseOnly(const char *layer_name_rot = nullptr);
						keys[0] = zt_animKeyMake(zt_variantMake_quat(bone->transform.rotation), 0);
						layers[(*layers_count)++] = zt_animLayerMake(zt_variantPointerMake_quat(&bone->transform.rotation), keys, 1, layer_name_rot);

						zt_debugOnly(zt_strMakePrintf(layer_name_sca, 128, "%s.scale", bone->name)) zt_releaseOnly(const char *layer_name_sca = nullptr);
						keys[0] = zt_animKeyMake(zt_variantMake_vec3(bone->transform.scale), 0);
						layers[(*layers_count)++] = zt_animLayerMake(zt_variantPointerMake_vec3(&bone->transform.scale), keys, 1, layer_name_sca);
					}
				};

				if(input->bones_used > 0) {
					ztAnimLayer layers[1024];
					int         layers_count = 0;

					zt_assert(zt_elementsOf(layers) > input->bones_used * 3);

					zt_fiz(input->bones_used) {
						BoneAnim::addStaticLayer(layers, zt_elementsOf(layers), &layers_count, &input->bones[i]);
					}

					ztAnimSequence *sequence = zt_animSequenceMake(ztAnimSequenceType_Synchronous, layers, layers_count, false);
					zt_animControllerAddSequence(input->root_model->anim_controller, "TPose", sequence);
				}
			}
		}
		serialCheck(zt_serialGroupPop(&serial));

		zt_fiz(animations_count) {
			serialCheck(zt_serialGroupPush(&serial));
			{
				ztGuid guid;
				serialCheck(zt_serialRead(&serial, &guid));
				if (guid != ZT_MODEL_FILE_GUID_ANIMATION) {
					error_msg = "Animation GUID mismatch"; goto end_processing;
				}

				char anim_name[256];
				i32 anim_name_len = 0;
				serialCheck(zt_serialRead(&serial, anim_name, zt_elementsOf(anim_name), &anim_name_len));

				double anim_duration = 0;
				serialCheck(zt_serialRead(&serial, &anim_duration));

				i32 ticks_per_second = 0;
				serialCheck(zt_serialRead(&serial, &ticks_per_second));

				anim_duration = anim_duration / ticks_per_second;

				i32 num_channels = 0;
				serialCheck(zt_serialRead(&serial, &num_channels));

				ztAnimLayer layers[1024];
				int         layers_count = 0;

				zt_fjz(num_channels) { // each channel is a bone

					serialCheck(zt_serialGroupPush(&serial));
					{
						char channel_name[128];
						i32 channel_name_len = 0;
						serialCheck(zt_serialRead(&serial, channel_name, zt_elementsOf(channel_name), &channel_name_len));

						struct Bone
						{
							static ztBone *findBone(ztModelLoaderInput *input, const char *bone_name)
							{
								zt_fiz(input->bones_used) {
									if (zt_strEquals(input->bones[i].name, bone_name)) {
										return &input->bones[i];
									}
								}

								return nullptr;
							}

							static ztModel *findModel(ztModelLoaderInput *input, ztBone *bone)
							{
								if (bone == nullptr) {
									return nullptr;
								}

								while (bone->parent) {
									bone = bone->parent;
								}

								zt_fiz(input->models_used) {
									if (input->models[i].bones_count > 0 && bone == &input->models[i].bones[input->models[i].bones_root_idx]) {
										return &input->models[i];
									}
								}

								return nullptr;
							}

							static ztModel *findModel(ztModelLoaderInput *input, const char *model_name)
							{
								zt_fiz(input->models_used) {
									if (zt_strEquals(input->models[i].name, model_name)) {
										return &input->models[i];
									}
								}

								return nullptr;
							}
						};

						ztTransform *anim_transform = nullptr;

						ztBone *bone = Bone::findBone(input, channel_name);
						ztModel *model = Bone::findModel(input, bone);
						if (bone && model) {
							anim_transform = &bone->transform;
						}
						else {
							model = Bone::findModel(input, channel_name);
							if (model) {
								anim_transform = &model->transform;
							}
						}

						if (anim_transform) {
							ztAnimKey keys[1024];
							int       keys_count = 0;

							i32 position_keys = 0;
							r64 prev_time = 0;
							serialCheck(zt_serialRead(&serial, &position_keys));
							zt_fkz(position_keys) {
								serialCheck(zt_serialGroupPush(&serial));
								{
									r64 time = 0;
									serialCheck(zt_serialRead(&serial, &time));

									ztVec3 position;
									serialCheck(zt_serialRead(&serial, &position));

									if (k == 0 && !zt_real32Eq(time, 0)) {
										zt_assert(keys_count < zt_elementsOf(keys));
										if (keys_count < zt_elementsOf(keys)) {
											keys[keys_count++] = zt_animKeyMake(zt_variantMake_vec3(anim_transform->position), 0);
										}
									}

									zt_assert(keys_count < zt_elementsOf(keys));
									if (keys_count < zt_elementsOf(keys)) {
										keys[keys_count++] = zt_animKeyMake(zt_variantMake_vec3(position), (r32)(time - prev_time) / ticks_per_second);
									}
									prev_time = time;
								}
								serialCheck(zt_serialGroupPop(&serial));
							}
							if (position_keys > 0) {
								zt_assert(layers_count < zt_elementsOf(layers));
								if (layers_count < zt_elementsOf(layers)) {
									zt_debugOnly(zt_strMakePrintf(layer_name, 128, "%s.position", channel_name)) zt_releaseOnly(const char *layer_name = nullptr);
									layers[layers_count++] = zt_animLayerMake(zt_variantPointerMake_vec3(&anim_transform->position), keys, keys_count, layer_name);
								}
								keys_count = 0;
							}

							i32 rotation_keys = 0;
							serialCheck(zt_serialRead(&serial, &rotation_keys));
							prev_time = 0;
							zt_fkz(rotation_keys) {
								serialCheck(zt_serialGroupPush(&serial));
								{
									r64 time = 0;
									serialCheck(zt_serialRead(&serial, &time));

									ztQuat rotation;
									serialCheck(zt_serialRead(&serial, &rotation));

									if (k == 0 && !zt_real32Eq(time, 0)) {
										zt_assert(keys_count < zt_elementsOf(keys));
										if (keys_count < zt_elementsOf(keys)) {
											keys[keys_count++] = zt_animKeyMake(zt_variantMake_quat(anim_transform->rotation), 0);
										}
									}

									zt_assert(keys_count < zt_elementsOf(keys));
									if (keys_count < zt_elementsOf(keys)) {
										keys[keys_count++] = zt_animKeyMake(zt_variantMake_quat(rotation), (r32)(time - prev_time) / ticks_per_second);
									}
									prev_time = time;
								}
								serialCheck(zt_serialGroupPop(&serial));
							}
							if (rotation_keys > 0) {
								zt_assert(layers_count < zt_elementsOf(layers));
								if (layers_count < zt_elementsOf(layers)) {
									zt_debugOnly(zt_strMakePrintf(layer_name, 128, "%s.rotation", channel_name)) zt_releaseOnly(const char* layer_name = nullptr);
									layers[layers_count++] = zt_animLayerMake(zt_variantPointerMake_quat(&anim_transform->rotation), keys, keys_count, layer_name);
								}
								keys_count = 0;
							}

							i32 scale_keys = 0;
							serialCheck(zt_serialRead(&serial, &scale_keys));
							prev_time = 0;
							zt_fkz(scale_keys) {
								serialCheck(zt_serialGroupPush(&serial));
								{
									r64 time = 0;
									serialCheck(zt_serialRead(&serial, &time));

									ztVec3 scale;
									serialCheck(zt_serialRead(&serial, &scale));

									if (k == 0 && !zt_real32Eq(time, 0)) {
										zt_assert(keys_count < zt_elementsOf(keys));
										if (keys_count < zt_elementsOf(keys)) {
											keys[keys_count++] = zt_animKeyMake(zt_variantMake_vec3(anim_transform->scale), 0);
										}
									}

									zt_assert(keys_count < zt_elementsOf(keys));
									if (keys_count < zt_elementsOf(keys)) {
										keys[keys_count++] = zt_animKeyMake(zt_variantMake_vec3(scale), (r32)(time - prev_time) / ticks_per_second);
									}
									prev_time = time;
								}
								serialCheck(zt_serialGroupPop(&serial));
							}
							if (scale_keys > 0) {
								zt_assert(layers_count < zt_elementsOf(layers));
								if (layers_count < zt_elementsOf(layers)) {
									zt_debugOnly(zt_strMakePrintf(layer_name, 128, "%s.scale", channel_name)) zt_releaseOnly(const char *layer_name = nullptr);
									layers[layers_count++] = zt_animLayerMake(zt_variantPointerMake_vec3(&anim_transform->scale), keys, keys_count, layer_name);
								}
								keys_count = 0;
							}
						}
						else {
							zt_logCritical("model animation missing channel object: %s", channel_name);
						}
					}
					serialCheck(zt_serialGroupPop(&serial));
				}

				if (layers_count > 0) {
					ztAnimSequence *sequence = zt_animSequenceMake(ztAnimSequenceType_Synchronous, layers, layers_count, true);
					zt_animControllerAddSequence(input->root_model->anim_controller, anim_name, sequence);
				}
			}
			serialCheck(zt_serialGroupPop(&serial));
		}
	}
	serialCheck(zt_serialGroupPop(&serial));

	zt_fiz(materials_count) {
		if (materials[i].diffuse_tex >= 0 && materials[i].diffuse_tex < textures_count) {
			materials[i].diffuse_tex  = textures[materials[i].diffuse_tex];
			materials[i].diffuse_flags = ztMaterialFlags_OwnsTexture;
		}
		if (materials[i].normal_tex >= 0 && materials[i].normal_tex < textures_count) {
			materials[i].normal_tex  = textures[materials[i].normal_tex];
			materials[i].normal_flags = ztMaterialFlags_OwnsTexture;
		}
		if (materials[i].specular_tex >= 0 && materials[i].specular_tex < textures_count) {
			materials[i].specular_tex  = textures[materials[i].specular_tex];
			materials[i].specular_flags = ztMaterialFlags_OwnsTexture;
		}
		if (materials[i].height_tex >= 0 && materials[i].height_tex < textures_count) {
			materials[i].height_tex  = textures[materials[i].height_tex];
			materials[i].height_flags = ztMaterialFlags_OwnsTexture;
		}
		if (materials[i].roughness_tex >= 0 && materials[i].roughness_tex < textures_count) {
			materials[i].roughness_tex  = textures[materials[i].roughness_tex];
			materials[i].roughness_flags = ztMaterialFlags_OwnsTexture;
		}
	}

	zt_fiz(mesh_count) {
		mesh_references[i] = 0;
	}

	zt_fiz(input->models_used) {
		if(model_material_indexes[i] != -1) {
			if( mesh_references[model_material_indexes[i]]++ == 0) {
				input->models[i].flags |= ztModelFlags_OwnsMaterials;
			}
			input->models[i].material = materials[model_material_indexes[i]];
		}

		input->models[i].flags |= ztModelFlags_Initialized;
	}
	

end_processing:
#	undef serialCheck
	zt_serialClose(&serial);

	if (error_msg) {
		zt_logCritical("model serialization failure: %s", error_msg);
	}

	zt_free(model_material_indexes);

	if (materials) {
		zt_free(materials);
	}
	if (textures) {
		zt_free(textures);
	}
	if (mesh_ids) {
		zt_free(mesh_ids);
	}
	if (mesh_materials) {
		zt_free(mesh_materials);
	}
	if (mesh_references) {
		zt_free(mesh_references);
	}

	return error_msg == nullptr;
}

// ================================================================================================================================================================================================

ztInternal void _zt_modelCountModelsAndBones(ztModel *model, i32 *models, i32 *bones)
{
	*models += 1;
	*bones += model->bones_count;

	zt_flink(child, model->first_child) {
		_zt_modelCountModelsAndBones(model, models, bones);
	}
}

// ================================================================================================================================================================================================

bool zt_modelClone(ztModelLoaderInput *input, ztModel *model_to_clone)
{
	i32 models_needed = 0, bones_needed = 0;
	_zt_modelCountModelsAndBones(model_to_clone, &models_needed, &bones_needed);

	if (models_needed > input->models_size || bones_needed > input->bones_size) {
		zt_logCritical("Unable to clone model.  Not enough cache storage");
		return false;
	}

	struct local
	{
		static void clone(ztModel *model_to_clone, ztModel *model, ztModelLoaderInput *input)
		{
			zt_memCpy(model, zt_sizeof(ztModel), model_to_clone, zt_sizeof(ztModel));

			// memcpy gets most things, there are some things that need modified

			zt_bitRemove(model->flags, ztModelFlags_OwnsMaterials);
			zt_bitRemove(model->flags, ztModelFlags_OwnsMesh);

			if (model->name) {
				model->name = zt_stringMakeFrom(model_to_clone->name);
			}

			model->first_child = nullptr;
			model->next        = nullptr;
			model->parent      = nullptr; // this is set outside of this function by the caller

			// cleanup bones
			if (model->bones) {
				model->bones = input->bones + input->bones_used;
				input->bones_used += model->bones_count;

				zt_memCpy(model->bones, zt_sizeof(ztBone) * model->bones_count, model_to_clone->bones, zt_sizeof(ztBone) * model_to_clone->bones_count);

				zt_fiz(model_to_clone->bones_count) {
					if (model_to_clone->bones[i].parent) {
						zt_fjz(model_to_clone->bones) {
							if (model_to_clone->bones[i].parent == &model_to_clone->bones[j]) {
								model->bones[i].parent = &model->bones[j];
								break;
							}
						}
					}
					if (model_to_clone->bones[i].first_child) {
						zt_fjz(model_to_clone->bones) {
							if (model_to_clone->bones[i].first_child == &model_to_clone->bones[j]) {
								model->bones[i].first_child = &model->bones[j];
								break;
							}
						}
					}
					if (model_to_clone->bones[i].next) {
						zt_fjz(model_to_clone->bones) {
							if (model_to_clone->bones[i].next == &model_to_clone->bones[j]) {
								model->bones[i].next = &model->bones[j];
								break;
							}
						}
					}

					if (model_to_clone->bones[i].name) {
						model->bones[i].name = zt_stringMakeFrom(model_to_clone->bones[i].name);
					}
				}

				if (model_to_clone->anim_controller) {
					model->anim_controller = zt_animControllerMake(model_to_clone->anim_controller->sequences_size, model_to_clone->anim_controller->anim_async_count);

					zt_fvz(seq_idx, model_to_clone->anim_controller->sequences_count) {
						ztAnimSequence *seq = model_to_clone->anim_controller->sequences[seq_idx];

						ztAnimLayer *nlayers = zt_mallocStructArrayArena(ztAnimLayer, seq->layers_count, zt_memGetTempArena());

						zt_fvz(lay_idx, seq->layers_count) {
							ztAnimLayer *layer = &seq->layers[lay_idx];

							ztVariantPointer layer_target;
							bool layer_target_found = false;

							zt_fvz(bone_idx, model_to_clone->bones_count) {
								if(layer->target.type == ztVariant_vec3 && layer->target.v_vec3 == &model_to_clone->bones[bone_idx].transform.position) {
									layer_target_found = true;
									layer_target = zt_variantPointerMake_vec3(&model->bones[bone_idx].transform.position);
									break;
								}
								if(layer->target.type == ztVariant_quat && layer->target.v_quat == &model_to_clone->bones[bone_idx].transform.rotation) {
									layer_target_found = true;
									layer_target = zt_variantPointerMake_quat(&model->bones[bone_idx].transform.rotation);
									break;
								}
								if(layer->target.type == ztVariant_vec3 && layer->target.v_vec3 == &model_to_clone->bones[bone_idx].transform.scale) {
									layer_target_found = true;
									layer_target = zt_variantPointerMake_vec3(&model->bones[bone_idx].transform.scale);
									break;
								}
							}

							zt_assertReturnOnFail(layer_target_found);

							nlayers[lay_idx] = zt_animLayerMake(layer_target, layer->keys, layer->keys_count, layer->name);
						}

						ztAnimSequence *nseq = zt_animSequenceMake(seq->type, nlayers, seq->layers_count, seq->loops);

						zt_freeArena(nlayers, zt_memGetTempArena());

						zt_animControllerAddSequence(model->anim_controller, model_to_clone->anim_controller->sequences_name[seq_idx], nseq);
					}
				}
			}

			// process children
			zt_flink(child_to_clone, model_to_clone->first_child) {
				ztModel *child = &input->models[input->models_used++];
				clone(child_to_clone, child, input);

				child->parent = model;
				zt_singleLinkAddToEnd(model->first_child, child);
			}
		}
	};

	input->root_model = &input->models[input->models_used++];

	local::clone(model_to_clone, input->root_model, input);

	return true;
}

// ================================================================================================================================================================================================

bool zt_modelMakeSkybox(ztModel *model, ztTextureID texture_id, bool owns_texture)
{
	ZT_PROFILE_RENDERING("zt_modelMakeSkybox");
	ztVec3 skybox_verts[] = {
		zt_vec3(-1.0f,  1.0f, -1.0f), zt_vec3(-1.0f, -1.0f, -1.0f), zt_vec3( 1.0f, -1.0f, -1.0f), zt_vec3( 1.0f, -1.0f, -1.0f), zt_vec3( 1.0f,  1.0f, -1.0f), zt_vec3(-1.0f,  1.0f, -1.0f),
		zt_vec3(-1.0f, -1.0f,  1.0f), zt_vec3(-1.0f, -1.0f, -1.0f), zt_vec3(-1.0f,  1.0f, -1.0f), zt_vec3(-1.0f,  1.0f, -1.0f), zt_vec3(-1.0f,  1.0f,  1.0f), zt_vec3(-1.0f, -1.0f,  1.0f),
		zt_vec3( 1.0f, -1.0f, -1.0f), zt_vec3( 1.0f, -1.0f,  1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3( 1.0f,  1.0f, -1.0f), zt_vec3( 1.0f, -1.0f, -1.0f),
		zt_vec3(-1.0f, -1.0f,  1.0f), zt_vec3(-1.0f,  1.0f,  1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3( 1.0f, -1.0f,  1.0f), zt_vec3(-1.0f, -1.0f,  1.0f),
		zt_vec3(-1.0f,  1.0f, -1.0f), zt_vec3( 1.0f,  1.0f, -1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3( 1.0f,  1.0f,  1.0f), zt_vec3(-1.0f,  1.0f,  1.0f), zt_vec3(-1.0f,  1.0f, -1.0f),
		zt_vec3(-1.0f, -1.0f, -1.0f), zt_vec3(-1.0f, -1.0f,  1.0f), zt_vec3( 1.0f, -1.0f, -1.0f), zt_vec3( 1.0f, -1.0f, -1.0f), zt_vec3(-1.0f, -1.0f,  1.0f), zt_vec3( 1.0f, -1.0f,  1.0f)
	};

	ztMeshID mesh = zt_meshMake(skybox_verts, nullptr, nullptr, zt_elementsOf(skybox_verts), nullptr, 0);
	if (mesh == ztInvalidID) {
		return false;
	}

	ztMaterial material = zt_materialMake(texture_id, ztColor_White, owns_texture ? ztMaterialFlags_OwnsTexture : 0);

	return zt_modelMakeFromMesh(model, mesh, &material, zt_shaderGetDefault(ztShaderDefault_Skybox), nullptr, ztModelFlags_OwnsMesh | ztModelFlags_OwnsMaterials);
}

// ================================================================================================================================================================================================

void zt_modelCalcMatrix(ztModel *model, const ztVec3 &world_offset)
{
	ZT_PROFILE_RENDERING("zt_modelCalcMatrix");

	struct local
	{
		static void calculateBone(ztBone *bone, const ztMat4 *parent_mat)
		{
			ztMat4 bone_transform = zt_transformToMat4(&bone->transform);
			ztMat4 current_transform = (*parent_mat) * bone_transform;

			zt_flink(child, bone->first_child) {
				calculateBone(child, &current_transform);
			}

			bone->mat_offset = current_transform * bone->mat_inverse_bind_transform;
			bone->mat_offset.cleanup(5);
		}

		// ================================================================================================================================================================================================

		static void calculateModel(ztModel *model, const ztMat4 &parent_mat)
		{
			zt_transformToMat4(&model->transform, &model->calculated_mat);
			model->calculated_mat = parent_mat * model->calculated_mat;

			for (ztModel *child = model->first_child; child != nullptr; child = child->next) {
				calculateModel(child, model->calculated_mat);
			}

			if (model->calculated_mat != model->prev_mat){
				model->prev_mat = model->calculated_mat;

				// only recalculate this information when we've changed
				zt_transformFromMat4(&model->calculated_transform, &model->calculated_mat);
				model->aabb_center = model->obb_center = ztVec3::min;	// mark aabb and obb as needing recalculated
			}

			if (model->bones_count && !zt_bitIsSet(model->flags, ztModelFlags_NoCalcBones)) {
				calculateBone(&model->bones[model->bones_root_idx], &ztMat4::identity);
			}
		}
	
		// ================================================================================================================================================================================================
	};

	while(model->parent) {
		model = model->parent;
	}

	if (world_offset != ztVec3::zero) {
		local::calculateModel(model, ztMat4::identity.getTranslate(world_offset));
	}
	else {
		local::calculateModel(model, ztMat4::identity);
	}
}

// ================================================================================================================================================================================================

void zt_modelGetAABB(ztModel *model, ztVec3 *center, ztVec3 *size)
{
	ZT_PROFILE_RENDERING("zt_modelGetAABB");

	if (model->aabb_center != ztVec3::min) {
		// todo(josh): once this stabilizes, we need to actually use this cached value
		*center = model->aabb_center;
		*size = model->aabb_size;
		return;
	}

	struct local
	{
		static void getExtents(ztModel *model, ztVec3 *min, ztVec3 *max, ztMat4& mat)
		{
			switch (model->type)
			{
				case ztModelType_Mesh: {
					ztVec3 center, size;
					zt_meshGetOBB(model->mesh_id, &center, &size);

					ztVec3 corners[8] = {
						zt_vec3(center.x - size.x / 2, center.y + size.y / 2, center.z - size.z / 2),	// top, far left
						zt_vec3(center.x - size.x / 2, center.y + size.y / 2, center.z + size.z / 2),	// top, near left
						zt_vec3(center.x + size.x / 2, center.y + size.y / 2, center.z + size.z / 2),	// top, near right
						zt_vec3(center.x + size.x / 2, center.y + size.y / 2, center.z - size.z / 2),	// top, far right
						zt_vec3(center.x - size.x / 2, center.y - size.y / 2, center.z - size.z / 2),	// bottom, far left
						zt_vec3(center.x - size.x / 2, center.y - size.y / 2, center.z + size.z / 2),	// bottom, near left
						zt_vec3(center.x + size.x / 2, center.y - size.y / 2, center.z + size.z / 2),	// bottom, near right
						zt_vec3(center.x + size.x / 2, center.y - size.y / 2, center.z - size.z / 2),	// bottom, far right
					};

					zt_fize(corners) {
						corners[i] = mat.getMultiply(corners[i]);

						min->x = zt_min(min->x, corners[i].x);
						min->y = zt_min(min->y, corners[i].y);
						min->z = zt_min(min->z, corners[i].z);

						max->x = zt_max(max->x, corners[i].x);
						max->y = zt_max(max->y, corners[i].y);
						max->z = zt_max(max->z, corners[i].z);
					}
				} break;

				case ztModelType_VertexArray:
				case ztModelType_Sprite:
				case ztModelType_SpriteAnimation:
				case ztModelType_ParticleSystem: {

					min->x = zt_min(min->x, -.5f);
					min->y = zt_min(min->y, -.5f);
					min->z = zt_min(min->z, -.5f);

					max->x = zt_max(max->x, .5f);
					max->y = zt_max(max->y, .5f);
					max->z = zt_max(max->z, .5f);
				} break;
			}

			zt_flink(child, model->first_child) {
				getExtents(child, min, max, child->calculated_mat);
			}
		}
	};

	ztVec3 min = ztVec3::max, max = ztVec3::min;
	local::getExtents(model, &min, &max, model->calculated_mat);

	*size = max - min;
	*center = zt_vec3(min.x + size->x / 2, min.y + size->y / 2, min.z + size->z / 2);
}

// ================================================================================================================================================================================================

void zt_modelGetOBB(ztModel *model, ztVec3 *center, ztVec3 *size)
{
	ZT_PROFILE_RENDERING("zt_modelGetOBB");

	if (model->mesh_id == ztInvalidID) {
		if (model->first_child) {
			zt_modelGetOBB(model->first_child, center, size);
			*center += model->first_child->transform.position;
		}
		return;
	}

	zt_meshGetOBB(model->mesh_id, center, size);
	return;

}

// ================================================================================================================================================================================================

i32 zt_modelGetVertices(ztModel *model, ztVec3 *vertices, i32 vertices_size, ztModelGetVerticesTransform_Enum transform)
{
	ZT_PROFILE_RENDERING("zt_modelGetVertices");

	i32 verts_count = 0;
	if (model->type == ztModelType_Mesh && model->mesh_id != ztInvalidID) {
		verts_count = zt_meshGetVertices(model->mesh_id, vertices, vertices_size);
	}
	else if (model->type == ztModelType_VertexArray && model->vertex_array_id != ztInvalidID) {
		verts_count = zt_vertexArrayGetVertices(model->vertex_array_id, vertices, vertices_size);
	}

	if(verts_count > 0 && verts_count <= vertices_size) {
		if(transform == ztModelGetVerticesTransform_LocalTransform) {
			ztMat4 local_mat = zt_transformToMat4(&model->transform);
			zt_fiz(verts_count) {
				vertices[i] = local_mat.getMultiply(vertices[i]);
			}
		}
		else if(transform == ztModelGetVerticesTransform_WorldTransform) {
			zt_modelCalcMatrix(model, ztVec3::zero);

			zt_fiz(verts_count) {
				vertices[i] = model->calculated_mat.getMultiply(vertices[i]);
			}
		}
	}

	zt_flink(child, model->first_child) {
		ztVec3 *child_verts = verts_count < vertices_size ? vertices + verts_count : nullptr;
		verts_count += zt_modelGetVertices(child, child_verts, vertices_size - verts_count, transform);
	}

	return verts_count;
}

// ================================================================================================================================================================================================

void zt_modelChildAdd(ztModel *parent_model, ztModel *child_model)
{
	ZT_PROFILE_RENDERING("zt_modelChildAdd");

	zt_returnOnNull(parent_model);
	zt_returnOnNull(child_model);

	if (child_model->parent) {
		zt_modelChildRemove(child_model->parent, child_model);
	}

	child_model->parent = parent_model;
	zt_singleLinkAddToEnd(parent_model->first_child, child_model);
}

// ================================================================================================================================================================================================

void zt_modelChildRemove(ztModel *parent_model, ztModel *child_model)
{
	ZT_PROFILE_RENDERING("zt_modelChildRemove");

	zt_returnOnNull(parent_model);
	zt_returnOnNull(child_model);

	ztModel *prev = nullptr;
	zt_flink(child, parent_model->first_child) {
		if (child == child_model) {
			if (prev) {
				prev->next = child->next;
			}
			else {
				parent_model->first_child = nullptr;
			}
			break;
		}
	}	
}

// ================================================================================================================================================================================================

i32 zt_modelGetChildCount(ztModel *model, bool immediate_children_only)
{
	ZT_PROFILE_RENDERING("zt_modelGetChildCount");

	i32 child_count = 0;
	zt_flink(child, model->first_child) {
		child_count += 1;

		if (!immediate_children_only) {
			child_count += zt_modelGetChildCount(child, false);
		}
	}

	return child_count;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal void _zt_modelEditWidgetLoadVerts(ztModelEditWidget *widget)
{
	ZT_PROFILE_RENDERING("_zt_modelEditWidgetLoadVerts");

	const char *base64_modelWidget = "eAHNnU/oZNlVx3/DGEwTMy24C2EcUETBzaBCTE69xgZXYbbSusjQmlGEjmEmE3VGnO6FE2jcCSKY38YR3LS7bEROvRaSCYiCSrYuXLmYXRDFkJCkpl7qzan7Of/qTTOJ4I/h5Hvuvd+uV6/eu+d7vvfjX3zj6rk3/vHqqS/trr78G7929bkX/v7qc5//7Ev3Xvyj3//s77306tUP4f+eOvz/R5/+2cPfmx+5cfj7hd+5e++lF+/eu3fzxiu/8sre/N3hv3fB/5pn7S/8m88b4fN5d+2sXTpvjrl0zF1j/bs2ow73bZ/a7sKVvJ9/yd3NZ06X54+vl+frN2/8389/fH/8e4B9+eVPTueR7/3MN6bTfw8RZu3iLGLKrH1jnL2XRUyStW+Ms4+ziCmzdo1xmv/OCdN9wH3XWHPn33mX8tpdwv0YcS7OP+5dWuUFsHvfF8mucQHsnuhFsk8vgD5m17u0ki/a/n18qfdbL7YSs+t9hcuLtndhOxfnaz+Sl837v7f8KFw2H8xvQYf7btNF27nY9k/oEj1enLePF+dHDn9ffeXuH3zh3t1Xj3fPT33sp2/dvPGVd/5Hjn/15o1f/+btQ+Tdx9XT3xWjp7+MlFniRZIsQZa0szSdfRj50Rd/+/DfX/3FX5Y4i5hDRIMsTcdhVsRUMbs2WGjKS+JPcFihpuvRYK7OyJKOQ8zK4sVf+JdPVp8FMWskwigwuikrX6EETN3ZmZWssPzc3XGSrISpXPIJ8t+n5C4O0+Dm9br3NTggHpxuCsttwr3oh4ibpdVXJclKbiXJCi+6lSz/fMtHEmURs0b0kpuCm1XeWJeP011hgnF5lbfIdRxtrEfTFUrF3R1Hg4jLa7nE8yxi1ogAI8B0sjTIEi+r/DfUXla5nvzauCir5NX5BLWXFXwWwc3rNe8Lv9wa7NNN/gVb/tvNyr/enSz3BlSuUBuzu78YzIp+Le3vVX5TcMfpPCG6v1cui/KXMP8xWFcoKa/kmSiZ66Lngg/sOeXSJzIJnwtaT2Qf2HNl5zm3mdV5Gu18gp2n0YSXvHvzevBj7968Pnz4rr/y+Vd/8M74/J/8ppy+///w7IcenyJfeurPD6+dP/ftpw+Rr3347iHyV2//2SHy8nPfmb0sYpbIgvnMC99dIut9x0aGkRWzD1nELJEFE7FYIu/8+43Di/Sf/uXVuub/euvpQ+Rjf/u/c8zdYlym6kWGkRWzu9wtxmUqwBwid97+9CHyiW+9t8L7b90+RP71m+/MMXeLcZmqFxlGVszucrcYl6kAI+9+mm8eIj/xF/+9rvAzL7xxiLz8qf+cY+4W4zJVLzKMrJjd5W4xLlMB5hD5m5966xD5/098Y13h8//214fI7/7TPyfcLcZlql5kGFkxu8vdYlymAswh8ne39RB587auK3z4H1+Zjn8T7hbjMlUvMoysmN3lbjEuUwFGjv/rdESuKzyMOR3HT7hbjMtUvcgwsmJ2l7vFuEwFGDl+mtPxk11XeLgGpuP1kHC3GJepepFhZMXsLneLcZkKMHL89h0i129/el3h4Ts7Hb+/CXeLcZmqFxlGVszucrcYl6kAI8e75a3jnXNd4eEeOx3vtwl3i3GZqhcZRlbM7nK3GJepACPHX7dbx1+6/fov/9x3puPv4z7mbjEuU/Uiw8iK2V3uFuMyFWCO9/APrRtFpzv2d6dTJOJuMS5T9SLDyIrZXe4W4zIdWHzvD8/WvMMKdzF3i3GZqhcZRlbM7nK3GDIliyWyfqYTrqgp5m4xLlP1IjZruKKmmLvFkClZLJHlO7g8mQx3gCnmbjEuU/UiNsveAdbZXe4WQ6ZksUTWe+aEO3bC3WJcpupFbNZwx064WwyZksUSWX/jJvzCJtwtxmWqXsRmDb+wCXeLIVOyWCJvHp9JlicT+0T06Pg34m4xLlP1IjZrWeEwu8vdYsiULJbI+gw54Qk24W4xLlP1IjZreIJNuFsMmZLFElmf+Se8cSTcLcZlql7EZg1vHAl3iyFTslgi6zvahDfEhLvFuEzVi9is4Q0x4W4xZEoWS2R9p76FN/qEu8W4TNWL2Kzhjf5WzN1iyJQslsi6B3ILOzAJd4txmaoXsVnDDsytmLvFkClZDHtot7BjNsXcLcZlql7EZq07ZnZ2l7vFuEwFGDk9PQ6f196M7HK3GJepepFhZMXsLneLcZkKMHJ62h++X7O5ElzuFuMyVS8yjKyY3eVuMS5TAWa5J8zn9wQ5vtOt31yXu8W4TNWLDCMrZne5W4zLVICR09v08Ps1mzuty91iXKbqRYaRFbO73C3GZSrAyGn3Y3jemM0vo8vdYlym6kWGkRWzu9wtxmUqwMhpt2p4PpzNk4zL3WJcpupFhpEVs7vcLcZlKsDIaXdxeJ6fzZOny91iXKbqRYaRFbO73C3GZSrAyGk3eHj/ms2bgsvdYlym6kWGkRWzu9wtxmUqwMhp9354X57Nm53L3WJcpupFhpEVs7vcLcZlKsDIqdoy7G/M5k3c5W4xLlP1IsPIitld7hbjMhVg5F"
									 "QdG/ajDlnPfv29/ShytxiXqXqRYWTF7C53i3GZCjByqmYO+4cz9g8H7hbjMlUvMoysmN3lbjEuUwHGrnl/vkK730vuFuMyVS9isw5P1IrZhyxiXKYCjL3GZlxRc8zdYlym6kVs1rLmYXaXu8W4TAcW9p4w1FPm83oKuVuMy1S9iM1aVjjM7nK3GDIli+EePuOOnXC3GJepehGbtaxwmN3lbjFkShbDb+6MX9iEu8W4TNWL2KxlhcPsLneLIVOyWGus83mN9dHxScbWl8ndYlym6kVs1rLCYXaXu8WQKVkMz7QznmAT7hbjMlUvYrOWFQ6zu9wthkzJYngHmfHGkXC3GJepehGbtaxwmN3lbjFkShZL5Pr0jjabHbP5XG9D7hbjMlUvYrOWFQ6zu9wthkzJYnjHf4w3+oS7xbhM1YvYrGWFw+wud4shU7IY9mQeYwcm4W4xLlP1IjZrWeEwu8vdYsiULCINnlXcRdwHVR6ZqhehBs8q7phFDJlG1yG/lfnVG32XieG/KiOdLGIYIVNGeD13MGWWenpIe7VEc7la0GFkKhIZGcbRHoZrpkqQys9SIenqRYmhco+RThYxjFBNxwg1kx0MI1S4MUIdYwfDCFVnjFBb2MFwPVSCUd1XquBcTSAxVGcx0skihhEqphihLq6DYYQqJkaoVetgGKGyiBHqxzoYRgZdk3gRaro6mCSy8zRC7uzaw1CzRFUMlU65IijSR3X0Nhwnz4o0S8RQPcJIJ4sYRqjoYIS6nQ6GEaosGKGWpoPheqh8oJolV31EGhhiqEZgpJNFDCNUCDBCHUgHwwir9oxQm9HBMGIr6az1c/YoixhGWN22EVefoD0M9QCsOFNFUFbbI+1BWcvmOGWWqwfo1Jc5Tpnl1uiJYbWUkU4WMYywgskI69QdDNfDqiIrxWVF1a0vd+qVHKfMcmu+xLD6xkgnixhGWBFjhHXPDobrYZWKlceyQufWKzv1L45TZrk1RGJYzUnqO7tGDcitBkYVFkbsyFEWa21cD6sedpxOxYeYfj2F4+RZUU2qU+PgOHlWVCcihjv2jHSyiGGEu+iMsFbSwXA93NlmtSLf1Y9qHJ09c46TZ0V1B+6rd1Tu7GXoYDp9Aez+yHsiop6Rbd0W7KnpYMqIepGkLynBlBFNu372cRYxnT4pdsPlPWJRD105snodhXmfXdSHWI6sXldm3qsY9XJu64Jkr2sH0+kbZXdw3jMb9RSXI6vXYZ33HUd92ds6mtm33sGUEfUi7P3vYDp99HRLyD0EIo+FcmT1HCdyH4bIp6IcWeFcIZ67RemAIYF3xB4s9pWTRgfjum3s8e8z4/NKappRzbccWb0KeF4Xjurm2yrO1BV0MJ0aPZUYuT4h0m+UI6unZsk1HpEGZpt6hBqhDqaMuAoc6qw6mDLiqpioVetgOrovqvtyzVukCdympqNmsoMpI64iMdKd5pgykqg6rXa3g+noYKl2zjXAkUZ6m7qYGvIOpoyoF6EOv4PpaNrZuZDr+aN+h3Jk9bo/8p6IqGekHFm9Dpq8ryTqu9nWscK+pA6m0+PDTq68vynq/ypHVq8bLu8Ri3roypHV6yjM++yiPsRtHXxun2aJafY87sBr15h9V/VXchx2B+c9s1FPcTmyeh3Wed9x1Je9raOZfesdTBlRL8Le/w6m00dPt4TcQyDyWNjmTkAPig6mjKgXoY9HB2Minivi60Z1cQUVyFqZ4A4asxK/m6vGrtb6REKtBrNyv5tIcTIoM9x9SWaVfjdS+d0sEepCmHWpcsWqkWxFirurzOrs0pZ7u67ihFkbVDJUnIh3fTOr9LuRyu9miVDdwqzc78ZVyVDd4t4RmFX63Ujld7NEqK1hVu5343riUH9jdwbXFTKLmM79cchydTzMyv1uXD0QVTvurwWzol+Uh/itehj/VrkKIWZtUDVRIeT+ujOr9LuRyu9miVCNxKzc78ZVNS1q9elcucJnJmaVfjdS+d0skWson5h1nfrdLBGyGHRO7pMfszpPkOVzp6uyYhYx16l6bNC4rxE+YTOr8xRePrurp/FiVu5303eK4VtKlJW/yZTvP66eLMpK/G605xQTednYrNLvRiq/m/WzcJVzNutJqev4Jsyszht1+R7u6uSY9aSUfPex48Cs+41dCbK4j30KKvCYtUE16GoEuWvDLGLI9H61H6Se/o9Zpd+N9pxiuKfGrNLvRiq/m/VZYj7/hWVW6Xfj6hpXJc0aWasp9nljyCKmsy85ZClmd7kTQ6ZkQeUld2CZRQyZkgX3bamYZBYxZNpxiuEuNrM6O93l/rh6ek1mlX432nOKYUWBWaXfjVR+N+u78Hz+hsis0u9Ge04xrNMwq/S7kcrvZt27GHSozHpSStm10rYz+xtDFjH9WtewHzVoXpm1QZVrFa5X7/02/aCqd2X2o4YsYsiULIYsxewud2ISlfBVrPdlhZVZid/NVRBx67L0smFW4ndDpolTDOvWzCr9bqTyuxm+OzM+r32MIdNIo3zHKImXb66Y6juziOnX/sUo"
									 "BobZXe7EkClZUEVNtQSzIr8bgRJCAr+b4bdpPr8f2ixiyLTjFEPFCbNKvxup/G6GZ4kZv18Jhkw7TjHU8TCr9LuRyu9mePab8byRYMi04xRDNRKzOqqmUgtF3bnLnRgy7ajeqfpiVkcZVurJFLO73IkhU7K4A4cOavKYVfrdSOV3M7wLz3j/SjBkeqfhFENlIbM6CsVS16iY3eVODJl2nGKe/fqo4GQWMR1t6JClnmMIs4gh0447CfW1UZbFkClZuGrawa8kyhp8T+jMclWdVBcpiW1WR21capQ1OEtvyIowucML3VuoxmZWR7Fd6rzVc11h1ganGFtTmFErmbE//zjGbNDKK2Z3uV9X5+2px4L+MuwuYFZ53p5U5+0Nta0Z9ZQEc91wyaF3DHs2mFWetyfVeXtDLXJG/SvBdBx51prmfF47fmSeiJhFTL/v5ZF5Rhpmd7kTQ6ZkQWcfdvgwK+oCeoTeoUdx75B6jjzMIoZMOyfVsf+KWeV5e1KdtzdoM2boARJMx9WI3kPsImNWpxut7GFTz2mIWeV5e9o7qY7deszqdPSVfYDquRoxqzxvT3sn1bHjkVmdrsiyl1I9ByVmleftaXpSnd0/nLB/OGQR0+kspQaPijtmleftacPJS7b6f5XXhja8vaR3ymPp/6UNby/pnbxYXhuaumtdNRzBruLvTu7AFV2ZiWLzKnYEo2qRc3UUkiVGG15a0tBeurNzrtJLSxp6SHeFuf9XpNwrNYruCnP/r0hNV+oG3RVyPVSmca6OCu5S/69IdVbq69zZORcVU9R0lZo3d4W5/1ekzip1aO4Kr1P/r0gxVWrD3BWW/l+RimlX+Xa5bl+71G9LG45g0juRi+sp/b+kpwgqMdrw/5JNWR0NjDa8vaR3mlTp/6UNby/pnfDE9VBlQR1IqZPRhmeZq9/gXB3VR4nRnpdWqSdxZy/9v7Th7SW9E4O4no4D1wb/L3c9uZfW842zf6IVcj2sbidV+0if4K4wYbGPdQ6danuJ0cr/y410spr1ZY6zIatT89XYESypd7uzcy5WMHNvL7cG7a6Q68mdvKKRy6xmvbJ0H+tkdWqIWjmCufVTd3bOxYrYnfREAbem6a6Q62HVjHN1KnQlRquTANxIJ6tTk9LGSQDSqHZJ4/wAbZwNII0KlLue8vwA6VV8OucHXFcnAcimrGaNg+NsyOrUHbRxNoA0KhrizcVddO7zl3UQbZx54O7Pc67Orn6J0cZJALL1/ADu8nVU7vcb/g7EdPoCyjOAO1mytdtig7+DNvpTpOHdoJtOsJZ218+l/g7a65Mqz0SXnitE57T10oVBeq4QHX+H0oVBNnlASK8Lsuz3lJu1m4PE/g4P4cLwMPZu6GDEG7l0YehkydaO5rJ3Wxrer9LrCi/736XhBisNf1hteL/qVn/Y0sVVNnnISsPpVdM62q6NkYaLa6dmpxe6bSQurhu8XzvVUreeu8H7dXPFeYM/rPZq9KWvayero3xwtRlUfZRZm9UjpU5GGt6vTQVOqTWShvdrU8VU6rWk4QYrPRfXDd6vm9V0G/xhtaE/lMAx9lJ/WG1oON2sUr/qalw7OtjyzMtO1mZ18QZ/WG3osaXh/aqbTmyVnovrBu9X6Z2MW7q4drKk5w9burjKJg/ZZsdK2ZsjDe9XiZ1eBb6u0vCHTTBun1Tp4trJkkb3mTZcXGWTh6z0OvjKXkXxMBf1PO6CSCdLGp2k2nBx7WRJoxtXGy6usslDVnodzWXvtjTcYKXXFb7BH1Z7ffTs/aerQJklW90JSh8GuVl7v0rP4aH0spCGG6y4roiveToMaiy4X8YsYoadrwfYL3vg7dZRX8IsYqiAIQvqObjnyCxi8t3DJcJ9Up4mxyxiyJQsqALhTi6ziMl3YJcId415Bh2ziCFTsqDihHvfzCIm39deIvzmUKPDLGLIlCyobuH3n1nEdNygefehHohZxJApWVB/8xDu3cwiJr8bLpFhn3T2tEfMIoZMyYKqHf4yMYsYMiUL/gryzEBmEUOmZEGFEH/LmUVM/ju9RPgkQU0Vs4ghU7K4hhqJz0PMIqbjjs9nuGvot5hFDJmSBZVPdHhhFjGd8wT4HEytGLOIIVOyoMqKDi/MIib3u1kifJegootZxJApWUQ6MPtOEmVZTO53s0SiNyurgYuyLIZMyYKaM74fMivC5O+HfKcd+kwee1kRZmA6sKC+jQ4vzCKmc74K9wWGXp3HXhYxZEoWVMXxrBtmEZP73az3lmHfxCrw1jvSkEUMmZIFFXjc/WEWMZ2Tf7jTRM0is4ghU7KgRpD7ZcwipnNWEvf4qI9kFjFkShaD/mZGDcbNIqZz3tRQN5qhPXKziCFTsqCKkQ4vzCKGTMmCe82DfsvNIoZMyYKKSe6GM4uY3O9mfZeZ8f41n79xMIsYMiULajpZP2AWMZ3T5Fi9oJ6VWcSQKVlQP8oaDLOIyasp617BjP2NwfOFWcSQKVlQdcozFZlFTF6RWvd2ZuxHDSpYZhFDpmQxKFx5CuUDL4uY5IRJNX"
									 "tx8/ke2qAJfuBlEUOmZEENLuupzCKGTMmC1Vzqj5lFTMJ0ZUG9L2vSzCImry4vEdbRhytq8rKIIVOyGO4JQ/Vdjm95zCImr9AvEXtPWLKGO4CbRQyZkgUVydRGMIsYMiULKjOGO7abRQyZkgXVz9SXMIuYztnCVLdQL84sYsiULKjPpkaHWcTkapslQl0RtenMIoZMyYJacDq8MIuYXLG0RKjNGp5g3SxiyJQs6FtB9RiziOmcHE6l2vDG4WYRQ6ZkcQduF9TbMYuYXEu3RKgRHN4Q3SxiyJQs6KxBhxdmEZOrD5cIdZb0ImEWMWRKFvTsWDRJVq/JLGJyv5slsmatGlP6njCLGDIlC9cxZNC8RlkWQ6ZkMeyhTdgxuxVnWQyZkgU9TagSZlaEcXXDKwtqpunnwqwIMzAdWNAJhSfMMYuY/Ly99Vqd8P2azq8oZhFDpmRxDdcVKuOZRUx+3t56b5nO7wnX8KlhFjFkShZ0eGEvAbOIyfsE1t+CCb9f0/kdm1nEkClZ0E2G/RjMIibvrFh/uyc8b0znv7DMIoZMyWKosU7Q6LhZxHTOIx10RRMqqm4WMWRKFnTJYacQs4ghU7JgV9JQAXeziCFTsqAjD3urmEVM56Rc9oPRw4hZxJApWdD9hyfMMYuYztnC7KmjXxKziCFTsqDTEE+YYxYx+Xl79097BRP2NwbnI2YRQ6ZkQVcjdk4yi5j8vL11b2fCftTgssQsYsiULPLz9galnJjdsAn7h1PVa0oNHhV3zEpUeStTXlG5k1d09SYYXhsau2sl3wuNMZwr9/8aPmVeqxpjkmtDcW1o7LeVZEVa0F3l/zWoMaO59pX/1xKhajH3/4oUkgmG+kON3bUS7aXGGM6V+38NSkLqITXGcD25/9eg7qNGUWMM15P7fw2KO+oGNcZwPVSm5f5fkQouwVBjprG7VqKv0xjDuaiYoqYr0bxpjOF6cv+vQcFFHZrGGK4n9/8aVFXUhmmM4Xpy/69B6SSpRqjv/6WxJ1eiodJKLWbXQ5VO7v8VKYISTKK3yf2/yixiqIHR2F0r0f9ojOFcuf/XoGahJkdjDNdDlQV1IIlORmMM10MlBufqqD4SDDUVGrtrJXoSjTGcK/f/GtQR1HhojOF6WLWnriDRXWiM4XpYSWetP9FCaIzheljdLqv2+0ZNfN9g4db6O9X2Unvg1rJz/68yi5ikvpz7f5VZxLDmq7G7VlLv1hjDuXL/r6F6yxq0xhiuh1XO3MkrqqgmmKRemft/lVnEsIaosad/Uj/VGMO5WBFjzS6paWqM4XpYNeNcnQpdgknqX/lJAGUWMUk1x61SRfU4jTHuKQjJ+QFljUyraqBdD6sw+fkBUcUnwST1lPwkgDKLmKTGwXEuyiKGdQeN3fmTmovGGM7FXXTu8yd1EI0xXA932jlXZ1c/wSR75vlJAGUWMetvSkflnuj5JcZ0+gJyf4eoJyLBXNRtkfSVSIxJ+lMk7lhJenOk6kL6WvuU66HjSeNeodwVIuqTyv0doh6xBCPxyLm/Q9Rnl2AkHrnj1JBkESOXdEEm/Z4SYzp9o+x1ZRdtkkWMxCN3nBqSLGLkko7mpHdbYkzSAy5xV3jS/y4xptNHn/vDRh4CCUbikTtOr0kWMRKPzPpXUkfT2AGj9I5wq5PlXLtNbhu7yh82qmkmGIlHzv1ho7pwgrmo4pzU1iXGdGr0HafXJIsYiUemNoOqjySLmIvUI4lORmJMordJFDiJ1khizKX+sIOCi3otiTEd3VfuDxtp3hLMRWq6RDcoMSbRHyaKxER7KZXKNPJ+jVSdiX5VYkxHB5v7w0Ya4ARzkbo40VFLjEn02BIrtBMtusSYjqY994eN9PwJRuKRc3/YqCciwUg8csfpNcki5qKOlaQ3R2JMp8eHfUnseEqyiJF45NwfNuoRSzASj9xxek2yiJFLOviSXkWJMRt6Ht1+2HL2vJNU0TOrsa9rkkWMxCN3nF6TLGLkko7mpHdbYkzSAy5xV3jS/y4xptNHz95/ugokWcTIJe4EiQ+DxJjEz0Fih4fEy0JiDPb9nvno08dnh2d+8qu/+ku/9X3ezEBl ";

	i32 uncompressed_size = 68756;

	i32 base64_len = zt_strLen(base64_modelWidget);

	byte *raw_data = zt_mallocStructArrayArena(byte, base64_len, zt_memGetTempArena());
	zt_assertReturnOnFail(raw_data != nullptr);

	i32 raw_len = zt_base64Decode(base64_modelWidget, base64_len, raw_data, base64_len);
	zt_assertReturnOnFail(raw_len > 0);

	void *uncompressed_data = zt_mallocStructArrayArena(byte, uncompressed_size, zt_memGetTempArena());
	zt_assertReturnOnFail(uncompressed_data != nullptr);

	i32 inflated_size = zt_compressInflate(raw_data, raw_len, uncompressed_data, uncompressed_size);
	zt_assertReturnOnFail(inflated_size == uncompressed_size);

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, uncompressed_data, inflated_size, "model_widget")) {
		zt_assertReturnOnFail(false);
	}

	while(true) {
		zt_serialGroupPush(&serial);
		{
			i32 vert_count = 0;
			zt_assertReturnOnFail(zt_serialRead(&serial, &vert_count));

			if (vert_count == 0) {
				break;
			}

			char name[64];
			i32 name_len;
			zt_assertReturnOnFail(zt_serialRead(&serial, name, zt_elementsOf(name), &name_len));

			int index = -1;
			if (zt_strEquals(name, "rotate_x")) index = ztModelEditWidget::Control_RotateX;
			if (zt_strEquals(name, "rotate_y")) index = ztModelEditWidget::Control_RotateY;
			if (zt_strEquals(name, "rotate_z")) index = ztModelEditWidget::Control_RotateZ;
			if (zt_strEquals(name, "translate_x")) index = ztModelEditWidget::Control_TranslateX;
			if (zt_strEquals(name, "translate_y")) index = ztModelEditWidget::Control_TranslateY;
			if (zt_strEquals(name, "translate_z")) index = ztModelEditWidget::Control_TranslateZ;
			if (zt_strEquals(name, "scale_x")) index = ztModelEditWidget::Control_ScaleX;
			if (zt_strEquals(name, "scale_y")) index = ztModelEditWidget::Control_ScaleY;
			if (zt_strEquals(name, "scale_z")) index = ztModelEditWidget::Control_ScaleZ;
			if (zt_strEquals(name, "scale_all")) index = ztModelEditWidget::Control_ScaleAll;

			zt_assert(index != -1);

			widget->verts_count[index] = vert_count;
			widget->verts[index] = zt_mallocStructArray(ztVec3, vert_count);

			ztVec3 min = ztVec3::max;
			ztVec3 max = ztVec3::min;

			zt_fiz(vert_count) {
				zt_assertReturnOnFail(zt_serialRead(&serial, &widget->verts[index][i]));

				zt_fjze(widget->verts[index][i].values) {
					min.values[j] = zt_min(min.values[j], widget->verts[index][i].values[j]);
					max.values[j] = zt_max(max.values[j], widget->verts[index][i].values[j]);
				}
			}

			widget->verts_aabb_center[index] = (min + max) * .5f;
			widget->verts_aabb_size[index] = max - min;
		}
		zt_serialGroupPop(&serial);
	}

	zt_serialClose(&serial);

	zt_freeArena(uncompressed_data, zt_memGetTempArena());
	zt_freeArena(raw_data, zt_memGetTempArena());
}

// ================================================================================================================================================================================================

bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztModel *model)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetMake");

	if (widget->verts[0] == nullptr) {
		_zt_modelEditWidgetLoadVerts(widget);
	}

	widget->model                 = model;
	widget->bone                  = nullptr;
	widget->dragging              = false;
	widget->hover                 = false;
	widget->verts_active          = -1;
	widget->snap_amount_translate = .25f;
	widget->snap_amount_rotation  = 5;
	widget->snap_amount_scale     = .25f;

	return true;
}

// ================================================================================================================================================================================================

bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztBone *bone)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetMake");

	if (widget->verts[0] == nullptr) {
		_zt_modelEditWidgetLoadVerts(widget);
	}

	widget->model                 = nullptr;
	widget->bone                  = bone;;
	widget->dragging              = false;
	widget->hover                 = false;
	widget->verts_active          = -1;
	widget->snap_amount_translate = .25f;
	widget->snap_amount_rotation  = 5;
	widget->snap_amount_scale     = .25f;

	return true;
}

// ================================================================================================================================================================================================

bool zt_modelEditWidgetMake(ztModelEditWidget *widget, ztTransform *transform)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetMake");

	if (widget->verts[0] == nullptr) {
		_zt_modelEditWidgetLoadVerts(widget);
	}

	widget->model = nullptr;
	widget->bone = nullptr;
	widget->transform = transform;
	widget->dragging = false;
	widget->hover = false;
	widget->verts_active = -1;
	widget->snap_amount_translate = .25f;
	widget->snap_amount_rotation = 5;
	widget->snap_amount_scale = .25f;

	return true;
}

// ================================================================================================================================================================================================

void zt_modelEditWidgetFree(ztModelEditWidget *widget)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetFree");

	zt_fize(widget->verts) {
		if(widget->verts[i]) {
			zt_free(widget->verts[i]);
			widget->verts[i] = 0;
			widget->verts_count[i] = 0;
		}
	}
}

// ================================================================================================================================================================================================

ztInternal ztMat4 _zt_modelEditWidgetGetMatInv(ztModelEditWidget *widget)
{
	if (widget->model) {
		return widget->model->calculated_mat.getInverse();
	}
	else if (widget->bone) {
		return widget->bone->mat_local_bind_transform.getInverse();
	}
	else if (widget->transform) {
		return zt_transformToMat4(widget->transform).getInverse();
	}

	return ztMat4::identity;
}

// ================================================================================================================================================================================================

ztInternal ztTransform *_zt_modelEditWidgetGetTransform(ztModelEditWidget *widget)
{
	if (widget->model) {
		return &widget->model->transform;
	}
	else if (widget->bone) {
		return &widget->bone->transform;
	}
	else if (widget->transform) {
		return widget->transform;
	}

	zt_assert(false);
	return nullptr;
}

// ================================================================================================================================================================================================

bool zt_modelEditWidgetUpdate(ztModelEditWidget *widget, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztCamera *camera, r32 dt)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetUpdate");

	zt_returnValOnNull(widget, false);
	zt_returnValOnNull(input_mouse, false);
	zt_returnValOnNull(camera, false);

	if (widget->model == nullptr && widget->bone == nullptr && widget->transform == nullptr) {
		return false;
	}


	bool snap = input_keys[ztInputKeys_Control].pressed();

	static ztMat4 orig_mat_inv;

	if(!widget->dragging) {
		ztVec3 ray_pos, ray_dir;
		ztMat4 calc_mat_inv = _zt_modelEditWidgetGetMatInv(widget);

		zt_cameraPerspGetMouseRayLocalToMatrix(camera, input_mouse->screen_x, input_mouse->screen_y, &ray_pos, &ray_dir, &calc_mat_inv);

		widget->verts_active = -1;

		r32 closest_time = ztReal32Max;

		ztVec3 intersect_pos = ztVec3::min;

		zt_fize(widget->verts_aabb_center) {
			ztVec3 intersection_point;
			if (zt_collisionRayInAABB(ray_pos, ray_dir, widget->verts_aabb_center[i], widget->verts_aabb_size[i], nullptr, &intersection_point)) {

				r32 intersect_time = ztReal32Max;
				bool intersect_tri = false;
				ztVec3 line_end = intersection_point + ray_dir * 10;
				for (int j = 0; j < widget->verts_count[i]; j += 3) {
					if (zt_collisionLineInTriangle(ray_pos, line_end, widget->verts[i][j], widget->verts[i][j+1], widget->verts[i][j+2], &intersection_point, &intersect_time)) {
						intersect_tri = true;
						break;
					}
				}

				if (intersect_tri && intersect_time < closest_time) {
					widget->verts_active = i;
					closest_time = intersect_time;
					intersect_pos = intersection_point;
				}
			}
		}

		if (widget->verts_active >= 0) {
			if (input_mouse->leftJustPressed()) {
				widget->dragging = true;
				// the intersect point is in object space, need to put it in world space

				intersect_pos = calc_mat_inv.getMultiply(intersect_pos);
				ztVec3 object_pos = calc_mat_inv.getMultiply(ztVec3::zero);

				ztVec2i screen_obj = zt_cameraPerspWorldToScreen(camera, object_pos);
				ztVec2i screen_int = zt_cameraPerspWorldToScreen(camera, intersect_pos);

				widget->pull_dir.x = screen_obj.x < screen_int.x ? -1 : 1;
				widget->pull_dir.y = screen_obj.y < screen_int.y ? -1 : 1;

				widget->pull_dist = object_pos.distance(camera->position);

				widget->dragging_origin = zt_vec2i(input_mouse->screen_x, input_mouse->screen_y);
				widget->dragging_transform_origin = *_zt_modelEditWidgetGetTransform(widget);

				return true;
			}
		}
	}
	else {
		if (input_mouse->leftJustReleased()) {
			widget->dragging = false;
			return false;
		}

		ztTransform *transform = _zt_modelEditWidgetGetTransform(widget);

		if(input_keys[ztInputKeys_Escape].justPressed() || input_mouse->rightJustPressed()) {
			*transform = widget->dragging_transform_origin;
			widget->dragging = false;
			return false;
		}
		else {
			ztVec2i dist_changed = zt_vec2i(input_mouse->screen_x - widget->dragging_origin.x, input_mouse->screen_y - widget->dragging_origin.y);

			//r32 max_delta = zt_abs(dist_changed.x) > zt_abs(dist_changed.y) ? dist_changed.x : dist_changed.y;
			r32 max_delta = (r32)-dist_changed.x;

			ztMat4 calc_mat_inv = _zt_modelEditWidgetGetMatInv(widget);
			ztVec3 object_pos = calc_mat_inv.getMultiply(ztVec3::zero);

			max_delta *= widget->pull_dist;

			if (input_keys[ztInputKeys_Shift].pressed()) {
				max_delta *= .1f;
			}

			ztVec3 pos_to_add = ztVec3::zero;
			ztVec3 rot_to_add = ztVec3::zero;
			ztVec3 sca_to_add = ztVec3::zero;

			bool snap = input_keys[ztInputKeys_Control].pressed();

			switch(widget->verts_active)
			{
				case ztModelEditWidget::Control_RotateX: {
					//quat_to_add = ztQuat::makeFromEuler(max_delta * .005f, 0, 0);
					rot_to_add.x = max_delta * .005f;
				} break;

				case ztModelEditWidget::Control_RotateY: {
					//quat_to_add = ztQuat::makeFromEuler(0, -max_delta * .005f, 0);
					rot_to_add.y = max_delta * .005f;
				} break;

				case ztModelEditWidget::Control_RotateZ: {
					//quat_to_add = ztQuat::makeFromEuler(0, 0, max_delta * .005f);
					rot_to_add.z = max_delta * .005f;
				} break;

				case ztModelEditWidget::Control_TranslateX: {
					pos_to_add.x = -max_delta * .00025f;
				} break;

				case ztModelEditWidget::Control_TranslateY: {
					pos_to_add.y = max_delta * .00025f;
				} break;

				case ztModelEditWidget::Control_TranslateZ: {
					pos_to_add.z = -max_delta * .00025f;
				} break;

				case ztModelEditWidget::Control_ScaleX: {
					sca_to_add.x = -max_delta * .00005f;
				} break;

				case ztModelEditWidget::Control_ScaleY: {
					sca_to_add.y = max_delta * .00005f;
				} break;

				case ztModelEditWidget::Control_ScaleZ: {
					sca_to_add.z = -max_delta * .00005f;
				} break;

				case ztModelEditWidget::Control_ScaleAll: {
					sca_to_add = zt_vec3(-max_delta, -max_delta, -max_delta) * .00005f;
				} break;
			}

			if (pos_to_add != ztVec3::zero) {
				ztMat4 mat = calc_mat_inv.getInverse();
				mat.translate(0, 0, 0);

				pos_to_add = mat.getMultiply(pos_to_add);

				transform->position = widget->dragging_transform_origin.position + pos_to_add;

				if (snap) {
					zt_fize(pos_to_add.values) {
						if (pos_to_add.values[i] != 0) {
							if (transform->position.values[i] > 0) {
								transform->position.values[i] += widget->snap_amount_translate;
							}

							r32 mod = zt_fmod(transform->position.values[i], widget->snap_amount_translate);
							transform->position.values[i] -= mod;
						}
					}
				}
			}

			if (rot_to_add != ztVec3::zero) {
				ztVec3 euler_before = snap ? transform->rotation.euler() : ztVec3::zero;
					
				ztQuat quat_to_add = ztQuat::makeFromEuler(rot_to_add);

				transform->rotation = widget->dragging_transform_origin.rotation * quat_to_add;

				if(snap) {
					ztVec3 euler_after = transform->rotation.euler();

					zt_fize(rot_to_add.values) {
						if (!zt_real32Close(euler_before.values[i], euler_after.values[i])) {
							r32 mod = zt_fmod(euler_after.values[i], widget->snap_amount_rotation);
							euler_after.values[i] -= mod;
						}
					}

					transform->rotation = ztQuat::makeFromEuler(euler_after);
				}
			}

			if (sca_to_add != ztVec3::zero) {
				transform->scale = widget->dragging_transform_origin.scale + sca_to_add;

				if (snap) {
					zt_fize(sca_to_add.values) {
						if (sca_to_add.values[i] != 0) {
							if (transform->scale.values[i] > 0) {
								transform->scale.values[i] += widget->snap_amount_scale;
							}

							r32 mod = zt_fmod(transform->scale.values[i], widget->snap_amount_translate);
							transform->scale.values[i] -= mod;
						}
					}
				}
			}
		}
	}

	return widget->dragging;
}

// ================================================================================================================================================================================================

void zt_modelEditWidgetRender(ztModelEditWidget *widget, ztCamera *camera, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetRender");

	zt_returnOnNull(widget);
	zt_returnOnNull(camera);
	zt_returnOnNull(draw_list);

	if (widget->model == nullptr && widget->bone == nullptr && widget->transform == nullptr) {
		return;
	}

	ztMat4 calculated_mat = _zt_modelEditWidgetGetMatInv(widget).getInverse();

	struct local
	{
		static void draw(ztDrawList *draw_list, ztModelEditWidget *widget, int vert, ztColor color)
		{
			if (widget->verts_active != vert) {
				color *= zt_vec4(.125f, .125f, .125f, 1);
			}

			ztVec2 uvs[3] = { ztVec2::zero, zt_vec2(0, 1), zt_vec2(1, 1) };
			ztVec4 colors[3] = {color, color, color};

			for (int i = 0; i < widget->verts_count[vert]; i += 3) {
				ztVec3 verts[3] = { widget->verts[vert][i], widget->verts[vert][i+1], widget->verts[vert][i+2] };

				ztVec3 normal;
				zt_triangleCalculateNormal(verts[0], verts[1], verts[2], &normal);

				ztVec3 norms[3] = {normal, normal, normal};

				zt_drawListAddFilledTriangle(draw_list, verts, uvs, norms, colors);
			}
		}
	};

#if 0
	{
		ztVec3 position, rotation, scale;
		calculated_mat.extract(&position, &rotation, &scale);

		ztTransform ntra;
		ntra.position = position;
		ntra.rotation = ztQuat::makeFromEuler(rotation);
		ntra.scale = ztVec3::one;

		calculated_mat = zt_transformToMat4(&ntra);
	}
#endif
	ztVec3 position = calculated_mat.getMultiply(ztVec3::zero);

	zt_drawListPushShader(draw_list, zt_shaderGetDefault(ztShaderDefault_Unlit));
	zt_drawListPushTexture(draw_list, ztTextureDefaultWhite);

	zt_drawListPushTransform(draw_list, calculated_mat);
	local::draw(draw_list, widget, ztModelEditWidget::Control_RotateX, ztColor_Red);
	local::draw(draw_list, widget, ztModelEditWidget::Control_RotateY, ztColor_Green);
	local::draw(draw_list, widget, ztModelEditWidget::Control_RotateZ, ztColor_Blue);
//	zt_drawListPopTransform(draw_list);
//
//	ztTransform t;
//	t.position = position;
//	t.rotation = ztQuat::identity;
//	t.scale    = ztVec3::one;
//	ztMat4 tm = zt_transformToMat4(&t);
//
//	zt_drawListPushTransform(draw_list, tm);
	local::draw(draw_list, widget, ztModelEditWidget::Control_TranslateX, ztColor_Red);
	local::draw(draw_list, widget, ztModelEditWidget::Control_TranslateY, ztColor_Green);
	local::draw(draw_list, widget, ztModelEditWidget::Control_TranslateZ, ztColor_Blue);
	local::draw(draw_list, widget, ztModelEditWidget::Control_ScaleX, ztColor_Red);
	local::draw(draw_list, widget, ztModelEditWidget::Control_ScaleY, ztColor_Green);
	local::draw(draw_list, widget, ztModelEditWidget::Control_ScaleZ, ztColor_Blue);
	local::draw(draw_list, widget, ztModelEditWidget::Control_ScaleAll, ztColor_Yellow);
	zt_drawListPopTransform(draw_list);

	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);

	return;
}

// ================================================================================================================================================================================================

void zt_modelEditWidgetRenderText(ztModelEditWidget *widget, ztCamera *camera_3d, ztCamera *camera_2d, /*ztFontID*/i32 font_id, ztVec2 offset, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetRenderText");

	zt_returnOnNull(widget);
	zt_returnOnNull(camera_3d);
	zt_returnOnNull(camera_2d);
	zt_returnOnNull(draw_list);

	if ((widget->model == nullptr && widget->bone == nullptr) || widget->hover == false) {
		return;
	}

	char display[256] = { 0 };

	ztTransform *transform = _zt_modelEditWidgetGetTransform(widget);

	ztVec3 euler = transform->rotation.euler();
	zt_strPrintf(display, zt_elementsOf(display), "Position: %.2f, %.2f, %.2f\nRotation: %.2f, %.2f, %.2f\nScale: %.2f, %.2f, %.2f", transform->position.x, transform->position.y, transform->position.z, euler.x, euler.y, euler.z, transform->scale.x, transform->scale.y, transform->scale.z);

	ztMat4 mat = _zt_modelEditWidgetGetMatInv(widget).getInverse();
	ztVec3 world_pos = mat.getMultiply(ztVec3::zero);

	ztVec2i screen_pos = zt_cameraPerspWorldToScreen(camera_3d, world_pos);
	ztVec2 text_pos = zt_cameraOrthoScreenToWorld(camera_2d, screen_pos.x, screen_pos.y);

	zt_drawListAddText2D(draw_list, font_id, display, text_pos + offset);
}

// ================================================================================================================================================================================================

bool zt_modelEditWidgetIsMouseWithinBounds(ztModelEditWidget *widget, ztCamera *camera, int screen_x, int screen_y)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetIsMouseWithinBounds");

	ztVec3 ray_pos, ray_dir;
	ztMat4 calc_mat_inv = _zt_modelEditWidgetGetMatInv(widget);

	zt_cameraPerspGetMouseRayLocalToMatrix(camera, screen_x, screen_y, &ray_pos, &ray_dir, &calc_mat_inv);

	zt_fize(widget->verts_aabb_center) {
		if (zt_collisionRayInAABB(ray_pos, ray_dir, widget->verts_aabb_center[i], widget->verts_aabb_size[i], nullptr, nullptr)) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_modelEditWidgetProcessWidgetModelFile(const char *file_name)
{
	ZT_PROFILE_RENDERING("zt_modelEditWidgetProcessWidgetModelFile");

	// this takes an ZTM file with objects representing the various controls and creates the vertices file that is required
	// for the widget.  this could theoretically be anything, but in reality should be kept simple (it's embedded in the source)

	i32 models_count = 16;
	ztModel *models = zt_mallocStructArrayArena(ztModel, models_count, zt_memGetTempArena());
	ztModelLoaderInput input;
	zt_memSet(&input, zt_sizeof(ztModelLoaderInput), 0);

	input.models = models;
	input.models_size = models_count;

	zt_modelMakeFromZtmFile(&input, file_name, zt_shaderGetDefault(ztShaderDefault_LitShadow), 0);

	char output_file[ztFileMaxPath];
	zt_fileGetFileInOtherFileDirectory(output_file, ztFileMaxPath, "model_edit_output.txt", file_name);

	ztSerial serial;
	if (zt_serialMakeWriter(&serial, output_file, "model_widget", 1)) {
		zt_fiz(input.models_used) {
			if (input.models[i].type == ztModelType_Mesh) {

				zt_serialGroupPush(&serial);

				i32 verts_count = zt_modelGetVertices(&input.models[i], nullptr, 0, ztModelGetVerticesTransform_NoTransform);
				ztVec3 *verts = zt_mallocStructArrayArena(ztVec3, verts_count, zt_memGetTempArena());
				zt_modelGetVertices(&input.models[i], verts, verts_count, ztModelGetVerticesTransform_NoTransform);

				zt_serialWrite(&serial, verts_count);
				zt_serialWrite(&serial, input.models[i].name, zt_strLen(input.models[i].name));

				zt_fjz(verts_count) {
					zt_serialWrite(&serial, verts[j]);
				}

				zt_serialGroupPop(&serial);

				zt_freeArena(verts, zt_memGetTempArena());
			}
		}

		zt_serialGroupPush(&serial);
		zt_serialWrite(&serial, 0);
		zt_serialGroupPop(&serial);

		zt_serialClose(&serial);
		zt_sleep(1);
	}

	zt_freeArena(models, zt_memGetTempArena());

	{
		i32 buffer_size = zt_kilobytes(64);
		void *buffer = zt_mallocStructArrayArena(byte, buffer_size, zt_memGetTempArena());

		i32 file_size = 0;
		void *file_data = zt_readEntireFile(output_file, &file_size, false, zt_memGetTempArena());

		if (buffer && file_data) {
			i32 compressed_size = zt_compressDeflate(file_data, file_size, buffer, buffer_size);

			i32 base64_size = compressed_size * 2;
			char *base64 = zt_mallocStructArrayArena(char, base64_size, zt_memGetTempArena());

			i32 base64_len = zt_base64Encode((const byte*)buffer, compressed_size, base64, base64_size);

			ztFile file;
			if (zt_fileOpen(&file, output_file, ztFileOpenMethod_WriteOver, zt_memGetTempArena())) {
				zt_fileWrite(&file, "const char *base64_modelWidget = \"");
				zt_fileWrite(&file, (void*)base64, base64_len);
				zt_fileWrite(&file, "\";\n\n");
				zt_fileWritef(&file, "i32 uncompressed_size = %d;\n", file_size);
				zt_fileClose(&file);
			}

		}


		zt_freeArena(file_data, zt_memGetTempArena());
		zt_freeArena(buffer, zt_memGetTempArena());
	}

	//ztFile file;
	//if (zt_fileOpen(&file, output_file, ztFileOpenMethod_WriteOver)) {
	//	zt_fiz(input.models_used) {
	//		if (input.models[i].type == ztModelType_Mesh) {

	//			zt_serialGroupPush(&serial);

	//			i32 verts_count = zt_modelGetVertices(&input.models[i], nullptr, 0, ztModelGetVerticesTransform_NoTransform);
	//			ztVec3 *verts = zt_mallocStructArrayArena(ztVec3, verts_count, zt_memGetTempArena());
	//			zt_modelGetVertices(&input.models[i], verts, verts_count, ztModelGetVerticesTransform_NoTransform);

	//			zt_serialWrite(&serial, verts_count);

	//			//zt_fileWritef(&file, "r32 %s_verts[] = {", input.models[i].name);

	//			zt_fjz(verts_count) {
	//				char *format = j == 0 ? "%.4ff, %.4ff, %.4ff" : ",%.4ff, %.4ff, %.4ff";
	//				zt_fileWritef(&file, format, verts[j].x, verts[j].y, verts[j].z);
	//			}

	//			zt_fileWrite(&file, "};\n\n");

	//			zt_freeArena(verts, zt_memGetTempArena());
	//		}
	//	}
	//	zt_fileClose(&file);
	//}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztScene *zt_sceneMake(ztMemoryArena *arena, int max_models, int shadow_map_res)
{
	ZT_PROFILE_RENDERING("zt_sceneMake");
	ztScene *scene = zt_mallocStructArena(ztScene, arena);
	scene->models = zt_mallocStructArrayArena(ztScene::ModelInfo, max_models, arena);
	scene->list_std = zt_mallocStructArrayArena(ztScene::ModelInfo*, max_models, arena);
	scene->list_std_count = 0;
	scene->list_trn = zt_mallocStructArrayArena(ztScene::ModelInfo*, max_models, arena);
	scene->list_trn_count = 0;
	scene->list_light = zt_mallocStructArrayArena(ztScene::LightInfo*, ZT_SCENE_MAX_LIGHTS, arena);
	scene->list_light_count = 0;
	scene->models_count = 0;
	scene->models_size = max_models;
	scene->arena = arena;
	scene->culling_distance = ztReal32Max;
	scene->vertex_array = ztInvalidID;
	scene->render_override = ZT_FUNCTION_POINTER_TO_VAR_NULL;
	scene->render_override_user_data = nullptr;

	scene->directional_light.light = nullptr;
	scene->tex_directional_shadow_map = zt_textureMakeRenderTarget(shadow_map_res, shadow_map_res, ztTextureFlags_DepthMap);
	zt_textureSetName(scene->tex_directional_shadow_map, "Directional Shadow Map");

	if(scene->tex_directional_shadow_map == ztInvalidID) {
		zt_freeArena(scene, arena);
		return nullptr;
	}

	scene->tex_depth          = ztInvalidID;
	scene->tex_irradiance_map = ztInvalidID;
	scene->tex_prefilter_map  = ztInvalidID;
	scene->tex_brdf_lut       = ztInvalidID;

	zt_fiz(ZT_SCENE_MAX_LIGHTS) {
		scene->lights[i].light         = nullptr;
		scene->lights[i].shadowmap_tex = ztInvalidID;
	}

	scene->skybox.model = nullptr;

	scene->shader_point_light_shadows = ztInvalidID;

	scene->extents_min = ztVec3::max;
	scene->extents_max = ztVec3::min;

	return scene;
}

// ================================================================================================================================================================================================

void zt_sceneFree(ztScene *scene)
{
	ZT_PROFILE_RENDERING("zt_sceneFree");
	if (scene == nullptr) {
		return;
	}

	if (scene->vertex_array != ztInvalidID) {
		zt_vertexArrayFree(scene->vertex_array);
		zt_freeArena(scene->vertex_array_vertices, scene->arena);
		scene->vertex_array = ztInvalidID;
	}

	zt_fiz(ZT_SCENE_MAX_LIGHTS) {
		if(scene->lights[i].shadowmap_tex != ztInvalidID) {
			zt_textureFree(scene->lights[i].shadowmap_tex);
		}
	}

	zt_textureFree(scene->tex_directional_shadow_map);
	zt_textureFree(scene->tex_depth);
	zt_textureFree(scene->tex_irradiance_map);
	zt_textureFree(scene->tex_prefilter_map);
	zt_textureFree(scene->tex_brdf_lut);

	zt_freeArena(scene->models, scene->arena);
	zt_freeArena(scene->list_light, scene->arena);
	zt_freeArena(scene->list_std, scene->arena);
	zt_freeArena(scene->list_trn, scene->arena);

	zt_shaderFree(scene->shader_point_light_shadows);

	zt_freeArena(scene, scene->arena);
}

// ================================================================================================================================================================================================

ztInternal void _zt_sceneRebuildLists(ztScene *scene)
{
	scene->list_trn_count = 0;
	scene->list_std_count = 0;

	scene->extents_min = ztVec3::max;
	scene->extents_max = ztVec3::min;

	zt_fiz(scene->models_count) {
		if (scene->models[i].model->type != ztModelType_Empty) {
			if (zt_bitIsSet(scene->models[i].flags, ztSceneModelFlags_HasTranslucent)) {
				scene->list_trn[scene->list_trn_count++] = &scene->models[i];
			}
			else {
				scene->list_std[scene->list_std_count++] = &scene->models[i];
			}

			ztVec3 aabb_center, aabb_extents;
			zt_modelGetAABB(scene->models[i].model, &aabb_center, &aabb_extents);

			zt_fjze(scene->extents_min.values) {
				scene->extents_min.values[j] = zt_min(scene->extents_min.values[j], scene->models[i].model->transform.position.values[j] + (aabb_center.values[j] - aabb_extents.values[j] * .5f));
				scene->extents_max.values[j] = zt_max(scene->extents_max.values[j], scene->models[i].model->transform.position.values[j] + (aabb_center.values[j] + aabb_extents.values[j] * .5f));
			}
		}
	}

	scene->list_light_count = 0;
	zt_fiz(scene->lights_count) {
		ztScene::LightInfo *light_info = &scene->lights[i];
		scene->list_light[scene->list_light_count++] = light_info;
	}
}

// ================================================================================================================================================================================================

void zt_sceneAddLight(ztScene *scene, ztLight *light, int shadow_map_res, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_sceneAddLight");
	zt_returnOnNull(scene);
	zt_returnOnNull(light);

	if (light->type == ztLightType_Directional) {
		scene->directional_light.light = light;
	}
	else {
		zt_assertReturnOnFail(scene->lights_count < zt_elementsOf(scene->lights));

		ztScene::LightInfo *light_info = &scene->lights[scene->lights_count++];

		light_info->light = light;
		light_info->flags = flags;

		if (light->casts_shadows) {
			light_info->shadowmap_tex = zt_textureMakeCubeMapForDepth(shadow_map_res);

			if((light->type == ztLightType_Spot || light->type == ztLightType_Point) && scene->shader_point_light_shadows == ztInvalidID) {
				scene->shader_point_light_shadows = zt_shaderMakePointLightShadows();
			}
		}

		_zt_sceneRebuildLists(scene);
	}
}

// ================================================================================================================================================================================================

void zt_sceneRemoveLight(ztScene *scene, ztLight *light)
{
	ZT_PROFILE_RENDERING("zt_sceneRemoveLight");
	zt_returnOnNull(scene);
	zt_returnOnNull(light);

	zt_assertReturnOnFail(scene->lights_count < zt_elementsOf(scene->lights));

	zt_fiz(scene->lights_count) {
		if(scene->lights[i].light == light) {

			if (light->casts_shadows) {
				zt_textureFree(scene->lights[i].shadowmap_tex);
			}

			for(int j = i; j < scene->lights_count - 1; ++j) {
				zt_memCpy(&scene->lights[j], zt_sizeof(ztScene::LightInfo), &scene->lights[j+1], zt_sizeof(ztScene::LightInfo));
			}

			scene->lights_count -= 1;

			_zt_sceneRebuildLists(scene);
			return;
		}
	}

	zt_assert(false); // do not remove lights that aren't in the scene
}

// ================================================================================================================================================================================================

bool zt_sceneMakeVertexArray(ztScene *scene, int max_vertices)
{
	zt_returnValOnNull(scene, false);
	zt_assertReturnValOnFail(max_vertices > 0, false);

	if (scene->vertex_array != ztInvalidID) {
		zt_vertexArrayFree(scene->vertex_array);
		zt_free(scene->vertex_array_vertices);
	}

	scene->vertex_array_vertices = zt_mallocStructArrayArena(ztVertexDefaultLit, max_vertices, scene->arena);
	scene->vertex_array_vertices_idx = 0;
	scene->vertex_array_size = max_vertices;
	scene->vertex_array = zt_vertexArrayMakeDefaultLit(scene->vertex_array_vertices, max_vertices);
	if (scene->vertex_array == ztInvalidID) {
		zt_free(scene->vertex_array_vertices);
		return false;
	}

	return true;
}

// ================================================================================================================================================================================================

void zt_sceneSetSkybox(ztScene *scene, ztModel *skybox)
{
	ZT_PROFILE_RENDERING("zt_sceneSetSkybox");
	zt_returnOnNull(scene);
	zt_returnOnNull(skybox);

	scene->skybox.model = skybox;
}

// ================================================================================================================================================================================================

void zt_sceneAddDepthPass(ztScene *scene, i32 w, i32 h)
{
	ZT_PROFILE_RENDERING("zt_sceneSetSkybox");
	zt_returnOnNull(scene);

	if (scene->tex_depth != ztInvalidID) {
		zt_textureFree(scene->tex_depth);
	}


	scene->tex_depth = zt_textureMakeRenderTarget(w, h, ztTextureFlags_DepthMap);
	zt_textureSetName(scene->tex_depth, "Scene Depth");
}

// ================================================================================================================================================================================================

ztInternal void _zt_sceneModelRefresh(ztScene *scene, int model_idx, bool process)
{
	struct local
	{
		static void processModel(ztScene *scene, i32 model_idx, ztModel *model, i32 flags, ztModel *root_parent)
		{
			if (model->type != ztModelType_Empty) {
				zt_modelGetAABB(scene->models[model_idx].model, &scene->models[model_idx].aabb_center, &scene->models[model_idx].aabb_size);
			}

			// add the sub models to the scene (so they can be culled)

			zt_flink(child, model->first_child) {
				int idx = -1;
				if (child->type != ztModelType_Empty) {
					idx = scene->models_count++;
					zt_assertReturnOnFail(idx < scene->models_size);

					scene->models[idx].model         = child;
					scene->models[idx].dist_from_cam = 0;
					scene->models[idx].flags         = flags;
					scene->models[idx].root_parent   = root_parent;
				}

				processModel(scene, idx, child, flags, root_parent);
			}
		}
	};

	if (zt_shaderHasVariable(scene->models[model_idx].model->shader, "light_pos", nullptr)) {
		scene->models[model_idx].flags |= ztSceneModelFlags_ShaderLit;
	}
	if (zt_shaderHasVariable(scene->models[model_idx].model->shader, "bones_count", nullptr)) {
		scene->models[model_idx].flags |= ztSceneModelFlags_ShaderBones;
	}

	if (process) {
		local::processModel(scene, model_idx, scene->models[model_idx].model, scene->models[model_idx].flags, scene->models[model_idx].model);
	}

	_zt_sceneRebuildLists(scene);
}

// ================================================================================================================================================================================================

void zt_sceneAddModel(ztScene *scene, ztModel *model, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_sceneAddModel");
	zt_returnOnNull(scene);
	zt_returnOnNull(model);

	if (scene->models_count == scene->models_size) {
		zt_assert(false);
		return;
	}

#	if defined(ZT_DEBUG)
	zt_fiz(scene->models_count) {
		if (scene->models[i].model == model) {
			zt_assert(false); // the same model instance can't be added twice
		}
	}
#	endif

	// TODO: sort according to shader
	int idx = scene->models_count++;
	zt_assertReturnOnFail(idx < scene->models_size);

	scene->models[idx].model           = model;
	scene->models[idx].dist_from_cam   = 0;
	scene->models[idx].flags           = flags;
	scene->models[idx].root_parent     = nullptr;
	scene->models[idx].index           = idx;
	scene->models[idx].render_override = ZT_FUNCTION_POINTER_TO_VAR_NULL;

	_zt_sceneModelRefresh(scene, idx, true);
}

// ================================================================================================================================================================================================

void zt_sceneRemoveModel(ztScene *scene, ztModel *model)
{
	ZT_PROFILE_RENDERING("zt_sceneRemoveModel");
	zt_returnOnNull(scene);
	zt_returnOnNull(model);

	zt_fiz(scene->models_count) {
		if (scene->models[i].model == model) {
			for (int j = i; j < scene->models_count - 1; ++j) {
				scene->models[j] = scene->models[j + 1];
			}
			scene->models_count -= 1;

			_zt_sceneRebuildLists(scene);

			// remove any sub models
			if (model->parent == nullptr) {
				zt_fizr(scene->models_count) {
					if (scene->models[i].root_parent == model) {
						zt_sceneRemoveModel(scene, scene->models[i].model);
					}
				}
			}

			return;
		}
	}

	zt_assert(false); // should not be removing a model that doesn't exist in the scene
}

// ================================================================================================================================================================================================

void zt_sceneRefreshModel(ztScene *scene, ztModel *model)
{
	ZT_PROFILE_RENDERING("zt_sceneRefreshModel");
	zt_returnOnNull(scene);
	zt_returnOnNull(model);

	zt_fiz(scene->models_count) {
		if (scene->models[i].model == model) {
			_zt_sceneModelRefresh(scene, i, false);
			return;
		}
	}

	zt_assert(false); // should not be working with a model that doesn't exist in the scene
}

// ================================================================================================================================================================================================

bool zt_sceneHasModel(ztScene *scene, ztModel *model)
{
	ZT_PROFILE_RENDERING("zt_sceneHasModel");
	zt_returnValOnNull(scene, false);

	if (model == nullptr) {
		return false;
	}

	zt_fiz(scene->models_count) {
		if (scene->models[i].model == model) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_sceneHasLight(ztScene *scene, ztLight *light)
{
	ZT_PROFILE_RENDERING("zt_sceneHasLight");
	zt_returnValOnNull(scene, false);

	if (light == nullptr) {
		return false;
	}

	zt_fiz(scene->lights_count) {
		if (scene->lights[i].light == light) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_sceneUpdate(ztScene *scene, r32 dt)
{
	ZT_PROFILE_RENDERING("zt_sceneUpdate");

	ztAnimController *anim_controllers[128];
	i32               anim_controllers_count = 0;

	zt_fiz(scene->models_count) {
		if (scene->models[i].model->anim_controller) {
			if (anim_controllers_count == zt_elementsOf(anim_controllers)) {
				zt_animControllerUpdate(anim_controllers, anim_controllers_count, dt);
				anim_controllers_count = 0;
			}

			anim_controllers[anim_controllers_count++] = scene->models[i].model->anim_controller;
		}
	}

	if (anim_controllers_count > 0) {
		zt_animControllerUpdate(anim_controllers, anim_controllers_count, dt);
	}
}

// ================================================================================================================================================================================================

void zt_scenePrepare(ztScene *scene, ztCamera *camera, const ztVec3 &world_offset)
{
	ZT_PROFILE_RENDERING("zt_scenePrepare");

	scene->models_culled = 0;

	zt_fiz(scene->models_count) {
		if (scene->models[i].root_parent == nullptr) {
			zt_modelCalcMatrix(scene->models[i].model, world_offset);
		}
		scene->models[i].dist_from_cam = zt_abs(scene->models[i].model->calculated_transform.position.distance(camera->position));
	}

	zt_fiz(scene->lights_count) {
		scene->lights[i].dist_from_cam = zt_abs(scene->lights[i].light->position.distance(camera->position));
	}

	ztFrustum camera_frustum = zt_cameraCalcViewFrustum(camera);

	if (scene->culling_distance != ztReal32Max) {
		zt_fiz(scene->models_count) {
			if (zt_bitIsSet(scene->models[i].flags, ztSceneModelFlags_ExcludeFromCull)) {
				continue;
			}

			bool visible = true;

			if (scene->models[i].dist_from_cam > scene->culling_distance) {
				visible = false;
			}
			else {
				ztVec3 aabb_pos, aabb_size;
				zt_modelGetAABB(scene->models[i].model, &aabb_pos, &aabb_size);

				if (!zt_collisionAABBInFrustum(camera_frustum, aabb_pos, aabb_size)) {
					visible = false;
				}
			}

			if (visible) {
				zt_bitRemove(scene->models[i].flags, ztSceneModelFlags_Culled);
			}
			else {
				scene->models_culled += 1;
				scene->models[i].flags |= ztSceneModelFlags_Culled;
			}
		}

		zt_fiz(scene->lights_count) {
			if (zt_bitIsSet(scene->lights[i].flags, ztSceneLightFlags_ExcludeFromCull)) {
				continue;
			}
			r32 radius = scene->lights[i].light->intensity * 1.5f;

			bool visible = true;

			if(scene->lights[i].dist_from_cam - radius > scene->culling_distance) {
				visible = false;
			}
			else {
				if(!zt_collisionSphereInFrustum(camera_frustum, scene->lights[i].light->position, radius)) {
					visible = false;
				}
			}

			if (visible) {
				zt_bitRemove(scene->lights[i].flags, ztSceneLightFlags_Culled);
			}
			else {
				scene->lights[i].flags |= ztSceneLightFlags_Culled;
			}
		}
	}

	struct sort
	{
		static int compareNearToFar(const void *vone, const void *vtwo)
		{
			const ztScene::ModelInfo *mone = *(ztScene::ModelInfo**)vone;
			const ztScene::ModelInfo *mtwo = *(ztScene::ModelInfo**)vtwo;

			if (zt_real32Eq(mone->dist_from_cam, mtwo->dist_from_cam)) {
				return mone < mtwo ? -1 : 1;
			}

			return mone->dist_from_cam <  mtwo->dist_from_cam ? -1 : 1;
		}

		static int compareFarToNear(const void *vone, const void *vtwo)
		{
			const ztScene::ModelInfo *mone = *(ztScene::ModelInfo**)vone;
			const ztScene::ModelInfo *mtwo = *(ztScene::ModelInfo**)vtwo;

			if (zt_real32Eq(mone->dist_from_cam, mtwo->dist_from_cam)) {
				return mone < mtwo ? 1 : -1;
			}

			return mone->dist_from_cam <  mtwo->dist_from_cam ? 1 : -1;
		}

		static int compareNearToFarLight(const void *vone, const void *vtwo)
		{
			const ztScene::LightInfo *lone = *(ztScene::LightInfo**)vone;
			const ztScene::LightInfo *ltwo = *(ztScene::LightInfo**)vtwo;

			if (zt_real32Eq(lone->dist_from_cam, ltwo->dist_from_cam)) {
				return lone < ltwo ? 1 : -1;
			}

			return lone->dist_from_cam <  ltwo->dist_from_cam ? 1 : -1;
		}
	};

	qsort(scene->list_std, scene->list_std_count, zt_sizeof(ztScene::ModelInfo*), sort::compareNearToFar);
	qsort(scene->list_trn, scene->list_trn_count, zt_sizeof(ztScene::ModelInfo*), sort::compareFarToNear);

	qsort(scene->list_light, scene->list_light_count, zt_sizeof(ztScene::LightInfo*), sort::compareNearToFarLight);
}

// ================================================================================================================================================================================================

void zt_sceneOptimize(ztScene *scene, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_sceneOptimize");
}

// ================================================================================================================================================================================================

ztInternal ztMat4 _zt_sceneLightingMakeLightMat(ztScene *scene, ztLight *light, ztCamera *camera, ztSceneLightingRules *lighting_rules, bool shadow_pass = false)
{
	ZT_PROFILE_RENDERING("_zt_sceneLightingMakeLightMat");
	zt_assertReturnValOnFail(light != nullptr, ztMat4::identity);
	zt_assertReturnValOnFail(camera != nullptr, ztMat4::identity);
	zt_assertReturnValOnFail(lighting_rules != nullptr, ztMat4::identity);

	r32 shadow_near = .1f - lighting_rules->shadow_distance_behind_camera;
	r32 shadow_far = lighting_rules->shadow_max_distance;

	ztVec3 scene_center = (scene->extents_min + scene->extents_max) * .5f;
	ztVec3 scene_extents = scene->extents_max - scene->extents_min;

	ztVec3 light_pos;
	zt_collisionRayInAABB(light->position * 999.f, light->position.getNormal() * -1, scene_center, scene_extents, nullptr, &light_pos);

	//light_pos *= .25f;
	light_pos.normalize();

	ztVec3 lookat = (scene_center - light_pos);
	lookat.normalize();

	//ztMat4 light_mat = ztMat4::identity.getLookAt(light->position.getNormal() * 1, ztVec3::zero);
	ztMat4 light_mat = ztMat4::identity.getLookAt(light_pos, ztVec3::zero);

	ztFrustum frustum = zt_cameraCalcViewFrustum(camera, shadow_far, shadow_near);

	ztVec3 points_in_lightspace[8];
	zt_fize(points_in_lightspace) points_in_lightspace[i] = light_mat.getMultiply(frustum.points[i]);
	zt_fize(points_in_lightspace) frustum.points[i] = points_in_lightspace[i];

	r32 min_x = ztReal32Max;
	r32 max_x = ztReal32Min;
	r32 min_y = ztReal32Max;
	r32 max_y = ztReal32Min;
	r32 min_z = ztReal32Max;
	r32 max_z = ztReal32Min;

	zt_fize(points_in_lightspace) {
		ztVec3 point = points_in_lightspace[i];
		min_x = zt_min(min_x, point.x);
		max_x = zt_max(max_x, point.x);
		min_y = zt_min(min_y, point.y);
		max_y = zt_max(max_y, point.y);
		min_z = zt_min(min_z, point.z);
		max_z = zt_max(max_z, point.z);
	}

	ztVec3 extents_min = light_mat.getMultiply(scene->extents_min);
	ztVec3 extents_max = light_mat.getMultiply(scene->extents_max);

//	min_x = zt_max(min_x, extents_min.x);
//	max_x = zt_min(max_x, extents_max.x);
//	min_y = zt_max(min_y, extents_min.y);
//	max_y = zt_min(max_y, extents_max.y);
//	min_z = zt_max(min_z, extents_min.z);
//	max_z = zt_min(max_z, extents_max.z);

	ztVec3 cube_center = zt_vec3((min_x + max_x) / 2, (min_y + max_y) / 2, (min_z + max_z) / 2);
	//cube_center = light_mat.getMultiply(cube_center);
	ztVec3 cube_size = zt_vec3(max_x - min_x, max_y - min_y, max_z - min_z);

	ztMat4 result = ztMat4::makeOrthoProjection(min_x, max_x, max_z, min_z, min_y * 1, max_y * 1);
	result = result * light_mat;
	return result;


	ztMat4 ortho_proj = ztMat4::identity;
	ortho_proj.c0r0 = 2.f / cube_size.x;
	ortho_proj.c1r1 = 2.f / cube_size.y;
	ortho_proj.c2r2 = -2.f / cube_size.z;
	ortho_proj.c3r3 = 1;

	ztMat4 light_move = ztMat4::identity.getTranslate(cube_center * -1);
	light_mat = light_move * ortho_proj;//light_mat;

	//return ortho_proj * light_mat;
	return light_mat;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_sceneLightingMakeLightMats(ztMat4 *mats, ztLight *light, ztCamera *camera, ztSceneLightingRules *lighting_rules, bool shadow_pass = false)
{
	ZT_PROFILE_RENDERING("_zt_sceneLightingMakeLightMats");
	zt_assertReturnValOnFail(light != nullptr, false);
	zt_assertReturnValOnFail(camera != nullptr, false);
	zt_assertReturnValOnFail(lighting_rules != nullptr, false);

	r32 shadow_near = .1f;
	r32 shadow_far = lighting_rules->shadow_max_distance;

	ztMat4 proj_mat = ztMat4::makePerspectiveProjection(zt_degreesToRadians(90), 1, 1, shadow_near, shadow_far);

	mats[0] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3( 1.0f,  0.0f,  0.0f), zt_vec3(0.0f, 1.0f,  0.0f)));
	mats[1] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3(-1.0f,  0.0f,  0.0f), zt_vec3(0.0f, 1.0f,  0.0f)));
	mats[2] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3( 0.0f, -1.0f,  0.0f), zt_vec3(0.0f, 0.0f, -1.0f)));
	mats[3] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3( 0.0f,  1.0f,  0.0f), zt_vec3(0.0f, 0.0f,  1.0f)));
	mats[4] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3( 0.0f,  0.0f, -1.0f), zt_vec3(0.0f, 1.0f,  0.0f)));
	mats[5] = (proj_mat * ztMat4::identity.getLookAt(light->position, light->position + zt_vec3( 0.0f,  0.0f,  1.0f), zt_vec3(0.0f, 1.0f,  0.0f)));

	return true;
}

// ================================================================================================================================================================================================

ztInternal void _zt_sceneDrawSprite(ztScene *scene, ztModel *model, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("_zt_sceneDrawSprite");
	ztModelSpriteFacing_Enum facing = model->type == ztModelType_Sprite ? model->sprite_facing : model->sprite_anim_facing;
	ztSprite *sprite = model->type == ztModelType_Sprite ? &model->sprite : zt_spriteAnimControllerActiveSprite(model->sprite_anim_controller);

	ztVec3 pos[6];
	ztVec2 uvs[6];
	ztVec3 rot = ztVec3::zero;
	ztVec3 nml = ztVec3::zero;


	switch (facing)
	{
		case ztModelSpriteFacing_Billboard: nml = zt_vec3(0, 0, 1); break;
		case ztModelSpriteFacing_NegX: rot = zt_vec3(0, -90, 0); nml = zt_vec3(-1, 0, 0); break;
		case ztModelSpriteFacing_PosX: rot = zt_vec3(0, 90, 0); nml = zt_vec3(1, 0, 0); break;
		case ztModelSpriteFacing_NegY: rot = zt_vec3(-90, 0, 0); nml = zt_vec3(0, -1, 0); break;
		case ztModelSpriteFacing_PosY: rot = zt_vec3(90, 0, 0); nml = zt_vec3(0, 1, 0); break;
		case ztModelSpriteFacing_NegZ: rot = zt_vec3(0, 180, 0); nml = zt_vec3(0, 0, -1); break;
		case ztModelSpriteFacing_PosZ: rot = zt_vec3(0, 0, 0); nml = zt_vec3(0, 0, 1); break;
	}

	zt_spriteGetTriangles(sprite, ztVec3::zero, rot, ztVec3::one, pos, uvs);

	if (facing == ztModelSpriteFacing_Billboard) {
		ztVec3 pos_lookat = model->calculated_mat.getInverse().getMultiply(camera->position);

		//if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisX)) pos_lookat.x = cmp_item->command->billboard_center.x;
		//if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisY)) pos_lookat.y = cmp_item->command->billboard_center.y;
		//if (!zt_bitIsSet(cmp_item->command->billboard_flags, ztDrawCommandBillboardFlags_AxisZ)) pos_lookat.z = cmp_item->command->billboard_center.z;

		ztMat4 mat = ztMat4::identity.getLookAt(pos_lookat, ztVec3::zero, zt_vec3(0, 1, 0)).getInverse();
		mat.values[ztMat4_Col3Row0] = mat.values[ztMat4_Col3Row1] = mat.values[ztMat4_Col3Row2] = 0; // remove translation

		//ztQuat quat = ztQuat::makeFromEuler(0, 0, 0);
		//zt_fiz(4) {
		//	quat.rotatePosition(&p[i]);
		//}

		zt_fize(pos) {
			pos[i] = mat * pos[i];
		}
		nml = mat * nml;
	}

	ztVertexDefaultLit vertices[6];
	zt_fize(pos) {
		vertices[i].position = model->transform.position + pos[i];
		vertices[i].uv = uvs[i];
		vertices[i].normal = nml;
		vertices[i].color = ztColor_White;
	}

	zt_vertexArrayDefaultCalculateTangentBitangent(vertices[0], vertices[1], vertices[2], &vertices[0].tangent, &vertices[0].bitangent);
	vertices[1].tangent = vertices[2].tangent = vertices[0].tangent;
	vertices[1].bitangent = vertices[2].bitangent = vertices[0].bitangent;

	zt_vertexArrayDefaultCalculateTangentBitangent(vertices[3], vertices[4], vertices[5], &vertices[3].tangent, &vertices[3].bitangent);
	vertices[4].tangent = vertices[5].tangent = vertices[3].tangent;
	vertices[4].bitangent = vertices[5].bitangent = vertices[3].bitangent;

	zt_vertexArrayUpdateDefaultLit(scene->vertex_array, vertices, zt_elementsOf(vertices));
	zt_vertexArrayDraw(scene->vertex_array);
}

// ================================================================================================================================================================================================

struct ztModelParticleRenderData
{
	ztModel *model;
};

// ================================================================================================================================================================================================

ZT_FUNC_PARTICLE_EMITTER_MESH_RENDER(_zt_modelParticleRenderMesh)
{
	ztModelParticleRenderData *data = (ztModelParticleRenderData*)user_data;

	// todo: support instanced rendering

	ztTransform tx = zt_transformMake(position, ztQuat::makeFromEuler(rotation), scale);
	ztMat4 mat = zt_transformToMat4(&tx);

	static u32 diffuse_color_hash = zt_strHash("diffuse_color");
	zt_shaderSetVariableVec4(data->model->shader, data->model->material.diffuse_color_override ? data->model->material.diffuse_color_override : diffuse_color_hash, color);

	zt_shaderSetModelMatrices(data->model->shader, data->model->calculated_mat * mat);

	zt_meshRender(mesh_id);
}

// ================================================================================================================================================================================================

ztInternal void _zt_sceneDrawParticle(ztScene *scene, ztModel *model, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("_zt_sceneDrawParticle");

	if (model->particle_emitter->system->system_rendering.type == ztParticleRenderingType_Mesh) {
		ztModelParticleRenderData data;
		data.model = model;

		zt_particleEmitterRender(model->particle_emitter, nullptr, camera, _zt_modelParticleRenderMesh, &data);
	}
	else {
		int verts = zt_particleEmitterFillVertices(model->particle_emitter, camera, scene->vertex_array_vertices, scene->vertex_array_size);
		zt_vertexArrayUpdateDefaultLit(scene->vertex_array, scene->vertex_array_vertices, verts);
		zt_vertexArrayDraw(scene->vertex_array);
	}
}

// ================================================================================================================================================================================================

void zt_sceneLighting(ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules)
{
#	if !defined(ZT_SHADER_DEFAULT_NO_LIGHTING)
	ZT_PROFILE_RENDERING("zt_sceneLighting");

	if (lighting_rules == nullptr) {
		static ztSceneLightingRules rules = {};
		lighting_rules = &rules;
	}

	struct local
	{
		static void renderModel(int pass, ztScene *scene, ztShaderID shader, ztModel *model, i32 model_flags, ztCamera *camera, i32 match_flags, bool *needs_multipass)
		{
			if ((match_flags == 0 || zt_bitIsSet(model_flags, match_flags)) && !zt_bitIsSet(model_flags, ztModelFlags_Hidden) && model->type != ztModelType_Invalid) {
				if ((pass == 0 && model->type == ztModelType_Mesh) || (pass == 1 && (model->type == ztModelType_Sprite || model->type == ztModelType_SpriteAnimation || model->type == ztModelType_ParticleSystem))) {

					if (model->type == ztModelType_ParticleSystem) {
						model->particle_emitter->position = model->calculated_mat.getMultiply(ztVec3::zero);
						zt_shaderSetModelMatrices(shader, ztMat4::identity);
					}
					else {

						static u32 bones_count_hash = 0;
						static u32 bones_names_hash[ZT_MAX_BONES];

						if (bones_count_hash == 0) {
							bones_count_hash = zt_strHash("bones_count");

							zt_fiz(ZT_MAX_BONES) {
								zt_strMakePrintf(bones_name, 128, "bones[%d]", i);
								bones_names_hash[i] = zt_strHash(bones_name);
							}
						}

						zt_shaderSetVariableInt(shader, bones_count_hash, model->bones_count);

						zt_fiz(model->bones_count) {
							zt_shaderSetVariableMat4(shader, bones_names_hash[i], model->bones[i].mat_offset);
						}

						zt_shaderSetModelMatrices(shader, model->calculated_mat);
					}

					bool changed_cull = zt_bitIsSet(model_flags, ztModelFlags_NoFaceCull);
					if (changed_cull) {
						zt_rendererSetFaceCulling(ztRendererFaceCulling_CullNone);
					}

					switch (model->type)
					{
						case ztModelType_Mesh: {
							zt_meshRender(model->mesh_id);
						} break;

						case ztModelType_VertexArray: {
							zt_vertexArrayDraw(model->vertex_array_id);
						} break;

						case ztModelType_SpriteAnimation:
						case ztModelType_Sprite: {
							zt_materialPrepare(&model->material, shader);
							zt_shaderApplyVariables(shader);
							_zt_sceneDrawSprite(scene, model, camera);
						} break;

						case ztModelType_ParticleSystem: {
							zt_materialPrepare(&model->material, shader);
							zt_shaderApplyVariables(shader);
							_zt_sceneDrawParticle(scene, model, camera);
						} break;
					}


					if (changed_cull) {
						zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);
					}
				}
				else {
					*needs_multipass = true;
				}
			}

			//ztModel *child = model->first_child;
			//while (child) {
			//	renderModelAndChildren(pass, scene, shader, child, camera, match_flags, needs_multipass);
			//	child = child->next;
			//}
		}
	};

	if (scene->directional_light.light) {
		ztMat4 light_mat = _zt_sceneLightingMakeLightMat(scene, scene->directional_light.light, camera, lighting_rules, true);

		_zt_rendererCheckToResetStats();

		zt_textureRenderTargetPrepare(scene->tex_directional_shadow_map, true);
		zt_rendererClear(zt_vec4(1, 1, 1, 1));
		zt_rendererSetDepthTest(true, ztRendererDepthTestFunction_Less);
		zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);

		for (int pass = 0; pass < 2; ++pass) {
			bool needs_multipass = false;

			ztShaderID shader = zt_shaderGetDefault(pass == 0 ? ztShaderDefault_ShadowDirectional : ztShaderDefault_ShadowDirectionalTextured);
			zt_shaderBegin(shader);

			static u32 light_matrix_hash = zt_strHash("light_matrix");
			zt_shaderSetVariableMat4(shader, light_matrix_hash, light_mat);

			zt_shaderApplyVariables(shader);

			zt_fiz(scene->models_count) {

				i32 model_flags = scene->models[i].model->flags;
				i32 model_info_flags = scene->models[i].flags;
				ztShaderID shader_to_use = shader;

				if (ZT_FUNCTION_POINTER_IS_VALID(scene->render_override) || ZT_FUNCTION_POINTER_IS_VALID(scene->models[i].render_override)) {
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Shadows, scene->render_override_user_data);
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->models[i].render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Shadows, scene->models[i].render_override_user_data);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader);
					zt_shaderBegin(shader_to_use);
					zt_shaderSetVariableMat4(shader_to_use, light_matrix_hash, light_mat);
					zt_shaderApplyVariables(shader_to_use);
				}

				if (!zt_bitIsSet(model_info_flags, ztSceneModelFlags_Culled)) {
					local::renderModel(pass, scene, shader, scene->models[i].model, model_flags, camera, ztModelFlags_CastsShadows, &needs_multipass);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader_to_use);
					zt_shaderBegin(shader);
					zt_shaderSetVariableMat4(shader, light_matrix_hash, light_mat);
					zt_shaderApplyVariables(shader);
				}
			}

			zt_shaderEnd(shader);

			if (!needs_multipass) {
				break;
			}
		}

		zt_textureRenderTargetCommit(scene->tex_directional_shadow_map);
	}

	//zt_fkz(ZT_SCENE_MAX_LIGHTS) {
	zt_fkz(scene->list_light_count) {

		ztScene::LightInfo *light_info = scene->list_light[k];

		if (light_info->light == nullptr || light_info->shadowmap_tex == ztInvalidID || zt_bitIsSet(light_info->flags, ztSceneLightFlags_Culled)) {
			continue;
		}

		ztMat4 matrices[6];
		if (!_zt_sceneLightingMakeLightMats(matrices, light_info->light, camera, lighting_rules, true)) {
			continue;
		}

		_zt_rendererCheckToResetStats();

		zt_textureRenderTargetPrepare(light_info->shadowmap_tex, true);
		zt_rendererClear(zt_vec4(0, 0, 0, 1));
		zt_rendererSetDepthTest(true, ztRendererDepthTestFunction_Less);
		zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);

		for (int pass = 0; pass < 2; ++pass) {
			bool needs_multipass = false;

			ztShaderID shader = ztInvalidID;

			if (pass == 0) {
				switch(light_info->light->type)
				{
					case ztLightType_Point:
					case ztLightType_Spot: {
						shader = scene->shader_point_light_shadows;
					} break;
				}
			}

			zt_shaderBegin(shader);

			static u32 shadow_matrices_hash[6] = {0};
			static u32 light_pos_hash = zt_strHash("light_pos");
			static u32 far_plane_hash = zt_strHash("far_plane");

			if (shadow_matrices_hash[0] == 0) {
				zt_fxz(6) {
					zt_strMakePrintf(var_name, 128, "shadow_matrices[%d]", x);
					shadow_matrices_hash[x] = zt_strHash(var_name);
				}
			}

			zt_fxz(6) {
				zt_shaderSetVariableMat4(shader, shadow_matrices_hash[x], matrices[x]);
			}

			zt_shaderSetVariableVec3(shader, light_pos_hash, light_info->light->position);
			zt_shaderSetVariableFloat(shader, far_plane_hash, lighting_rules->shadow_max_distance);
			light_info->far_plane = lighting_rules->shadow_max_distance;

			zt_shaderApplyVariables(shader);

			zt_fiz(scene->models_count) {
				i32 model_flags = scene->models[i].model->flags;
				i32 model_info_flags = scene->models[i].flags;
				ztShaderID shader_to_use = shader;

				if (ZT_FUNCTION_POINTER_IS_VALID(scene->render_override) || ZT_FUNCTION_POINTER_IS_VALID(scene->models[i].render_override)) {
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Shadows, scene->render_override_user_data);
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->models[i].render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Shadows, scene->models[i].render_override_user_data);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader);
					zt_shaderBegin(shader_to_use);
					zt_fxz(6) {
						zt_shaderSetVariableMat4(shader_to_use, shadow_matrices_hash[x], matrices[x]);
					}

					zt_shaderSetVariableVec3(shader_to_use, light_pos_hash, light_info->light->position);
					zt_shaderSetVariableFloat(shader_to_use, far_plane_hash, lighting_rules->shadow_max_distance);

					zt_shaderApplyVariables(shader_to_use);
				}

				if (!zt_bitIsSet(model_info_flags, ztSceneModelFlags_Culled)) {
					local::renderModel(pass, scene, shader, scene->models[i].model, model_flags, camera, ztModelFlags_CastsShadows, &needs_multipass);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader_to_use);
					zt_shaderBegin(shader);
					zt_shaderSetVariableVec3(shader, light_pos_hash, light_info->light->position);
					zt_shaderSetVariableFloat(shader, far_plane_hash, lighting_rules->shadow_max_distance);
					light_info->far_plane = lighting_rules->shadow_max_distance;

					zt_shaderApplyVariables(shader);
				}
			}

			zt_shaderEnd(shader);

			if (!needs_multipass) {
				break;
			}
			else break; // no support for textures yet
		}

		zt_textureRenderTargetCommit(light_info->shadowmap_tex);
	}

#	endif
}

// ================================================================================================================================================================================================

void zt_sceneDepth(ztScene *scene, ztCamera *camera)
{
#	if !defined(ZT_SHADER_DEFAULT_NO_LIGHTING)
	ZT_PROFILE_RENDERING("zt_sceneDepth");

	struct local
	{
		static void renderModel(int pass, ztScene *scene, ztShaderID shader, ztModel *model, i32 model_flags, ztCamera *camera, i32 match_flags, bool *needs_multipass)
		{
			if ((match_flags == 0 || zt_bitIsSet(model_flags, match_flags)) && !zt_bitIsSet(model_flags, ztModelFlags_Hidden) && !zt_bitIsSet(model_flags, ztModelFlags_ShadowOnly) && model->type != ztModelType_Invalid) {
				if ((pass == 0 && model->type == ztModelType_Mesh) || (pass == 1 && (model->type == ztModelType_Sprite || model->type == ztModelType_SpriteAnimation || model->type == ztModelType_ParticleSystem))) {

					if (model->type == ztModelType_ParticleSystem) {
						model->particle_emitter->position = model->calculated_mat.getMultiply(ztVec3::zero);
						zt_shaderSetModelMatrices(shader, ztMat4::identity);
					}
					else {
						zt_shaderSetModelMatrices(shader, model->calculated_mat);
					}

					bool changed_cull = zt_bitIsSet(model_flags, ztModelFlags_NoFaceCull);
					if (changed_cull) {
						zt_rendererSetFaceCulling(ztRendererFaceCulling_CullNone);
					}

					switch (model->type)
					{
						case ztModelType_Mesh: {
							zt_meshRender(model->mesh_id);
						} break;

						case ztModelType_VertexArray: {
							zt_vertexArrayDraw(model->vertex_array_id);
						} break;

						case ztModelType_SpriteAnimation:
						case ztModelType_Sprite: {
							zt_materialPrepare(&model->material, shader);
							zt_shaderApplyVariables(shader);
							_zt_sceneDrawSprite(scene, model, camera);
						} break;

						case ztModelType_ParticleSystem: {
							zt_materialPrepare(&model->material, shader);
							zt_shaderApplyVariables(shader);
							_zt_sceneDrawParticle(scene, model, camera);
						} break;
					}


					if (changed_cull) {
						zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);
					}
				}
				else {
					*needs_multipass = true;
				}
			}

			//ztModel *child = model->first_child;
			//while (child) {
			//	renderModelAndChildren(pass, scene, shader, child, camera, match_flags, needs_multipass);
			//	child = child->next;
			//}
		}
	};

	if (scene->tex_depth != ztInvalidID) {
		_zt_rendererCheckToResetStats();

		zt_textureRenderTargetPrepare(scene->tex_depth, true);
		zt_rendererClear(zt_vec4(1, 1, 1, 1));
		zt_rendererSetDepthTest(true, ztRendererDepthTestFunction_LessEqual);

		for (int pass = 0; pass < 2; ++pass) {
			bool needs_multipass = false;

			ztShaderID shader = zt_shaderGetDefault(pass == 0 ? ztShaderDefault_Depth : ztShaderDefault_DepthTextured);
			zt_shaderBegin(shader);

			zt_shaderSetCameraMatrices(shader, camera->mat_proj, camera->mat_view);

			zt_shaderApplyVariables(shader);

			zt_fiz(scene->models_count) {
				i32 model_flags = scene->models[i].model->flags;
				i32 model_info_flags = scene->models[i].flags;
				ztShaderID shader_to_use = shader;

				if (ZT_FUNCTION_POINTER_IS_VALID(scene->render_override) || ZT_FUNCTION_POINTER_IS_VALID(scene->models[i].render_override)) {
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Depth, scene->render_override_user_data);
					ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->models[i].render_override, ztSceneRenderModelOverride_Func)(scene, i, scene->models[i].model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Depth, scene->models[i].render_override_user_data);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader);
					zt_shaderBegin(shader_to_use);
					zt_shaderSetCameraMatrices(shader_to_use, camera->mat_proj, camera->mat_view);
					zt_shaderApplyVariables(shader_to_use);
				}

				if (!zt_bitIsSet(model_info_flags, ztSceneModelFlags_Culled)) {
					local::renderModel(pass, scene, shader, scene->models[i].model, model_flags, camera, 0, &needs_multipass);
				}

				if (shader_to_use != shader) {
					zt_shaderEnd(shader_to_use);
					zt_shaderBegin(shader);
					zt_shaderSetCameraMatrices(shader_to_use, camera->mat_proj, camera->mat_view);
					zt_shaderApplyVariables(shader);
				}
			}

			zt_shaderEnd(shader);

			if (!needs_multipass) {
				break;
			}
		}

		zt_textureRenderTargetCommit(scene->tex_depth);
	}

#	endif
}

// ================================================================================================================================================================================================

void zt_sceneRender(ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules)
{
	ZT_PROFILE_RENDERING("zt_sceneRender");
	struct local
	{
		static void renderModel(ztScene *scene, ztScene::ModelInfo *scene_model_info, i32 scene_model_index, ztModel *model, ztCamera *camera, ztMat4 *light_mat, ztShaderID *active_shader, ztSceneLightingRules *lighting_rules)
		{
			if (model->type == ztModelType_Invalid) {
				return;
			}

			i32 model_flags = model->flags;
			i32 model_info_flags = scene_model_info->flags;
			ztShaderID shader_to_use = model->shader;

			if (ZT_FUNCTION_POINTER_IS_VALID(scene->render_override) || ZT_FUNCTION_POINTER_IS_VALID(scene_model_info->render_override)) {
				ZT_FUNCTION_POINTER_ACCESS_SAFE(scene->render_override, ztSceneRenderModelOverride_Func)(scene, scene_model_index, model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Render, scene->render_override_user_data);
				ZT_FUNCTION_POINTER_ACCESS_SAFE(scene_model_info->render_override, ztSceneRenderModelOverride_Func)(scene, scene_model_index, model, &shader_to_use, &model_info_flags, &model_flags, ztSceneRenderStage_Render, scene_model_info->render_override_user_data);
			}

			if (zt_bitIsSet(model_info_flags, ztSceneModelFlags_Culled) || zt_bitIsSet(model_flags, ztModelFlags_Hidden) || zt_bitIsSet(model_flags, ztModelFlags_ShadowOnly)) {
				return;
			}

			ztSprite *sprite_anim = model->type == ztModelType_SpriteAnimation ? zt_spriteAnimControllerActiveSprite(model->sprite_anim_controller) : nullptr;

			bool shader_supports_lights = zt_bitIsSet(model_info_flags, ztSceneModelFlags_ShaderLit);
			bool shader_supports_bones = zt_bitIsSet(model_info_flags, ztSceneModelFlags_ShaderBones);

			if (shader_to_use != *active_shader) {
				if (*active_shader != ztInvalidID) {
					zt_shaderEnd(*active_shader);
				}
				*active_shader = shader_to_use;
				zt_shaderBegin(*active_shader);

				if (shader_supports_lights) {
					if (scene->directional_light.light) {
						static u32 light_matrix_hash    = zt_strHash("light_matrix");
						static u32 light_pos_hash       = zt_strHash("light_pos");
						static u32 light_ambient_hash   = zt_strHash("light_ambient");
						static u32 light_intensity_hash = zt_strHash("light_intensity");
						static u32 light_color_hash     = zt_strHash("light_color");
						static u32 view_pos_hash        = zt_strHash("view_pos");

						zt_shaderSetVariableMat4(*active_shader, light_matrix_hash, *light_mat);
						zt_shaderSetVariableVec3(*active_shader, light_pos_hash, (/*camera->position + */scene->directional_light.light->position) * 10000);
						zt_shaderSetVariableFloat(*active_shader, light_ambient_hash, scene->directional_light.light->ambient);
						zt_shaderSetVariableFloat(*active_shader, light_intensity_hash, scene->directional_light.light->intensity);
						zt_shaderSetVariableVec4(*active_shader, light_color_hash, scene->directional_light.light->color);
						zt_shaderSetVariableVec3(*active_shader, view_pos_hash, camera->position);
					}

					int point_lights = 0;
					static u32 point_lights_ambient_color_hash [ZT_SCENE_MAX_LIGHTS] = { 0 };
					static u32 point_lights_intensity_hash     [ZT_SCENE_MAX_LIGHTS];
					static u32 point_lights_pos_hash           [ZT_SCENE_MAX_LIGHTS];
					static u32 point_lights_far_plane_hash     [ZT_SCENE_MAX_LIGHTS];
					static u32 point_lights_shadowmap_use_hash [ZT_SCENE_MAX_LIGHTS];
					static u32 point_lights_shadowmap_hash     [ZT_SCENE_MAX_LIGHTS];

					int spot_lights = 0;
					static u32 spot_lights_ambient_color_hash  [ZT_SCENE_MAX_LIGHTS] = { 0 };
					static u32 spot_lights_intensity_hash      [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_direction_hash      [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_pos_hash            [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_cutoff_in_hash      [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_cutoff_out_hash     [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_far_plane_hash      [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_shadowmap_use_hash  [ZT_SCENE_MAX_LIGHTS];
					static u32 spot_lights_shadowmap_hash      [ZT_SCENE_MAX_LIGHTS];

					//zt_fiz(ZT_SCENE_MAX_LIGHTS) {
					zt_fiz(scene->list_light_count) {
						ztScene::LightInfo *light_info = scene->list_light[i];

						if (light_info->light != 0 && !zt_bitIsSet(light_info->flags, ztSceneLightFlags_Culled)) {

							switch (light_info->light->type)
							{
								case ztLightType_Point: {
									if (point_lights_ambient_color_hash[point_lights] == 0) {
										char varname[128];
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights[%d].ambient_color", point_lights); point_lights_ambient_color_hash[point_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights[%d].intensity",     point_lights); point_lights_intensity_hash    [point_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights[%d].pos",           point_lights); point_lights_pos_hash          [point_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights[%d].far_plane",     point_lights); point_lights_far_plane_hash    [point_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights[%d].shadowmap_use", point_lights); point_lights_shadowmap_use_hash[point_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "point_lights_shadowmap[%d]",     point_lights); point_lights_shadowmap_hash    [point_lights] = zt_strHash(varname);
									}

									zt_shaderSetVariableVec3 (*active_shader, point_lights_ambient_color_hash [point_lights], light_info->light->color.rgb * light_info->light->intensity);
									zt_shaderSetVariableFloat(*active_shader, point_lights_intensity_hash     [point_lights], light_info->light->intensity);
									zt_shaderSetVariableVec3 (*active_shader, point_lights_pos_hash           [point_lights], light_info->light->position);
									zt_shaderSetVariableFloat(*active_shader, point_lights_far_plane_hash     [point_lights], light_info->far_plane);
									zt_shaderSetVariableInt  (*active_shader, point_lights_shadowmap_use_hash [point_lights], light_info->light->casts_shadows ? 1 : 0);
									zt_shaderSetVariableTex  (*active_shader, point_lights_shadowmap_hash     [point_lights], light_info->light->casts_shadows ? light_info->shadowmap_tex : 0);
									point_lights += 1;
								} break;

								case ztLightType_Spot: {
									if (spot_lights_ambient_color_hash[spot_lights] == 0) {
										char varname[128];
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].ambient_color", spot_lights); spot_lights_ambient_color_hash[spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].intensity",     spot_lights); spot_lights_intensity_hash    [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].direction",     spot_lights); spot_lights_direction_hash    [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].pos",           spot_lights); spot_lights_pos_hash          [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].cutoff_in",     spot_lights); spot_lights_cutoff_in_hash    [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].cutoff_out",    spot_lights); spot_lights_cutoff_out_hash   [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].far_plane",     spot_lights); spot_lights_far_plane_hash    [spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights[%d].shadowmap_use", spot_lights); spot_lights_shadowmap_use_hash[spot_lights] = zt_strHash(varname);
										zt_strPrintf(varname, zt_elementsOf(varname), "spot_lights_shadowmap[%d]",     spot_lights); spot_lights_shadowmap_hash    [spot_lights] = zt_strHash(varname);
									}

									zt_shaderSetVariableVec3 (*active_shader, spot_lights_ambient_color_hash [spot_lights], light_info->light->color.rgb * light_info->light->intensity);
									zt_shaderSetVariableFloat(*active_shader, spot_lights_intensity_hash     [spot_lights], light_info->light->intensity);
									zt_shaderSetVariableVec3 (*active_shader, spot_lights_direction_hash     [spot_lights], light_info->light->direction);
									zt_shaderSetVariableVec3 (*active_shader, spot_lights_pos_hash           [spot_lights], light_info->light->position);
									zt_shaderSetVariableFloat(*active_shader, spot_lights_cutoff_in_hash     [spot_lights], light_info->light->cutoff_in);
									zt_shaderSetVariableFloat(*active_shader, spot_lights_cutoff_out_hash    [spot_lights], light_info->light->cutoff_out);
									zt_shaderSetVariableFloat(*active_shader, spot_lights_far_plane_hash     [spot_lights], light_info->far_plane);
									zt_shaderSetVariableInt  (*active_shader, spot_lights_shadowmap_use_hash [spot_lights], light_info->light->casts_shadows ? 1 : 0);
									zt_shaderSetVariableTex  (*active_shader, spot_lights_shadowmap_hash     [spot_lights], light_info->light->casts_shadows ? scene->lights[spot_lights].shadowmap_tex : 0);
									spot_lights += 1;
								} break;
							}
						}
					}

					static u32 point_lights_count_hash = zt_strHash("point_lights_count");
					static u32 spot_lights_count_hash  = zt_strHash("spot_lights_count");

					zt_shaderSetVariableInt(*active_shader, point_lights_count_hash, point_lights);
					zt_shaderSetVariableInt(*active_shader, spot_lights_count_hash, spot_lights);
				}

				zt_shaderSetCameraMatrices(*active_shader, camera->mat_proj, camera->mat_view);
				if (model->shader_vars) {
					zt_shaderApplyVariables(*active_shader, model->shader_vars);
				}
			}
			else if (model->shader_vars) {
				zt_shaderApplyVariables(*active_shader, model->shader_vars);
			}

			if (sprite_anim) {
				model->material.diffuse_tex = sprite_anim->tex;
			}
			else if (model->type == ztModelType_ParticleSystem) {
				if (model->particle_emitter->system->system_rendering.type != ztParticleRenderingType_Mesh) {
					model->material.diffuse_tex = model->particle_emitter->system->system_rendering.type == ztParticleRenderingType_BillBoard ? model->particle_emitter->system->system_rendering.billboard.sprite.tex : model->particle_emitter->system->system_rendering.facing.sprite.tex;
				}
			}

			ztTextureID additional_textures[8];
			u32 additional_textures_hashes[8];
			int additional_textures_count = 0;

			if (shader_supports_lights) {
				static u32 directional_light_shadowmap_hash = zt_strHash("directional_light_shadowmap");

				int idx = additional_textures_count++;
				additional_textures[idx] = scene->tex_directional_shadow_map;
				additional_textures_hashes[idx] = directional_light_shadowmap_hash;
			}

			if (scene->tex_irradiance_map != ztInvalidID) {
				static u32 irradiance_map_tex_hash = zt_strHash("irradiance_map_tex");

				int idx = additional_textures_count++;
				additional_textures[idx] = scene->tex_irradiance_map;
				additional_textures_hashes[idx] = irradiance_map_tex_hash;
			}

			if (scene->tex_prefilter_map != ztInvalidID) {
				static u32 prefilter_map_tex_hash = zt_strHash("prefilter_map_tex");

				int idx = additional_textures_count++;
				additional_textures[idx] = scene->tex_prefilter_map;
				additional_textures_hashes[idx] = prefilter_map_tex_hash;
			}

			if (scene->tex_brdf_lut != ztInvalidID) {
				static u32 brdf_lut_tex_hash = zt_strHash("brdf_lut_tex");

				int idx = additional_textures_count++;
				additional_textures[idx] = scene->tex_brdf_lut;
				additional_textures_hashes[idx] = brdf_lut_tex_hash;
			}

			if (additional_textures_count > 0) {
				zt_materialPrepare(&model->material, *active_shader, additional_textures, additional_textures_hashes, additional_textures_count);
			}
			else {
				zt_materialPrepare(&model->material, *active_shader);
			}

			if (shader_supports_bones) {
				static u32 bones_count_hash = 0;
				static u32 bones_names_hash[ZT_MAX_BONES];

				if (bones_count_hash == 0) {
					bones_count_hash = zt_strHash("bones_count");

					zt_fiz(ZT_MAX_BONES) {
						zt_strMakePrintf(bones_name, 128, "bones[%d]", i);
						bones_names_hash[i] = zt_strHash(bones_name);
					}
				}

				zt_shaderSetVariableInt(*active_shader, bones_count_hash, model->bones_count);

				zt_fiz(model->bones_count) {
#						if defined(ZT_DEBUG)
					if (i == 0 && !zt_shaderHasVariable(*active_shader, bones_names_hash[i], nullptr)) {
						break;
					}
#						endif

					zt_shaderSetVariableMat4(*active_shader, bones_names_hash[i], model->bones[i].mat_offset);

#						if defined(ZT_DEBUG)
					if (i == model->bones_count - 1) {
						zt_assert(zt_shaderHasVariable(*active_shader, bones_names_hash[i], nullptr));
					}
#						endif
					//	zt_shaderSetVariableMat4(*active_shader, zt_strHash(bones_name), model->calculated_mat);
				}
			}

			if (model->type == ztModelType_ParticleSystem) {
				model->particle_emitter->position = model->calculated_mat.getMultiply(ztVec3::zero);
				zt_shaderSetModelMatrices(*active_shader, ztMat4::identity);
			}
			else {
				zt_shaderSetModelMatrices(*active_shader, model->calculated_mat);
			}

			bool changed_cull = zt_bitIsSet(model_flags, ztModelFlags_NoFaceCull);
			if (changed_cull) {
				zt_rendererSetFaceCulling(ztRendererFaceCulling_CullNone);
			}

			switch (model->type)
			{
				case ztModelType_Mesh: {
					zt_meshRender(model->mesh_id);
				} break;

				case ztModelType_VertexArray: {
					zt_vertexArrayDraw(model->vertex_array_id);
				} break;

				case ztModelType_SpriteAnimation:
				case ztModelType_Sprite: {
					_zt_sceneDrawSprite(scene, model, camera);
				} break;

				case ztModelType_ParticleSystem: {
					_zt_sceneDrawParticle(scene, model, camera);
				} break;
			}

			if (changed_cull) {
				zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);
			}
			//ztModel *child = model->first_child;
			//while (child) {
			//	local::renderModelAndChildren(scene, scene_model_info, child, camera, light_mat, active_shader, lighting_rules);
			//	child = child->next;
			//}
		}
	};

	_zt_rendererCheckToResetStats();

	if (lighting_rules == nullptr) {
		static ztSceneLightingRules rules = {};
		lighting_rules = &rules;
	}


	zt_rendererSetDepthTest(true, ztRendererDepthTestFunction_LessEqual);

	ztShaderID shader = ztInvalidID;

	ztMat4 light_mat;
	if (scene->directional_light.light) {
		light_mat = _zt_sceneLightingMakeLightMat(scene, scene->directional_light.light, camera, lighting_rules);
	}
	else {
		light_mat = ztMat4::identity;
	}

	//glDisable(GL_BLEND);

	zt_fiz(scene->list_std_count) {
		local::renderModel(scene, scene->list_std[i], scene->list_std[i]->index, scene->list_std[i]->model, camera, &light_mat, &shader, lighting_rules);
	}

	if (shader != ztInvalidID) {
		zt_shaderEnd(shader);
		shader = ztInvalidID;
	}

	//glEnable(GL_BLEND);

	if (scene->skybox.model) {
		static u32 skybox_hash = zt_strHash("skybox_tex");

		ztMat4 mat_view = camera->mat_view;
		mat_view.values[ztMat4_Col3Row0] = mat_view.values[ztMat4_Col3Row1] = mat_view.values[ztMat4_Col3Row2] = 0;
		mat_view.values[ztMat4_Col3Row3] = 1;

		zt_shaderBegin(scene->skybox.model->shader);
		zt_shaderSetCameraMatrices(scene->skybox.model->shader, camera->mat_proj, mat_view);
		zt_shaderSetVariableTexCube(scene->skybox.model->shader, skybox_hash, scene->skybox.model->material.diffuse_tex);
		zt_shaderApplyVariables(scene->skybox.model->shader);
		zt_meshRender(scene->skybox.model->mesh_id);
		zt_shaderEnd(scene->skybox.model->shader);
	}

	zt_rendererEnableDepthWriting(false);
	zt_fiz(scene->list_trn_count) {
		local::renderModel(scene, scene->list_trn[i], scene->list_trn[i]->index, scene->list_trn[i]->model, camera, &light_mat, &shader, lighting_rules);
	}
	zt_rendererEnableDepthWriting(true);

	if (shader != ztInvalidID) {
		zt_shaderEnd(shader);
	}
}

// ================================================================================================================================================================================================

void zt_sceneRenderDebug(ztDrawList *draw_list, i32 debug_flags, ztScene *scene, ztCamera *camera, ztSceneLightingRules *lighting_rules)
{
	struct local
	{
		static bool bitIsSetInParentHierarchy(ztModel *model, i32 flags)
		{
			if (zt_bitIsSet(model->flags, flags)) {
				return true;
			}

			//if (model->parent) {
			//	return bitIsSetInParentHierarchy(model->parent, flags);
			//}

			return false;
		}

		static ztVec3 totalScale(ztModel *model)
		{
			ztVec3 scale = model->transform.scale;
			if (model->parent) {
				scale *= totalScale(model->parent);
			}

			return scale;
		}

		static ztMat4 calculateMat(ztBone *bone)
		{
			ztMat4 mat = zt_transformToMat4(&bone->transform);
			if (bone->parent) {
				ztMat4 mat_p = calculateMat(bone->parent);
				mat = mat_p * mat;
			}

			return mat;
		}

		static void drawBone(ztDrawList *draw_list, ztBone *bone, ztModel *model, const ztMat4& parent_transform)
		{
			// todo(josh): this is wrong.  fix it
			//return;

#if 0
//			ztMat4 current_local_transform = zt_transformToMat4(&bone->transform);
//			ztMat4 current_transform = parent_transform * current_local_transform;

			ztMat4 current_local_transform = zt_transformToMat4(&bone->transform_base);
			ztMat4 current_transform = parent_transform * current_local_transform;

			//*
			zt_drawListPushTransform(draw_list, current_transform);
			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Yellow : (bone->transform.rotation.euler().equalsClose(bone->transform_base.rotation.euler()) ? ztColor_Green : ztColor_Cyan));

			r32 size = .02f * bone->size / model->transform.scale.x;
			zt_drawListAddEmptyBone(draw_list, ztVec3::zero, 12 * size, 1 * size, 2 * size);
			zt_drawListAddEmptySimpleSphere(draw_list, zt_vec3(0, bone->size * .2f, 0), .025f, 8);
			zt_drawListPopColor(draw_list);
			zt_drawListPopTransform(draw_list);
			//*/

			if (true) {
				zt_drawListPushTransform(draw_list, bone->mat_offset);
				zt_drawListPushColor(draw_list, ztColor_Red);

				r32 size = .025f * bone->size / model->transform.scale.x;
				zt_drawListAddEmptyBone(draw_list, ztVec3::zero, 12 * size, 1 * size, 2 * size);
				zt_drawListAddEmptySimpleSphere(draw_list, zt_vec3(0, bone->size * .2f, 0), .025f, 8);
				zt_drawListPopColor(draw_list);
				zt_drawListPopTransform(draw_list);
			}

			zt_flink(child, bone->first_child) {
				drawBone(draw_list, child, model, current_transform);// parent_transform);
			}
#else
			/*
			// draw bones based on bind transforms
			ztVec3 bone_pos = model->calculated_mat.getMultiply(bone->mat_local_bind_transform.getMultiply(ztVec3::zero));
			
			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Yellow : ztColor_Cyan);

			r32 size = .025f;//.025f * bone->size / model->transform.scale.x;
			zt_drawListAddEmptyBone(draw_list, bone_pos, 12 * size, 1 * size, 2 * size);

			if (zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) && bone->parent) {
				ztVec3 parent_bone_pos = model->calculated_mat.getMultiply(bone->parent->mat_local_bind_transform.getMultiply(ztVec3::zero));

				zt_drawListAddLine(draw_list, bone_pos, parent_bone_pos);
			}

			zt_drawListPopColor(draw_list);

			zt_flink(child, bone->first_child) {
				drawBone(draw_list, child, model, model->calculated_mat);
			}
			// */
			//*
			// draw bones based on global position matrix:
			ztMat4 from_bone_to_global = parent_transform * bone->mat_offset * bone->mat_model;
			ztVec3 bone_global_pos = from_bone_to_global.getMultiply(ztVec3::zero);

			zt_drawListPushTransform(draw_list, from_bone_to_global);
			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Yellow : ztColor_Cyan);

			r32 size = .025f * bone->size / model->transform.scale.x;
			zt_drawListAddEmptyBone(draw_list, ztVec3::zero, 12 * size, 1 * size, 2 * size);
			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Red : ztColor_Purple);
			zt_drawListAddEmptySimpleSphere(draw_list, ztVec3::zero, size * .5f, 8);
			zt_drawListPopColor(draw_list);
			zt_drawListPopColor(draw_list);
			zt_drawListPopTransform(draw_list);

			zt_flink(child, bone->first_child) {
				drawBone(draw_list, child, model, parent_transform);
			}
			//*/
#endif

//			ztVec3 pos = bone->mat_model.getMultiply(ztVec3::zero);
//			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Yellow : ztColor_Green);
//			zt_drawListAddEmptyCubeFromCenterSize(draw_list, pos, zt_vec3(.25f, .25f, .25f));
//			zt_drawListPopColor(draw_list);


//			pos = current_transform.getMultiply(ztVec3::zero);
//			//zt_drawListPushTransform(draw_list, model->calculated_mat * mat);
//			zt_drawListPushColor(draw_list, zt_bitIsSet(bone->flags, ztBoneFlags_DebugDrawHighlight) ? ztColor_Purple : (bone->transform.rotation.euler().equalsClose(bone->transform_base.rotation.euler()) ? ztColor_Blue : ztColor_Orange));
//			zt_drawListAddEmptyCubeFromCenterSize(draw_list, pos, zt_vec3(.20f, .20f, .20f));
//			zt_drawListPopColor(draw_list);


		}

		static void renderModelAndChildren(ztDrawList *draw_list, i32 debug_flags, ztScene *scene, ztScene::ModelInfo *scene_model_info, ztModel *model, ztCamera *camera)
		{
			if (zt_bitIsSet(model->flags, ztModelFlags_Hidden)) {
				return;
			}

			if (zt_bitIsSet(debug_flags, ztModelFlags_DebugDrawAxis) && bitIsSetInParentHierarchy(model, ztModelFlags_DebugDrawAxis)) {
				zt_drawListAddAxis(draw_list, model->calculated_mat);
			}

			if (zt_bitIsSet(debug_flags, ztModelFlags_DrawOrigin) && bitIsSetInParentHierarchy(model, ztModelFlags_DrawOrigin)) {
				ztVec3 point_origin = model->parent ? model->parent->calculated_mat.getMultiply(ztVec3::zero) : ztVec3::zero;
				ztVec3 point_current = model->calculated_mat.getMultiply(ztVec3::zero);

				zt_drawListPushColor(draw_list, ztColor_Cyan);
				zt_drawListAddLine(draw_list, point_origin, point_current);
				zt_drawListPopColor(draw_list);
			}

			if (zt_bitIsSet(debug_flags, ztModelFlags_DebugDrawAABB) && bitIsSetInParentHierarchy(model, ztModelFlags_DebugDrawAABB)) {
				zt_drawListPushColor(draw_list, ztColor_Yellow);
				ztVec3 aabb_center, aabb_size;

				zt_modelGetAABB(model, &aabb_center, &aabb_size);
				ztVec3 pos = ztVec3::zero;// model->calculated_mat.getMultiply(ztVec3::zero);
				zt_drawListAddEmptyCubeFromCenterSize(draw_list, pos + aabb_center, aabb_size * totalScale(model));
				zt_drawListPopColor(draw_list);
			}

			if (zt_bitIsSet(debug_flags, ztModelFlags_DebugDrawOBB) && bitIsSetInParentHierarchy(model, ztModelFlags_DebugDrawOBB)) {
				zt_drawListPushColor(draw_list, ztColor_Orange);
				zt_drawListPushTransform(draw_list, model->calculated_mat);
				ztVec3 obb_center, obb_size;

				zt_modelGetOBB(model, &obb_center, &obb_size);
				zt_drawListAddEmptyCubeFromCenterSize(draw_list, obb_center, obb_size);
				zt_drawListPopTransform(draw_list);
				zt_drawListPopColor(draw_list);
			}

			if (zt_bitIsSet(debug_flags, ztModelFlags_DebugDrawBones) && bitIsSetInParentHierarchy(model, ztModelFlags_DebugDrawBones) && model->bones_count > 0) {
			//if (zt_bitIsSet(debug_flags, ztModelFlags_DebugDrawBones) && model->bones_count > 0) {
				drawBone(draw_list, &model->bones[model->bones_root_idx], model, model->calculated_mat);
			}

			ztModel *child = model->first_child;
			while (child) {
				local::renderModelAndChildren(draw_list, debug_flags, scene, scene_model_info, child, camera);
				child = child->next;
			}
		}
	};

	_zt_rendererCheckToResetStats();

	//zt_rendererSetDepthTest(false, ztRendererDepthTestFunction_LessEqual);
	zt_rendererClearDepth();

	zt_fiz(scene->models_count) {
		local::renderModelAndChildren(draw_list, debug_flags, scene, &scene->models[i], scene->models[i].model, camera);
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_QUADTREE_SERIAL_GUID      zt_guidMake(0x084a3e25, 0xa0c64f59, 0x86f0ac03, 0xd52c92d4)
#define ZT_QUADTREE_SERIAL_VERSION   10000
#define ZT_QUADTREE_SERIAL_FILE_ID   "ZT QuadTree File"

// ================================================================================================================================================================================================

void zt_quadTreeMake(ztQuadTree *quadtree, i32 max_objects_per_node, i32 max_node_levels, ztVec2 center, ztVec2 size, zt_QuadTreeItemContained_Func *callback, void *user_data)
{
	ZT_PROFILE_GAME("zt_quadTreeMake");
	struct local
	{
		static void count(ztVec2 center, ztVec2 size, i32 max_objects_per_node, i32 max_node_levels, i32 current_node_level, i32 *node_count, i32 *max_node_count, i32 *object_count, zt_QuadTreeItemContained_Func *callback, void *user_data)
		{
			ZT_PROFILE_GAME("zt_quadTreeMake::count");
			i32 objects_in_this_node = 0;
			i32 object_idx = 0;
			while (true) {
				bool object_is_valid = false;
				ztQuadTreeItemContainedResult_Enum result = (callback)(object_idx++, center, size, user_data);
				if (result == ztQuadTreeItemContainedResult_Inside) {
					objects_in_this_node += 1;
					if (objects_in_this_node > max_objects_per_node && current_node_level != max_node_levels) {
						break;
					}
				}
				else if (result == ztQuadTreeItemContainedResult_InvalidIndex) {
					break;
				}
			}

			if (objects_in_this_node <= max_objects_per_node || current_node_level == max_node_levels) { // final node
				*object_count += objects_in_this_node;
				return;
			}
			else { // split node and move down the tree
				ztVec2 nsize = zt_vec2(size.x / 2.f, size.y / 2.f);

				ztVec2 centers[4] = {
					zt_vec2(center.x - nsize.x * .5f, center.y + nsize.y * .5f),
					zt_vec2(center.x - nsize.x * .5f, center.y - nsize.y * .5f),
					zt_vec2(center.x + nsize.x * .5f, center.y - nsize.y * .5f),
					zt_vec2(center.x + nsize.x * .5f, center.y + nsize.y * .5f),
				};

				*max_node_count = zt_max(*max_node_count, *node_count + 4);

				zt_fize(centers) {
					i32 sub_object_count = 0;
					count(centers[i], nsize, max_objects_per_node, max_node_levels, current_node_level + 1, node_count, max_node_count, &sub_object_count, callback, user_data);

					if (sub_object_count > 0) {
						*object_count += sub_object_count;
						*node_count += 1;
					}
				}
			}
		}

		static void populate(ztQuadTree *tree, ztQuadTree::Node *node, i32 max_objects_per_node, i32 max_node_levels, i32 current_node_level, zt_QuadTreeItemContained_Func *callback, void *user_data)
		{
			ZT_PROFILE_GAME("zt_quadTreeMake::populate");
			i32 objects_in_this_node = 0;
			i32 object_idx = 0;
			while (true) {
				bool object_is_valid = false;
				ztQuadTreeItemContainedResult_Enum result = (callback)(object_idx++, node->center, node->size, user_data);
				if (result == ztQuadTreeItemContainedResult_Inside) {
					objects_in_this_node += 1;

					if (objects_in_this_node > max_objects_per_node && current_node_level != max_node_levels) {
						break;
					}
				}
				else if (result == ztQuadTreeItemContainedResult_InvalidIndex) {
					break;
				}
			}

			if (objects_in_this_node <= max_objects_per_node || current_node_level == max_node_levels) { // final node
				if (objects_in_this_node == 0) {
					return;
				}

				node->objects = tree->objects_cache + tree->objects_cache_used;
				node->objects_count = 0;
				tree->objects_cache_used += objects_in_this_node;
				zt_assert(tree->objects_cache_used <= tree->objects_cache_size);

				object_idx = 0;
				while (true) {
					bool object_is_valid = false;
					ztQuadTreeItemContainedResult_Enum result = (callback)(object_idx++, node->center, node->size, user_data);
					if (result == ztQuadTreeItemContainedResult_Inside) {
						node->objects[node->objects_count++] = object_idx - 1;
					}
					else if (result == ztQuadTreeItemContainedResult_InvalidIndex) {
						break;
					}
				}
				zt_assert(node->objects_count == objects_in_this_node);
				return;
			}
			else { // split node and move down the tree
				ztVec2 nsize = zt_vec2(node->size.x / 2.f, node->size.y / 2.f);

				ztVec2 centers[4] = {
					zt_vec2(node->center.x - nsize.x * .5f, node->center.y + nsize.y * .5f),
					zt_vec2(node->center.x - nsize.x * .5f, node->center.y - nsize.y * .5f),
					zt_vec2(node->center.x + nsize.x * .5f, node->center.y - nsize.y * .5f),
					zt_vec2(node->center.x + nsize.x * .5f, node->center.y + nsize.y * .5f),
				};

				zt_fize(centers) {
					zt_assert(tree->nodes_cache_used < tree->nodes_cache_size);
					ztQuadTree::Node *cnode = &tree->nodes_cache[tree->nodes_cache_used++];
					cnode->center = centers[i];
					cnode->size = nsize;

					populate(tree, cnode, max_objects_per_node, max_node_levels, current_node_level + 1, callback, user_data);

					if (cnode->objects_count == 0) {
						bool has_child_nodes = false;
						zt_fjze(cnode->nodes) {
							if (cnode->nodes[j] != nullptr) {
								has_child_nodes = true;
								break;
							}
						}
						if (!has_child_nodes) {
							tree->nodes_cache_used -= 1;
							cnode = nullptr;
						}
					}

					node->nodes[i] = cnode;
				}
			}
		}
	};

	zt_memSet(quadtree, zt_sizeof(ztQuadTree), 0);

	i32 node_count = 1, max_node_count = 1, object_count = 0;
	{
		ztBlockProfiler profile("QuadTree count");
		local::count(center, size, max_objects_per_node, max_node_levels, 0, &node_count, &max_node_count, &object_count, callback, user_data);
		node_count += zt_max(32, zt_convertToi32Floor(node_count * .5f));
		object_count += zt_max(32, zt_convertToi32Floor(object_count * .5f));
	}

	quadtree->nodes_cache = zt_mallocStructArray(ztQuadTree::Node, node_count);
	quadtree->nodes_cache_size = node_count;
	quadtree->nodes_cache_used = 0;
	quadtree->objects_cache = zt_mallocStructArray(i32, object_count);
	quadtree->objects_cache_size = object_count;
	quadtree->objects_cache_used = 0;

	ztQuadTree::Node *root_node = &quadtree->nodes_cache[quadtree->nodes_cache_used++];
	root_node->center = center;
	root_node->size = size;

	{
		ztBlockProfiler profile("QuadTree populate");
		local::populate(quadtree, root_node, max_objects_per_node, max_node_levels, 0, callback, user_data);
	}

	quadtree->root_node = root_node;
}

// ================================================================================================================================================================================================

bool zt_quadTreeMake(ztQuadTree *quadtree, ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_GAME("zt_quadTreeMake");

	zt_returnValOnNull(quadtree, false);
	zt_returnValOnNull(asset_mgr, false);

	if (asset_id < 0 || asset_id >= asset_mgr->asset_count) {
		return false;
	}

	void *data = nullptr;
	i32   size = 0;

	if (!_zt_assetLoadData(asset_mgr, asset_id, nullptr, 0, &data, &size)) {
		return false;
	}

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, data, size, ZT_QUADTREE_SERIAL_FILE_ID)) {
		return false;
	}

	bool result = zt_quadTreeLoad(quadtree, &serial);

	zt_serialClose(&serial);

	_zt_assetFreeData(asset_mgr, data);

	return result;
}

// ================================================================================================================================================================================================

void zt_quadTreeFree(ztQuadTree *quadtree)
{
	ZT_PROFILE_GAME("zt_quadTreeMake");

	if (quadtree == nullptr) {
		return;
	}

	if (quadtree->nodes_cache) {
		zt_free(quadtree->nodes_cache);
		quadtree->nodes_cache = nullptr;
		quadtree->nodes_cache_size = quadtree->nodes_cache_used = 0;
	}

	if (quadtree->objects_cache) {
		zt_free(quadtree->objects_cache);
		quadtree->objects_cache = nullptr;
		quadtree->objects_cache_size = quadtree->objects_cache_used = 0;
	}

	quadtree->root_node = nullptr;
}

// ================================================================================================================================================================================================

i32 zt_quadTreeFindNodesThatIntersect(ztQuadTree *quadtree, ztQuadTree::Node **nodes, i32 nodes_size, ztVec2 center, ztVec2 size)
{
	ZT_PROFILE_GAME("zt_quadTreeFindNodesThatIntersect");

	zt_returnValOnNull(quadtree, 0);
	zt_returnValOnNull(quadtree->root_node, 0);

	struct local
	{
		static void testIntersect(ztQuadTree::Node *node, ztQuadTree::Node **nodes, i32 nodes_size, i32 *nodes_idx, ztVec2 center, ztVec2 size)
		{
			ZT_PROFILE_GAME("zt_quadTreeFindNodesThatIntersect::testIntersect");

			if (!zt_collisionAABBInAABB(zt_vec3(center, 0), zt_vec3(size, 1), zt_vec3(node->center, 0), zt_vec3(node->size, 1))) {
				return;
			}

			if (node->objects_count > 0) {
				int idx = (*nodes_idx)++;
				if (idx < nodes_size) {
					nodes[idx] = node;
				}
			}
			else {
				zt_fize(node->nodes) {
					if (node->nodes[i]) {
						testIntersect(node->nodes[i], nodes, nodes_size, nodes_idx, center, size);
					}
				}
			}
		}
	};

	i32 nodes_idx = 0;
	local::testIntersect(quadtree->root_node, nodes, nodes_size, &nodes_idx, center, size);
	return nodes_idx;
}

// ================================================================================================================================================================================================

i32 zt_quadTreeFindNodesThatIntersectLine(ztQuadTree *quadtree, ztQuadTree::Node **nodes, i32 nodes_size, ztVec2 line_beg, ztVec2 line_end)
{
	ZT_PROFILE_GAME("zt_quadTreeFindNodesThatIntersectLine");

	zt_returnValOnNull(quadtree, 0);
	zt_returnValOnNull(quadtree->root_node, 0);

	struct local
	{
		static void testIntersect(ztQuadTree::Node *node, ztQuadTree::Node **nodes, i32 nodes_size, i32 *nodes_idx, ztVec2 line_beg, ztVec2 line_end)
		{
			ZT_PROFILE_GAME("zt_quadTreeFindNodesThatIntersectLine::testIntersect");

			if (!zt_collisionLineSegmentInAABB(line_beg, line_end, node->center, node->size)) {
				return;
			}

			if (node->objects_count > 0) {
				int idx = (*nodes_idx)++;
				if (idx < nodes_size) {
					nodes[idx] = node;
				}
			}
			else {
				zt_fize(node->nodes) {
					if (node->nodes[i]) {
						testIntersect(node->nodes[i], nodes, nodes_size, nodes_idx, line_beg, line_end);
					}
				}
			}
		}
	};

	i32 nodes_idx = 0;
	local::testIntersect(quadtree->root_node, nodes, nodes_size, &nodes_idx, line_beg, line_end);
	return nodes_idx;
}

// ================================================================================================================================================================================================

bool zt_quadTreeSaveToFile(ztQuadTree *quadtree, const char *file)
{
	ZT_PROFILE_GAME("zt_quadTreeSaveToFile");

	zt_returnValOnNull(quadtree, false);

	if (zt_fileExists(file)) {
		return false;
	}

	ztSerial serial;
	if (!zt_serialMakeWriter(&serial, file, ZT_QUADTREE_SERIAL_FILE_ID, ZT_QUADTREE_SERIAL_VERSION)) {
		return false;
	}

	bool result = zt_quadTreeSave(quadtree, &serial);

	zt_serialClose(&serial);

	return result;
}

// ================================================================================================================================================================================================

bool zt_quadTreeSave(ztQuadTree *quadtree, ztSerial *serial)
{
	ZT_PROFILE_GAME("zt_quadTreeSave");

	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialWrite(serial, ZT_QUADTREE_SERIAL_GUID)) return false;
		if (!zt_serialWrite(serial, (i32)ZT_QUADTREE_SERIAL_VERSION)) return false;

		if (!zt_serialWrite(serial, quadtree->objects_cache_used)) return false;
		zt_fiz(quadtree->objects_cache_used) {
			if (!zt_serialWrite(serial, quadtree->objects_cache[i])) return false;
		}

		if (!zt_serialWrite(serial, quadtree->nodes_cache_used)) return false;
		zt_fiz(quadtree->nodes_cache_used) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialWrite(serial, quadtree->nodes_cache[i].center)) return false;
				if (!zt_serialWrite(serial, quadtree->nodes_cache[i].size)) return false;
				if (!zt_serialWrite(serial, quadtree->nodes_cache[i].objects_count)) return false;

				if (quadtree->nodes_cache[i].objects_count > 0) {
					i32 start = (i32)(quadtree->nodes_cache[i].objects - quadtree->objects_cache);
					if (!zt_serialWrite(serial, start)) return false;
				}

				zt_fjz(4) {
					i32 node_idx = -1;
					if (quadtree->nodes_cache[i].nodes[j] != nullptr) {
						zt_fkz(quadtree->nodes_cache_used) {
							if (quadtree->nodes_cache[i].nodes[j] == &quadtree->nodes_cache[k]) {
								node_idx = k;
								break;
							}
						}
					}

					if (!zt_serialWrite(serial, node_idx)) return false;
				}
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		i32 root_node_idx = -1;
		zt_fkz(quadtree->nodes_cache_used) {
			if (quadtree->root_node == &quadtree->nodes_cache[k]) {
				root_node_idx = k;
				break;
			}
		}
		if (!zt_serialWrite(serial, root_node_idx)) return false;
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_quadTreeLoad(ztQuadTree *quadtree, ztSerial *serial)
{
	ZT_PROFILE_GAME("zt_quadTreeLoad");

	if (!zt_serialGroupPush(serial)) return false;
	{
		ztGuid guid;
		if (!zt_serialRead(serial, &guid)) return false;
		zt_assertReturnValOnFail(guid == ZT_QUADTREE_SERIAL_GUID, false);

		i32 version = 0;
		if (!zt_serialRead(serial, &version)) return false;
		zt_assertReturnValOnFail(version >= 0 && version <= ZT_QUADTREE_SERIAL_VERSION, false);

		if (!zt_serialRead(serial, &quadtree->objects_cache_used)) return false;
		zt_assertReturnValOnFail(quadtree->objects_cache_used > 0, false);

		quadtree->objects_cache_size = quadtree->objects_cache_used;
		quadtree->objects_cache = zt_mallocStructArray(i32, quadtree->objects_cache_used);

		zt_fiz(quadtree->objects_cache_used) {
			if (!zt_serialRead(serial, &quadtree->objects_cache[i])) return false;
		}

		if (!zt_serialRead(serial, &quadtree->nodes_cache_used)) return false;
		zt_assertReturnValOnFail(quadtree->nodes_cache_used > 0, false);

		quadtree->nodes_cache_size = quadtree->nodes_cache_used;
		quadtree->nodes_cache = zt_mallocStructArray(ztQuadTree::Node, quadtree->nodes_cache_size);

		zt_fiz(quadtree->nodes_cache_used) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialRead(serial, &quadtree->nodes_cache[i].center)) return false;
				if (!zt_serialRead(serial, &quadtree->nodes_cache[i].size)) return false;
				if (!zt_serialRead(serial, &quadtree->nodes_cache[i].objects_count)) return false;

				if (quadtree->nodes_cache[i].objects_count) {
					i32 start = -1;
					if (!zt_serialRead(serial, &start)) return false;
					zt_assertReturnValOnFail(start >= 0 && start < quadtree->objects_cache_size, false);

					quadtree->nodes_cache[i].objects = quadtree->objects_cache + start;
				}
				else {
					quadtree->nodes_cache[i].objects = nullptr;
				}

				zt_fjz(4) {
					i32 node_idx = -1;
					if (!zt_serialRead(serial, &node_idx)) return false;
					zt_assertReturnValOnFail(node_idx >= -1 && node_idx < quadtree->nodes_cache_size, false);

					if (node_idx < 0) {
						quadtree->nodes_cache[i].nodes[j] = nullptr;
					}
					else {
						quadtree->nodes_cache[i].nodes[j] = &quadtree->nodes_cache[node_idx];
					}
				}
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		i32 root_node_idx = -1;
		if (!zt_serialRead(serial, &root_node_idx)) return false;
		zt_assertReturnValOnFail(root_node_idx >= -1 && root_node_idx < quadtree->nodes_cache_size, false);

		quadtree->root_node = &quadtree->nodes_cache[root_node_idx];
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_OCTREE_SERIAL_GUID      zt_guidMake(0x4bc57cb4, 0x94074d69, 0xb9693ac2, 0xe433bea1)
#define ZT_OCTREE_SERIAL_VERSION   10000
#define ZT_OCTREE_SERIAL_FILE_ID   "ZT OcTree File"

// ================================================================================================================================================================================================

void zt_ocTreeMake(ztOcTree *octree, i32 max_objects_per_node, i32 max_node_levels, ztVec3 center, ztVec3 size, zt_OcTreeItemContained_Func *callback, void *user_data)
{
	ZT_PROFILE_GAME("zt_ocTreeMake");

	struct local
	{
		static void count(ztVec3 center, ztVec3 size, i32 max_objects_per_node, i32 max_node_levels, i32 current_node_level, i32 *node_count, i32 *object_count, zt_OcTreeItemContained_Func *callback, void *user_data)
		{
			ZT_PROFILE_GAME("zt_ocTreeMake::count");

			i32 objects_in_this_node = 0;
			i32 object_idx = 0;
			while (true) {
				bool object_is_valid = false;
				ztOcTreeItemContainedResult_Enum result = (callback)(object_idx++, center, size, user_data);
				if (result == ztOcTreeItemContainedResult_Inside) {
					objects_in_this_node += 1;
					if (objects_in_this_node > max_objects_per_node && current_node_level != max_node_levels) {
						break;
					}
				}
				else if (result == ztOcTreeItemContainedResult_InvalidIndex) {
					break;
				}
			}

			if (objects_in_this_node <= max_objects_per_node || current_node_level == max_node_levels) { // final node
				*object_count += objects_in_this_node;
				return;
			}
			else { // split node and move down the tree
				ztVec3 nsize = zt_vec3(size.x / 2.f, size.y / 2.f, size.z / 2.f);

				ztVec3 centers[8] = {
					zt_vec3(center.x - nsize.x * .5f, center.y + nsize.y * .5f, center.z + nsize.z * .5f),
					zt_vec3(center.x - nsize.x * .5f, center.y + nsize.y * .5f, center.z - nsize.z * .5f),
					zt_vec3(center.x + nsize.x * .5f, center.y + nsize.y * .5f, center.z - nsize.z * .5f),
					zt_vec3(center.x + nsize.x * .5f, center.y + nsize.y * .5f, center.z + nsize.z * .5f),
					zt_vec3(center.x - nsize.x * .5f, center.y - nsize.y * .5f, center.z + nsize.z * .5f),
					zt_vec3(center.x - nsize.x * .5f, center.y - nsize.y * .5f, center.z - nsize.z * .5f),
					zt_vec3(center.x + nsize.x * .5f, center.y - nsize.y * .5f, center.z - nsize.z * .5f),
					zt_vec3(center.x + nsize.x * .5f, center.y - nsize.y * .5f, center.z + nsize.z * .5f),
				};

				zt_fize(centers) {
					i32 sub_object_count = 0;
					count(centers[i], nsize, max_objects_per_node, max_node_levels, current_node_level + 1, node_count, &sub_object_count, callback, user_data);

					if (sub_object_count > 0) {
						*object_count += sub_object_count;
						*node_count += 1;
					}
				}
			}
		}

		static void populate(ztOcTree *tree, ztOcTree::Node *node, i32 max_objects_per_node, i32 max_node_levels, i32 current_node_level, zt_OcTreeItemContained_Func *callback, void *user_data)
		{
			ZT_PROFILE_GAME("zt_ocTreeMake::populate");

			i32 objects_in_this_node = 0;
			i32 object_idx = 0;
			while (true) {
				bool object_is_valid = false;
				ztOcTreeItemContainedResult_Enum result = (callback)(object_idx++, node->center, node->size, user_data);
				if (result == ztOcTreeItemContainedResult_Inside) {
					objects_in_this_node += 1;

					if (objects_in_this_node > max_objects_per_node && current_node_level != max_node_levels) {
						break;
					}
				}
				else if (result == ztOcTreeItemContainedResult_InvalidIndex) {
					break;
				}
			}

			if (objects_in_this_node <= max_objects_per_node || current_node_level == max_node_levels) { // final node
				if (objects_in_this_node == 0) {
					return;
				}

				node->objects = tree->objects_cache + tree->objects_cache_used;
				node->objects_count = 0;
				tree->objects_cache_used += objects_in_this_node;
				zt_assert(tree->objects_cache_used <= tree->objects_cache_size);

				object_idx = 0;
				while (true) {
					bool object_is_valid = false;
					ztOcTreeItemContainedResult_Enum result = (callback)(object_idx++, node->center, node->size, user_data);
					if (result == ztOcTreeItemContainedResult_Inside) {
						node->objects[node->objects_count++] = object_idx - 1;
					}
					else if (result == ztOcTreeItemContainedResult_InvalidIndex) {
						break;
					}
				}
				zt_assert(node->objects_count == objects_in_this_node);
				return;
			}
			else { // split node and move down the tree
				ztVec3 nsize = zt_vec3(node->size.x / 2.f, node->size.y / 2.f, node->size.z / 2.f);

				ztVec3 centers[8] = {
					zt_vec3(node->center.x - nsize.x * .5f, node->center.y + nsize.y * .5f, node->center.z + nsize.z * .5f),
					zt_vec3(node->center.x - nsize.x * .5f, node->center.y + nsize.y * .5f, node->center.z - nsize.z * .5f),
					zt_vec3(node->center.x + nsize.x * .5f, node->center.y + nsize.y * .5f, node->center.z - nsize.z * .5f),
					zt_vec3(node->center.x + nsize.x * .5f, node->center.y + nsize.y * .5f, node->center.z + nsize.z * .5f),
					zt_vec3(node->center.x - nsize.x * .5f, node->center.y - nsize.y * .5f, node->center.z + nsize.z * .5f),
					zt_vec3(node->center.x - nsize.x * .5f, node->center.y - nsize.y * .5f, node->center.z - nsize.z * .5f),
					zt_vec3(node->center.x + nsize.x * .5f, node->center.y - nsize.y * .5f, node->center.z - nsize.z * .5f),
					zt_vec3(node->center.x + nsize.x * .5f, node->center.y - nsize.y * .5f, node->center.z + nsize.z * .5f),
				};

				zt_fize(centers) {
					zt_assert(tree->nodes_cache_used < tree->nodes_cache_size);
					ztOcTree::Node *cnode = &tree->nodes_cache[tree->nodes_cache_used++];
					cnode->center = centers[i];
					cnode->size = nsize;

					populate(tree, cnode, max_objects_per_node, max_node_levels, current_node_level + 1, callback, user_data);

					if (cnode->objects_count == 0) {
						bool has_child_nodes = false;
						zt_fjze(cnode->nodes) {
							if (cnode->nodes[j] != nullptr) {
								has_child_nodes = true;
								break;
							}
						}
						if (!has_child_nodes) {
							tree->nodes_cache_used -= 1;
							cnode = nullptr;
						}
					}

					node->nodes[i] = cnode;
				}
			}
		}
	};

	zt_memSet(octree, zt_sizeof(ztOcTree), 0);

	i32 node_count = 1, object_count = 0;
	{
		ztBlockProfiler profile("OcTree count");
		local::count(center, size, max_objects_per_node, max_node_levels, 0, &node_count, &object_count, callback, user_data);
		node_count += zt_convertToi32Floor(node_count * .1f);
		object_count += zt_convertToi32Floor(object_count * .1f);
	}

	octree->nodes_cache = zt_mallocStructArray(ztOcTree::Node, node_count);
	octree->nodes_cache_size = node_count;
	octree->nodes_cache_used = 0;
	octree->objects_cache = zt_mallocStructArray(i32, object_count);
	octree->objects_cache_size = object_count;
	octree->objects_cache_used = 0;

	ztOcTree::Node *root_node = &octree->nodes_cache[octree->nodes_cache_used++];
	root_node->center = center;
	root_node->size = size;

	{
		ztBlockProfiler profile("OcTree populate");
		local::populate(octree, root_node, max_objects_per_node, max_node_levels, 0, callback, user_data);
	}

	octree->root_node = root_node;
}

// ================================================================================================================================================================================================

bool zt_ocTreeMake(ztOcTree *octree, ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_GAME("zt_ocTreeMake");
	zt_returnValOnNull(octree, false);
	zt_returnValOnNull(asset_mgr, false);

	if (asset_id < 0 || asset_id >= asset_mgr->asset_count) {
		return false;
	}

	void *data = nullptr;
	i32   size = 0;

	if (!_zt_assetLoadData(asset_mgr, asset_id, nullptr, 0, &data, &size)) {
		return false;
	}

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, data, size, ZT_OCTREE_SERIAL_FILE_ID)) {
		return false;
	}

	bool result = zt_ocTreeLoad(octree, &serial);

	zt_serialClose(&serial);

	_zt_assetFreeData(asset_mgr, data);

	return result;
}

// ================================================================================================================================================================================================

void zt_ocTreeFree(ztOcTree *octree)
{
	ZT_PROFILE_GAME("zt_ocTreeFree");
	if (octree == nullptr) {
		return;
	}

	if (octree->nodes_cache) {
		zt_free(octree->nodes_cache);
		octree->nodes_cache = nullptr;
		octree->nodes_cache_size = octree->nodes_cache_used = 0;
	}

	if (octree->objects_cache) {
		zt_free(octree->objects_cache);
		octree->objects_cache = nullptr;
		octree->objects_cache_size = octree->objects_cache_used = 0;
	}

	octree->root_node = nullptr;
}

// ================================================================================================================================================================================================

i32 zt_ocTreeFindNodesThatIntersect(ztOcTree *octree, ztOcTree::Node **nodes, i32 nodes_size, ztVec3 center, ztVec3 size)
{
	ZT_PROFILE_GAME("zt_ocTreeFindNodesThatIntersect");
	zt_returnValOnNull(octree, 0);
	zt_returnValOnNull(octree->root_node, 0);

	struct local
	{
		static void testIntersect(ztOcTree::Node *node, ztOcTree::Node **nodes, i32 nodes_size, i32 *nodes_idx, ztVec3 center, ztVec3 size)
		{
			if (!zt_collisionAABBInAABB(center, size, node->center, node->size)) {
				return;
			}

			if (node->objects_count > 0) {
				int idx = (*nodes_idx)++;
				if (idx < nodes_size) {
					nodes[idx] = node;
				}
			}
			else {
				zt_fize(node->nodes) {
					if (node->nodes[i]) {
						testIntersect(node->nodes[i], nodes, nodes_size, nodes_idx, center, size);
					}
				}
			}
		}
	};

	i32 nodes_idx = 0;
	local::testIntersect(octree->root_node, nodes, nodes_size, &nodes_idx, center, size);
	return nodes_idx;
}

// ================================================================================================================================================================================================

i32 zt_ocTreeFindNodesThatIntersectLine(ztOcTree *octree, ztOcTree::Node **nodes, i32 nodes_size, ztVec3 line_beg, ztVec3 line_end)
{
	ZT_PROFILE_GAME("zt_ocTreeFindNodesThatIntersectLine");
	zt_returnValOnNull(octree, 0);
	zt_returnValOnNull(octree->root_node, 0);

	struct local
	{
		static void testIntersect(ztOcTree::Node *node, ztOcTree::Node **nodes, i32 nodes_size, i32 *nodes_idx, ztVec3 line_beg, ztVec3 line_end)
		{
			if (!zt_collisionLineSegmentInAABB(line_beg, line_end, node->center, node->size)) {
				return;
			}

			if (node->objects_count > 0) {
				int idx = (*nodes_idx)++;
				if (idx < nodes_size) {
					nodes[idx] = node;
				}
			}
			else {
				zt_fize(node->nodes) {
					if (node->nodes[i]) {
						testIntersect(node->nodes[i], nodes, nodes_size, nodes_idx, line_beg, line_end);
					}
				}
			}
		}
	};

	i32 nodes_idx = 0;
	local::testIntersect(octree->root_node, nodes, nodes_size, &nodes_idx, line_beg, line_end);
	return nodes_idx;
}

// ================================================================================================================================================================================================

bool zt_ocTreeSaveToFile(ztOcTree *octree, const char *file)
{
	ZT_PROFILE_GAME("zt_ocTreeSaveToFile");
	zt_returnValOnNull(octree, false);

	if (zt_fileExists(file)) {
		return false;
	}

	ztSerial serial;
	if (!zt_serialMakeWriter(&serial, file, ZT_OCTREE_SERIAL_FILE_ID, ZT_OCTREE_SERIAL_VERSION)) {
		return false;
	}

	bool result = zt_ocTreeSave(octree, &serial);

	zt_serialClose(&serial);

	return result;
}

// ================================================================================================================================================================================================

bool zt_ocTreeSave(ztOcTree *octree, ztSerial *serial)
{
	ZT_PROFILE_GAME("zt_ocTreeSave");
	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialWrite(serial, ZT_OCTREE_SERIAL_GUID)) return false;
		if (!zt_serialWrite(serial, (i32)ZT_OCTREE_SERIAL_VERSION)) return false;

		if (!zt_serialWrite(serial, octree->objects_cache_used)) return false;
		zt_fiz(octree->objects_cache_used) {
			if (!zt_serialWrite(serial, octree->objects_cache[i])) return false;
		}

		if (!zt_serialWrite(serial, octree->nodes_cache_used)) return false;
		zt_fiz(octree->nodes_cache_used) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialWrite(serial, octree->nodes_cache[i].center)) return false;
				if (!zt_serialWrite(serial, octree->nodes_cache[i].size)) return false;
				if (!zt_serialWrite(serial, octree->nodes_cache[i].objects_count)) return false;

				if (octree->nodes_cache[i].objects_count > 0) {
					i32 start = (i32)(octree->nodes_cache[i].objects - octree->objects_cache);
					if (!zt_serialWrite(serial, start)) return false;
				}

				zt_fjz(8) {
					i32 node_idx = -1;
					if (octree->nodes_cache[i].nodes[j] != nullptr) {
						zt_fkz(octree->nodes_cache_used) {
							if (octree->nodes_cache[i].nodes[j] == &octree->nodes_cache[k]) {
								node_idx = k;
								break;
							}
						}
					}

					if (!zt_serialWrite(serial, node_idx)) return false;
				}
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		i32 root_node_idx = -1;
		zt_fkz(octree->nodes_cache_used) {
			if (octree->root_node == &octree->nodes_cache[k]) {
				root_node_idx = k;
				break;
			}
		}
		if (!zt_serialWrite(serial, root_node_idx)) return false;
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_ocTreeLoad(ztOcTree *octree, ztSerial *serial)
{
	ZT_PROFILE_GAME("zt_ocTreeLoad");
	if (!zt_serialGroupPush(serial)) return false;
	{
		ztGuid guid;
		if (!zt_serialRead(serial, &guid)) return false;
		zt_assertReturnValOnFail(guid == ZT_OCTREE_SERIAL_GUID, false);

		i32 version = 0;
		if (!zt_serialRead(serial, &version)) return false;
		zt_assertReturnValOnFail(version >= 0 && version <= ZT_OCTREE_SERIAL_VERSION, false);

		if (!zt_serialRead(serial, &octree->objects_cache_used)) return false;
		//zt_assertReturnValOnFail(octree->objects_cache_used > 0, false);

		if (octree->objects_cache_used == 0) {
			if (!zt_serialGroupPop(serial)) return false;
			return true;
		}

		octree->objects_cache_size = octree->objects_cache_used;
		octree->objects_cache = zt_mallocStructArray(i32, octree->objects_cache_used);

		zt_fiz(octree->objects_cache_used) {
			if (!zt_serialRead(serial, &octree->objects_cache[i])) return false;
		}

		if (!zt_serialRead(serial, &octree->nodes_cache_used)) return false;
		zt_assertReturnValOnFail(octree->nodes_cache_used > 0, false);

		octree->nodes_cache_size = octree->nodes_cache_used;
		octree->nodes_cache = zt_mallocStructArray(ztOcTree::Node, octree->nodes_cache_size);

		zt_fiz(octree->nodes_cache_used) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialRead(serial, &octree->nodes_cache[i].center)) return false;
				if (!zt_serialRead(serial, &octree->nodes_cache[i].size)) return false;
				if (!zt_serialRead(serial, &octree->nodes_cache[i].objects_count)) return false;

				if (octree->nodes_cache[i].objects_count) {
					i32 start = -1;
					if (!zt_serialRead(serial, &start)) return false;
					zt_assertReturnValOnFail(start >= 0 && start < octree->objects_cache_size, false);

					octree->nodes_cache[i].objects = octree->objects_cache + start;
				}
				else {
					octree->nodes_cache[i].objects = nullptr;
				}

				zt_fjz(8) {
					i32 node_idx = -1;
					if (!zt_serialRead(serial, &node_idx)) return false;
					zt_assertReturnValOnFail(node_idx >= -1 && node_idx < octree->nodes_cache_size, false);

					if (node_idx < 0) {
						octree->nodes_cache[i].nodes[j] = nullptr;
					}
					else {
						octree->nodes_cache[i].nodes[j] = &octree->nodes_cache[node_idx];
					}
				}
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		i32 root_node_idx = -1;
		if (!zt_serialRead(serial, &root_node_idx)) return false;
		zt_assertReturnValOnFail(root_node_idx >= -1 && root_node_idx < octree->nodes_cache_size, false);

		octree->root_node = &octree->nodes_cache[root_node_idx];
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_ocTreeClone(ztOcTree *dest, ztOcTree *source)
{
	ZT_PROFILE_GAME("zt_ocTreeClone");

	zt_returnValOnNull(source, false);
	zt_returnValOnNull(dest, false);

	dest->nodes_cache = zt_mallocStructArray(ztOcTree::Node, source->nodes_cache_size);
	if (dest->nodes_cache == nullptr) {
		return false;
	}

	dest->nodes_cache_size = source->nodes_cache_size;
	dest->nodes_cache_used = source->nodes_cache_used;

	dest->objects_cache = zt_mallocStructArray(i32, source->objects_cache_size);
	if (dest->objects_cache == nullptr) {
		return false;
	}

	dest->objects_cache_size = source->objects_cache_size;
	dest->objects_cache_used = source->objects_cache_used;

	zt_memCpy(dest->objects_cache, zt_sizeof(i32) * source->objects_cache_used, source->objects_cache, zt_sizeof(i32) * source->objects_cache_used);


	zt_fiz(source->nodes_cache_used) {
		zt_memCpy(&dest->nodes_cache[i], zt_sizeof(ztOcTree::Node), &source->nodes_cache[i], zt_sizeof(ztOcTree::Node));
		if (source->root_node == &source->nodes_cache[i]) {
			dest->root_node = &dest->nodes_cache[i];
		}
	}

	zt_fiz(source->nodes_cache_used) {
		zt_fjze(source->nodes_cache[i].nodes) {
			if (source->nodes_cache[i].nodes[j] == nullptr) {
				continue;
			}

			zt_fkz(source->nodes_cache_used) {
				if (source->nodes_cache[i].nodes[j] == &source->nodes_cache[k]) {
					dest->nodes_cache[i].nodes[j] = &dest->nodes_cache[k];
					break;
				}
			}
		}

		if (source->nodes_cache[i].objects) {
			i32 object_offset = source->nodes_cache[i].objects - source->objects_cache;
			dest->nodes_cache[i].objects = dest->objects_cache + object_offset;
		}
	}

	return true;
}

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestModel)
{
	ZT_PROFILE_GAME("zt_ocTreeItemContainedTestModel");
	ztOcTreeItemContainedTestModelData *model_data = (ztOcTreeItemContainedTestModelData*)user_data;

	if (object_idx < 0 || object_idx >= model_data->models_count) {
		return ztOcTreeItemContainedResult_InvalidIndex;
	}

	ztVec3 aabb_center, aabb_size;
	zt_modelGetAABB(model_data->models[object_idx], &aabb_center, &aabb_size);

	if (zt_collisionAABBInAABB(center, size, aabb_center, aabb_size)) {
		return ztOcTreeItemContainedResult_Inside;
	}

	return ztOcTreeItemContainedResult_Outside;
}

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestVertices)
{
	ZT_PROFILE_GAME("zt_ocTreeItemContainedTestVertices");
	ztOcTreeItemContainedTestVerticesData *test_data = (ztOcTreeItemContainedTestVerticesData*)user_data;

	if (object_idx < 0 || object_idx >= test_data->vertices_count) {
		return ztOcTreeItemContainedResult_InvalidIndex;
	}

	if (zt_collisionPointInAABB(test_data->vertices[object_idx], center, size)) {
		return ztOcTreeItemContainedResult_Inside;
	}

	zt_collisionPointInAABB(test_data->vertices[object_idx], center, size);

	return ztOcTreeItemContainedResult_Outside;
}

// ================================================================================================================================================================================================

ZT_FUNC_OCTREE_ITEM_CONTAINED(zt_ocTreeItemContainedTestTriangles)
{
	ZT_PROFILE_GAME("zt_ocTreeItemContainedTestTriangles");
	ztOcTreeItemContainedTestTriangles *test_data = (ztOcTreeItemContainedTestTriangles*)user_data;

	if (object_idx < 0 || object_idx >= test_data->triangles_count) {
		return ztOcTreeItemContainedResult_InvalidIndex;
	}

	if (zt_collisionTriangleInAABB(test_data->triangles[object_idx].points[0], test_data->triangles[object_idx].points[1], test_data->triangles[object_idx].points[2], center, size)) {
		return ztOcTreeItemContainedResult_Inside;
	}

	return ztOcTreeItemContainedResult_Outside;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

bool zt_rendererGetMaxVersionSupported(ztRenderer_Enum renderer, i32* v_major, i32* v_minor)
{
	if (renderer == ztRenderer_OpenGL) {
		zt_noOpenGLSupport(return false);

		// TODO(josh): this needs updated to check dlls
		*v_major = 4;
		*v_minor = 5;
		return true;
	}
	else if (renderer == ztRenderer_DirectX) {
		zt_noDirectxSupport(return false);

		*v_major = 11;
		*v_minor = 0;
	}

	*v_major = *v_minor = 0;

	return false;
}

// ================================================================================================================================================================================================

void zt_rendererClear(r32 r, r32 g, r32 b, r32 a)
{
	ZT_PROFILE_RENDERING("zt_rendererClear");
	switch(zt_game->win_game_settings[0].renderer)
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_clear(r, g, b, a));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_clear(zt_game->win_details[0].dx_context, r, g, b, a));
		} break;
	}
}

// ================================================================================================================================================================================================

void zt_rendererClear(ztVec4 clr)
{
	return zt_rendererClear(clr.r, clr.g, clr.b, clr.a);
}

// ================================================================================================================================================================================================

void zt_rendererClearDepth()
{
	ZT_PROFILE_RENDERING("zt_rendererClearDepth");
	switch (zt_game->win_game_settings[0].renderer)
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_clearDepth());
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_clearDepth(zt_game->win_details[0].dx_context));
		} break;
	}
}

// ================================================================================================================================================================================================

bool zt_rendererUvsFlipYRenderTarget()
{
	ZT_PROFILE_RENDERING("zt_rendererUvsReversed");
	switch (zt_game->win_game_settings[0].renderer)
	{
		case ztRenderer_OpenGL: {
			return false;
		} break;

		case ztRenderer_DirectX: {
			return true;
		} break;
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_rendererSetDepthTest(bool depth_test, ztRendererDepthTestFunction_Enum function)
{
	ZT_PROFILE_RENDERING("zt_rendererSetDepthTest");
	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			if (!depth_test) {
				ztgl_depthTestOff();
			}
			else {
				switch (function)
				{
					case ztRendererDepthTestFunction_Never       : ztgl_depthTestNever();        break;
					case ztRendererDepthTestFunction_Less        : ztgl_depthTestLess();         break;
					case ztRendererDepthTestFunction_LessEqual   : ztgl_depthTestLessEqual();    break;
					case ztRendererDepthTestFunction_Equal       : ztgl_depthTestEqual();        break;
					case ztRendererDepthTestFunction_Greater     : ztgl_depthTestGreater();      break;
					case ztRendererDepthTestFunction_NotEqual    : ztgl_depthTestNotEqual();     break;
					case ztRendererDepthTestFunction_GreaterEqual: ztgl_depthTestGreaterEqual(); break;
					case ztRendererDepthTestFunction_Always      : ztgl_depthTestAlways();       break;
				}
				
			}
#			endif
		} break;
		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			switch (function)
			{
				case ztRendererDepthTestFunction_Never       : ztdx_depthTestNever(zt_game->win_details[0].dx_context);        break;
				case ztRendererDepthTestFunction_Less        : ztdx_depthTestLess(zt_game->win_details[0].dx_context);         break;
				case ztRendererDepthTestFunction_LessEqual   : ztdx_depthTestLessEqual(zt_game->win_details[0].dx_context);    break;
				case ztRendererDepthTestFunction_Equal       : ztdx_depthTestEqual(zt_game->win_details[0].dx_context);        break;
				case ztRendererDepthTestFunction_Greater     : ztdx_depthTestGreater(zt_game->win_details[0].dx_context);      break;
				case ztRendererDepthTestFunction_NotEqual    : ztdx_depthTestNotEqual(zt_game->win_details[0].dx_context);     break;
				case ztRendererDepthTestFunction_GreaterEqual: ztdx_depthTestGreaterEqual(zt_game->win_details[0].dx_context); break;
				case ztRendererDepthTestFunction_Always      : ztdx_depthTestAlways(zt_game->win_details[0].dx_context);       break;
			}
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

void zt_rendererEnableDepthWriting(bool depth_writing)
{
}

// ================================================================================================================================================================================================

void zt_rendererSetFaceCulling(ztRendererFaceCulling_Enum culling)
{
	ZT_PROFILE_RENDERING("zt_rendererSetFaceCulling");
	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			switch (culling)
			{
				case ztRendererFaceCulling_CullBack : ztgl_cullBack(); break;
				case ztRendererFaceCulling_CullFront: ztgl_cullFront(); break;
				case ztRendererFaceCulling_CullNone : ztgl_cullNone(); break;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			switch (culling)
			{
				case ztRendererFaceCulling_CullBack : ztdx_cullBack(zt_game->win_details[0].dx_context); break;
				case ztRendererFaceCulling_CullFront: ztdx_cullFront(zt_game->win_details[0].dx_context); break;
				case ztRendererFaceCulling_CullNone : ztdx_cullNone(zt_game->win_details[0].dx_context); break;
			}
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

void zt_rendererSetBlendMode(ztRendererBlendMode_Enum source, ztRendererBlendMode_Enum dest)
{
	ZT_PROFILE_RENDERING("zt_rendererSetBlendMode");
	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztgl_blendMode((ztGLBlendMode_Enum)source, (ztGLBlendMode_Enum)dest);
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			ztdx_blendMode(zt_game->win_details[0].dx_context, (ztBlendModeDX_Enum)source, (ztBlendModeDX_Enum)dest);
#			endif
		} break;
	}

}

// ================================================================================================================================================================================================

void zt_rendererRequestChange(ztRenderer_Enum renderer)
{
	ZT_PROFILE_RENDERING("zt_rendererRequestChange");
	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_Change;
	request->change_to = renderer;
}

// ================================================================================================================================================================================================

void zt_rendererRequestWindowed()
{
	ZT_PROFILE_RENDERING("zt_rendererRequestWindowed");
	if (zt_bitIsSet(zt_game->win_game_settings[0].renderer_flags, ztRendererRequest_Windowed))
		return;

	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_Windowed;
}

// ================================================================================================================================================================================================

void zt_rendererRequestWindowedBorderless()
{
	ZT_PROFILE_RENDERING("zt_rendererRequestWindowedBorderless");
	if (zt_bitIsSet(zt_game->win_game_settings[0].renderer_flags, ztRendererRequest_WindowedBorderless))
		return;

	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_WindowedBorderless;
}

// ================================================================================================================================================================================================

void zt_rendererRequestFullscreen()
{
	ZT_PROFILE_RENDERING("zt_rendererRequestFullscreen");
	if (zt_bitIsSet(zt_game->win_game_settings[0].renderer_flags, ztRendererFlags_Fullscreen))
		return;

	if (zt_game->win_count > 1)
		return; // cannot go into fullscreen if there are multiple windows opened

	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_Fullscreen;
}

// ================================================================================================================================================================================================

void zt_rendererRequestResolution(ztVec2i resolution)
{
	ZT_PROFILE_RENDERING("zt_rendererRequestResolution");

	if (zt_game->win_count > 1)
		return; // cannot do this if there are multiple windows opened

	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_Resolution;
	request->resolution = resolution;
}

// ================================================================================================================================================================================================

void zt_rendererRequestUpdatePixelsPerUnit(r32 ppu)
{
	ZT_PROFILE_RENDERING("zt_rendererRequestUpdatePixelsPerUnit");

	if (zt_game->win_count > 1)
		return; // cannot do this if there are multiple windows opened

	if (zt_game->renderer_requests_count >= zt_elementsOf(zt_game->renderer_requests))
		return;

	ztRendererRequest* request = &zt_game->renderer_requests[zt_game->renderer_requests_count++];
	request->type = ztRendererRequest_UpdatePixelsPerUnit;
	request->ppu = ppu;
}

// ================================================================================================================================================================================================

int zt_resolutionGetAvailable(ztResolution *resolutions, int resolutions_count, i32 aspect_ratio_flags, ztVec2i minimum, bool current_display_only)
{
	ztDisplay displays[8];
	int display_count = zt_displayGetDetails(displays, zt_elementsOf(displays));

	int resolutions_idx = 0;

	struct
	{
		ztVec2i resolution;
		ztAspectRatio_Enum aspect_ratio;
	} 
	
	possible_resolutions[] = {
		{ { 4096, 2160 }, ztAspectRatio_Unknown },
		{ { 3840, 2160 }, ztAspectRatio_16x9 },
		{ { 2560, 1600 }, ztAspectRatio_16x10 },
		{ { 2048, 1536 }, ztAspectRatio_4x3 },
		{ { 1920, 1440 }, ztAspectRatio_4x3 },
		{ { 1920, 1200 }, ztAspectRatio_16x10 },
		{ { 1920, 1080 }, ztAspectRatio_16x9 },
		{ { 1728,  960 }, ztAspectRatio_Unknown },
		{ { 1680, 1050 }, ztAspectRatio_16x10 },
		{ { 1600, 1200 }, ztAspectRatio_4x3 },
		{ { 1600, 1024 }, ztAspectRatio_Unknown },
		{ { 1600,  900 }, ztAspectRatio_16x9 },
		{ { 1440,  810 }, ztAspectRatio_16x9 },
		{ { 1366,  768 }, ztAspectRatio_16x9 },
		{ { 1280, 1024 }, ztAspectRatio_Unknown },
		{ { 1280,  960 }, ztAspectRatio_4x3 },
		{ { 1280,  800 }, ztAspectRatio_16x10 },
		{ { 1280,  768 }, ztAspectRatio_Unknown },
		{ { 1280,  720 }, ztAspectRatio_16x9 },
		{ { 1152,  864 }, ztAspectRatio_4x3 },
		{ { 1024,  768 }, ztAspectRatio_4x3 },
		{ {  960,  540 }, ztAspectRatio_16x9 },
		{ {  858,  480 }, ztAspectRatio_Unknown },
		{ {  800,  600 }, ztAspectRatio_4x3 },
	};


	zt_fiz(2) {
		bool finding_primary = i == 0;

		zt_fjz(display_count) {
			if (finding_primary != displays[j].primary) {
				continue;
			}

			if (current_display_only) {
#				ifdef ZT_WINDOWS
				i64 monitor = (i64)MonitorFromWindow(zt_game->win_details[0].handle, MONITOR_DEFAULTTONEAREST);
				if (monitor != displays[j].platform_id) {
					continue;
				}
#				endif
			}

			ztVec2i maximum = zt_vec2i(displays[j].screen_area.z, displays[j].screen_area.w);

			zt_fkze(possible_resolutions) {
				if (possible_resolutions[k].resolution.x > maximum.x || possible_resolutions[k].resolution.x < minimum.x || possible_resolutions[k].resolution.y > maximum.y || possible_resolutions[k].resolution.y < minimum.y) {
					continue;
				}

				if (aspect_ratio_flags != 0 && !zt_bitIsSet(aspect_ratio_flags, zt_bit(possible_resolutions[k].aspect_ratio))) {
					continue;
				}

				if (resolutions_idx >= resolutions_count) {
					continue;
				}

				ztResolution *res = &resolutions[resolutions_idx++];

				res->display      = displays[j];
				res->aspect_ratio = possible_resolutions[k].aspect_ratio;
				res->dimensions   = possible_resolutions[k].resolution;
			}
		}
	}

	return resolutions_idx;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal ztShLangToken *_zt_shaderLangTokenize(const char *data, int data_len, int *shader_tokens_size)
{
	//TODO: Numbers not recognized
	//# not recognized
	// comments not working

	ztToken *tokens = nullptr;
	int tokens_size = 0;

	while (true) {
		int tokens_count = zt_strTokenize(data, data_len, " \t\r\n,<>-+=!@$%^&*()[]{}\\|;:\'\"/?", tokens, tokens_size, ztStrTokenizeFlags_IncludeTokens | ztStrTokenizeFlags_ProcessQuotes | ztStrTokenizeFlags_KeepQuotes | ztStrTokenizeFlags_TrimWhitespace);
		if (tokens == nullptr) {
			tokens_size = tokens_count;
			tokens = zt_mallocStructArray(ztToken, tokens_count);
		}
		else break;
	}

	ztShLangToken *shader_tokens = nullptr;
	int shader_tokens_count = 0;
	int shader_idx = 0;

	while (shader_tokens_count == 0) {
		int line_count = 1;
		int line_idx = 0;

		char token[2048];

		ztShLangToken prev_token_local = {}, curr_token_local = {};
		ztShLangToken *prev_token, *curr_token;

		prev_token_local.type = ztShLangTokenType_Invalid;
		prev_token = &prev_token_local;

		curr_token = nullptr;

		if (shader_idx != 0) {
			shader_tokens_count = shader_idx + 1;
			shader_tokens = zt_mallocStructArray(ztShLangToken, shader_tokens_count);
		}
		shader_idx = 0;

		bool reuse_token = false;
		bool comment_until_eol = false;
		bool comment_until_eoc = false;
		bool comment_until_eoc_pe = false;

		int whitespace_count = 0;

		zt_fiz(tokens_size) {
			zt_strCpy(token, zt_elementsOf(token), data + tokens[i].beg, tokens[i].len);

			if (comment_until_eol) {
				if (token[0] == '\n') {
					comment_until_eol = false;
				}
				else {
					prev_token->token_len += tokens[i].len;
					continue;
				}
			}
			else if (comment_until_eoc) {
				prev_token->token_len += tokens[i].len;
				if (token[0] == '\n') {
					line_count += 1;
				}

				if (comment_until_eoc_pe) {
					if (token[0] == '/') {
						comment_until_eoc = comment_until_eoc_pe = false;
					}
					else {
						comment_until_eoc_pe = token[0] == '*';
					}
				}
				else {
					comment_until_eoc_pe = token[0] == '*';
				}
				continue;
			}

			if (!reuse_token) {
				if (shader_idx >= shader_tokens_count) {
					shader_idx += 1;
					prev_token_local = curr_token_local;
					prev_token = &prev_token_local;
					curr_token = &curr_token_local;
					zt_memSet(curr_token, zt_sizeof(ztShLangToken), 0);
				}
				else {
					prev_token = curr_token;
					curr_token = &shader_tokens[shader_idx++];

					if (prev_token == nullptr) {
						prev_token = &prev_token_local;
						zt_memSet(prev_token, zt_sizeof(ztShLangToken), 0);
					}
				}
			}

			reuse_token = false;

			curr_token->line      = line_count;
			curr_token->col       = tokens[i].beg - line_idx;
			curr_token->token_beg = tokens[i].beg;
			curr_token->token_len = tokens[i].len;

			ztShLangTokenType_Enum type = ztShLangTokenType_Invalid;
			i32 flags = 0;

			if (tokens[i].len == 1) {
				switch (token[0])
				{
					case '\n': {
						line_count += 1;
						line_idx = tokens[i].beg + 1;
						reuse_token = true;
						whitespace_count += 1;
						comment_until_eol = false;
					} break;

					case '\t':
					case ' ':
					case '\r': {
						reuse_token = true;
						whitespace_count += 1;
					} break;

					default: {
						switch (token[0])
						{
							case '(': type = ztShLangTokenType_ParenOpen; break;
							case ')': type = ztShLangTokenType_ParenClose; break;
							case '[': type = ztShLangTokenType_BracketOpen; break;
							case ']': type = ztShLangTokenType_BracketClose; break;
							case ',': type = ztShLangTokenType_Comma; break;
							case '%': type = ztShLangTokenType_Mod; flags |= ztShLangTokenFlags_Operator; break;
							case '!': type = ztShLangTokenType_Not; flags |= ztShLangTokenFlags_Operator | ztShLangTokenFlags_ConditionOperator; break;
							case '~': type = ztShLangTokenType_BitwiseNot; flags |= ztShLangTokenFlags_Operator; break;
							case '^': type = ztShLangTokenType_BitwiseXor; flags |= ztShLangTokenFlags_Operator; break;
							case ';': type = ztShLangTokenType_EndCommand; break;
							case '?': type = ztShLangTokenType_Question; break;
							case ':': type = ztShLangTokenType_Colon; break;


							case '{': {
								type = ztShLangTokenType_BraceOpen;
								flags |= ztShLangTokenFlags_ScopeChange;
							} break;

							case '}': {
								type = ztShLangTokenType_BraceClose;
								flags |= ztShLangTokenFlags_ScopeChange;
							} break;

							case '*': {
								if (prev_token->type == ztShLangTokenType_Divide) {
									prev_token->type = ztShLangTokenType_Comment;
									prev_token->token_len += 1;
									zt_bitRemove(prev_token->flags, ztShLangTokenFlags_Operator);
									comment_until_eoc = true;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_Multiply;
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '/': {
								if (prev_token->type == ztShLangTokenType_Divide) {
									prev_token->type = ztShLangTokenType_Comment;
									prev_token->token_len += 1;
									zt_bitRemove(prev_token->flags, ztShLangTokenFlags_Operator);
									comment_until_eol = true;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_Divide;
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '>': {
								if (prev_token->type == ztShLangTokenType_GreaterThan) {
									prev_token->type = ztShLangTokenType_BitwiseShiftRight;
									prev_token->token_len += 1;
									zt_bitRemove(prev_token->flags, ztShLangTokenFlags_ConditionOperator);
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_GreaterThan;
									flags |= ztShLangTokenFlags_Operator | ztShLangTokenFlags_ConditionOperator;
								}
							} break;

							case '<': {
								if (prev_token->type == ztShLangTokenType_LessThan) {
									prev_token->type = ztShLangTokenType_BitwiseShiftLeft;
									prev_token->token_len += 1;
									zt_bitRemove(prev_token->flags, ztShLangTokenFlags_ConditionOperator);
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_LessThan;
									flags |= ztShLangTokenFlags_Operator | ztShLangTokenFlags_ConditionOperator;
								}
							} break;

							case '&': {
								if (prev_token->type == ztShLangTokenType_BitwiseAnd) {
									prev_token->type = ztShLangTokenType_And;
									prev_token->token_len += 1;
									prev_token->flags |= ztShLangTokenFlags_ConditionOperator;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_BitwiseAnd;
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '|': {
								if (prev_token->type == ztShLangTokenType_BitwiseOr) {
									prev_token->type = ztShLangTokenType_Or;
									prev_token->token_len += 1;
									prev_token->flags |= ztShLangTokenFlags_ConditionOperator;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_BitwiseOr;
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '=': {
								type = ztShLangTokenType_Equal;
								flags |= ztShLangTokenFlags_Operator;

								ztShLangTokenType_Enum new_type = ztShLangTokenType_Invalid;

								switch (prev_token->type)
								{
									case ztShLangTokenType_Equal:       new_type = ztShLangTokenType_DoubleEqual; break;
									case ztShLangTokenType_Plus:        new_type = ztShLangTokenType_PlusEqual; break;
									case ztShLangTokenType_Minus:       new_type = ztShLangTokenType_MinusEqual; break;
									case ztShLangTokenType_Multiply:    new_type = ztShLangTokenType_MultiplyEqual; break;
									case ztShLangTokenType_Divide:      new_type = ztShLangTokenType_DivideEqual; break;
									case ztShLangTokenType_GreaterThan: new_type = ztShLangTokenType_GreaterThanOrEqual; break;
									case ztShLangTokenType_LessThan:    new_type = ztShLangTokenType_LessThanOrEqual; break;
									case ztShLangTokenType_Mod:         new_type = ztShLangTokenType_ModEqual; break;
									case ztShLangTokenType_Not:         new_type = ztShLangTokenType_NotEqual; break;
									case ztShLangTokenType_BitwiseAnd:  new_type = ztShLangTokenType_BitwiseAndEqual; break;
									case ztShLangTokenType_BitwiseOr:   new_type = ztShLangTokenType_BitwiseOrEqual; break;
									case ztShLangTokenType_BitwiseXor:  new_type = ztShLangTokenType_BitwiseXorEqual; break;
								}

								if (whitespace_count == 0 && new_type != ztShLangTokenType_Invalid) {
									prev_token->type = new_type;
									prev_token->token_len += 1;
									prev_token->flags |= ztShLangTokenFlags_ConditionOperator;
									type = ztShLangTokenType_Invalid;
									reuse_token = true;
								}

							} break;

							case '+': {
								if (prev_token->type == ztShLangTokenType_Plus) {
									prev_token->type = ztShLangTokenType_DoublePlus;
									prev_token->token_len += 1;
									type = ztShLangTokenType_Invalid;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_Plus;
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '-': {
								if (prev_token->type == ztShLangTokenType_Minus) {
									prev_token->type = ztShLangTokenType_DoubleMinus;
									prev_token->token_len += 1;
									type = ztShLangTokenType_Invalid;
									reuse_token = true;
								}
								else if(prev_token->type == ztShLangTokenType_NumberFloat && zt_strEndsWith(data + tokens[i-1].beg, tokens[i - 1].len, "e", 1)) {
									prev_token->token_len += 1;
									type = ztShLangTokenType_Invalid;
									reuse_token = true;
								}
								else {
									type = ztShLangTokenType_Minus; 
									flags |= ztShLangTokenFlags_Operator;
								}
							} break;

							case '0':
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
								type = ztShLangTokenType_NumberInteger;
								flags |= ztShLangTokenFlags_Number;
								break;

							default:
								type = ztShLangTokenType_Identifier;
								break;
						}

						whitespace_count = 0;
					} break;
				}
			}
			else {
				whitespace_count = 0;

				if (token[0] == '\"') {
					type = ztShLangTokenType_QuotedString;
					flags = ztShLangTokenFlags_String;
				}
				else if (token[0] == '#') {
					type = ztShLangTokenType_PreprocessCommand;
				}
				else {
					bool is_number = false;
					zt_strToInt(token, 0, &is_number);
					if (!is_number && zt_strStartsWith(token, "0x")) {
						zt_strToIntHex(token + 2, 0, &is_number);
					}
					if (is_number) {
						if(prev_token->type == ztShLangTokenType_NumberFloat && zt_strEndsWith(data + prev_token->token_beg, prev_token->token_len, "e-", 2)) {
							prev_token->token_len += curr_token->token_len;
							type = ztShLangTokenType_Invalid;
							reuse_token = true;
						}
						else {
							type = ztShLangTokenType_NumberInteger;
							flags = ztShLangTokenFlags_Number;
						}
					}
					else {
						zt_strToReal32(token, 0, &is_number);
						if (!is_number) {
							zt_strToReal64(token, 0, &is_number);
						}
						if (is_number) {
							type = ztShLangTokenType_NumberFloat;
							flags = ztShLangTokenFlags_Number;
						}
					}

					if (!is_number) {
						type = ztShLangTokenType_Identifier;

						     if (zt_strEquals(token, "if"             )) { type = ztShLangTokenType_If;          flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "else"           )) { type = ztShLangTokenType_Else;        flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "for"            )) { type = ztShLangTokenType_For;         flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "while"          )) { type = ztShLangTokenType_While;       flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "const"          )) { type = ztShLangTokenType_Const;       flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "struct"         )) { type = ztShLangTokenType_Struct;      flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "return"         )) { type = ztShLangTokenType_Return;      flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "break"          )) { type = ztShLangTokenType_Break;       flags = ztShLangTokenFlags_Command; }
						else if (zt_strEquals(token, "continue"       )) { type = ztShLangTokenType_Continue;    flags = ztShLangTokenFlags_Command; }

						else if (zt_strEquals(token, "void"           )) { type = ztShLangTokenType_void;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "int"            )) { type = ztShLangTokenType_int;         flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "uint"           )) { type = ztShLangTokenType_uint;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "float"          )) { type = ztShLangTokenType_float;       flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "double"         )) { type = ztShLangTokenType_double;      flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "bool"           )) { type = ztShLangTokenType_bool;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "vec2"           )) { type = ztShLangTokenType_vec2;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "vec3"           )) { type = ztShLangTokenType_vec3;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "vec4"           )) { type = ztShLangTokenType_vec4;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "ivec2"          )) { type = ztShLangTokenType_ivec2;       flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "ivec3"          )) { type = ztShLangTokenType_ivec3;       flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "ivec4"          )) { type = ztShLangTokenType_ivec4;       flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "mat2"           )) { type = ztShLangTokenType_mat2;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "mat3"           )) { type = ztShLangTokenType_mat3;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "mat4"           )) { type = ztShLangTokenType_mat4;        flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "texture2d"      )) { type = ztShLangTokenType_texture2d;   flags = ztShLangTokenFlags_DataType; }
						else if (zt_strEquals(token, "textureCube"    )) { type = ztShLangTokenType_textureCube; flags = ztShLangTokenFlags_DataType; }

						else if (zt_strEquals(token, "true"           )) { type = ztShLangTokenType_True;        flags = ztShLangTokenFlags_Bool; }
						else if (zt_strEquals(token, "false"          )) { type = ztShLangTokenType_False;       flags = ztShLangTokenFlags_Bool; }

						else if (zt_strEquals(token, "program"        )) { type = ztShLangTokenType_Program; }

						else {
							if (zt_strFind(token, ".")) {
								flags |= ztShLangTokenFlags_IdentifierWithAccess;
							}
						}
					}
				}
			}

			if (type != ztShLangTokenType_Invalid) {
				curr_token->type = type;
				curr_token->flags = flags;
			}
		}
	}

	while(shader_idx > 0 && shader_tokens[shader_idx-1].type == ztShLangTokenType_Invalid) {
		shader_idx -= 1;
		shader_tokens_count -= 1;
	}

	zt_free(tokens);

	*shader_tokens_size = shader_tokens_count;
	return shader_tokens;
}

// ================================================================================================================================================================================================
#include <stdio.h> 

ztInternal ztShLangSyntaxNode *_zt_shaderLangErrorMessage(ztShLangSyntaxNode *global_node, ztShLangToken *token, ztString *error, char *file_data, const char *message, ...)
{
#	if defined(ZT_COMPILER_MSVC)
	va_list arg_ptr; \
		va_start(arg_ptr, message); \
		char message_buffer[1024 * 16]; \
		vsnprintf_s(message_buffer, zt_elementsOf(message_buffer), message, arg_ptr);
#	elif defined(ZT_COMPILER_LLVM) || defined(ZT_ANDROID)
	va_list arg_ptr; \
		va_start(arg_ptr, message); \
		char message_buffer[1024 * 16]; \
		vsnprintf(message_buffer, zt_elementsOf(message_buffer), message, arg_ptr);
#	else
#		error "Unsupported compiler"
#	endif

	int line_beg = zt_max(0, zt_strFindLastPos(file_data, "\n", token->token_beg) + 1);
	int line_end = zt_strFindPos(file_data, "\n", token->token_beg + token->token_len);
	if (line_end == ztStrPosNotFound) {
		line_end = token->token_beg + token->token_len;
	}
	const int max_line_len = 512;
	int token_ch = zt_max(0, token->token_beg - line_beg);
	if (line_end - line_beg > max_line_len) {
		token_ch -= (line_end - line_beg) - 100;
		line_beg = line_end - 100;
	}

	char line_ch[max_line_len] = { 0 };
	zt_fiz(token_ch) {
		if (file_data[line_beg + i] == '\t') {
			line_ch[i] = '\t';
		}
		else {
			line_ch[i] = ' ';
		}
	}
	line_ch[token_ch] = '^';

	char line_err[max_line_len];
	zt_strCpy(line_err, zt_elementsOf(line_err), file_data + line_beg, zt_min(line_end - line_beg, 100));

	zt_strMakePrintf(err_buff, 2048, "line %d: error: %s\n+\t%s\n+\t%s", token->line, message_buffer, line_err, line_ch);
	*error = zt_stringMakeFrom(err_buff);

	return nullptr;
}

// ================================================================================================================================================================================================

const char *_zt_shaderLangSyntaxNodeDesc(ztShLangSyntaxNode *node)
{
	switch (node->type)
	{
		case ztShLangSyntaxNodeType_Scope:              return "scope";
		case ztShLangSyntaxNodeType_Structure:          return "structure declaration";
		case ztShLangSyntaxNodeType_VariableDecl:       return "variable declaration";
		case ztShLangSyntaxNodeType_ProgramDecl:        return "program declaration";
		case ztShLangSyntaxNodeType_FunctionDecl:       return "function declaration";
		case ztShLangSyntaxNodeType_ConditionTest:      return "conditional test";
		case ztShLangSyntaxNodeType_Return:             return "return";
		case ztShLangSyntaxNodeType_Loop:               return "loop";
		case ztShLangSyntaxNodeType_Continue:           return "continue";
		case ztShLangSyntaxNodeType_Break:              return "break";
		case ztShLangSyntaxNodeType_Variable:           return "variable";
		case ztShLangSyntaxNodeType_Operation:          return "operation";
		case ztShLangSyntaxNodeType_FunctionCall:       return "function call";
		case ztShLangSyntaxNodeType_ValueNumberInt:     return "integer";
		case ztShLangSyntaxNodeType_ValueNumberFloat:   return "floating point";
		case ztShLangSyntaxNodeType_ValueString:        return "string";
		case ztShLangSyntaxNodeType_ValueBool:          return "boolean";
		default: zt_assert(false);
	}

	return "<unknown syntax node type";
}

// ================================================================================================================================================================================================

const char *_zt_shaderLangTokenTypeDesc(ztShLangTokenType_Enum token_type)
{
	switch (token_type)
	{
		case ztShLangTokenType_Invalid:            return "<invalid>";

		case ztShLangTokenType_ParenOpen:          return "(";
		case ztShLangTokenType_ParenClose:         return ")";
		case ztShLangTokenType_BraceOpen:          return "{";
		case ztShLangTokenType_BraceClose:         return "}";
		case ztShLangTokenType_BracketOpen:        return "[";
		case ztShLangTokenType_BracketClose:       return "]";
		case ztShLangTokenType_Comma:              return ",";

		case ztShLangTokenType_Equal:              return "=";
		case ztShLangTokenType_DoubleEqual:        return "==";
		case ztShLangTokenType_Plus:               return "+";
		case ztShLangTokenType_PlusEqual:          return "+=";
		case ztShLangTokenType_DoublePlus:         return "++";
		case ztShLangTokenType_Minus:              return "-";
		case ztShLangTokenType_MinusEqual:         return "-=";
		case ztShLangTokenType_DoubleMinus:        return "--";
		case ztShLangTokenType_Multiply:           return "*";
		case ztShLangTokenType_MultiplyEqual:      return "*=";
		case ztShLangTokenType_Divide:             return "/";
		case ztShLangTokenType_DivideEqual:        return "/=";
		case ztShLangTokenType_GreaterThan:        return ">";
		case ztShLangTokenType_GreaterThanOrEqual: return ">=";
		case ztShLangTokenType_LessThan:           return "<";
		case ztShLangTokenType_LessThanOrEqual:    return "<=";
		case ztShLangTokenType_Mod:                return "%";
		case ztShLangTokenType_ModEqual:           return "%=";
		case ztShLangTokenType_Not:                return "!";
		case ztShLangTokenType_NotEqual:           return "!=";
		case ztShLangTokenType_And:                return "&&";
		case ztShLangTokenType_Or:                 return "||";

		case ztShLangTokenType_BitwiseAnd:         return "&";
		case ztShLangTokenType_BitwiseAndEqual:    return "&=";
		case ztShLangTokenType_BitwiseOr:          return "|";
		case ztShLangTokenType_BitwiseOrEqual:     return "|=";
		case ztShLangTokenType_BitwiseNot:         return "~";
		case ztShLangTokenType_BitwiseXor:         return "^";
		case ztShLangTokenType_BitwiseXorEqual:    return "^=";
		case ztShLangTokenType_BitwiseShiftLeft:   return "<<";
		case ztShLangTokenType_BitwiseShiftRight:  return ">>";

		case ztShLangTokenType_EndCommand:         return ";";
		case ztShLangTokenType_Question:           return "?";
		case ztShLangTokenType_Colon:              return ":";

		case ztShLangTokenType_QuotedChar:         return "\"string\"";
		case ztShLangTokenType_QuotedString:       return "\'char\'";

		case ztShLangTokenType_Comment:            return "// or /* ... */";

		case ztShLangTokenType_If:                 return "if";
		case ztShLangTokenType_Else:               return "else";
		case ztShLangTokenType_For:                return "for";
		case ztShLangTokenType_While:              return "while";
		case ztShLangTokenType_Const:              return "const";
		case ztShLangTokenType_Struct:             return "struct";
		case ztShLangTokenType_Return:             return "return";
		case ztShLangTokenType_Break:              return "break";
		case ztShLangTokenType_Continue:           return "continue";

		case ztShLangTokenType_void:               return "void";
		case ztShLangTokenType_int:                return "int";
		case ztShLangTokenType_uint:               return "uint";
		case ztShLangTokenType_float:              return "float";
		case ztShLangTokenType_double:             return "double";
		case ztShLangTokenType_bool:               return "bool";
		case ztShLangTokenType_vec2:               return "vec2";
		case ztShLangTokenType_vec3:               return "vec3";
		case ztShLangTokenType_vec4:               return "vec4";
		case ztShLangTokenType_ivec2:              return "ivec2";
		case ztShLangTokenType_ivec3:              return "ivec3";
		case ztShLangTokenType_ivec4:              return "ivec4";
		case ztShLangTokenType_mat2:               return "mat2";
		case ztShLangTokenType_mat3:               return "mat3";
		case ztShLangTokenType_mat4:               return "mat4";
		case ztShLangTokenType_texture2d:          return "texture2d";
		case ztShLangTokenType_textureCube:        return "textureCube";

		case ztShLangTokenType_NumberInteger:      return "<integer>";
		case ztShLangTokenType_NumberFloat:        return "<floating point>";
		case ztShLangTokenType_True:               return "true";
		case ztShLangTokenType_False:              return "false";

		case ztShLangTokenType_Program:            return "program";

		case ztShLangTokenType_Identifier:         return "<identifier>";
		case ztShLangTokenType_PreprocessCommand:  return "<preprocess>";

		case ztShLangTokenType_Access:             return ".";
	}

	return "<unknown>";
}

// ================================================================================================================================================================================================

ztShLangTokenType_Enum _zt_shaderLangTokenTypeFromDesc(char *desc, int desc_len = -1)
{
	if (zt_strEquals(desc, "(")) return ztShLangTokenType_ParenOpen;
	if (zt_strEquals(desc, ")")) return ztShLangTokenType_ParenClose;
	if (zt_strEquals(desc, "{")) return ztShLangTokenType_BraceOpen;
	if (zt_strEquals(desc, "}")) return ztShLangTokenType_BraceClose;
	if (zt_strEquals(desc, "[")) return ztShLangTokenType_BracketOpen;
	if (zt_strEquals(desc, "]")) return ztShLangTokenType_BracketClose;
	if (zt_strEquals(desc, ",")) return ztShLangTokenType_Comma;

	if (zt_strEquals(desc, "=")) return ztShLangTokenType_Equal;
	if (zt_strEquals(desc, "==")) return ztShLangTokenType_DoubleEqual;
	if (zt_strEquals(desc, "+")) return ztShLangTokenType_Plus;
	if (zt_strEquals(desc, "+=")) return ztShLangTokenType_PlusEqual;
	if (zt_strEquals(desc, "++")) return ztShLangTokenType_DoublePlus;
	if (zt_strEquals(desc, "-")) return ztShLangTokenType_Minus;
	if (zt_strEquals(desc, "-=")) return ztShLangTokenType_MinusEqual;
	if (zt_strEquals(desc, "--")) return ztShLangTokenType_DoubleMinus;
	if (zt_strEquals(desc, "*")) return ztShLangTokenType_Multiply;
	if (zt_strEquals(desc, "*=")) return ztShLangTokenType_MultiplyEqual;
	if (zt_strEquals(desc, "/")) return ztShLangTokenType_Divide;
	if (zt_strEquals(desc, "/=")) return ztShLangTokenType_DivideEqual;
	if (zt_strEquals(desc, ">")) return ztShLangTokenType_GreaterThan;
	if (zt_strEquals(desc, ">=")) return ztShLangTokenType_GreaterThanOrEqual;
	if (zt_strEquals(desc, "<")) return ztShLangTokenType_LessThan;
	if (zt_strEquals(desc, "<=")) return ztShLangTokenType_LessThanOrEqual;
	if (zt_strEquals(desc, "%")) return ztShLangTokenType_Mod;
	if (zt_strEquals(desc, "%=")) return ztShLangTokenType_ModEqual;
	if (zt_strEquals(desc, "!")) return ztShLangTokenType_Not;
	if (zt_strEquals(desc, "!=")) return ztShLangTokenType_NotEqual;
	if (zt_strEquals(desc, "&&")) return ztShLangTokenType_And;
	if (zt_strEquals(desc, "||")) return ztShLangTokenType_Or;

	if (zt_strEquals(desc, "&")) return ztShLangTokenType_BitwiseAnd;
	if (zt_strEquals(desc, "&=")) return ztShLangTokenType_BitwiseAndEqual;
	if (zt_strEquals(desc, "|")) return ztShLangTokenType_BitwiseOr;
	if (zt_strEquals(desc, "|=")) return ztShLangTokenType_BitwiseOrEqual;
	if (zt_strEquals(desc, "~")) return ztShLangTokenType_BitwiseNot;
	if (zt_strEquals(desc, "^")) return ztShLangTokenType_BitwiseXor;
	if (zt_strEquals(desc, "^=")) return ztShLangTokenType_BitwiseXorEqual;
	if (zt_strEquals(desc, "<<")) return ztShLangTokenType_BitwiseShiftLeft;
	if (zt_strEquals(desc, ">>")) return ztShLangTokenType_BitwiseShiftRight;

	if (zt_strEquals(desc, ";")) return ztShLangTokenType_EndCommand;
	if (zt_strEquals(desc, "?")) return ztShLangTokenType_Question;
	if (zt_strEquals(desc, ":")) return ztShLangTokenType_Colon;

	if (zt_strStartsWith(desc, "\"")) return ztShLangTokenType_QuotedChar;
	if (zt_strStartsWith(desc, "\'")) return ztShLangTokenType_QuotedString;

	if (zt_strEquals(desc, "if")) return ztShLangTokenType_If;
	if (zt_strEquals(desc, "else")) return ztShLangTokenType_Else;
	if (zt_strEquals(desc, "for")) return ztShLangTokenType_For;
	if (zt_strEquals(desc, "while")) return ztShLangTokenType_While;
	if (zt_strEquals(desc, "const")) return ztShLangTokenType_Const;
	if (zt_strEquals(desc, "struct")) return ztShLangTokenType_Struct;
	if (zt_strEquals(desc, "return")) return ztShLangTokenType_Return;
	if (zt_strEquals(desc, "break")) return ztShLangTokenType_Break;
	if (zt_strEquals(desc, "continue")) return ztShLangTokenType_Continue;

	if (zt_strEquals(desc, "void")) return ztShLangTokenType_void;
	if (zt_strEquals(desc, "int")) return ztShLangTokenType_int;
	if (zt_strEquals(desc, "uint")) return ztShLangTokenType_uint;
	if (zt_strEquals(desc, "float")) return ztShLangTokenType_float;
	if (zt_strEquals(desc, "double")) return ztShLangTokenType_double;
	if (zt_strEquals(desc, "bool")) return ztShLangTokenType_bool;
	if (zt_strEquals(desc, "vec2")) return ztShLangTokenType_vec2;
	if (zt_strEquals(desc, "vec3")) return ztShLangTokenType_vec3;
	if (zt_strEquals(desc, "vec4")) return ztShLangTokenType_vec4;
	if (zt_strEquals(desc, "ivec2")) return ztShLangTokenType_ivec2;
	if (zt_strEquals(desc, "ivec3")) return ztShLangTokenType_ivec3;
	if (zt_strEquals(desc, "ivec4")) return ztShLangTokenType_ivec4;
	if (zt_strEquals(desc, "mat2")) return ztShLangTokenType_mat2;
	if (zt_strEquals(desc, "mat3")) return ztShLangTokenType_mat3;
	if (zt_strEquals(desc, "mat4")) return ztShLangTokenType_mat4;
	if (zt_strEquals(desc, "texture2d")) return ztShLangTokenType_texture2d;
	if (zt_strEquals(desc, "textureCube")) return ztShLangTokenType_textureCube;

	if (zt_strEquals(desc, "true")) return ztShLangTokenType_True;
	if (zt_strEquals(desc, "false")) return ztShLangTokenType_False;

	if (zt_strEquals(desc, "program")) return ztShLangTokenType_Program;

	if (zt_strEquals(desc, "<identifier>")) return ztShLangTokenType_Identifier;
	if (zt_strEquals(desc, "<preprocess>")) return ztShLangTokenType_PreprocessCommand;

	if (zt_strStartsWith(desc, "//")) return ztShLangTokenType_Comment;
	if (zt_strStartsWith(desc, "/*")) return ztShLangTokenType_Comment;

	if (zt_strIsInt(desc) || zt_strIsIntHex(desc)) return ztShLangTokenType_NumberInteger;
	if (zt_strIsReal32(desc) || zt_strIsReal64(desc)) return ztShLangTokenType_NumberFloat;

	return ztShLangTokenType_Identifier;
}

// ================================================================================================================================================================================================

ztShLangSyntaxNode *_zt_shaderLangGenerateSyntaxTree(char *file_data, ztShLangToken *tokens, int tokens_count, ztString *error)
{
#	define tokens_left	(tokens_count - (token_idx+1))
#	define make_node(var, token_type, tok)	ztShLangSyntaxNode *var = &global_node->cache->cache[global_node->cache->cache_used++]; zt_assert(global_node->cache->cache_used < global_node->cache->cache_size); var->type = token_type; var->next = nullptr; var->parent = nullptr; var->cache = nullptr; var->token = tok
#	define make_node_with_parent(var, token_type, parent_node, tok)	ztShLangSyntaxNode *var = &global_node->cache->cache[global_node->cache->cache_used++]; zt_assert(global_node->cache->cache_used < global_node->cache->cache_size); var->type = token_type; var->next = nullptr; var->parent = parent_node; var->cache = nullptr; zt_singleLinkAddToEnd(parent_node->first_child, var); var->token = tok

#	define err_to_string(tok)	 local::tokenToString(tok, file_data, error_buff_1, zt_elementsOf(error_buff_1))
#	define error_ueof() _zt_shaderLangErrorMessage(global_node, &tokens[tokens_count - 1], error, file_data, "Unexpected end of file")
#	define error_ute(tok) _zt_shaderLangErrorMessage(global_node, tok, error, file_data, "Unexpected token encountered")
#	define read_next_token(var)	if (tokens_left <= 0) return error_ueof(); ztShLangToken *var = &tokens[token_idx++]; while(var->type == ztShLangTokenType_Comment) { if (tokens_left <= 0) return error_ueof(); var = &tokens[token_idx++];}
#	define push_back_token()	token_idx--
#	define make_string(tok) local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, file_data + tok->token_beg, tok->token_len)
#	define make_parent(node_c, node_p)	zt_singleLinkAddToEnd(node_p->first_child, node_c); node_c->parent = node_p;

	struct local
	{
		static char *makeString(char *cache, int *cache_used, int cache_size, const char *source, int source_len)
		{
			zt_assert(*cache_used + source_len + 1 < cache_size);
			if(*cache_used + source_len + 1 >= cache_size) {
				static char out_of_memory[32];
				zt_strCpy(out_of_memory, 32, "out of memory");
				return out_of_memory;
			}

			zt_strCpy(cache + (*cache_used), source_len + 1, source, source_len);

			*cache_used += source_len + 1;
			return cache + ((*cache_used) - (source_len + 1));
		}

		static char *tokenToString(ztShLangToken *token, char *file_data, char *buffer, int buffer_len)
		{
			zt_strCpy(buffer, buffer_len, file_data + token->token_beg, token->token_len);
			return buffer;
		}

		// ---------------------------------------------

		static ztShLangSyntaxNode *readVariable(ztShLangSyntaxNode *global_node, ztString *error, char *file_data, ztShLangToken *tokens, int tokens_count, int &token_idx, bool error_out_if_not_variable, bool allow_const)
		{
			bool is_const = false;

			read_next_token(data_type);

			if (data_type->type == ztShLangTokenType_Const) {
				if (!allow_const) {
					return error_out_if_not_variable ? _zt_shaderLangErrorMessage(global_node, data_type, error, file_data, "Const variable declarations are not valid here") : nullptr;
				}
				is_const = true;
				read_next_token(data_type_next);
				data_type = data_type_next;
			}

			if (!zt_bitIsSet(data_type->flags, ztShLangTokenFlags_DataType) && data_type->type != ztShLangTokenType_Identifier) {
				return error_out_if_not_variable ? _zt_shaderLangErrorMessage(global_node, data_type, error, file_data, "Expecting data type to variable declaration") : nullptr;
			}

			read_next_token(var_name);
			if (var_name->type != ztShLangTokenType_Identifier) {
				return error_out_if_not_variable ? _zt_shaderLangErrorMessage(global_node, var_name, error, file_data, "Invalid variable name") : nullptr;
			}

			read_next_token(var_op);

			if (var_op->type == ztShLangTokenType_ParenOpen) { // this is a function declaration
				return error_out_if_not_variable ? _zt_shaderLangErrorMessage(global_node, var_op, error, file_data, "Expecting variable declaration.  Function declaration is not legal here") : nullptr;
			}

			int array_size = -1;
			if (var_op->type == ztShLangTokenType_BracketOpen) {
				read_next_token(array_size_tok);
				if (array_size_tok->type == ztShLangTokenType_NumberInteger) {
					array_size = zt_strToInt(file_data + array_size_tok->token_beg, array_size_tok->token_len, 0);
					if (array_size <= 0) {
						return _zt_shaderLangErrorMessage(global_node, array_size_tok, error, file_data, "Invalid array size");
					}
					read_next_token(close_bracket);
					if (close_bracket->type != ztShLangTokenType_BracketClose) {
						return _zt_shaderLangErrorMessage(global_node, close_bracket, error, file_data, "Expected ']'");
					}
				}
				else if (array_size_tok->type == ztShLangTokenType_BracketClose) {
					// only valid if followed by an equals sign
					read_next_token(array_assign_eq_sign);
					if (array_assign_eq_sign->type != ztShLangTokenType_Equal) {
						return _zt_shaderLangErrorMessage(global_node, array_assign_eq_sign, error, file_data, "Expecting array data assignment for empty array");
					}
					push_back_token();
				}
				else {

					return _zt_shaderLangErrorMessage(global_node, array_size_tok, error, file_data, "Expecting array size");
				}

				read_next_token(var_op_next);
				var_op = var_op_next;
			}

			ztShLangToken *tok_qualifier = nullptr;
			if (var_op->type == ztShLangTokenType_Colon) {
				read_next_token(tok_qual);
				tok_qualifier = tok_qual;

				read_next_token(var_op_next);
				var_op = var_op_next;
			}

			if (var_op->type != ztShLangTokenType_Equal && var_op->type != ztShLangTokenType_EndCommand && var_op->type != ztShLangTokenType_ParenClose && var_op->type != ztShLangTokenType_Comma) {
				return _zt_shaderLangErrorMessage(global_node, var_op, error, file_data, "Unexpected token encountered after variable declaration");
			}

			push_back_token();

			make_node(variable, ztShLangSyntaxNodeType_VariableDecl, var_name);

			variable->variable_decl.type_name  = make_string(data_type);
			variable->variable_decl.type       = _zt_shaderLangTokenTypeFromDesc(variable->variable_decl.type_name);
			variable->variable_decl.name       = make_string(var_name);
			variable->variable_decl.qualifier  = tok_qualifier ? make_string(tok_qualifier) : nullptr;
			variable->variable_decl.array_size = array_size;
			variable->variable_decl.is_const   = is_const;

			return variable;
		}

		// ---------------------------------------------

		static ztShLangSyntaxNode *readExpression(ztShLangSyntaxNode *global_node, ztString *error, char *file_data, ztShLangToken *tokens, int tokens_count, int &token_idx, bool can_declare, bool is_condition, bool is_var_assignment)
		{
			read_next_token(expr_begin);

			char error_buff_1[256];

			ztShLangSyntaxNode *result = nullptr;

			//bool check_for_further_expressions = !is_condition;
			bool check_for_further_expressions = true;

			bool is_const = false;
			if (expr_begin->type == ztShLangTokenType_Const) {
				is_const = true;
				read_next_token(after_const);
				expr_begin = after_const;
			}

			bool is_data_type = zt_bitIsSet(expr_begin->flags, ztShLangTokenFlags_DataType);
			if (expr_begin->type == ztShLangTokenType_Identifier || is_data_type) {
				read_next_token(ident_op);
				if (!is_data_type && zt_bitIsSet(ident_op->flags, ztShLangTokenFlags_Operator)) {
					bool condition = zt_bitIsSet(ident_op->flags, ztShLangTokenFlags_ConditionOperator);

					ztShLangSyntaxNode *expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, condition, false);
					if (expr == nullptr) {
						if (ident_op->type != ztShLangTokenType_DoublePlus && ident_op->type != ztShLangTokenType_DoubleMinus) {
							return nullptr;
						}
					}

					make_node(var_left, ztShLangSyntaxNodeType_Variable, expr_begin);
					var_left->variable_val.name = make_string(expr_begin);
					var_left->variable_val.token_type = expr_begin->type;

					make_node(operation, ztShLangSyntaxNodeType_Operation, ident_op);
					operation->operation.left = var_left;
					make_parent(var_left, operation);
					operation->operation.right = expr;
					if (expr != nullptr) {
						make_parent(expr, operation);
					}
					operation->operation.op = ident_op->type;
					operation->operation.returns = ztShLangTokenType_Invalid;
					operation->operation.left_type = ztShLangTokenType_Invalid;
					operation->operation.right_type = ztShLangTokenType_Invalid;

					result = operation;
				}
				else if (ident_op->type == ztShLangTokenType_ParenOpen) {
					// function call
					make_node(func_node, ztShLangSyntaxNodeType_FunctionCall, expr_begin);
					func_node->function_call.name = make_string(expr_begin);
					func_node->function_call.decl = nullptr;
					while (true) {
						read_next_token(func_param);
						if (func_param->type == ztShLangTokenType_ParenClose) {
							break;
						}

						if (func_param->type == ztShLangTokenType_Comma) {
							// noop
						}
						else {
							push_back_token();
						}

						ztShLangSyntaxNode *param = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
						if (param == nullptr) {
							if (zt_strLen(*error) == 0) {
								return _zt_shaderLangErrorMessage(global_node, func_param, error, file_data, "Expecting expression for function parameter");
							}
							return nullptr;
						}
						make_parent(param, func_node);
					}

					result = func_node;
				}
				else {
					if (can_declare) { // declaring a variable
						if (is_data_type || ident_op->type == ztShLangTokenType_Identifier) {
							push_back_token();
							push_back_token();
							if (is_const) {
								push_back_token();
							}
							result = readVariable(global_node, error, file_data, tokens, tokens_count, token_idx, true, true);
							if (result == nullptr) {
								return nullptr;
							}
						}
						else if (ident_op->type == ztShLangTokenType_BracketOpen) {
							// do nothing
							push_back_token();
						}
						else {
							return _zt_shaderLangErrorMessage(global_node, expr_begin, error, file_data, "Unexpected data type encountered");
						}
					}
					else {
						push_back_token();
					}
				}

				if (result == nullptr) {
					make_node(var_ident, ztShLangSyntaxNodeType_Variable, expr_begin);
					var_ident->variable_val.name = make_string(expr_begin);
					var_ident->variable_val.token_type = expr_begin->type;
					result = var_ident;

					read_next_token(bracket_test);
					if (bracket_test->type == ztShLangTokenType_BracketOpen) {
						ztShLangSyntaxNode *index_expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
						if (index_expr == nullptr) {
							return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, bracket_test, error, file_data, "Expecting valid expression for variable array index") : nullptr;
						}
						make_parent(index_expr, result);

						read_next_token(bracket_end);
						if (bracket_end->type != ztShLangTokenType_BracketClose) {
							return _zt_shaderLangErrorMessage(global_node, bracket_test, error, file_data, "Expecting ']' following variable array index expression");
						}

						// check for multi-dimensional array access
						while (true) {
							read_next_token(bracket_open);
							if (bracket_open->type != ztShLangTokenType_BracketOpen) {
								push_back_token();
								break;
							}
							ztShLangSyntaxNode *index_node = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
							read_next_token(bracket_close);
							if (bracket_close->type != ztShLangTokenType_BracketClose) {
								return error_ute(bracket_close);
							}
							make_parent(index_node, result);
						}
					}
					else {
						push_back_token();
					}
				}
			}
			else if (zt_bitIsSet(expr_begin->flags, ztShLangTokenFlags_String)) {
				make_node(var_val, ztShLangSyntaxNodeType_ValueString, expr_begin);
				var_val->value.value = make_string(expr_begin);
				result = var_val;
			}
			else if (zt_bitIsSet(expr_begin->flags, ztShLangTokenFlags_Number)) {
				make_node(var_val, expr_begin->type == ztShLangTokenType_NumberInteger ? ztShLangSyntaxNodeType_ValueNumberInt : ztShLangSyntaxNodeType_ValueNumberFloat, expr_begin);
				var_val->value.value = make_string(expr_begin);
				result = var_val;
			}
			else if (zt_bitIsSet(expr_begin->flags, ztShLangTokenFlags_Bool)) {
				make_node(var_val, ztShLangSyntaxNodeType_ValueBool, expr_begin);
				var_val->value.value = make_string(expr_begin);
				result = var_val;
			}
			else if (zt_bitIsSet(expr_begin->flags, ztShLangTokenFlags_Command)) {
				if (expr_begin->type == ztShLangTokenType_If || expr_begin->type == ztShLangTokenType_While) {
					if (!can_declare) {
						return _zt_shaderLangErrorMessage(global_node, expr_begin, error, file_data, "'%s' is not valid here", err_to_string(expr_begin));
					}

					read_next_token(paren_open);
					if (paren_open->type != ztShLangTokenType_ParenOpen) {
						return _zt_shaderLangErrorMessage(global_node, paren_open, error, file_data, "Expecting '('");
					}
					read_next_token(cond_expr_tok);
					push_back_token();
					ztShLangSyntaxNode *cond_expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
					if (cond_expr == nullptr) {
						return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, cond_expr_tok, error, file_data, "Expecting expression for '%s' statement", err_to_string(expr_begin)) : nullptr;
					}
					read_next_token(paren_close);
					if (paren_close->type != ztShLangTokenType_ParenClose) {
						return _zt_shaderLangErrorMessage(global_node, paren_close, error, file_data, "Expecting ')' following '%s' expression", err_to_string(expr_begin));
					}

					make_node(cond_node, ztShLangSyntaxNodeType_ConditionTest, expr_begin);
					make_parent(cond_expr, cond_node);

					cond_node->condition.op        = expr_begin->type;
					cond_node->condition.expr      = cond_expr;
					cond_node->condition.if_true   = nullptr;
					cond_node->condition.if_false  = nullptr;
					cond_node->condition.is_inline = false;

					read_next_token(cond_begin);

					int statements = ztInt32Max;
					if (cond_begin->type != ztShLangTokenType_BraceOpen) {
						push_back_token();
						statements = 1;
					}

					make_node_with_parent(cond_scope, ztShLangSyntaxNodeType_Scope, cond_node, expr_begin);
					cond_scope->scope.name = nullptr;
					cond_node->condition.if_true = cond_scope;

					while (statements-- > 0) {
						read_next_token(statment_tok);
						push_back_token();
						ztShLangSyntaxNode *statement = readStatement(global_node, error, file_data, tokens, tokens_count, token_idx, cond_scope);
						if (statement == nullptr) {
							return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, statment_tok, error, file_data, "Expecting statement for '%s'", err_to_string(expr_begin)) : nullptr;
						}

						if (statements > 0) {
							read_next_token(brace_close);
							if (brace_close->type == ztShLangTokenType_BraceClose) {
								break;
							}
							else {
								push_back_token();
							}
						}
					}

					if (expr_begin->type == ztShLangTokenType_If) {
						read_next_token(else_tok);
						if (else_tok->type != ztShLangTokenType_Else) {
							push_back_token();
						}
						else {
							make_node_with_parent(else_scope, ztShLangSyntaxNodeType_Scope, cond_node, else_tok);
							else_scope->scope.name = nullptr;
							cond_node->condition.if_false = else_scope;

							int statements = ztInt32Max;
							read_next_token(brace_open);
							if (brace_open->type != ztShLangTokenType_BraceOpen) {
								push_back_token();
								statements = 1;
							}

							while (statements-- > 0) {
								read_next_token(statment_tok);
								push_back_token();
								ztShLangSyntaxNode *statement = readStatement(global_node, error, file_data, tokens, tokens_count, token_idx, else_scope);
								if (statement == nullptr) {
									return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, statment_tok, error, file_data, "Expecting statement for 'else'") : nullptr;
								}

								if (statements > 0) {
									read_next_token(brace_close);
									if (brace_close->type == ztShLangTokenType_BraceClose) {
										break;
									}
									else {
										push_back_token();
									}
								}
							}

						}
					}

					result = cond_node;
					check_for_further_expressions = false;
				}
				else if (expr_begin->type == ztShLangTokenType_For) {
					read_next_token(paren_open);
					if (paren_open->type != ztShLangTokenType_ParenOpen) {
						return _zt_shaderLangErrorMessage(global_node, paren_open, error, file_data, "Expecting '(' after 'for'");
					}

					ztShLangSyntaxNode *init_node = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, true, false, false);
					if (init_node == nullptr && *error != nullptr) {
						return nullptr;
					}

					read_next_token(init_end);
					if (init_end->type != ztShLangTokenType_EndCommand) {
						return error_ute(init_end);
					}

					ztShLangSyntaxNode *cond_node = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, true, false, false);
					if (cond_node == nullptr && *error != nullptr) {
						return nullptr;
					}

					read_next_token(cond_end);
					if (cond_end->type != ztShLangTokenType_EndCommand) {
						return error_ute(cond_end);
					}

					ztShLangSyntaxNode *loop_node = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, true, false, false);
					if (loop_node == nullptr && *error != nullptr) {
						return nullptr;
					}

					read_next_token(loop_end);
					if (loop_end->type != ztShLangTokenType_ParenClose) {
						return error_ute(loop_end);
					}

					int statements = ztInt32Max;

					read_next_token(for_beg);
					if (for_beg->type != ztShLangTokenType_BraceOpen) {
						push_back_token();
						statements = 1;
					}


					make_node(for_node, ztShLangSyntaxNodeType_Loop, expr_begin);
					make_node(for_scope, ztShLangSyntaxNodeType_Scope, for_beg);

					for_node->loop.init = init_node;
					if (init_node) {
						make_parent(init_node, for_node);
					}

					for_node->loop.condition = cond_node;
					if (cond_node) {
						make_parent(cond_node, for_node);
					}

					for_node->loop.loop = loop_node;
					if (loop_node) {
						make_parent(loop_node, for_node);
					}

					make_parent(for_scope, for_node);

					while (statements-- > 0) {
						read_next_token(statment_tok);
						push_back_token();
						ztShLangSyntaxNode *statement = readStatement(global_node, error, file_data, tokens, tokens_count, token_idx, for_scope);
						if (statement == nullptr) {
							return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, statment_tok, error, file_data, "Expecting statement for 'for'") : nullptr;
						}

						if (statements > 0) {
							read_next_token(brace_close);
							if (brace_close->type == ztShLangTokenType_BraceClose) {
								break;
							}
							else {
								push_back_token();
							}
						}
					}

					result = for_node;
					check_for_further_expressions = false;
				}
				else if (expr_begin->type == ztShLangTokenType_Break) {
					make_node(loop_control_node, ztShLangSyntaxNodeType_Break, expr_begin);
					result = loop_control_node;
					check_for_further_expressions = false;
				}
				else if (expr_begin->type == ztShLangTokenType_Continue) {
					make_node(loop_control_node, ztShLangSyntaxNodeType_Continue, expr_begin);
					result = loop_control_node;
					check_for_further_expressions = false;
				}
				else if (expr_begin->type == ztShLangTokenType_Return) {
					make_node(ret_node, ztShLangSyntaxNodeType_Return, expr_begin);

					read_next_token(void_check);
					if (void_check->type != ztShLangTokenType_EndCommand) {
						push_back_token();

						ztShLangSyntaxNode *ret_expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
						if (ret_expr == nullptr) {
							return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, void_check, error, file_data, "Expecting expression following 'return'") : nullptr;
						}
						make_parent(ret_expr, ret_node);
					}

					result = ret_node;
					//check_for_further_expressions = false;
				}
			}
			if (expr_begin->type == ztShLangTokenType_ParenOpen) {
				make_node(group_node, ztShLangSyntaxNodeType_Group, expr_begin);
				ztShLangSyntaxNode *expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, can_declare, is_condition, is_var_assignment);

				make_parent(expr, group_node);

				read_next_token(paren_close);
				if (paren_close->type != ztShLangTokenType_ParenClose) {
					return error_ute(paren_close);
				}

				result = group_node;
			}

			if (result == nullptr) {
				if (expr_begin->type == ztShLangTokenType_Minus || expr_begin->type == ztShLangTokenType_DoubleMinus || expr_begin->type == ztShLangTokenType_DoublePlus) {
					ztShLangSyntaxNode *expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);

					if (expr != nullptr) {
						make_node(operation, ztShLangSyntaxNodeType_Operation, expr_begin);

						make_node_with_parent(left_zero, ztShLangSyntaxNodeType_ValueEmpty, operation, expr_begin);
						left_zero->value.value = nullptr;

						operation->operation.left = left_zero;
						operation->operation.right = expr;
						operation->operation.op = expr_begin->type;
						operation->operation.returns = ztShLangTokenType_Invalid;
						operation->operation.left_type = ztShLangTokenType_Invalid;
						operation->operation.right_type = ztShLangTokenType_Invalid;

						make_parent(expr, operation);

						result = operation;
					}
				}
			}

			if (result == nullptr) {
				push_back_token();
				if (expr_begin->type == ztShLangTokenType_EndCommand || expr_begin->type == ztShLangTokenType_ParenClose || expr_begin->type == ztShLangTokenType_Comma || expr_begin->type == ztShLangTokenType_Colon) {
					return nullptr;
				}
				if (expr_begin->type == ztShLangTokenType_ParenOpen) {
					result = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
				}
				else {
					return error_ute(expr_begin);
				}
			}

			if (check_for_further_expressions) {

				read_next_token(ident_next);
				if (ident_next->type == ztShLangTokenType_ParenClose || ident_next->type == ztShLangTokenType_Comma || ident_next->type == ztShLangTokenType_Colon || ident_next->type == ztShLangTokenType_BracketOpen || ident_next->type == ztShLangTokenType_BracketClose) {
					push_back_token();
				}
				else if (ident_next->type == ztShLangTokenType_Identifier && *(file_data + ident_next->token_beg) == '.') {
					make_node(operation, ztShLangSyntaxNodeType_Operation, expr_begin);

					make_parent(result, operation);
					make_node_with_parent(right_zero, ztShLangSyntaxNodeType_ValueEmpty, operation, expr_begin);
					right_zero->value.value = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, file_data + ident_next->token_beg, ident_next->token_len);


					operation->operation.left = result;
					operation->operation.right = right_zero;
					operation->operation.op = ztShLangTokenType_Access;
					operation->operation.returns = ztShLangTokenType_Invalid;
					operation->operation.left_type = ztShLangTokenType_Invalid;
					operation->operation.right_type = ztShLangTokenType_Invalid;
					result = operation;
				}
				else if (ident_next->type != ztShLangTokenType_EndCommand) {
					if (zt_bitIsSet(ident_next->flags, ztShLangTokenFlags_Operator)) {
						{
							ztShLangSyntaxNode *vardecl_node = nullptr;
							if (result->type == ztShLangSyntaxNodeType_VariableDecl) {
								vardecl_node = result;

								make_node(var_node, ztShLangSyntaxNodeType_Variable, vardecl_node->token);
								var_node->variable_val.name = make_string(vardecl_node->token);
								var_node->variable_val.token_type = vardecl_node->token->type;
								result = var_node;
							}

							ztShLangSyntaxNode *return_node = result->type == ztShLangSyntaxNodeType_Return ? result : nullptr;

							if (return_node) {
								result = return_node->first_child;
							}

							make_node(operation, ztShLangSyntaxNodeType_Operation, ident_next);
							operation->operation.op = ident_next->type;
							operation->operation.returns = ztShLangTokenType_Invalid;
							operation->operation.left_type = ztShLangTokenType_Invalid;
							operation->operation.right_type = ztShLangTokenType_Invalid;
							operation->operation.left = result;

							ztShLangSyntaxNode *expr = nullptr;

							read_next_token(brace_check);
							if (brace_check->type == ztShLangTokenType_BraceOpen) {
								make_node(brace_scope, ztShLangSyntaxNodeType_Scope, brace_check);
								ztShLangSyntaxNode *value = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, true);
								if (value == nullptr) {
									return nullptr;
								}

								int value_count = 0;
								while (value) {
									value_count += 1;
									make_parent(value, brace_scope);
									read_next_token(end_check);
									if (end_check->type == ztShLangTokenType_BraceClose) {
										break;
									}

									value = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, true);
								}

								vardecl_node->variable_decl.array_size = value_count;

								expr = brace_scope;
							}
							else {
								push_back_token();
								expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, zt_bitIsSet(ident_next->flags, ztShLangTokenFlags_ConditionOperator), false);
							}

							if (expr == nullptr) {
								return nullptr;
							}

							operation->operation.right = expr;


							make_parent(result, operation);
							make_parent(expr, operation);

							result = operation;

							if (vardecl_node) {
								make_parent(operation, vardecl_node);
								result = vardecl_node;
							}

							if (return_node) {
								return_node->first_child = operation;
								operation->parent = return_node;
								result = return_node;
							}

							read_next_token(check_for_question);
							if (check_for_question->type == ztShLangTokenType_Question) {
								make_node(inl_cond_node, ztShLangSyntaxNodeType_ConditionTest, ident_next);
								inl_cond_node->condition.op = check_for_question->type;
								inl_cond_node->condition.is_inline = true;

								ztShLangSyntaxNode *if_true = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
								if (if_true == nullptr) {
									return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, ident_next, error, file_data, "Expecting true condition for '?' operator") : nullptr;
								}
								read_next_token(colon);
								if (colon->type != ztShLangTokenType_Colon) {
									return _zt_shaderLangErrorMessage(global_node, colon, error, file_data, "Expecting ':' for '?' operator");
								}
								ztShLangSyntaxNode *if_false = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
								if (if_false == nullptr) {
									return *error == nullptr ? _zt_shaderLangErrorMessage(global_node, colon, error, file_data, "Expecting false condition for '?' operator") : nullptr;
								}

								inl_cond_node->condition.expr = result;
								make_parent(result, inl_cond_node);

								inl_cond_node->condition.if_true = if_true;
								make_parent(if_true, inl_cond_node);

								inl_cond_node->condition.if_false = if_false;
								make_parent(if_false, inl_cond_node);

								result = inl_cond_node;
							}
							else {
								push_back_token();
							}
						}
					}
					else if (ident_next->type == ztShLangTokenType_Question) {
						if (is_condition) {
							push_back_token();
						}
						else {
							zt_assert(false);
						}
					}
					else if (ident_next->type == ztShLangTokenType_BracketOpen) {
						if (result->type == ztShLangSyntaxNodeType_Variable) {
							ztShLangSyntaxNode *index_node = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, false, false, false);
							read_next_token(bracket_close);
							if (bracket_close->type != ztShLangTokenType_BracketClose) {
								return error_ute(bracket_close);
							}
							make_parent(index_node, result);
						}
						else {
							return error_ute(ident_next);
						}
					}
					else if(ident_next->type == ztShLangTokenType_BraceClose && is_var_assignment) {
						push_back_token();
						return result;
					}
					else {
						return error_ute(ident_next);
					}
				}
				else {
					push_back_token(); // push end command token back on the stack
				}
			}

			return result;
		}

		// ---------------------------------------------

		static ztShLangSyntaxNode *readStatement(ztShLangSyntaxNode *global_node, ztString *error, char *file_data, ztShLangToken *tokens, int tokens_count, int &token_idx, ztShLangSyntaxNode *scope)
		{
			ztShLangSyntaxNode *expr = readExpression(global_node, error, file_data, tokens, tokens_count, token_idx, true, false, false);
			if (expr) {
				expr->parent = scope;
				zt_singleLinkAddToEnd(scope->first_child, expr);

				read_next_token(end_cmd);
				if (end_cmd->type != ztShLangTokenType_EndCommand) {
					switch (expr->type)
					{
						case ztShLangSyntaxNodeType_VariableDecl:
						case ztShLangSyntaxNodeType_Return:
						case ztShLangSyntaxNodeType_Continue:
						case ztShLangSyntaxNodeType_Break:
						case ztShLangSyntaxNodeType_Operation:
						case ztShLangSyntaxNodeType_FunctionCall:
						case ztShLangSyntaxNodeType_ValueNumberInt:
						case ztShLangSyntaxNodeType_ValueNumberFloat:
						case ztShLangSyntaxNodeType_ValueString:
						case ztShLangSyntaxNodeType_ValueBool:
							return _zt_shaderLangErrorMessage(global_node, end_cmd, error, file_data, "Expecting ';'");

						default:
							push_back_token();
					}
				}
			}
			return expr;
		}
	};

	// ---------------------------------------------

	ztShLangSyntaxNodeCache *cache = zt_mallocStruct(ztShLangSyntaxNodeCache);
	cache->cache_size = tokens_count + 512; // extra to account for the built in functions and types
	cache->cache_used = 0;
	cache->cache = zt_mallocStructArray(ztShLangSyntaxNode, cache->cache_size);
	//zt_memSet(cache->cache, zt_sizeof(ztShLangSyntaxNode) * cache->cache_size, 0);
	cache->string_cache_size = zt_kilobytes(512);
	cache->string_cache_used = 0;
	cache->string_cache = zt_mallocStructArray(char, cache->string_cache_size);

	ztShLangSyntaxNode *global_node = &cache->cache[cache->cache_used++];
	global_node->type = ztShLangSyntaxNodeType_Scope;
	global_node->next = nullptr;
	global_node->parent = nullptr;
	global_node->token = nullptr;
	global_node->cache = cache;
	global_node->scope.name = nullptr;//make_string("global");

	ztShLangSyntaxNode *active_scope = global_node;

	char error_buff_1[256] = { 0 };
	*error = nullptr;

	int token_idx = 0;

	while (tokens_left > 0) {
		read_next_token(token);

		if (token->type == ztShLangTokenType_Invalid) {
			return _zt_shaderLangErrorMessage(global_node, token, error, file_data, "Unexpected token encountered: %s", err_to_string(token));
		}
		if (token->type == ztShLangTokenType_Comment) {
			continue;
		}

		if (active_scope == global_node) {
			if (token->type == ztShLangTokenType_Struct) {
				read_next_token(identifier);
				if (identifier->type != ztShLangTokenType_Identifier) {
					return _zt_shaderLangErrorMessage(global_node, token, error, file_data, "Expected identifier after struct declaration");
				}
				read_next_token(brace_open);
				if (brace_open->type != ztShLangTokenType_BraceOpen) {
					return _zt_shaderLangErrorMessage(global_node, brace_open, error, file_data, "Expected '{' after struct '%s' declaration", err_to_string(identifier));
				}

				make_node_with_parent(struct_node, ztShLangSyntaxNodeType_Structure, active_scope, identifier);

				struct_node->structure.name = make_string(identifier);

				while (true) {
					read_next_token(struct_tok);
					if (struct_tok->type == ztShLangTokenType_BraceClose) {
						break;
					}
					push_back_token();

					ztShLangSyntaxNode *var_node = local::readVariable(global_node, error, file_data, tokens, tokens_count, token_idx, true, false);
					if (!var_node) {
						return nullptr;
					}

					make_parent(var_node, struct_node);

					read_next_token(post_var_decl);
					if (post_var_decl->type != ztShLangTokenType_EndCommand) {
						return error_ute(post_var_decl);
					}
				}

				continue;
			}
		}

		if (zt_bitIsSet(token->flags, ztShLangTokenFlags_DataType) || token->type == ztShLangTokenType_Const || token->type == ztShLangTokenType_Identifier) {
			bool is_const = false;
			if (token->type == ztShLangTokenType_Const) {
				is_const = true;
				read_next_token(token_next);
				token = token_next;
			}

			if (zt_bitIsSet(token->flags, ztShLangTokenFlags_DataType) || token->type == ztShLangTokenType_Identifier) {
				read_next_token(identifier);
				if (identifier->type == ztShLangTokenType_Identifier) {
					read_next_token(paren);
					if (paren->type == ztShLangTokenType_ParenOpen) {
						make_node_with_parent(func_node, ztShLangSyntaxNodeType_FunctionDecl, active_scope, identifier);

						func_node->function_decl.returns_name = make_string(token);
						func_node->function_decl.returns      = _zt_shaderLangTokenTypeFromDesc(func_node->function_decl.returns_name);
						func_node->function_decl.name         = make_string(identifier);

						while (true) {
							read_next_token(func_param);
							if (func_param->type == ztShLangTokenType_ParenClose) {
								break;
							}
							if (func_param->type != ztShLangTokenType_Comma) {
								if (!(zt_bitIsSet(func_param->flags, ztShLangTokenFlags_DataType) || func_param->type == ztShLangTokenType_Const || func_param->type == ztShLangTokenType_Identifier)) {
									return error_ute(func_param);
								}
								push_back_token();
							}

							ztShLangSyntaxNode *var_node = local::readVariable(global_node, error, file_data, tokens, tokens_count, token_idx, true, true);
							if (var_node == nullptr) {
								return nullptr;
							}

							make_parent(var_node, func_node);
						}

						read_next_token(brace_open);
						if (brace_open->type != ztShLangTokenType_BraceOpen) {
							return error_ute(brace_open);
						}

						make_node_with_parent(func_scope, ztShLangSyntaxNodeType_Scope, func_node, identifier);
						active_scope = func_scope;

						while (true) {
							ztShLangSyntaxNode *statement = local::readStatement(global_node, error, file_data, tokens, tokens_count, token_idx, active_scope);
							if (statement == nullptr) {
								if (*error) {
									return nullptr;
								}
							}

							read_next_token(brace_check);
							if (brace_check->type == ztShLangTokenType_BraceClose) {
								break;
							}
							push_back_token();
						}

						active_scope = active_scope->parent->parent;
						// if we're here, the closing brace has already been read
					}
					else { // this is not a function, but a variable declaration
						push_back_token(); // what we thought was paren open
						push_back_token(); // identifier
						push_back_token(); // data type

						if (is_const) {
							push_back_token();
						}

						ztShLangSyntaxNode *var_node = local::readVariable(global_node, error, file_data, tokens, tokens_count, token_idx, true, true);
						if (!var_node) {
							return nullptr;
						}
					}
				}
				else {
					push_back_token();
				}
			}
			continue;
		}

		if (token->type == ztShLangTokenType_Program) {
			if (active_scope != global_node) {
				return _zt_shaderLangErrorMessage(global_node, token, error, file_data, "Program may only be declared in the global scope");
			}
			read_next_token(program_name);
			if (program_name->type != ztShLangTokenType_Identifier) {
				return _zt_shaderLangErrorMessage(global_node, program_name, error, file_data, "Expecting program name");
			}
			read_next_token(brace_open);
			if (brace_open->type != ztShLangTokenType_BraceOpen) {
				return _zt_shaderLangErrorMessage(global_node, brace_open, error, file_data, "Expecting opening brace for program");
			}

			make_node_with_parent(program_node, ztShLangSyntaxNodeType_ProgramDecl, active_scope, program_name);
			program_node->parent = active_scope;
			program_node->program.name = make_string(program_name);
			active_scope = program_node;
			continue;
		}

		if (token->type == ztShLangTokenType_BraceClose) {
			if (active_scope == global_node) {
				return _zt_shaderLangErrorMessage(global_node, token, error, file_data, "Unexpected end of scope");
			}

			active_scope = active_scope->parent;
			while (active_scope->type != ztShLangSyntaxNodeType_Scope) {
				active_scope = active_scope->parent;
			}

			continue;
		}

		_zt_shaderLangErrorMessage(global_node, token, error, file_data, "Unexpected token encountered in global scope: %s", err_to_string(token));
		return global_node;
	}

	// add the built-in functions
	{
		// function name,<param data types>,return data type
		const char *built_in_functions[] = {
			"textureSample,texture2d,vec2,vec4",
			"textureSample,textureCube,vec3,vec4",
			"textureSampleLOD,textureCube,vec3,float,vec4",
			"textureSize,texture2d,vec2",
			"atan,float,float",
			"tan,float,float",
			"lerp,float,float,float,float",
			"lerp,vec2,vec2,float,vec2",
			"lerp,vec3,vec3,float,vec3",
			"lerp,vec4,vec4,float,vec4",
			"clamp,float,float,float,float",
			"clamp,vec2,vec2,vec2,vec2",
			"clamp,vec3,vec3,vec3,vec3",
			"clamp,vec4,vec4,vec4,vec4",
			"min,float,float,float",
			"min,vec2,vec2,vec2",
			"min,vec3,vec3,vec3",
			"min,vec4,vec4,vec4",
			"max,float,float,float",
			"max,vec2,vec2,vec2",
			"max,vec3,vec3,vec3",
			"max,vec4,vec4,vec4",
			"normalize,vec2,vec2",
			"normalize,vec3,vec3",
			"normalize,vec4,vec4",
			"pow,float,float,float",
			"pow,vec2,vec2,vec2",
			"pow,vec3,vec3,vec3",
			"pow,vec4,vec4,vec4",
			"exp,float,float",
			"exp,vec2,vec2",
			"exp,vec3,vec3",
			"exp,vec4,vec4",
			"dot,vec2,vec2,float",
			"dot,vec3,vec3,float",
			"dot,vec4,vec4,float",
			"length,vec2,float",
			"length,vec3,float",
			"transpose,mat3,mat3",
			"transpose,mat4,mat4",
			"inverse,mat3,mat3",
			"inverse,mat4,mat4",
			"smoothstep,float,float,float,float",
			"sin,float,float",
			"cos,float,float", 
			"exp,float,float",
			"fract,float,float",
			"fract,vec2,vec2",
			"fract,vec3,vec3",
			"floor,float,float",
			"floor,vec2,vec2",
			"floor,vec3,vec3",
			"floor,vec4,vec4",
			"ceil,float,float",
			"ceil,vec2,vec2",
			"ceil,vec3,vec3",
			"ceil,vec4,vec4",
			"abs,float,float",
			"abs,vec2,vec2",
			"abs,vec3,vec3",
			"abs,vec4,vec4",
			"distance,vec2,vec2,float",
			"distance,vec3,vec3,float",
			"mod,float,float,float",
			"mod,vec2,float,vec2",
			"mod,vec3,float,vec3",
			"log,vec2,vec2",
			"log,vec3,vec3",
			"log,float,float",
			"cross,vec2,vec2,vec2",
			"cross,vec3,vec3,vec3",
			"cross,vec4,vec4,vec4",
			"sqrt,float,float",
			"sqrt,vec2,vec2",
			"sqrt,vec3,vec3",
			"sqrt,vec4,vec4",
			"discard,void",
			"dFdx,float,float",
			"dFdx,vec2,vec2",
			"dFdx,vec3,vec3",
			"dFdx,vec4,vec4",
			"dFdy,float,float",
			"dFdy,vec2,vec2",
			"dFdy,vec3,vec3",
			"dFdy,vec4,vec4",
			"reflect,vec3,vec3,vec3",
			"sign,float,float",
			"step,float,float,float",
			"isnan,float,bool",

			"int,int,int",
			"int,uint,int",
			"int,float,int",
			"int,double,int",
			"uint,uint,uint",
			"uint,int,uint",
			"uint,float,uint",
			"uint,double,uint",
			"float,float,float",
			"float,int,float",
			"float,uint,float",
			"float,double,float",
			"double,double,float",
			"double,float,float",
			"double,int,float",
			"double,uint,float",
			"bool,int,bool",
			"bool,uint,bool",
			"bool,float,bool",
			"bool,double,bool",
			"vec2,vec2,vec2",
			"vec2,float,float,vec2",
			"vec2,float,vec2",
			"vec3,vec3,vec3",
			"vec3,float,float,float,vec3",
			"vec3,vec2,float,vec3",
			"vec3,float,vec3",
			"vec3,vec4,vec3",
			"vec4,vec4,vec4",
			"vec4,float,float,float,float,vec4",
			"vec4,vec2,float,float,vec4",
			"vec4,vec2,vec2,vec4",
			"vec4,vec3,float,vec4",
			"vec4,float,vec4",
			"ivec2,ivec2,ivec2",
			"ivec2,int,int,ivec2",
			"ivec3,ivec3,ivec3",
			"ivec3,int,int,int,ivec3",
			"ivec3,ivec2,int,ivec3",
			"ivec3,int,ivec3",
			"ivec3,ivec4,ivec3",
			"ivec4,ivec4,ivec4",
			"ivec4,int,int,int,int,ivec4",
			"ivec4,ivec2,int,int,vec4",
			"ivec4,ivec2,ivec2,ivec4",
			"ivec4,ivec3,int,ivec4",
			"ivec4,int,ivec4",
			"mat2,mat2,mat2",
			"mat2,float,float,float,float,mat2",
			"mat3,mat3,mat3",
			"mat3,float,float,float,float,float,float,float,float,float,mat3",
			"mat3,vec3,vec3,vec3,mat3",
			"mat3,mat4,mat3",
			"mat4,mat4,mat4",
			"mat4,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,mat4",
			"mat4,vec4,vec4,vec4,vec4,mat4",
		};

		// #	define make_string(tok) local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, file_data + tok->token_beg, tok->token_len)

		zt_fize(built_in_functions) {
			ztToken tokens[32];
			int tokens_count = zt_strTokenize(built_in_functions[i], ", ", tokens, zt_elementsOf(tokens));
			zt_assert(tokens_count > 1);

			make_node_with_parent(func_node, ztShLangSyntaxNodeType_FunctionDecl, global_node, nullptr);
			func_node->function_decl.returns_name = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_functions[i] + tokens[tokens_count - 1].beg, tokens[tokens_count - 1].len);
			func_node->function_decl.returns      = _zt_shaderLangTokenTypeFromDesc(func_node->function_decl.returns_name);
			func_node->function_decl.name         = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_functions[i] + tokens[0].beg, tokens[0].len);

			for (int j = 1; j < tokens_count - 1; ++j) {
				make_node_with_parent(variable, ztShLangSyntaxNodeType_VariableDecl, func_node, nullptr);

				variable->variable_decl.type_name = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_functions[i] + tokens[j].beg, tokens[j].len);
				variable->variable_decl.type       = _zt_shaderLangTokenTypeFromDesc(variable->variable_decl.type_name);
				variable->variable_decl.name       = nullptr;
				variable->variable_decl.qualifier  = nullptr;
				variable->variable_decl.array_size = -1;
			}
		}
	}
	// add the built-in structs
	{
		const char *built_in_structs[] = {
			"vec2,float x,float y",
			"vec3,float x,float y,float z,float r,float g,float b,vec2 xy,vec2 xz,vec2 yz",
			"vec4,float x,float y,float z,float w,float r,float g,float b,float a,vec2 xy,vec2 yz,vec2 zw,vec3 xyz,vec3 rgb",
			"ivec2,int x,int y",
			"ivec3,int x,int y,int z,int r,int g,int b,ivec2 xy",
			"ivec4,int x,int y,int z,int w,ivec3 xyz",
		};

		zt_fize(built_in_structs) {
			ztToken tokens[32];
			int tokens_count = zt_strTokenize(built_in_structs[i], ", ", tokens, zt_elementsOf(tokens));
			zt_assert(tokens_count > 1);

			make_node_with_parent(struct_node, ztShLangSyntaxNodeType_Structure, global_node, nullptr);
			struct_node->structure.name = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_structs[i] + tokens[0].beg, tokens[0].len);

			for (int j = 1; j < tokens_count; j += 2) {
				make_node_with_parent(variable, ztShLangSyntaxNodeType_VariableDecl, struct_node, nullptr);

				variable->variable_decl.type_name = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_structs[i] + tokens[j].beg, tokens[j].len);
				variable->variable_decl.type = _zt_shaderLangTokenTypeFromDesc(variable->variable_decl.type_name);
				variable->variable_decl.name = local::makeString(global_node->cache->string_cache, &global_node->cache->string_cache_used, global_node->cache->string_cache_size, built_in_structs[i] + tokens[j + 1].beg, tokens[j + 1].len);
				variable->variable_decl.qualifier = nullptr;
				variable->variable_decl.array_size = -1;
			}
		}

	}

	return global_node;

#	undef tokens_left
#	undef make_node
#	undef make_node_with_parent
#	undef err_to_string
#	undef err_to_string
#	undef error_ueof
#	undef error_ute
#	undef read_next_token
#	undef push_back_token
#	undef make_string
#	undef make_parent
}

// ================================================================================================================================================================================================

void _zt_shaderLangFreeSyntaxTree(ztShLangSyntaxNode *node)
{
	if (node->cache) {
		ztShLangSyntaxNodeCache *cache = node->cache;

		zt_memSet(cache->cache, zt_sizeof(ztShLangSyntaxNode) * cache->cache_size, 0); // node pointer is invalid after this
		zt_free(cache->cache);

		zt_memSet(cache->string_cache, cache->string_cache_size, 0);
		zt_free(cache->string_cache);

		zt_free(cache);
	}
}

// ================================================================================================================================================================================================

ztShLangSyntaxNode *_zt_shaderLangFindStructure(ztShLangSyntaxNode *node, const char *name)
{
	ztShLangSyntaxNode *global_node = node;
	while (global_node->parent) {
		global_node = global_node->parent;
	}

	zt_flink(child, global_node->first_child) {
		if (child->type == ztShLangSyntaxNodeType_Structure && zt_strEquals(child->structure.name, name)) {
			return child;
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_shaderLangVerifySyntaxTree(ztShLangSyntaxNode *global_scope, char *file_data, ztString *error)
{
	struct local
	{
		static bool isAllowedHere(char *file_data, ztShLangSyntaxNode *var_node, ztShLangSyntaxNodeType_Enum *allowed_types, int allowed_types_count, const char *scope_name, ztString *error)
		{
			zt_fiz(allowed_types_count) {
				if (var_node->type == allowed_types[i]) {
					return true;
				}
			}
			_zt_shaderLangErrorMessage(nullptr, var_node->token, error, file_data, "%s is illegal in %s", _zt_shaderLangSyntaxNodeDesc(var_node), scope_name);
			return false;
		}

		// ================================================================================================================================================================================================

		static ztString findDataType(ztShLangSyntaxNode *scope, ztShLangSyntaxNode *var_node, const char *ident)
		{
			zt_assert(var_node == nullptr || var_node->type == ztShLangSyntaxNodeType_Variable);

			zt_flink(child, scope->first_child) {
				if (child->type == ztShLangSyntaxNodeType_VariableDecl) {
					if (zt_strEquals(child->variable_decl.name, ident)) {
						if (var_node && var_node->variable_val.decl == nullptr) {
							var_node->variable_val.decl = child;
						}
						return child->variable_decl.type_name;
					}
				}
			}

			if (scope->parent) {
				return findDataType(scope->parent, var_node, ident);
			}

			return nullptr;
		}

		// ================================================================================================================================================================================================

		static bool variableInScope(char *file_data, ztShLangSyntaxNode *var_node, ztString *error)
		{
			zt_assert(var_node->type == ztShLangSyntaxNodeType_Variable);
			var_node->variable_val.decl = nullptr;

			ztToken tokens[16];
			int tokens_count = 0;

			char *name = var_node->value.value;

			if (zt_bitIsSet(var_node->token->flags, ztShLangTokenFlags_IdentifierWithAccess)) {
				tokens_count = zt_strTokenize(name, ".", tokens, zt_elementsOf(tokens));
			}
			else {
				tokens_count = 1;
				tokens[0].beg = 0;
				tokens[0].len = zt_strLen(name);
			}

			ztShLangSyntaxNode *global_scope = var_node;
			while (global_scope->parent) {
				global_scope = global_scope->parent;
			}

			ztShLangSyntaxNode *orig_var_node = var_node;
			zt_fiz(tokens_count) {
				char token[256];
				zt_strCpy(token, zt_elementsOf(token), name + tokens[i].beg, tokens[i].len);

				ztString data_type = findDataType(var_node, (i == tokens_count - 1 ? orig_var_node : nullptr), token);
				if (data_type == nullptr) {
					_zt_shaderLangErrorMessage(nullptr, orig_var_node->token, error, file_data, "Undeclared identifier");
					return false;
				}

				var_node = nullptr;
				zt_flink(struct_node, global_scope->first_child) {
					if (struct_node->type == ztShLangSyntaxNodeType_Structure) {
						if (zt_strEquals(struct_node->structure.name, data_type)) {
							var_node = struct_node;
							break;
						}
					}
				}
				if (var_node == nullptr) {

					const char *built_in_datatypes[] = {
						"int",
						"uint",
						"float",
						"double",
						"bool",
						"vec2",
						"vec3",
						"vec4",
						"ivec2",
						"ivec3",
						"ivec4",
						"mat3",
						"mat4",
						"texture2d",
						"textureCube",
					};

					zt_fize(built_in_datatypes) {
						if (zt_strEquals(built_in_datatypes[i], data_type)) {
							return true;
						}
					}

					_zt_shaderLangErrorMessage(nullptr, orig_var_node->token, error, file_data, "'%s' is not a valid data type", data_type);
					return false;
				}
			}

			return true;
		}

		// ================================================================================================================================================================================================

		static ztShLangTokenType_Enum getExpressionDataType(ztShLangSyntaxNode *node, ztString *error, char *file_data)
		{
			if (node->type == ztShLangSyntaxNodeType_Variable) {
				return node->variable_val.decl->variable_decl.type;
			}
			if (node->type == ztShLangSyntaxNodeType_FunctionCall) {
				ztShLangSyntaxNode *func_node = findFunction(node, nullptr, error, file_data);
				if (func_node) {
					return func_node->function_decl.returns;
				}
			}
			if (node->type == ztShLangSyntaxNodeType_ValueNumberInt) {
				return ztShLangTokenType_int;
			}
			if (node->type == ztShLangSyntaxNodeType_ValueNumberFloat) {
				return ztShLangTokenType_float;
			}
			if (node->type == ztShLangSyntaxNodeType_ValueBool) {
				return ztShLangTokenType_bool;
			}
			if (node->type == ztShLangSyntaxNodeType_Operation) {
				return getOperationType(node, error, file_data);
			}
			if (node->type == ztShLangSyntaxNodeType_Group) {
				return getExpressionDataType(node->first_child, error, file_data);
			}
			return ztShLangTokenType_Invalid;
		}

		// ================================================================================================================================================================================================

		static ztShLangSyntaxNode *findFunction(ztShLangSyntaxNode *node, bool *found, ztString *error, char *file_data)
		{
			ztShLangSyntaxNode *global_scope = node->parent;
			while (global_scope->parent) {
				global_scope = global_scope->parent;
			}

			zt_flink(child, global_scope->first_child) {
				if (child->type == ztShLangSyntaxNodeType_FunctionDecl) {
					if (zt_strEquals(child->function_decl.name, node->function_call.name)) {
						if (found) *found = true;

						// check parameters
						ztShLangSyntaxNode *param_decl = child->first_child;
						ztShLangSyntaxNode *param_call = node->first_child;

						while (param_decl && param_call) {
							if (param_decl->type != ztShLangSyntaxNodeType_VariableDecl) {
								break;
							}

							ztShLangTokenType_Enum decl_type = param_decl->variable_decl.type;
							ztShLangTokenType_Enum call_type = getExpressionDataType(param_call, error, file_data);

							if (decl_type != call_type) {
								if (!((decl_type == ztShLangTokenType_int   && call_type == ztShLangTokenType_float) ||
									(decl_type == ztShLangTokenType_float && call_type == ztShLangTokenType_int))) {
									break;
								}
							}

							if (decl_type == ztShLangTokenType_Identifier) {
								// todo: struct parameter... make sure they match
							}

							param_decl = param_decl->next;
							param_call = param_call->next;
						}

						//if (param_decl && !param_call && param_decl->type == ztShLangSyntaxNodeType_Scope) {
						if ((param_decl == nullptr || param_decl->type == ztShLangSyntaxNodeType_Scope) && param_call == nullptr) {
							if (node->function_call.decl == nullptr) {
								node->function_call.decl = child;
							}

							return child;
						}
					}
				}
			}

			return nullptr;
		}

		// ================================================================================================================================================================================================

		static bool isValidFunction(ztShLangSyntaxNode *global_scope, ztShLangSyntaxNode *func_node, char *file_data, ztString *error)
		{
			bool found = false;
			if (findFunction(func_node, &found, error, file_data)) {
				return true;
			}

			_zt_shaderLangErrorMessage(nullptr, func_node->token, error, file_data, (found ? "parameter mismatch for function '%s'" : "'%s' is not a valid function"), func_node->function_call.name);
			return false;
		}

		// ================================================================================================================================================================================================

		static ztShLangTokenType_Enum getOperationType(ztShLangSyntaxNode *op_node, ztString *error, char *file_data)
		{
			if (op_node->type != ztShLangSyntaxNodeType_Operation) {
				return ztShLangTokenType_Invalid;
			}

			if (op_node->operation.returns != ztShLangTokenType_Invalid) {
				return op_node->operation.returns;
			}

			struct sublocal
			{
				static ztShLangSyntaxNode *findFunctionDecl(ztShLangSyntaxNode *node, ztString *error, char *file_data)
				{
					bool found = false;
					ztShLangSyntaxNode *func_decl_node = findFunction(node, &found, error, file_data);
					if (func_decl_node) {
						return func_decl_node;
					}

					_zt_shaderLangErrorMessage(nullptr, node->token, error, file_data, (found ? "parameter mismatch for function '%s'" : "'%s' is not a valid function"), node->function_call.name);
					return nullptr;
				}

				static ztShLangTokenType_Enum getType(ztShLangSyntaxNode *node, ztString *error, char *file_data)
				{
					if (node->type == ztShLangSyntaxNodeType_ValueNumberInt) {
						return ztShLangTokenType_int;
					}
					if (node->type == ztShLangSyntaxNodeType_ValueNumberFloat) {
						return ztShLangTokenType_float;
					}
					if (node->type == ztShLangSyntaxNodeType_ValueBool || node->type == ztShLangSyntaxNodeType_ConditionTest) {
						return ztShLangTokenType_bool;
					}
					if (node->type == ztShLangSyntaxNodeType_Variable) {
						return node->variable_val.decl->variable_decl.type;
					}
					if (node->type == ztShLangSyntaxNodeType_FunctionCall) {
						if (node->function_call.decl == nullptr) {
							ztShLangSyntaxNode *func_decl_node = findFunctionDecl(node, error, file_data);
							node->function_call.decl = func_decl_node;
						}
						return node->function_call.decl ? node->function_call.decl->function_decl.returns : ztShLangTokenType_Invalid;
					}
					if (node->type == ztShLangSyntaxNodeType_Operation) {
						return local::getOperationType(node, error, file_data);
					}
					if (node->type == ztShLangSyntaxNodeType_Group) {
						return getType(node->first_child, error, file_data);
					}
					if (node->type == ztShLangSyntaxNodeType_Scope) {
						ztShLangTokenType_Enum first_type = getType(node->first_child, error, file_data);

						zt_flink(value, node->first_child->next) {
							ztShLangTokenType_Enum this_type = getType(value, error, file_data);
							if (this_type != first_type) {
								return ztShLangTokenType_Invalid;
							}
						}

						return first_type;
					}

					return ztShLangTokenType_Identifier;
				}

				static const char *getTypeString(ztShLangSyntaxNode *node, ztShLangTokenType_Enum result_type, ztString *error, char *file_data)
				{
					if (result_type != ztShLangTokenType_Identifier) {
						return _zt_shaderLangTokenTypeDesc(result_type);
					}

					return nullptr;
				}

				static ztShLangTokenType_Enum convertToLCD(ztShLangTokenType_Enum type)
				{
					switch (type)
					{
						case ztShLangTokenType_int:
						case ztShLangTokenType_uint:
						case ztShLangTokenType_double:
						case ztShLangTokenType_bool:
							return ztShLangTokenType_float;
					}

					return type;
				}
			};

			ztShLangTokenType_Enum left_orig = sublocal::getType(op_node->operation.left, error, file_data);

			if (op_node->operation.right == nullptr) {
				if (op_node->operation.op == ztShLangTokenType_DoublePlus || op_node->operation.op == ztShLangTokenType_DoubleMinus) {
					return left_orig;
				}
				return ztShLangTokenType_Invalid;
			}
			else {
				ztShLangTokenType_Enum right_orig = sublocal::getType(op_node->operation.right, error, file_data);

				op_node->operation.left_type = left_orig;
				op_node->operation.right_type = right_orig;

				ztShLangTokenType_Enum left = zt_min(left_orig, right_orig);
				ztShLangTokenType_Enum right = zt_max(left_orig, right_orig);

				if (left == right) {
					op_node->operation.returns = left;
					return left;
				}
				else {
					if (op_node->operation.op == ztShLangTokenType_Access) {
						const char *left_type = sublocal::getTypeString(op_node->operation.left, left_orig, error, file_data);
						ztShLangSyntaxNode *struct_node = _zt_shaderLangFindStructure(op_node, left_type);

						if (struct_node) {
							char ident[256];
							zt_strCpy(ident, zt_elementsOf(ident), op_node->operation.right->value.value);

							if (ident[0] == '.') {
								zt_flink(child, struct_node->first_child) {
									if (zt_strEquals(child->variable_decl.name, ident + 1)) {
										op_node->operation.returns = child->variable_decl.type;
										return child->variable_decl.type;
									}
								}
							}
						}
					}
					if (op_node->operation.left->type == ztShLangSyntaxNodeType_ValueEmpty) {
						op_node->operation.returns = right_orig;
						return right_orig;
					}

					// check for compatible types
					if (sublocal::convertToLCD(left) == sublocal::convertToLCD(right)) {
						op_node->operation.returns = right;
						return right;
					}

					if (left == ztShLangTokenType_float || left == ztShLangTokenType_double || left == ztShLangTokenType_int || left == ztShLangTokenType_uint) {
						if (right == ztShLangTokenType_vec2 || right == ztShLangTokenType_vec3 || right == ztShLangTokenType_vec4 || right == ztShLangTokenType_mat2 || right == ztShLangTokenType_mat3 || right == ztShLangTokenType_mat4) {
							op_node->operation.returns = right;
							return right;
						}
					}

					if (left == ztShLangTokenType_vec2 || left == ztShLangTokenType_vec3 || left == ztShLangTokenType_vec4) {
						if (right == ztShLangTokenType_mat2 || right == ztShLangTokenType_mat3 || right == ztShLangTokenType_mat4) {
							op_node->operation.returns = left;
							return left;
						}
					}

					if (*error == nullptr) {
						_zt_shaderLangErrorMessage(nullptr, op_node->token, error, file_data, "parameter mismatch in '%s' operation ('%s' is not compatible with '%s')", _zt_shaderLangTokenTypeDesc(op_node->operation.op), _zt_shaderLangTokenTypeDesc(left_orig), _zt_shaderLangTokenTypeDesc(right_orig));
					}
					return ztShLangTokenType_Invalid;
				}
			}
		}

		// ================================================================================================================================================================================================

		static bool isValidOperation(ztShLangSyntaxNode *op_node, ztString *error, char *file_data)
		{
			if (op_node->operation.returns != ztShLangTokenType_Invalid) {
				return true;
			}

			if (getOperationType(op_node, error, file_data) == ztShLangTokenType_Invalid) {
				return false;
			}

			return true;
		}

		// ================================================================================================================================================================================================

		static bool isValidDataType(ztShLangSyntaxNode *global_scope, ztShLangSyntaxNode *var_node)
		{
			if (var_node->type != ztShLangSyntaxNodeType_VariableDecl) {
				return false;
			}

			switch (var_node->variable_val.token_type)
			{
				case ztShLangTokenType_void:
				case ztShLangTokenType_int:
				case ztShLangTokenType_uint:
				case ztShLangTokenType_float:
				case ztShLangTokenType_double:
				case ztShLangTokenType_bool:
				case ztShLangTokenType_vec2:
				case ztShLangTokenType_vec3:
				case ztShLangTokenType_vec4:
				case ztShLangTokenType_ivec2:
				case ztShLangTokenType_ivec3:
				case ztShLangTokenType_ivec4:
				case ztShLangTokenType_mat3:
				case ztShLangTokenType_mat4:
				case ztShLangTokenType_texture2d:
					return true;

				case ztShLangTokenType_Identifier: {
					ztString data_type = var_node->variable_val.name;
					if (zt_strEquals(data_type, "vertex_shader") ||
						zt_strEquals(data_type, "geometry_shader") ||
						zt_strEquals(data_type, "pixel_sahder")) {
						return true;
					}

					zt_flink(struct_node, global_scope->first_child) {
						if (struct_node->type == ztShLangSyntaxNodeType_Structure) {
							if (zt_strEquals(struct_node->structure.name, data_type)) {
								return true;
							}
						}
					}
				} break;
			}

			return false;
		}

		// ================================================================================================================================================================================================

		static bool validateNodeStage1(ztShLangSyntaxNode *global_scope, char *file_data, ztShLangSyntaxNode *var_node, ztString *error)
		{
			if (var_node == global_scope) {
				ztShLangSyntaxNodeType_Enum allowed_in_global[] = {
					ztShLangSyntaxNodeType_Scope,
					ztShLangSyntaxNodeType_Structure,
					ztShLangSyntaxNodeType_VariableDecl,
					ztShLangSyntaxNodeType_ProgramDecl,
					ztShLangSyntaxNodeType_FunctionDecl,
				};
				bool program_found = false;

				zt_flink(child, global_scope->first_child) {
					if (!isAllowedHere(file_data, child, allowed_in_global, zt_elementsOf(allowed_in_global), "global scope", error)) {
						return false;
					}

					if (child->type == ztShLangSyntaxNodeType_ProgramDecl) {
						program_found = true;

						int vertex_found = 0;
						int pixel_found = 0;

						zt_flink(child2, child->first_child) {
							if (child2->type == ztShLangSyntaxNodeType_FunctionDecl) {
								if (zt_strEquals(child2->function_decl.returns_name, "vertex_shader")) {
									vertex_found += 1;

									bool input_found = false, uniforms_found = false, output_found = false;
									zt_flink(param, child2->first_child) {
										if (param->type != ztShLangSyntaxNodeType_VariableDecl) break;

										if (param->variable_decl.qualifier == nullptr) {
											_zt_shaderLangErrorMessage(nullptr, param->token, error, file_data, "Invalid parameter to vertex shader function '%s': '%s'", child2->function_decl.name, param->variable_decl.name);
											return false;
										}
										if (zt_strEquals(param->variable_decl.qualifier, "input")) {
											input_found = true;
										}
										if (zt_strEquals(param->variable_decl.qualifier, "uniforms")) uniforms_found = true;
										if (zt_strEquals(param->variable_decl.qualifier, "output")) {
											output_found = true;
											ztShLangSyntaxNode *struct_output = _zt_shaderLangFindStructure(global_scope, param->variable_decl.type_name);
											if (!struct_output) {
												_zt_shaderLangErrorMessage(nullptr, param->token, error, file_data, "Invalid parameter to vertex shader function '%s': '%s'", child2->function_decl.name, param->variable_decl.name);
												return false;
											}
											bool found_pos = false;
											zt_flink(member, struct_output->first_child) {
												if (zt_strEquals(member->variable_decl.qualifier, "position")) found_pos = true;
											}
											if (!found_pos) {
												*error = zt_stringMakeFrom("Shader vertex output structure must contain a member with a position qualifier");
												return false;
											}
										}
									}

									if (!input_found) { *error = zt_stringMakeFrom("Shader vertex function must pass in an input structure"); return false; }
									if (!uniforms_found) { *error = zt_stringMakeFrom("Shader vertex function must pass in a uniforms structure"); return false; }
									if (!output_found) { *error = zt_stringMakeFrom("Shader vertex function must pass in an output structure"); return false; }
								}
								else if (zt_strEquals(child2->function_decl.returns_name, "pixel_shader")) {
									pixel_found += 1;

									bool input_found = false, uniforms_found = false, output_found = false;
									zt_flink(param, child2->first_child) {
										if (param->type != ztShLangSyntaxNodeType_VariableDecl) break;

										if (param->variable_decl.qualifier == nullptr) {
											_zt_shaderLangErrorMessage(nullptr, param->token, error, file_data, "Invalid parameter to pixel shader function '%s': '%s'", child2->function_decl.name, param->variable_decl.name);
											return false;
										}
										if (zt_strEquals(param->variable_decl.qualifier, "input")) {
											input_found = true;
										}
										if (zt_strEquals(param->variable_decl.qualifier, "uniforms")) uniforms_found = true;
										if (zt_strEquals(param->variable_decl.qualifier, "output")) {
											output_found = true;
											ztShLangSyntaxNode *struct_output = _zt_shaderLangFindStructure(global_scope, param->variable_decl.type_name);
											if (!struct_output) {
												_zt_shaderLangErrorMessage(nullptr, param->token, error, file_data, "Invalid parameter to pixel shader function '%s': '%s'", child2->function_decl.name, param->variable_decl.name);
												return false;
											}
											bool found_color = false;
											zt_flink(member, struct_output->first_child) {
												if (zt_strEquals(member->variable_decl.qualifier, "color")) found_color = true;
											}
											if (!found_color) {
												//*error = zt_stringMakeFrom("Shader pixel output structure must contain a member with a color qualifier");
												//return false;
											}
										}
									}
								}
							}
						}
						if (vertex_found == 0) { *error = zt_stringMakeFrom("Shader must contain a vertex function"); return false; }
						if (vertex_found >= 2) { *error = zt_stringMakeFrom("Shader must contain only one vertex function"); return false; }
						if (pixel_found == 0) { *error = zt_stringMakeFrom("Shader must contain a pixel function"); return false; }
						if (pixel_found >= 2) { *error = zt_stringMakeFrom("Shader must contain only one pixel function"); return false; }
					}
				}

				if (!program_found) {
					*error = zt_stringMakeFrom("Shader is missing a program");
					return false;
				}
			}

			if (var_node->type == ztShLangSyntaxNodeType_Variable) {
				if (!variableInScope(file_data, var_node, error)) {
					return false;
				}
			}

			zt_flink(child, var_node->first_child) {
				if (!validateNodeStage1(global_scope, file_data, child, error)) {
					return false;
				}
			}

			return true;
		}

		// ================================================================================================================================================================================================

		static bool validateNodeStage2(ztShLangSyntaxNode *global_scope, char *file_data, ztShLangSyntaxNode *var_node, ztString *error)
		{
			if (var_node->type == ztShLangSyntaxNodeType_Operation) {
				if (!isValidOperation(var_node, error, file_data)) {
					return false;
				}
			}

			zt_flink(child, var_node->first_child) {
				if (!validateNodeStage2(global_scope, file_data, child, error)) {
					return false;
				}
			}

			return true;
		}

		// ================================================================================================================================================================================================

		static bool validateNodeStage3(ztShLangSyntaxNode *global_scope, char *file_data, ztShLangSyntaxNode *var_node, ztString *error)
		{
			if (var_node->type == ztShLangSyntaxNodeType_FunctionCall) {
				if (!isValidFunction(global_scope, var_node, file_data, error)) {
					return false;
				}
			}

			zt_flink(child, var_node->first_child) {
				if (!validateNodeStage3(global_scope, file_data, child, error)) {
					return false;
				}
			}

			return true;
		}
	};

	return local::validateNodeStage1(global_scope, file_data, global_scope, error) &&
	       local::validateNodeStage2(global_scope, file_data, global_scope, error) &&
	       local::validateNodeStage3(global_scope, file_data, global_scope, error);
}

// ================================================================================================================================================================================================

ztInternal void _zt_shaderLangDumpSyntaxTree(ztShLangSyntaxNode *node, int indent = 0)
{
	char indention[128] = { 0 };
	zt_fiz(zt_min(zt_elementsOf(indention), indent)) {
		indention[i] = '\t';
		indention[i + 1] = 0;
	}

	switch (node->type)
	{
		case ztShLangSyntaxNodeType_Scope: {
			zt_logVerbose("%s scope '%s'", indention, (node->scope.name ? node->scope.name : "unnamed"));
		} break;

		case ztShLangSyntaxNodeType_Structure: {
			zt_logVerbose("%s structure '%s'", indention, node->structure.name);
		} break;

		case ztShLangSyntaxNodeType_VariableDecl: {
			zt_logVerbose("%s variable decl; name '%s'; type '%s'; qualifier '%s'; array size '%d'; const '%s'", indention, node->variable_decl.name, node->variable_decl.type_name, node->variable_decl.qualifier, node->variable_decl.array_size, (node->variable_decl.is_const ? "true" : "false"));
		} break;

		case ztShLangSyntaxNodeType_ProgramDecl: {
			zt_logVerbose("%s program decl; name '%s'", indention, node->program.name);
		} break;

		case ztShLangSyntaxNodeType_FunctionDecl: {
			zt_logVerbose("%s function decl; name '%s'; returns '%s'", indention, node->function_decl.name, node->function_decl.returns_name);
		} break;

		case ztShLangSyntaxNodeType_ConditionTest: {
			zt_logVerbose("%s condition test; operator '%s'", indention, _zt_shaderLangTokenTypeDesc(node->token->type));
		} break;

		case ztShLangSyntaxNodeType_Return: {
			zt_logVerbose("%s return", indention);
		} break;

		case ztShLangSyntaxNodeType_Loop: {
			zt_logVerbose("%s loop", indention);
		} break;

		case ztShLangSyntaxNodeType_Continue: {
			zt_logVerbose("%s continue", indention);
		} break;

		case ztShLangSyntaxNodeType_Break: {
			zt_logVerbose("%s break", indention);
		} break;

		case ztShLangSyntaxNodeType_Variable: {
			zt_logVerbose("%s variable name '%s'; token type '%s'", indention, node->variable_val.name, _zt_shaderLangTokenTypeDesc(node->variable_val.token_type));
		} break;

		case ztShLangSyntaxNodeType_Operation: {
			zt_logVerbose("%s operation '%s'", indention, _zt_shaderLangTokenTypeDesc(node->operation.op));
		} break;

		case ztShLangSyntaxNodeType_FunctionCall: {
			zt_logVerbose("%s function call '%s'", indention, node->function_call.name);
		} break;

		case ztShLangSyntaxNodeType_ValueNumberInt: {
			zt_logVerbose("%s integer '%s'", indention, node->value.value);
		} break;

		case ztShLangSyntaxNodeType_ValueNumberFloat: {
			zt_logVerbose("%s float '%s'", indention, node->value.value);
		} break;

		case ztShLangSyntaxNodeType_ValueString: {
			zt_logVerbose("%s string '%s'", indention, node->value.value);
		} break;

		case ztShLangSyntaxNodeType_ValueBool: {
			zt_logVerbose("%s bool '%s'", indention, node->value.value);
		} break;
	}

	zt_flink(child, node->first_child) {
		_zt_shaderLangDumpSyntaxTree(child, indent + 1);
	}
}

// ================================================================================================================================================================================================

ztInternal bool _zt_shaderLangIsStructureReferenced(ztShLangSyntaxNode *node, const char *name, ztShLangSyntaxNode **functions_checked, int *functions_checked_size)
{
	zt_flink(child, node->first_child) {
		if (child->type == ztShLangSyntaxNodeType_VariableDecl && zt_strEquals(child->variable_decl.type_name, name)) {
			return true;
		}

		if (child->type == ztShLangSyntaxNodeType_FunctionCall) {
			if (zt_strEquals(child->function_call.name, name)) {
				return true;
			}

			// search this function
			ztShLangSyntaxNode *global_scope = node->parent;
			while (global_scope->parent) {
				global_scope = global_scope->parent;
			}

			zt_flink(child2, global_scope->first_child) {
				if (child2 == child->function_call.decl) {

					bool found = false;
					zt_fiz(*functions_checked_size) {
						if ((found = (functions_checked[i] == child2))) {
							break;
						}
					}
					if (!found) {
						functions_checked[(*functions_checked_size)++] = child2;
						if (_zt_shaderLangIsStructureReferenced(child2, name, functions_checked, functions_checked_size)) {
							return true;
						}
					}
				}
			}
		}

		if (child->type == ztShLangSyntaxNodeType_ProgramDecl) {
			continue;
		}

		if (_zt_shaderLangIsStructureReferenced(child, name, functions_checked, functions_checked_size)) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool _zt_shaderLangIsStructureReferenced(ztShLangSyntaxNode *node, const char *name)
{
	ztShLangSyntaxNode *functions_checked[512];
	zt_fize(functions_checked) {
		functions_checked[i] = nullptr;
	}
	int functions_checked_size = 0;

	functions_checked[functions_checked_size++] = node;

	return _zt_shaderLangIsStructureReferenced(node, name, functions_checked, &functions_checked_size);
}

// ================================================================================================================================================================================================

ztInternal bool _zt_shaderLangIsFunctionReferenced(ztShLangSyntaxNode *node, const char *name, ztShLangSyntaxNode **functions_checked, int *functions_checked_size)
{
	zt_flink(child, node->first_child) {
		if (child->type == ztShLangSyntaxNodeType_FunctionCall) {
			if (zt_strEquals(child->function_call.name, name)) {
				return true;
			}

			// search this function
			ztShLangSyntaxNode *global_scope = node->parent;
			while (global_scope->parent) {
				global_scope = global_scope->parent;
			}

			zt_flink(child2, global_scope->first_child) {
				if (child2 == child->function_call.decl) {

					bool found = false;
					zt_fiz(*functions_checked_size) {
						if ((found = (functions_checked[i] == child2))) {
							break;
						}
					}
					if (!found) {
						functions_checked[(*functions_checked_size)++] = child2;
						if (_zt_shaderLangIsFunctionReferenced(child2, name, functions_checked, functions_checked_size)) {
							return true;
						}
					}
				}
			}
		}

		if (child->type == ztShLangSyntaxNodeType_ProgramDecl) {
			continue;
		}

		if (_zt_shaderLangIsFunctionReferenced(child, name, functions_checked, functions_checked_size)) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool _zt_shaderLangIsFunctionReferenced(ztShLangSyntaxNode *node, const char *name)
{
	ztShLangSyntaxNode *functions_checked[512];
	zt_fize(functions_checked) {
		functions_checked[i] = nullptr;
	}
	int functions_checked_size = 0;

	functions_checked[functions_checked_size++] = node;

	return _zt_shaderLangIsFunctionReferenced(node, name, functions_checked, &functions_checked_size);
}

// ================================================================================================================================================================================================

ztInternal bool _zt_shaderLangIsVariableReferenced(ztShLangSyntaxNode *node, ztShLangSyntaxNode *var_decl_node, ztShLangSyntaxNode **functions_checked, int *functions_checked_size)
{
	zt_flink(child, node->first_child) {
		if (child->type == ztShLangSyntaxNodeType_Variable && child->variable_val.decl == var_decl_node) {
			return true;
		}

		if (child->type == ztShLangSyntaxNodeType_FunctionCall) {
			// search this function
			ztShLangSyntaxNode *global_scope = node->parent;
			while (global_scope->parent) {
				global_scope = global_scope->parent;
			}

			zt_flink(child2, global_scope->first_child) {
				if (child2 == child->function_call.decl) {

					bool found = false;
					zt_fiz(*functions_checked_size) {
						if ((found = (functions_checked[i] == child2))) {
							break;
						}
					}
					if (!found) {
						functions_checked[(*functions_checked_size)++] = child2;
						if (_zt_shaderLangIsVariableReferenced(child2, var_decl_node, functions_checked, functions_checked_size)) {
							return true;
						}
					}
				}
			}
		}

		if (child->type == ztShLangSyntaxNodeType_ProgramDecl) {
			continue;
		}

		if (_zt_shaderLangIsVariableReferenced(child, var_decl_node, functions_checked, functions_checked_size)) {
			return true;
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool _zt_shaderLangIsVariableReferenced(ztShLangSyntaxNode *node, ztShLangSyntaxNode *var_decl_node)
{
	ztShLangSyntaxNode *functions_checked[512];
	zt_fize(functions_checked) {
		functions_checked[i] = nullptr;
	}
	int functions_checked_size = 0;

	functions_checked[functions_checked_size++] = node;

	return _zt_shaderLangIsVariableReferenced(node, var_decl_node, functions_checked, &functions_checked_size);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

static ztShaderID _zt_shaderMakeBase(const char *name, const char *data_in, i32 data_len, ztShaderID replace);

// ---------

ZT_FUNCTION_POINTER_REGISTER(_zt_rendererShaderReload, ztInternal ZT_FUNC_ASSET_UPDATED(_zt_rendererShaderReload))
{
	ZT_PROFILE_RENDERING("_zt_rendererShaderReload");
	zt_logInfo("shader reload: asset_id: %d (%s)", asset_id, asset_manager->asset_name[asset_id]);
	ztShaderID shader_id = (ztShaderID)(pointer)user_data;
	zt_assert(shader_id >= 0 && shader_id < zt_game->shaders_count);

	i32 size = zt_assetSize(asset_manager, asset_id);
	if (size <= 0) {
		zt_logCritical("shader reload: unable to determine asset size");
		return;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_manager->arena);
	if (!data) {
		zt_logCritical("shader reload: unable to allocate memory for asset data");
		return;
	}

	const char *error = nullptr;
	ztShaderID result_shader_id = ztInvalidID;

	if (!zt_assetLoadData(asset_manager, asset_id, data, size)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	result_shader_id = _zt_shaderMakeBase(asset_manager->asset_name[asset_id], data, size, shader_id);
	if (result_shader_id == ztInvalidID) {
		goto on_error;
	}

	zt_game->shaders[shader_id].load_type = ztShaderLoadType_Asset;
	zt_game->shaders[shader_id].asset_mgr = asset_manager;
	zt_game->shaders[shader_id].asset_id  = asset_id;

	zt_assetAddReloadCallback(asset_manager, asset_id, ZT_FUNCTION_POINTER_TO_VAR(_zt_rendererShaderReload), (void*)shader_id); // since re-making the shader removed this, we need to add it back for future use

	zt_freeArena(data, asset_manager->arena);
	return;

on_error:
	zt_logCritical("Unable to reload shader (%s). %s.", asset_manager->asset_name[asset_id], error);
	zt_freeArena(data, asset_manager->arena);
}

// ================================================================================================================================================================================================

ztInternal void _zt_shaderSetupVariables(ztShader *shader)
{
	if (shader->renderer == ztRenderer_OpenGL) {
#		if defined(ZT_OPENGL)
			shader->variables.variables_count = shader->gl_shader->uniforms_count;
			if(shader->variables.variables_count > zt_elementsOf(shader->variables.variables)) {
				zt_logCritical("shader has too many uniforms");
				shader->variables.variables_count = zt_elementsOf(shader->variables.variables);
			}
			zt_fiz(shader->variables.variables_count) {
				ztShaderVariable_Enum var_type = ztShaderVariable_Invalid;
				switch (shader->gl_shader->uniforms[i].type)
				{
					case GL_FLOAT       : var_type = ztShaderVariable_Float; break;
					case GL_FLOAT_VEC2  : var_type = ztShaderVariable_Vec2; break;
					case GL_FLOAT_VEC3  : var_type = ztShaderVariable_Vec3; break;
					case GL_FLOAT_VEC4  : var_type = ztShaderVariable_Vec4; break;
					case GL_INT         : var_type = ztShaderVariable_Int; break;
					case GL_FLOAT_MAT3  : var_type = ztShaderVariable_Mat3; break;
					case GL_FLOAT_MAT4  : var_type = ztShaderVariable_Mat4; break;
					case GL_SAMPLER_2D  : var_type = ztShaderVariable_Tex; break;
					case GL_SAMPLER_CUBE: var_type = ztShaderVariable_TexCube; break;
				}

				if (var_type == ztShaderVariable_Invalid) {
					zt_logCritical("Unsupported shader variable type in variable %s", shader->gl_shader->uniforms[i].name);
				}
				else {
					shader->variables.variables[i].type = var_type;
					zt_strCpy(shader->variables.variables[i].name, zt_elementsOf(shader->variables.variables[i].name), shader->gl_shader->uniforms[i].name);
					shader->variables.variables[i].name_hash = zt_strHash(shader->variables.variables[i].name);
					shader->variables.variables[i].changed = true;
				}
			}
#		endif // ZT_OPENGL
	}
	else if (shader->renderer == ztRenderer_DirectX) {
#		if defined(ZT_DIRECTX)
			shader->variables.variables_count = dx_shader->variables_count;
			zt_fiz(shader->variables.variables_count) {
				ztShaderVariable_Enum var_type = ztShaderVariable_Invalid;
				switch (dx_shader->variables[i].type)
				{
					case ztShaderDXVariableType_Float:   var_type = ztShaderVariable_Float; break;
					case ztShaderDXVariableType_Vec2:    var_type = ztShaderVariable_Vec2; break;
					case ztShaderDXVariableType_Vec3:    var_type = ztShaderVariable_Vec3; break;
					case ztShaderDXVariableType_Vec4:    var_type = ztShaderVariable_Vec4; break;
					case ztShaderDXVariableType_Int:     var_type = ztShaderVariable_Int; break;
					case ztShaderDXVariableType_Mat3:    var_type = ztShaderVariable_Mat3; break;
					case ztShaderDXVariableType_Mat4:    var_type = ztShaderVariable_Mat4; break;
					case ztShaderDXVariableType_Tex:     var_type = ztShaderVariable_Tex; break;
					case ztShaderDXVariableType_TexCube: var_type = ztShaderVariable_TexCube; break;
				}

				if (var_type == ztShaderVariable_Invalid) {
					zt_logCritical("Unsupported shader variable type in variable %s", dx_shader->variables[i].name);
				}
				else {
					shader->variables.variables[i].type = var_type;
					zt_strCpy(shader->variables.variables[i].name, zt_elementsOf(shader->variables.variables[i].name), dx_shader->variables[i].name);
					shader->variables.variables[i].name_hash = zt_strHash(shader->variables.variables[i].name);
					shader->variables.variables[i].changed = true;
				}
			}
#		endif // ZT_DIRECTX
	}}

// ================================================================================================================================================================================================

ztInternal ztShaderID _zt_shaderGetNextID()
{
	zt_fiz(zt_game->shaders_count) {
		if (zt_game->shaders[i].renderer == ztRenderer_Invalid) {
			return i;
		}
	}

	zt_assert(zt_game->shaders_count < zt_elementsOf(zt_game->shaders));
	return zt_game->shaders_count++;
}

// ================================================================================================================================================================================================

ztInternal ztShaderID _zt_shaderMakeBase(const char *name, const char *data_in, i32 data_len, ztShaderID replace = ztInvalidID)
{
	ZT_PROFILE_RENDERING("_zt_shaderMakeBase");
	ztShaderID shader_id = ztInvalidID;

	ztShaderVariableValues var_values;
	if (replace != ztInvalidID) {
		zt_shaderPopulateVariables(replace, &var_values);
	}

	int shader_tokens_size = 0;
	ztShLangToken *shader_tokens = _zt_shaderLangTokenize(data_in, data_len, &shader_tokens_size);

	ztString error = nullptr;
	ztShLangSyntaxNode *syntax_root = _zt_shaderLangGenerateSyntaxTree((char*)data_in, shader_tokens, shader_tokens_size, &error);

	if (error) {
		zt_logCritical(error);
		zt_stringFree(error);
		return ztInvalidID;
	}

	if (!_zt_shaderLangVerifySyntaxTree(syntax_root, (char*)data_in, &error)) {
 		zt_logCritical(error);
		zt_stringFree(error);
		return ztInvalidID;
	}

	//_zt_shaderLangDumpSyntaxTree(syntax_root);

	ztGameSettings *game_settings = &zt_game->win_game_settings[0];
	if (game_settings->renderer == ztRenderer_OpenGL) {
#		if defined(ZT_OPENGL)

		ztString vert_src = nullptr, geom_src = nullptr, frag_src = nullptr;
		if (_zt_shaderLangConvertToGLSL(syntax_root, &vert_src, &geom_src, &frag_src, &error)) {
			if (replace != ztInvalidID) {
				shader_id = replace;
			}
			else {
				shader_id = _zt_shaderGetNextID();
			}

			ztShaderGL *gl_shader = ztgl_shaderMake(zt_game->win_details[0].gl_context, vert_src, frag_src, geom_src);
			if (gl_shader != nullptr) {
				if (replace != ztInvalidID) {
					zt_shaderFree(replace);
				}
				zt_game->shaders[shader_id].gl_shader = gl_shader;

				ztShader* shader = &zt_game->shaders[shader_id];

				shader->renderer = ztRenderer_OpenGL;

				_zt_shaderSetupVariables(shader);
			}
			else {
				shader_id = ztInvalidID;
			}

			if (gl_shader == nullptr) {
				error = zt_stringMakeFrom("Unable to compile OpenGL shader program");

				if (vert_src) zt_logCritical("Failed vertex shader:\n%s", vert_src);
				if (geom_src) zt_logCritical("Failed geometry shader:\n%s", geom_src);
				if (frag_src) zt_logCritical("Failed fragment shader:\n%s", frag_src);
			}
			else if (!zt_game->shader_loading_default) {
				zt_debugOnly(zt_logVerbose("OpenGL vertex shader:\n%s", vert_src));
				zt_debugOnly(zt_logVerbose("OpenGL geometry shader:\n%s", geom_src));
				zt_debugOnly(zt_logVerbose("OpenGL fragment shader:\n%s", frag_src));
			}

			if (vert_src) zt_stringFree(vert_src, zt_memGetGlobalArena());
			if (geom_src) zt_stringFree(geom_src, zt_memGetGlobalArena());
			if (frag_src) zt_stringFree(frag_src, zt_memGetGlobalArena());

#		else
		error = zt_stringMakeFrom("DirectX has been disabled in the library.");
#		endif // ZT_OPENGL
		}
	}
	else if (game_settings->renderer == ztRenderer_DirectX) {
#		if defined(ZT_DIRECTX)
		ztString vert_src = nullptr, geom_src = nullptr, frag_src = nullptr;
		if (_zt_shaderLangConvertToHLSL(syntax_root, &vert_src, &geom_src, &frag_src, &error)) {


			char *vert_entry = "vertexShader";
			char *frag_entry = "pixelShader";

			ztShaderDX *dx_shader = ztdx_shaderMake(zt_game->win_details[0].dx_context, vert_src, vert_entry, frag_src, frag_entry);
			if (dx_shader != nullptr) {
				if (replace != ztInvalidID) {
					zt_shaderFree(replace);
					shader_id = replace;
				}
				else {
					shader_id = _zt_shaderGetNextID();
				}

				ztShader* shader = &zt_game->shaders[shader_id];
				shader->renderer = ztRenderer_DirectX;
				shader->dx_shader = dx_shader;

				_zt_shaderSetupVariables(shader);
			}

			if (dx_shader == nullptr) {
				error = zt_stringMakeFrom("Unable to compile DirectX shader program");

				if (vert_src) zt_logCritical("Failed vertex shader:\n%s", vert_src);
				if (geom_src) zt_logCritical("Failed geometry shader:\n%s", geom_src);
				if (frag_src) zt_logCritical("Failed fragment shader:\n%s", frag_src);
			}
			else if (!zt_game->shader_loading_default) {
				zt_debugOnly(zt_logVerbose("OpenGL vertex shader:\n%s", vert_src));
				zt_debugOnly(zt_logVerbose("OpenGL geometry shader:\n%s", geom_src));
				zt_debugOnly(zt_logVerbose("OpenGL fragment shader:\n%s", frag_src));
			}


			if (vert_src) zt_stringFree(vert_src);
			if (geom_src) zt_stringFree(geom_src);
			if (frag_src) zt_stringFree(frag_src);
		}
#		else
		error = zt_stringMakeFrom("DirectX has been disabled in the library.");
#		endif // ZT_DIRECTX
	}

	_zt_shaderLangFreeSyntaxTree(syntax_root);

	zt_free(shader_tokens);

	if (error) {
		zt_logCritical("Unable to make shader '%s' (%s)", name, error);
		zt_stringFree(error);
		return ztInvalidID;
	}

	if (replace != ztInvalidID && shader_id != ztInvalidID) {
		ztShader *shader = &zt_game->shaders[shader_id];
		zt_fjz(shader->variables.variables_count) {
			zt_fiz(var_values.variables_count) {
				if (zt_strEquals(var_values.variables[i].name, shader->variables.variables[j].name)) {
					zt_memCpy(&shader->variables.variables[j], zt_sizeof(ztShaderVariableValues::Variable), &var_values.variables[i], zt_sizeof(ztShaderVariableValues::Variable));
					break;
				}
			}
		}
	}
	else {
		zt_game->shaders[shader_id].callbacks.begin_func      = ZT_FUNCTION_POINTER_TO_VAR_NULL;
		zt_game->shaders[shader_id].callbacks.begin_user_data = nullptr;
		zt_game->shaders[shader_id].callbacks.end_func        = ZT_FUNCTION_POINTER_TO_VAR_NULL;
		zt_game->shaders[shader_id].callbacks.end_user_data   = nullptr;
	}

	return shader_id;

#if 0
	ztGameSettings *game_settings = &zt_game->win_game_settings[0];
	if (game_settings->renderer == ztRenderer_OpenGL) {
	}
	else if (game_settings->renderer == ztRenderer_DirectX) {
#if defined(ZT_DIRECTX)
		if (dx_vert_cnt == 0) { error = zt_stringMakeFrom("No DirectX vertex shader found"); goto on_error; }
		if (dx_frag_cnt == 0) { error = zt_stringMakeFrom("No DirectX fragment shader found"); goto on_error; }

		char *vert_src = data + dx_vert_beg[0];
		vert_src[dx_vert_len[0]] = 0;
		char vert_entry[128] = { 0 };

		char *frag_src = data + dx_frag_beg[0];
		frag_src[dx_frag_len[0]] = 0;
		char frag_entry[128] = { 0 };

		struct DirectX
		{
			static void getEntryFunction(char *start, int start_len, const char *src, char entry_func[128])
			{
				int label_pos = zt_strFindLastPos(start, start_len, "<<[", (int)(src - start) - 4);
				char *header = start + label_pos;
				int label_end = zt_strFindPos(header, "]>>", 0);

				ztToken header_tokens[4];
				int header_tokens_count = zt_strTokenize(header, label_end, " ,", header_tokens, zt_elementsOf(header_tokens), ztStrTokenizeFlags_TrimWhitespace);
				if (header_tokens_count == 2) { // 0 - hlsl_xx, 1 - entry function
					zt_strCpy(entry_func, 128, header + header_tokens[1].beg, header_tokens[1].len);
				}
			}
		};

		DirectX::getEntryFunction((char*)data_in, data_len, data_in + dx_vert_beg[0], vert_entry);
		DirectX::getEntryFunction((char*)data_in, data_len, data_in + dx_frag_beg[0], frag_entry);

		if (replace != ztInvalidID) {
			zt_shaderFree(replace);
			shader_id = replace;
		}
		else {
			zt_assert(zt_game->shaders_count < zt_elementsOf(zt_game->shaders));
			shader_id = zt_game->shaders_count++;
		}

		ztShader* shader = &zt_game->shaders[shader_id];
		shader->renderer = ztRenderer_DirectX;
		ztShaderDX *dx_shader = shader->dx_shader = ztdx_shaderMake(zt_game->win_details[0].dx_context, vert_src, vert_entry, frag_src, frag_entry);
		if (shader->dx_shader == nullptr) {
			return ztInvalidID;
		}

		shader->variables.variables_count = dx_shader->variables_count;
		zt_fiz(shader->variables.variables_count) {
			ztShaderVariable_Enum var_type = ztShaderVariable_Invalid;
			switch (dx_shader->variables[i].type)
			{
				case ztShaderDXVariableType_Float  : var_type = ztShaderVariable_Float; break;
				case ztShaderDXVariableType_Vec2   : var_type = ztShaderVariable_Vec2; break;
				case ztShaderDXVariableType_Vec3   : var_type = ztShaderVariable_Vec3; break;
				case ztShaderDXVariableType_Vec4   : var_type = ztShaderVariable_Vec4; break;
				case ztShaderDXVariableType_Int    : var_type = ztShaderVariable_Int; break;
				case ztShaderDXVariableType_Mat3   : var_type = ztShaderVariable_Mat3; break;
				case ztShaderDXVariableType_Mat4   : var_type = ztShaderVariable_Mat4; break;
				case ztShaderDXVariableType_Tex    : var_type = ztShaderVariable_Tex; break;
				case ztShaderDXVariableType_TexCube: var_type = ztShaderVariable_TexCube; break;
			}

			if (var_type == ztShaderVariable_Invalid) {
				zt_logCritical("Unsupported shader variable type in variable %s", dx_shader->variables[i].name);
			}
			else {
				shader->variables.variables[i].type = var_type;
				zt_strCpy(shader->variables.variables[i].name, zt_elementsOf(shader->variables.variables[i].name), dx_shader->variables[i].name);
				shader->variables.variables[i].name_hash = zt_strHash(shader->variables.variables[i].name);
				shader->variables.variables[i].changed = true;
			}
		}

		return shader_id;
#else
		zt_logCritical("DirectX has been disabled in the library.");
		return ztInvalidID;
#endif // ZT_DIRECTX
	}
#endif
	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderMake(const char *name, const char *data, i32 data_len)
{
	ZT_PROFILE_RENDERING("zt_shaderMake(char*)");
	ztShaderID shader_id = _zt_shaderMakeBase(name, data, data_len);
	if (shader_id == ztInvalidID) {
		return shader_id;
	}

	zt_game->shaders[shader_id].load_type = ztShaderLoadType_Data;
	zt_game->shaders[shader_id].data = data;
	zt_game->shaders[shader_id].data_len = data_len;

	return shader_id;
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderMake(ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_RENDERING("zt_shaderMake(ztAssetID)");
	zt_returnValOnNull(asset_mgr, ztInvalidID);
	if(asset_id == ztInvalidID) {
		return ztInvalidID;
	}
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_Shader && asset_mgr->asset_type[asset_id] != ztAssetManagerType_Unknown) {
		return ztInvalidID;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return ztInvalidID;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return ztInvalidID;
	}

	const char *error = nullptr;
	ztShaderID shader_id = ztInvalidID;

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	shader_id = _zt_shaderMakeBase(asset_mgr->asset_name[asset_id], data, size);
	if (shader_id == ztInvalidID) {
		goto on_error;
	}

	zt_game->shaders[shader_id].load_type = ztShaderLoadType_Asset;
	zt_game->shaders[shader_id].asset_mgr = asset_mgr;
	zt_game->shaders[shader_id].asset_id = asset_id;

	asset_mgr->asset_callback_ids[asset_id] = shader_id;

	zt_assetAddReloadCallback(asset_mgr, asset_id, ZT_FUNCTION_POINTER_TO_VAR(_zt_rendererShaderReload), (void*)shader_id);

	zt_freeArena(data, asset_mgr->arena);
	return shader_id;

on_error:
	zt_logCritical("Unable to load shader (%s). %s.", asset_mgr->asset_name[asset_id], error);
	zt_freeArena(data, asset_mgr->arena);
	return ztInvalidID;
}

// ================================================================================================================================================================================================

void zt_shaderFree(ztShaderID shader_id)
{
	ZT_PROFILE_RENDERING("zt_shaderFree");
	if (shader_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count);

	ztShader* shader = &zt_game->shaders[shader_id];

	if (shader->renderer == ztRenderer_Invalid) {
		return;
	}

	if (shader->load_type == ztShaderLoadType_Asset && shader->asset_mgr) {
		zt_assetRemoveReloadCallback(shader->asset_mgr, shader->asset_id, (void*)shader_id);
	}

	if (shader->renderer == ztRenderer_OpenGL) {
		zt_openGLSupport(ztgl_shaderFree(shader->gl_shader));
	}
	else if (shader->renderer == ztRenderer_DirectX) {
		zt_directxSupport(ztdx_shaderFree(zt_game->win_details[0].dx_context, shader->dx_shader));
	}

	// we need to keep the callbacks otherwise they are lost when reloading a shader.  these are overwritten when loading a new shader, so there's no risk of old values being held over upon variable reuse
	ztShaderCallbacks callbacks;
	zt_memCpy(&callbacks, zt_sizeof(callbacks), &shader->callbacks, zt_sizeof(shader->callbacks));

	zt_memSet(shader, sizeof(ztShader), 0);

	zt_memCpy(&shader->callbacks, zt_sizeof(shader->callbacks), &callbacks, zt_sizeof(callbacks));
}

// ================================================================================================================================================================================================

void zt_shaderBegin(ztShaderID shader_id)
{
	ZT_PROFILE_RENDERING("zt_shaderBegin");
	zt_game->game_details.curr_frame.shader_switches += 1;

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_shaderBegin(zt_game->shaders[shader_id].gl_shader));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_shaderBegin(zt_game->win_details[0].dx_context, zt_game->shaders[shader_id].dx_shader));
		} break;

		default: {
			zt_assert(false);
		}
	}

	zt_fiz(zt_game->shaders[shader_id].variables.variables_count) {
		zt_game->shaders[shader_id].variables.variables[i].changed = true;
	}

	ZT_FUNCTION_POINTER_ACCESS_SAFE(zt_game->shaders[shader_id].callbacks.begin_func, ztShaderBegin_Func)(shader_id, zt_game->shaders[shader_id].callbacks.begin_user_data);
}

// ================================================================================================================================================================================================

void zt_shaderEnd(ztShaderID shader_id)
{
	ZT_PROFILE_RENDERING("zt_shaderEnd");
	zt_assertReturnOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count);

	ZT_FUNCTION_POINTER_ACCESS_SAFE(zt_game->shaders[shader_id].callbacks.end_func, ztShaderEnd_Func)(shader_id, zt_game->shaders[shader_id].callbacks.end_user_data);

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_shaderEnd(zt_game->shaders[shader_id].gl_shader));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_shaderEnd(zt_game->win_details[0].dx_context, zt_game->shaders[shader_id].dx_shader));
		} break;

		default: {
			zt_assert(false);
		}
	}
}

// ================================================================================================================================================================================================

void zt_shaderSetCallbacks(ztShaderID shader_id, ZT_FUNCTION_POINTER_VAR(begin_func, ztShaderBegin_Func), void *begin_user_data, ZT_FUNCTION_POINTER_VAR(end_func, ztShaderEnd_Func), void *end_user_data)
{
	ZT_PROFILE_RENDERING("zt_shaderEnd");
	zt_assertReturnOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count);

	zt_game->shaders[shader_id].callbacks.begin_func      = begin_func;
	zt_game->shaders[shader_id].callbacks.begin_user_data = begin_user_data;
	zt_game->shaders[shader_id].callbacks.end_func        = end_func;
	zt_game->shaders[shader_id].callbacks.end_user_data   = end_user_data;
}

// ================================================================================================================================================================================================

void zt_shaderSetCameraMatrices(ztShaderID shader_id, const ztMat4& projection, const ztMat4& view)
{
	ZT_PROFILE_RENDERING("zt_shaderSetCameraMatrices");
	static u32 view_hash = zt_strHash("view");
	static u32 projection_hash = zt_strHash("projection");
	zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, view_hash, view);
	zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, projection_hash, projection);
	zt_shaderApplyVariables(shader_id);
}

// ================================================================================================================================================================================================

void zt_shaderSetModelMatrices(ztShaderID shader_id, const ztMat4& model)
{
	ZT_PROFILE_RENDERING("zt_shaderSetModelMatrices");
	static u32 model_hash = zt_strHash("model");
	zt_shaderSetVariableMat4(&zt_game->shaders[shader_id].variables, model_hash, model);
	zt_shaderApplyVariables(shader_id);
}

// ================================================================================================================================================================================================

void zt_shaderPopulateVariables(ztShaderID shader_id, ztShaderVariableValues *shader_vars)
{
	ZT_PROFILE_RENDERING("zt_shaderPopulateVariables");
	zt_returnOnNull(shader_vars);
	zt_assertReturnOnFail(shader_id >= 0 && shader_id <= zt_game->shaders_count);

	zt_memCpy(shader_vars, zt_sizeof(ztShaderVariableValues), &zt_game->shaders[shader_id].variables, zt_sizeof(ztShaderVariableValues));

	zt_fiz(shader_vars->variables_count) {
		shader_vars->variables[i].changed = false;
	}
}

// ================================================================================================================================================================================================

void zt_shaderApplyVariables(ztShaderID shader_id, ztShaderVariableValues *shader_vars)
{
	ZT_PROFILE_RENDERING("zt_shaderApplyVariables");
	zt_returnOnNull(shader_vars);
	zt_assertReturnOnFail(shader_id >= 0 && shader_id <= zt_game->shaders_count);

	ztShaderVariableValues *shader = &zt_game->shaders[shader_id].variables;

#	if defined(ZT_DEBUG)
	// validate that the shader variables match up
	zt_assertReturnOnFail(shader->variables_count == shader_vars->variables_count);
	zt_fiz(shader->variables_count) {
		zt_assertReturnOnFail(shader->variables[i].type == shader_vars->variables[i].type);
		zt_assertReturnOnFail(zt_strEquals(shader->variables[i].name, shader_vars->variables[i].name));
	}
#	endif
	zt_fiz(shader->variables_count) {
		switch(shader->variables[i].type)
		{
			case ztShaderVariable_Float: {
				if(shader->variables[i].val_float != shader_vars->variables[i].val_float) {
					shader->variables[i].val_float = shader_vars->variables[i].val_float;
					shader->variables[i].changed = true;
				}
			} break;

			case ztShaderVariable_Int: {
				if(shader->variables[i].val_int != shader_vars->variables[i].val_int) {
					shader->variables[i].val_int = shader_vars->variables[i].val_int;
					shader->variables[i].changed = true;
				}
			} break;

			case ztShaderVariable_Vec2: {
				zt_fkze(shader->variables[i].val_vec2) {
					if(shader->variables[i].val_vec2[k] != shader_vars->variables[i].val_vec2[k]) {
						shader->variables[i].val_vec2[k] = shader_vars->variables[i].val_vec2[k];
						shader->variables[i].changed = true;
					}
				}
			} break;

			case ztShaderVariable_Vec3: {
				zt_fkze(shader->variables[i].val_vec3) {
					if(shader->variables[i].val_vec3[k] != shader_vars->variables[i].val_vec3[k]) {
						shader->variables[i].val_vec3[k] = shader_vars->variables[i].val_vec3[k];
						shader->variables[i].changed = true;
					}
				}
			} break;

			case ztShaderVariable_Vec4: {
				zt_fkze(shader->variables[i].val_vec4) {
					if(shader->variables[i].val_vec4[k] != shader_vars->variables[i].val_vec4[k]) {
						shader->variables[i].val_vec4[k] = shader_vars->variables[i].val_vec4[k];
						shader->variables[i].changed = true;
					}
				}
			} break;

			case ztShaderVariable_Mat3: {
				zt_fkze(shader->variables[i].val_mat3) {
					if(shader->variables[i].val_mat3[k] != shader_vars->variables[i].val_mat3[k]) {
						shader->variables[i].val_mat3[k] = shader_vars->variables[i].val_mat3[k];
						shader->variables[i].changed = true;
					}
				}
			} break;

			case ztShaderVariable_Mat4: {
				zt_fkze(shader->variables[i].val_mat4) {
					if(shader->variables[i].val_mat4[k] != shader_vars->variables[i].val_mat4[k]) {
						shader->variables[i].val_mat4[k] = shader_vars->variables[i].val_mat4[k];
						shader->variables[i].changed = true;
					}
				}
			} break;

			case ztShaderVariable_TexCube:
			case ztShaderVariable_Tex: {
				if(shader->variables[i].val_tex != shader_vars->variables[i].val_tex) {
					shader->variables[i].val_tex = shader_vars->variables[i].val_tex;
					shader->variables[i].changed = true;
				}
			} break;
		}
	}

	zt_shaderApplyVariables(shader_id);
}

// ================================================================================================================================================================================================

ztInternal void _zt_shaderApplyVariable(ztShaderID shader_id, int var_idx)
{
	ZT_PROFILE_RENDERING("_zt_shaderApplyVariable");
	ztShader *shader = &zt_game->shaders[shader_id];
	ztShaderVariableValues *shader_vars = &shader->variables;

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			if (shader_vars->variables_count) {
				ztShaderVariableValues::Variable *val = &shader_vars->variables[var_idx];
				if (val->changed || val->type == ztShaderVariable_Tex || val->type == ztShaderVariable_TexCube) {
					switch (val->type)
					{
						case ztShaderVariable_Float: ztgl_shaderVariableFloat(shader->gl_shader, val->name_hash, val->val_float); break;
						case ztShaderVariable_Int: ztgl_shaderVariableInt(shader->gl_shader, val->name_hash, val->val_int); break;
						case ztShaderVariable_Vec2: ztgl_shaderVariableVec2(shader->gl_shader, val->name_hash, val->val_vec2); break;
						case ztShaderVariable_Vec3: ztgl_shaderVariableVec3(shader->gl_shader, val->name_hash, val->val_vec3); break;
						case ztShaderVariable_Vec4: ztgl_shaderVariableVec4(shader->gl_shader, val->name_hash, val->val_vec4); break;
						case ztShaderVariable_Mat3: ztgl_shaderVariableMat3(shader->gl_shader, val->name_hash, val->val_mat3); break;
						case ztShaderVariable_Mat4: ztgl_shaderVariableMat4(shader->gl_shader, val->name_hash, val->val_mat4); break;
						case ztShaderVariable_Tex: ztgl_textureBindReset(shader->gl_shader); ztgl_shaderVariableTex(shader->gl_shader, val->name_hash, zt_game->textures[val->val_tex].gl_texture); break;
						case ztShaderVariable_TexCube: ztgl_textureBindReset(shader->gl_shader); ztgl_shaderVariableTex(shader->gl_shader, val->name_hash, zt_game->textures[val->val_tex].gl_texture); break;
					}
					val->changed = false;
				}
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			// populate cbuffer data
			if (shader_vars->variables_count) {
				ztShaderVariableValues::Variable *val = &shader_vars->variables[var_idx];
				if (val->changed || val->type == ztShaderVariable_Tex || val->type == ztShaderVariable_TexCube) {
					switch (val->type)
					{
						case ztShaderVariable_Float: ztdx_shaderVariableFloat(shader->dx_shader, val->name_hash, val->val_float); break;
						case ztShaderVariable_Int: ztdx_shaderVariableInt(shader->dx_shader, val->name_hash, val->val_int); break;
						case ztShaderVariable_Vec2: ztdx_shaderVariableVec2(shader->dx_shader, val->name_hash, val->val_vec2); break;
						case ztShaderVariable_Vec3: ztdx_shaderVariableVec3(shader->dx_shader, val->name_hash, val->val_vec3); break;
						case ztShaderVariable_Vec4: ztdx_shaderVariableVec4(shader->dx_shader, val->name_hash, val->val_vec4); break;
						case ztShaderVariable_Mat3: ztdx_shaderVariableMat3(shader->dx_shader, val->name_hash, val->val_mat3); break;
						case ztShaderVariable_Mat4: ztdx_shaderVariableMat4(shader->dx_shader, val->name_hash, val->val_mat4); break;
						case ztShaderVariable_Tex: ztdx_shaderVariableTex(shader->dx_shader, val->name_hash, zt_game->textures[val->val_tex].dx_texture); break;
						case ztShaderVariable_TexCube: ztdx_shaderVariableTex(shader->dx_shader, val->name_hash, zt_game->textures[val->val_tex].dx_texture); break;
					}
					val->changed = false;

					ztdx_shaderPopulateConstantBuffers(zt_game->win_details[0].dx_context, shader->dx_shader);
				}
			}
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

void zt_shaderApplyVariables(ztShaderID shader_id)
{
	ZT_PROFILE_RENDERING("zt_shaderApplyVariables");
	ztShader *shader = &zt_game->shaders[shader_id];
	ztShaderVariableValues *shader_vars = &shader->variables;

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			if (shader_vars->variables_count) {
				{
					ZT_PROFILE_RENDERING("ztgl_textureBindReset");
					ztgl_textureBindReset(shader->gl_shader);
				}
				{
					ZT_PROFILE_RENDERING("ztgl_shaderVariable...");

					zt_fiz(shader_vars->variables_count) {
						ztShaderVariableValues::Variable *val = &shader_vars->variables[i];
						if (val->changed || val->type == ztShaderVariable_Tex || val->type == ztShaderVariable_TexCube) {
							switch (val->type)
							{
								case ztShaderVariable_Float  : ztgl_shaderVariableFloat(shader->gl_shader, val->name_hash, val->val_float); break;
								case ztShaderVariable_Int    : ztgl_shaderVariableInt  (shader->gl_shader, val->name_hash, val->val_int  ); break;
								case ztShaderVariable_Vec2   : ztgl_shaderVariableVec2 (shader->gl_shader, val->name_hash, val->val_vec2 ); break;
								case ztShaderVariable_Vec3   : ztgl_shaderVariableVec3 (shader->gl_shader, val->name_hash, val->val_vec3 ); break;
								case ztShaderVariable_Vec4   : ztgl_shaderVariableVec4 (shader->gl_shader, val->name_hash, val->val_vec4 ); break;
								case ztShaderVariable_Mat3   : ztgl_shaderVariableMat3 (shader->gl_shader, val->name_hash, val->val_mat3 ); break;
								case ztShaderVariable_Mat4   : ztgl_shaderVariableMat4 (shader->gl_shader, val->name_hash, val->val_mat4 ); break;
								case ztShaderVariable_Tex    : ztgl_shaderVariableTex  (shader->gl_shader, val->name_hash, zt_game->textures[val->val_tex].gl_texture); break;
								case ztShaderVariable_TexCube: ztgl_shaderVariableTex  (shader->gl_shader, val->name_hash, zt_game->textures[val->val_tex].gl_texture); break;
							}
							val->changed = false;
						}
					}
				}
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			// populate cbuffer data
			if (shader_vars->variables_count) {
				int changed = 0;
				zt_fiz(shader_vars->variables_count) {
					ztShaderVariableValues::Variable *val = &shader_vars->variables[i];
					if (val->changed || val->type == ztShaderVariable_Tex || val->type == ztShaderVariable_TexCube) {
						changed += 1;
						switch (val->type)
						{
							case ztShaderVariable_Float  : ztdx_shaderVariableFloat(shader->dx_shader, val->name_hash, val->val_float); break;
							case ztShaderVariable_Int    : ztdx_shaderVariableInt  (shader->dx_shader, val->name_hash, val->val_int  ); break;
							case ztShaderVariable_Vec2   : ztdx_shaderVariableVec2 (shader->dx_shader, val->name_hash, val->val_vec2 ); break;
							case ztShaderVariable_Vec3   : ztdx_shaderVariableVec3 (shader->dx_shader, val->name_hash, val->val_vec3 ); break;
							case ztShaderVariable_Vec4   : ztdx_shaderVariableVec4 (shader->dx_shader, val->name_hash, val->val_vec4 ); break;
							case ztShaderVariable_Mat3   : ztdx_shaderVariableMat3 (shader->dx_shader, val->name_hash, val->val_mat3 ); break;
							case ztShaderVariable_Mat4   : ztdx_shaderVariableMat4 (shader->dx_shader, val->name_hash, val->val_mat4 ); break;
							case ztShaderVariable_Tex    : ztdx_shaderVariableTex  (shader->dx_shader, val->name_hash, zt_game->textures[val->val_tex].dx_texture); break;
							case ztShaderVariable_TexCube: ztdx_shaderVariableTex  (shader->dx_shader, val->name_hash, zt_game->textures[val->val_tex].dx_texture); break;
						}
						val->changed = false;
					}
				}

				if (changed > 0) {
					ztdx_shaderPopulateConstantBuffers(zt_game->win_details[0].dx_context, shader->dx_shader);
				}
			}
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

bool zt_shaderHasVariable(ztShaderVariableValues *shader_vars, const char *variable, ztShaderVariable_Enum *type)
{
	return zt_shaderHasVariable(shader_vars, zt_strHash(variable), type);
}

// ================================================================================================================================================================================================

bool zt_shaderHasVariable(ztShaderVariableValues *shader_vars, u32 variable_hash, ztShaderVariable_Enum *type)
{
	ZT_PROFILE_RENDERING("zt_shaderHasVariable");
	zt_returnValOnNull(shader_vars, false);

	zt_fiz(shader_vars->variables_count) {
		if (shader_vars->variables[i].name_hash == variable_hash) {
			if (type) *type = shader_vars->variables[i].type;
			return true;
		}
	}
	if (type) *type = ztShaderVariable_Invalid;
	return false;
}

// ================================================================================================================================================================================================

#define _zt_shaderCheckHash(shader_vars) \
        int idx = -1; \
        zt_fiz(shader_vars->variables_count) { \
            if (shader_vars->variables[i].name_hash == variable_hash) {\
                idx = i; break; \
            } \
        } \
        if (idx == -1) { return 0; }

#define _zt_shaderCheckType(shared_vars, shader_type) \
        if (shader_vars->variables[idx].type != shader_type) { \
            zt_assert(false); \
            return 0; \
        }

#define _zt_shaderCheckHashAndType(shared_vars, shader_type) \
        _zt_shaderCheckHash(shader_vars); \
        _zt_shaderCheckType(shader_vars, shader_type);


// ================================================================================================================================================================================================

int zt_shaderSetVariableFloat  (ztShaderVariableValues *shader_vars, const char *variable, r32 value          ) { return zt_shaderSetVariableFloat  (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableInt    (ztShaderVariableValues *shader_vars, const char *variable, i32 value          ) { return zt_shaderSetVariableInt    (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableVec2   (ztShaderVariableValues *shader_vars, const char *variable, const ztVec2 &value) { return zt_shaderSetVariableVec2   (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableVec3   (ztShaderVariableValues *shader_vars, const char *variable, const ztVec3 &value) { return zt_shaderSetVariableVec3   (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableVec4   (ztShaderVariableValues *shader_vars, const char *variable, const ztVec4 &value) { return zt_shaderSetVariableVec4   (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableMat4   (ztShaderVariableValues *shader_vars, const char *variable, const ztMat4& value) { return zt_shaderSetVariableMat4   (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableMat3   (ztShaderVariableValues *shader_vars, const char *variable, r32 value[12]      ) { return zt_shaderSetVariableMat3   (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableTex    (ztShaderVariableValues *shader_vars, const char *variable, ztTextureID value  ) { return zt_shaderSetVariableTex    (shader_vars, zt_strHash(variable), value); }
int zt_shaderSetVariableTexCube(ztShaderVariableValues *shader_vars, const char *variable, ztTextureID value  ) { return zt_shaderSetVariableTexCube(shader_vars, zt_strHash(variable), value); }

// ================================================================================================================================================================================================

int zt_shaderSetVariableFloat(ztShaderVariableValues *shader_vars, u32 variable_hash, r32 value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableFloat");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Float);
	if (shader_vars->variables[idx].val_float != value) {
		shader_vars->variables[idx].changed = true;
		shader_vars->variables[idx].val_float = value;
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableInt(ztShaderVariableValues *shader_vars, u32 variable_hash, i32 value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableInt");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Int);
	if (shader_vars->variables[idx].val_int != value) {
		shader_vars->variables[idx].changed = true;
		shader_vars->variables[idx].val_int = value;
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableVec2(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec2 &value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableVec2");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Vec2);

	zt_fize(value.values) {
		if(shader_vars->variables[idx].val_vec2[i] != value.values[i]) {
			shader_vars->variables[idx].changed = true;
			shader_vars->variables[idx].val_vec2[0] = value.values[0];
			shader_vars->variables[idx].val_vec2[1] = value.values[1];
			break;
		}
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableVec3(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec3 &value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableVec3");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Vec3);
	zt_fize(value.values) {
		if(shader_vars->variables[idx].val_vec3[i] != value.values[i]) {
			shader_vars->variables[idx].changed = true;
			shader_vars->variables[idx].val_vec3[0] = value.values[0];
			shader_vars->variables[idx].val_vec3[1] = value.values[1];
			shader_vars->variables[idx].val_vec3[2] = value.values[2];
			break;
		}
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableVec4(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztVec4 &value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableVec4");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Vec4);
	zt_fize(value.values) {
		if(shader_vars->variables[idx].val_vec4[i] != value.values[i]) {
			shader_vars->variables[idx].changed = true;
			shader_vars->variables[idx].val_vec4[0] = value.values[0];
			shader_vars->variables[idx].val_vec4[1] = value.values[1];
			shader_vars->variables[idx].val_vec4[2] = value.values[2];
			shader_vars->variables[idx].val_vec4[3] = value.values[3];
			break;
		}
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableMat4(ztShaderVariableValues *shader_vars, u32 variable_hash, const ztMat4& value)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableMat4");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Mat4);
	zt_fize(value.values) {
		if(shader_vars->variables[idx].val_mat4[i] != value.values[i]) {
			shader_vars->variables[idx].changed = true;
			zt_fiz(zt_elementsOf(value.values)) {
				shader_vars->variables[idx].val_mat4[i] = value.values[i];
			}
			break;
		}
	}
	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableMat3(ztShaderVariableValues *shader_vars, u32 variable_hash, r32 value[12])
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableMat3");
	_zt_shaderCheckHashAndType(shader_vars, ztShaderVariable_Mat3);
	zt_fiz(12) {
		if(shader_vars->variables[idx].val_mat3[i] != value[i]) {
			shader_vars->variables[idx].changed = true;
			zt_fiz(12) {
				shader_vars->variables[idx].val_mat3[i] = value[i];
			}
			break;
		}
	}

	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableTex(ztShaderVariableValues *shader_vars, u32 variable_hash, ztTextureID texture)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableTex");
	_zt_shaderCheckHash(shader_vars);

	if (shader_vars->variables[idx].type == ztShaderVariable_Tex || shader_vars->variables[idx].type == ztShaderVariable_TexCube) {
		if (shader_vars->variables[idx].val_tex != texture) {
			shader_vars->variables[idx].changed = true;
			shader_vars->variables[idx].val_tex = texture;
		}
	}

	return idx;
}

// ================================================================================================================================================================================================

int zt_shaderSetVariableTexCube(ztShaderVariableValues *shader_vars, u32 variable_hash, ztTextureID texture)
{
	ZT_PROFILE_RENDERING("zt_shaderSetVariableTexCube");
	_zt_shaderCheckHash(shader_vars);

	if (shader_vars->variables[idx].type == ztShaderVariable_Tex || shader_vars->variables[idx].type == ztShaderVariable_TexCube) {
		if (shader_vars->variables[idx].val_tex != texture) {
			shader_vars->variables[idx].changed = true;
			shader_vars->variables[idx].val_tex = texture;
		}
	}

	return idx;
}

// ================================================================================================================================================================================================

#undef _zt_shaderCheckHash
#undef _zt_shaderCheckType
#undef _zt_shaderCheckHashAndType

// ================================================================================================================================================================================================

#define _zt_shaderCheck(shader_id) \
	zt_assertReturnOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count); \
	ztShaderVariableValues *shader_vars = &zt_game->shaders[shader_id].variables;

// ================================================================================================================================================================================================

bool zt_shaderHasVariable(ztShaderID shader_id, const char *variable, ztShaderVariable_Enum *type)
{
	ZT_PROFILE_RENDERING("zt_shaderHasVariable");
	zt_assertReturnValOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count, false);
	return zt_shaderHasVariable(&zt_game->shaders[shader_id].variables, variable, type);
}

// ================================================================================================================================================================================================

bool zt_shaderHasVariable(ztShaderID shader_id, u32 variable_hash, ztShaderVariable_Enum *type)
{
	ZT_PROFILE_RENDERING("zt_shaderHasVariable");
	zt_assertReturnValOnFail(shader_id >= 0 && shader_id < zt_game->shaders_count, false);
	return zt_shaderHasVariable(&zt_game->shaders[shader_id].variables, variable_hash, type);
}

// ================================================================================================================================================================================================

void zt_shaderSetVariableFloat  (ztShaderID shader_id, const char *variable, r32 value          , bool apply_immediately) { zt_shaderSetVariableFloat  (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableInt    (ztShaderID shader_id, const char *variable, i32 value          , bool apply_immediately) { zt_shaderSetVariableInt    (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableVec2   (ztShaderID shader_id, const char *variable, const ztVec2 &value, bool apply_immediately) { zt_shaderSetVariableVec2   (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableVec3   (ztShaderID shader_id, const char *variable, const ztVec3 &value, bool apply_immediately) { zt_shaderSetVariableVec3   (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableVec4   (ztShaderID shader_id, const char *variable, const ztVec4 &value, bool apply_immediately) { zt_shaderSetVariableVec4   (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableMat4   (ztShaderID shader_id, const char *variable, const ztMat4& value, bool apply_immediately) { zt_shaderSetVariableMat4   (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableMat3   (ztShaderID shader_id, const char *variable, r32 value[12]      , bool apply_immediately) { zt_shaderSetVariableMat3   (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableTex    (ztShaderID shader_id, const char *variable, i32 value          , bool apply_immediately) { zt_shaderSetVariableTex    (shader_id, zt_strHash(variable), value); }
void zt_shaderSetVariableTexCube(ztShaderID shader_id, const char *variable, i32 value          , bool apply_immediately) { zt_shaderSetVariableTexCube(shader_id, zt_strHash(variable), value); }

// ================================================================================================================================================================================================

void zt_shaderSetVariableFloat  (ztShaderID shader_id, u32 variable_hash, r32 value          , bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableFloat  (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableInt    (ztShaderID shader_id, u32 variable_hash, i32 value          , bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableInt    (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableVec2   (ztShaderID shader_id, u32 variable_hash, const ztVec2 &value, bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableVec2   (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableVec3   (ztShaderID shader_id, u32 variable_hash, const ztVec3 &value, bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableVec3   (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableVec4   (ztShaderID shader_id, u32 variable_hash, const ztVec4 &value, bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableVec4   (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableMat4   (ztShaderID shader_id, u32 variable_hash, const ztMat4& value, bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableMat4   (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableMat3   (ztShaderID shader_id, u32 variable_hash, r32 value[12]      , bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableMat3   (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableTex    (ztShaderID shader_id, u32 variable_hash, i32 value          , bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableTex    (shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }
void zt_shaderSetVariableTexCube(ztShaderID shader_id, u32 variable_hash, i32 value          , bool apply_immediately) { _zt_shaderCheck(shader_id); int idx = zt_shaderSetVariableTexCube(shader_vars, variable_hash, value); if(apply_immediately) _zt_shaderApplyVariable(shader_id, idx); }

// ================================================================================================================================================================================================

ztShaderID zt_shaderGetDefault(ztShaderDefault_Enum shader_default)
{
	if (shader_default < ztShaderDefault_Solid || shader_default >= ztShaderDefault_MAX) {
		return ztInvalidID;
	}

	if (zt_game->shader_defaults[shader_default] == ztInvalidID) {
		zt_logInfo("main: loading default shader: %s", _zt_default_shaders_names[shader_default]);

		zt_game->shader_loading_default = true;
		zt_game->shader_defaults[shader_default] = zt_shaderMake(_zt_default_shaders_names[shader_default], _zt_default_shaders[shader_default], zt_strLen(_zt_default_shaders[shader_default]));
		zt_game->shader_loading_default = false;
		if (zt_game->shader_defaults[shader_default] == ztInvalidID) {
			zt_logCritical("main: Failed to load default shader: %s", _zt_default_shaders_names[shader_default]);
			return false;
		}
	}

	return zt_game->shader_defaults[shader_default];
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderMakePointLightShadows()
{
	switch(zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#		if defined(ZT_OPENGL)
			ztShaderGL *gl_shader = ztgl_shaderMakePointLightShadows(zt_game->win_details[0].gl_context);
			if (gl_shader != nullptr) {
				ztShaderID shader_id = _zt_shaderGetNextID();
				zt_game->shaders[shader_id].gl_shader = gl_shader;

				ztShader* shader = &zt_game->shaders[shader_id];
				shader->renderer = ztRenderer_OpenGL;

				_zt_shaderSetupVariables(shader);

				zt_game->shaders[shader_id].callbacks.begin_func      = ZT_FUNCTION_POINTER_TO_VAR_NULL;
				zt_game->shaders[shader_id].callbacks.begin_user_data = nullptr;
				zt_game->shaders[shader_id].callbacks.end_func        = ZT_FUNCTION_POINTER_TO_VAR_NULL;
				zt_game->shaders[shader_id].callbacks.end_user_data   = nullptr;

				return shader_id;
			}
#		endif
		} break;

		case ztRenderer_DirectX: {
#		if defined(ZT_DIRECTX)
			zt_assert(false);
#		endif
		} break;
	}

	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderMakeStandard(ztShaderStandardSettings *settings)
{
	zt_returnValOnNull(settings, ztInvalidID);

	int buffer_len = zt_kilobytes(64);
	char *buffer = zt_mallocStructArrayArena(char, buffer_len, zt->mem_arena_stack);
	if (buffer == nullptr) {
		return ztInvalidID;
	}
	buffer[0] = 0;

	zt_strCat(buffer, buffer_len,
		"struct VertexInput\n"
		"{\n"
		"	vec3  position : 0;\n"
		"	vec2  uv : 1;\n"
		"	vec3  normal : 2;\n"
		"	vec4  color : 3;\n"
		"	vec4  tangent : 4;\n"
		"	vec4  bitangent : 5;\n"
		);

	if (settings->support_bones) {
		zt_strCat(buffer, buffer_len,
			"	ivec4 bones : 6;\n"
			"	vec4  weights : 7;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"}\n"
		"\n"
		"struct PixelInput\n"
		"{\n"
		"	vec4 position : position;\n"
		"	vec3 frag_pos;\n"
		"	vec4 frag_pos_light_space;\n"
		"	vec3 normal;\n"
		"	vec2 uv;\n"
		"	vec4 color;\n"
		);

	if (settings->write_position) {
		zt_strCat(buffer, buffer_len,
			"	vec4 frag_pos_view;\n"
			);
	}
	if (settings->write_normal) {
		zt_strCat(buffer, buffer_len,
			"	vec3 normal_view;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"}\n"
		"\n"
		"struct PixelOutput\n"
		"{\n"
		"	vec4 color : color;\n"
		);

	if (settings->write_position) {
		zt_strCat(buffer, buffer_len,
			"	vec4 position;\n"
			);
	}
	if (settings->write_normal) {
		zt_strCat(buffer, buffer_len,
			"	vec4 normal;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"}\n"
		"\n"
		"struct Textures\n"
		"{\n"
		"	texture2d   diffuse_tex;\n"
		"	texture2d   specular_tex;\n"
		"	texture2d   normal_tex;\n"
		"	texture2d   height_tex;\n"
		"	texture2d   roughness_tex;\n"
		"\n"
		);

	if (settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"	textureCube irradiance_map_tex;\n"
			"	textureCube prefilter_map_tex;\n"
			"	texture2d   brdf_lut_tex;\n"
			"\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"	texture2d   directional_light_shadowmap;\n"
		);

	if (settings->max_point_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"	textureCube point_lights_shadowmap[%d];\n",
			settings->max_point_lights
			);
	}
	if (settings->max_spot_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"	textureCube spot_lights_shadowmap[%d];\n",
			settings->max_spot_lights
			);
	}

	zt_strCat(buffer, buffer_len,
		"}\n"
		"\n"
		);

	if (settings->max_point_lights > 0) {
		zt_strCat(buffer, buffer_len,
			"struct PointLight\n"
			"{\n"
			"	vec3  pos;\n"
			"	float intensity;\n"
			"	vec3  ambient_color;\n"
			"	int   shadowmap_use;\n"
			"	float far_plane;\n"
			"}\n"
			"\n"
			);
	}
	if (settings->max_spot_lights > 0) {
		zt_strCat(buffer, buffer_len,
			"struct SpotLight\n"
			"{\n"
			"	vec3  pos;\n"
			"	float intensity;\n"
			"	vec3  direction;\n"
			"	float cutoff_in;\n"
			"	float cutoff_out;\n"
			"	vec3  ambient_color;\n"
			"	int   shadowmap_use;\n"
			"	float far_plane;\n"
			"}\n"
			"\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"struct Uniforms\n"
		"{\n"
		"	mat4       model;\n"
		"	mat4       view;\n"
		"	mat4       projection;\n"
		"\n"
		"	vec3       view_pos;\n"
		"\n"
		"	mat4       light_matrix;\n"
		"	vec3       light_pos;\n"
		"	float      light_ambient;\n"
		"	float      light_intensity;\n"
		"	vec4       light_color;\n"
		"\n"
		);

	if (settings->max_point_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"	PointLight point_lights[%d];\n"
			"	int        point_lights_count;\n",
			settings->max_point_lights
			);
	}

	if (settings->max_spot_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"	SpotLight spot_lights[%d];\n"
			"	int       spot_lights_count;\n",
			settings->max_spot_lights
			);
	}

	if (settings->support_bones) {
		zt_strCatf(buffer, buffer_len,
			"	mat4      bones[%d];\n"
			"	int       bones_count;\n",
			settings->max_bones
			);
	}

	if (!settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"	float     shininess;\n"
			"	vec4      diffuse_color;\n"
			);
	}

	if (settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"}\n"
			"\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"vec3 fresnelSchlick(float cos_theta, vec3 v)\n"
			"{\n"
			"	return v + (1.0 - v) * pow(1.0 - cos_theta, 3.0);\n"
			"}\n"
			"\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"vec3 fresnelSchlickRoughness(float cos_theta, vec3 v, float roughness)\n"
			"{\n"
			"	return v + (max(vec3(1.0 - roughness), v) - v) * pow(1.0 - cos_theta, 3.0);\n"
			"}\n"
			"\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"float distributionGGX(vec3 n, vec3 h, float roughness)\n"
			"{\n"
			"	float a = roughness * roughness;\n"
			"	float a2 = a * a;\n"
			"	float n_dot_h = max(dot(n, h), 0.0);\n"
			"	float n_dot_h2 = n_dot_h * n_dot_h;\n"
			"\n"
			"	float nom = a2;\n"
			"	float denom = (n_dot_h2 * (a2 - 1.0) + 1.0);\n"
			"	denom = 3.14159265359 * denom * denom;\n"
			"\n"
			"	return nom / denom;\n"
			"}\n"
			"\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"float geometrySchlickGGX(float n_dot_v, float roughness)\n"
			"{\n"
			"	float r = (roughness + 1.0);\n"
			"	float k = (r * r) / 8.0;\n"
			"\n"
			"	float nom = n_dot_v;\n"
			"	float denom = n_dot_v * (1.0 - k) + k;\n"
			"\n"
			"	return nom / denom;\n"
			"}\n"
			"\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"float geometrySmith(vec3 n, vec3 v, vec3 l, float roughness)\n"
			"{\n"
			"	float n_dot_v = max(dot(n, v), 0.0);\n"
			"	float n_dot_l = max(dot(n, l), 0.0);\n"
			"	float ggx2 = geometrySchlickGGX(n_dot_v, roughness);\n"
			"	float ggx1 = geometrySchlickGGX(n_dot_l, roughness);\n"
			"\n"
			"	return ggx1 * ggx2;\n"
			"}\n"
			"\n"
			);
	}
	else {
		zt_strCat(buffer, buffer_len,
			"}\n"
			"\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
		"\n"
		"vec2 parallaxMapping(vec2 uv, vec3 view_dir, Textures textures)\n"
		"{\n"
		"	float height = textureSample(textures.height_tex, uv).r;\n"
		"	vec2 p = view_dir.xy * ((1.0 - height) * .0025);\n"
		"	return uv - p;\n"
		"}\n"
		"\n"
		"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
		"\n"
		"vec3 normalCalculation(PixelInput _input, Textures textures)\n"
		"{\n"
		"	vec3 tangent_normal = textureSample(textures.normal_tex, _input.uv).xyz;\n"
		"	if (tangent_normal == vec3(1)) {\n"
		"		tangent_normal = _input.normal;\n"
		"		return tangent_normal;\n"
		"	}\n"
		"	else {\n"
		"		tangent_normal = tangent_normal * 2.0 - 1.0;\n"
		"	}\n"
		"\n"
		"	vec3 Q1 = dFdx(_input.position.xyz);\n"
		"	vec3 Q2 = dFdy(_input.position.xyz);\n"
		"	vec2 st1 = dFdx(_input.uv);\n"
		"	vec2 st2 = dFdy(_input.uv);\n"
		"\n"
		"	vec3 normal = normalize(_input.normal);\n"
		"	vec3 T = normalize(Q1*st2.y - Q2*st1.y);\n"
		"	vec3 B = -normalize(cross(normal, T));\n"
		"	mat3 TBN = mat3(T, B, normal);\n"
		"\n"
		"	return normalize(TBN * tangent_normal);\n"
		"}\n"
		"\n"
		"float shadowCalculation(vec3 light_dir, vec3 normal, PixelInput _input, Textures textures)\n"
		"{\n"
		"	vec3 proj_coords = _input.frag_pos_light_space.xyz / _input.frag_pos_light_space.w;\n"
		"	proj_coords = proj_coords * 0.5 + 0.5;\n"
		"	if (proj_coords.x < 0.0 || proj_coords.x > 1.0 || proj_coords.y < 0.0 || proj_coords.y > 1.0) {\n"
		"		return 0.0;\n"
		"	}\n"
		"\n"
		"	float current_depth = proj_coords.z;\n"
		"	if (current_depth > 1.0 || current_depth < 0.0) {\n"
		"		return 0.0;\n"
		"	}\n"
		"\n"
		"	float bias = max(0.005 * (1.0 - dot(normal, light_dir)), 0.005);\n"
		"\n"
		"	float shadow = 0.0;\n"
		"	vec2 texel_size = 1.0 / textureSize(textures.directional_light_shadowmap);// * .5;\n"
		"\n"
		"	const int samples = 3;\n"
		"	for (int x = -samples; x <= samples; ++x) {\n"
		"		for (int y = -samples; y <= samples; ++y) {\n"
		"			float pcf_depth = textureSample(textures.directional_light_shadowmap, proj_coords.xy + vec2(x, y) * texel_size).r;\n"
		"			shadow += (current_depth - bias) > pcf_depth ? 1.0 : 0.0;\n"
		"		}\n"
		"	}\n"
		"	shadow /= (float(samples) * 2.0 + 1.0) * (float(samples) * 2.0 + 1.0);\n"
		"	return shadow;\n"
		"}\n"
		"\n"
		"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
		"\n"
		);

	zt_fiz(2) {
		if ((i == 0 && settings->max_point_lights > 0) || (i == 1 && settings->max_spot_lights > 0)) {
			zt_strCatf(buffer, buffer_len,
				"float shadowCalculation%sLight(%sLight light, textureCube depth_tex, vec3 normal, PixelInput _input, Textures textures)\n",
				i == 0 ? "Point" : "Spot",
				i == 0 ? "Point" : "Spot"
				);

			zt_strCat(buffer, buffer_len,
				"{\n"
				"	if (light.shadowmap_use == 0) {\n"
				"		return 0;\n"
				"	}\n"
				"\n"
				"	vec3 frag_to_light = (_input.frag_pos - light.pos) * vec3(1, -1, -1);\n"
				"	float current_depth = length(frag_to_light);\n"
				"\n"
				"	float shadow = 0;\n"
				"\n"
				"	float offset = 0.1;\n"
				"	float bias = 0.05;\n"
				"\n"
				"	int samples = 20;\n"
				"	vec3 sample_offset_dir[20] = {\n"
				"		vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),\n"
				"		vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),\n"
				"		vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0),\n"
				"		vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),\n"
				"		vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1)\n"
				"	};\n"
				"	float sample_offset_radius = 0.05;\n"
				"\n"
				"	for (int i = 0; i < samples; ++i) {\n"
				"		float closest_depth = textureSample(depth_tex, frag_to_light + sample_offset_dir[i] * sample_offset_radius).r;\n"
				"		closest_depth *= light.far_plane;\n"
				"\n"
				"		if (current_depth - bias > closest_depth) {\n"
				"			shadow += 1;\n"
				"		}\n"
				"	}\n"
				"\n"
				"	shadow /= float(samples);\n"
				"\n"
				"	return shadow;\n"
				"}\n"
				"\n"
				"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
				);
		}
	}

	if (settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			"vec3 calculateLighting(vec3 light_dir, vec3 view_dir, vec3 normal, vec3 f0, vec3 light_pos, vec3 world_pos, vec3 light_color, float light_intensity, float shadow, vec3 albedo, float metallic, float roughness, bool directional)\n"
			"{\n"
			"	vec3 H = normalize(view_dir + light_dir);\n"
			"	vec3 radiance;\n"
			"	if (directional) {\n"
			"		float distance = 1;//normalize(light_pos);\n"
			"		float attenuation = 1.0 / (distance * distance);\n"
			"		radiance = light_color * attenuation * (1 - shadow) * light_intensity;\n"
			//"		radiance = light_color * (1 - shadow) * light_intensity;\n"
			"	}\n"
			"	else {\n"
			"		float distance = length(light_pos - world_pos);\n"
			"		float attenuation = 1.0 / (distance * distance);\n"
			"		radiance = light_color * attenuation * (1 - shadow) * light_intensity;\n"
			"	}\n"
			"\n"
			"	float NDF = distributionGGX(normal, H, roughness);\n"
			"	float G   = geometrySmith(normal, view_dir, light_dir, roughness);\n"
			"	vec3  F   = fresnelSchlick(max(dot(H, view_dir), 0.0), f0);\n"
			"\n"
			"	vec3  nominator   = NDF * G * F;\n"
			"	float denominator = 4 * max(dot(normal, view_dir), 0.0) * max(dot(normal, light_dir), 0.0) + 0.001;\n"
			"	vec3  specular    = nominator / denominator;\n"
			"\n"
			"	vec3 kS = F;\n"
			"	vec3 kD = vec3(1.0) - kS;\n"
			"	kD *= 1.0 - metallic;\n"
			"\n"
			"	float NdotL = max(dot(normal, light_dir), 0.0);\n"
			"\n"
			"	return (kD * albedo / 3.14159265359 + specular) * radiance * NdotL; // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n"
			"}\n"
			"// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
			"\n"
			);
	}
	else {
		zt_strCat(buffer, buffer_len,
			"		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n"
			"		float specularCalculation(vec3 light_dir, vec3 normal, vec3 view_dir, float spec_value, float shininess)\n"
			"		{\n"
			"			vec3 halfway_dir = normalize(light_dir + view_dir);\n"
			"			return pow(max(dot(normal, halfway_dir), 0.0), 256.0) * shininess * 5.0 * spec_value;\n"
			"		}\n\n"
			"		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n"
			"		vec3 calculateLighting(vec3 light_dir, vec3 view_dir, vec3 normal, vec3 f0, vec3 light_pos, vec3 world_pos, vec3 light_color, float light_intensity, float shadow, vec3 albedo, float metallic, float roughness, bool directional)\n"
			"		{\n"
			"			vec3 light_clr = light_color * light_intensity;\n"
			"			float diff = max(dot(light_dir, normal), 0.0);\n"
			"			vec3 diffuse = diff * light_clr;\n"
			"\n"
			"			float distance;\n"
			"			if (directional) {\n"
			"				distance = 1;\n"
			"			}\n"
			"			else {\n"
			"				distance = length(light_pos - world_pos);\n"
			"			}\n"
			"\n"
			"			float attenuation = 1.0 / (distance * distance);\n"
			"			vec3 specular = specularCalculation(light_dir, normal, view_dir, metallic, roughness) * light_color;\n"
			"			return ((1.0 - shadow) * (diffuse + specular)) * albedo * attenuation;\n"
			"		}\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"program DefaultLit\n"
		"{\n"
		"	vertex_shader vertexShader(VertexInput _input : input, Uniforms uniforms : uniforms, PixelInput _output : output)\n"
		"	{\n"
		"		mat4 model_mat = uniforms.model;\n"
		);

	if (settings->support_bones) {
		zt_strCat(buffer, buffer_len,
			"		if (uniforms.bones_count > 0) {\n"
			"			mat4 bone_mat  = uniforms.bones[_input.bones.x] * _input.weights.x;\n"
			"			bone_mat      += uniforms.bones[_input.bones.y] * _input.weights.y;\n"
			"			bone_mat      += uniforms.bones[_input.bones.z] * _input.weights.z;\n"
			"			bone_mat      += uniforms.bones[_input.bones.w] * _input.weights.w;\n\n"
			"			model_mat = uniforms.model * bone_mat;\n"
			"		}\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"		_output.position             = uniforms.projection * uniforms.view * model_mat * vec4(_input.position, 1.0);\n"
		"		_output.frag_pos             = vec3(model_mat * vec4(_input.position, 1.0));\n"
		"		_output.normal               = mat3(model_mat) * _input.normal;\n"
		"		_output.uv                   = _input.uv;\n"
		"		_output.color                = _input.color;\n"
		"		_output.frag_pos_light_space = uniforms.light_matrix * vec4(_output.frag_pos, 1.0);\n"
		);

	if (settings->write_position) {
		zt_strCat(buffer, buffer_len,
			"		_output.frag_pos_view = uniforms.view * model_mat * vec4(_input.position, 1);\n"
			);
	}
	if (settings->write_normal) {
		zt_strCat(buffer, buffer_len,
			"		_output.normal_view = mat3(uniforms.view) * mat3(model_mat) * _input.normal;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"	}\n"
		"\n"
		"	// ------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
		"	// ------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
		"\n"
		"	pixel_shader pixelShader(PixelInput _input : input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n"
		"	{\n"
		"		vec3 world_pos = _input.frag_pos;\n"
		"		vec3 view_dir = normalize(uniforms.view_pos - world_pos);\n"
		);

	if (settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"\n"
			"		vec3 albedo = pow(textureSample(textures.diffuse_tex, _input.uv).rgb, vec3(2.2));\n"
			"		//vec3 albedo = textureSample(textures.diffuse_tex, _input.uv).rgb;\n"
			"		float metallic = textureSample(textures.specular_tex, _input.uv).r;\n"
			"		float roughness = textureSample(textures.roughness_tex, _input.uv).r;\n"
			"		float ao = .005;//texture(aoMap, TexCoords).r;\n"
			);
	}
	else {
		zt_strCat(buffer, buffer_len,
			"		vec2 uv = parallaxMapping(_input.uv, view_dir, textures);\n"
//			"		if (uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0) {\n"
//			"			discard();\n"
//			"		}\n"
			"\n"
			"		vec4 albedo_full = textureSample(textures.diffuse_tex, uv) * _input.color * uniforms.diffuse_color;\n"
//			"		if (albedo_full.a < .1) {\n"
//			"			discard();\n"
//			"		}\n"
			"		vec3 albedo = albedo_full.rgb;\n"
			"\n"
			"		float metallic = textureSample(textures.specular_tex, uv).r;\n"
			"		float roughness = uniforms.shininess;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"\n"
		"		vec3 normal = normalCalculation(_input, textures);\n"
		"		vec3 reflection = reflect(-view_dir, normal);\n"
		"\n"
		"		vec3 F0 = vec3(0.04);\n"
		"		F0 = lerp(F0, albedo, metallic);\n"
		"\n"
		"		vec3 Lo = vec3(0.0);\n"
		"\n"
		"		// directional light\n"
		"		if (true) {\n"
		"			vec3 light_dir = normalize(uniforms.light_pos);\n"
		"			float shadow = min(1 - uniforms.light_ambient, shadowCalculation(light_dir, normal, _input, textures));\n"
		"			//float shadow = shadowCalculation(light_dir, normal, _input, textures);\n"
		"			vec4 light_color = uniforms.light_color;\n"
		"			Lo += calculateLighting(light_dir, view_dir, normal, F0, uniforms.light_pos, vec3(0), light_color.rgb, uniforms.light_intensity, shadow, albedo, metallic, roughness, true);\n"
		"		}\n"
		"\n"
		);

	if (settings->max_point_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"		if (true) { // point lights\n"
			"			for (int i = 0; i < %d; ++i) {\n"
			"				if (i >= uniforms.point_lights_count) {\n"
			"					break;\n"
			"				}\n"
			"\n"
			"				PointLight light = uniforms.point_lights[i];\n"
			"				vec3 light_dir = normalize(light.pos - world_pos);\n"
			"				float shadow = shadowCalculationPointLight(light, textures.point_lights_shadowmap[i], normal, _input, textures);\n"
			"				Lo += calculateLighting(light_dir, view_dir, normal, F0, light.pos, world_pos, light.ambient_color, light.intensity, shadow, albedo, metallic, roughness, false);\n"
			"			}\n"
			"		}\n"
			"\n",
			settings->max_point_lights
			);
	}

	if (settings->max_spot_lights > 0) {
		zt_strCatf(buffer, buffer_len,
			"		if (true) { // spot lights\n"
			"			for (int i = 0; i < %d; ++i) {\n"
			"				if (i >= uniforms.spot_lights_count) {\n"
			"					break;\n"
			"				}\n"
			"\n"
			"				SpotLight light = uniforms.spot_lights[i];\n"
			"				vec3 light_dir = normalize(light.pos - world_pos);\n"
			"				float shadow = shadowCalculationSpotLight(light, textures.spot_lights_shadowmap[i], normal, _input, textures);\n"
			"				Lo += calculateLighting(light_dir, view_dir, normal, F0, light.pos, world_pos, light.ambient_color, light.intensity, shadow, albedo, metallic, roughness, false);\n"
			"			}\n"
			"		}\n"
			"\n",
			settings->max_spot_lights
			);
	}

	if (settings->use_pbr) {
		zt_strCat(buffer, buffer_len,
			"		// ambient lighting (we now use IBL as the ambient term)\n"
			"		vec3 F = fresnelSchlickRoughness(max(dot(normal, view_dir), 0.0), F0, roughness);\n"
			"\n"
			"		vec3 kS = F;\n"
			"		vec3 kD = 1.0 - kS;\n"
			"		kD *= 1.0 - metallic;\n"
			"\n"
			"		vec3 irradiance = textureSample(textures.irradiance_map_tex, normal).rgb;\n"
			"		vec3 diffuse = irradiance * albedo * uniforms.light_ambient;\n"
			"\n"
			"		// sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n"
			"		const float MAX_REFLECTION_LOD = 4.0;\n"
			"		vec3 prefilteredColor = textureSampleLOD(textures.prefilter_map_tex, reflection, roughness * MAX_REFLECTION_LOD).rgb;\n"
			"		vec2 brdf = textureSample(textures.brdf_lut_tex, vec2(max(dot(normal, view_dir), 0.0), roughness)).xy;\n"
			"		vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n"
			"\n"
			"		vec3 ambient = (kD * diffuse + specular) * ao;\n"
			"\n"
			"		vec3 color = ambient + Lo;\n"
			"\n"
			"		// HDR tonemapping\n"
			"		color = color / (color + vec3(1.0));\n"
			"		// gamma correct\n"
			"		color = pow(color, vec3(1.0/2.2)); \n"
			"\n"
			"\n"
			"		_output.color = vec4(color, 1.0);\n"
			);
	}
	else {
		zt_strCat(buffer, buffer_len,
			"		vec3 color = (albedo * uniforms.light_ambient) + Lo;\n"
			"		\n"
			"		_output.color = vec4(min(color.x, 1), min(color.y, 1), min(color.z, 1), 1.0);\n"
			"		_output.position = _input.frag_pos_view;\n"
			"		_output.normal = vec4(normalize(_input.normal_view), 1);\n"
			);
	}

	if (settings->write_position) {
		zt_strCat(buffer, buffer_len,
			"		_output.position = _input.frag_pos_view;\n"
			);
	}
	if (settings->write_normal) {
		zt_strCat(buffer, buffer_len,
			"		_output.normal = vec4(normalize(_input.normal_view), 1);\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"	}\n"
		"}\n"
		);

	ztShaderID result = zt_shaderMake("StandardShader", buffer, zt_strLen(buffer));

	zt_freeArena(buffer, zt->mem_arena_stack);

	return result;
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderBuildAmbientOcclusion(ztShaderAmbientOcclusionSettings *settings)
{
	zt_returnValOnNull(settings, ztInvalidID);

	int buffer_len = zt_kilobytes(64);
	char *buffer = zt_mallocStructArrayArena(char, buffer_len, zt->mem_arena_stack);
	if (buffer == nullptr) {
		return ztInvalidID;
	}
	buffer[0] = 0;

	zt_strCat(buffer, buffer_len,
		"struct VertexInput\n"
		"{\n"
		"	vec3 position : 0;\n"
		"	vec2 uv : 1;\n"
		"}\n\n"
		"struct PixelInput\n"
		"{\n"
		"	vec4 position : position;\n"
		"	vec2 uv;\n"
		"	mat4 proj;\n"
		"}\n\n"
		"struct PixelOutput\n"
		"{\n"
		"	vec4 color : color;\n"
		"}\n\n"
		"struct Textures\n"
		"{\n"
		"	texture2d position_tex;\n"
		"	texture2d normal_tex;\n"
		"	texture2d noise_tex;\n"
		"}\n\n"
		"struct Uniforms\n"
		"{\n"
		"	mat4 model;\n"
		"	mat4 view;\n"
		"	mat4 projection;\n"
		"	\n"
		"	mat4 cam_proj;\n"
		"	float radius;\n"
		"	float bias;\n"
		"	int samples;\n"
		"}\n\n\n"
		"program AmbientOcclusion\n"
		"{\n"
		"	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n"
		"	{\n"
		"		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n"
		"		_output.uv = _input.uv;\n"
		"		_output.proj = uniforms.cam_proj;\n"
		"	}\n"
		"\n"
		"	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n"
		"	{\n"
		"		vec2 noise_scale = textureSize(textures.position_tex) / vec2(4.0, 4.0);\n"
		"		\n"
		"		vec3 kernels[] = { vec3(-0.002653, -0.002754, 0.001899), vec3(-0.087793, -0.039482, 0.017967), vec3(-0.015935, 0.034456, 0.038461), vec3(0.016084, 0.012467, 0.003128), vec3(-0.036631, 0.008479, 0.050961), vec3(0.029393, -0.020169, 0.003774), vec3(-0.054996, 0.042855, 0.022173), vec3(-0.027956, -0.019687, 0.004943), vec3(0.004512, 0.016531, 0.012118), vec3(-0.013076, 0.000412, 0.015548), vec3(0.002620, 0.003538, 0.009588), vec3(0.044101, 0.023600, 0.000938), vec3(-0.042423, -0.002516, 0.031865), vec3(0.010303, -0.021516, 0.083335), vec3(-0.006624, -0.009561, 0.011636), vec3(0.098235, -0.085460, 0.046724), vec3(0.008439, 0.013164, 0.026478), vec3(0.006236, 0.072253, 0.056957), vec3(0.029851, 0.005779, 0.025764), vec3(-0.000024, -0.000100, 0.000855), vec3(0.021803, -0.036413, 0.027307), vec3(-0.022628, -0.100774, 0.077730), vec3(-0.140845, -0.064150, 0.055073), vec3(0.160229, 0.014875, 0.131890), vec3(-0.162901, 0.067310, 0.089489), vec3(0.009212, -0.012979, 0.019421), vec3(0.207777, 0.095488, 0.023471), vec3(-0.030307, 0.163340, 0.099766), vec3(0.012027, 0.081427, 0.076049), vec3(0.008256, -0.009202, 0.004746), vec3(-0.174059, -0.125532, 0.013659), vec3(-0.123190, -0.162086, 0.192199), vec3(0.079728, 0.045446, 0.083276), vec3(0.068169, 0.134876, 0.071926), vec3(0.011139, -0.011122, 0.001227), vec3(0.062146, -0.048333, 0.040802), vec3(0.318199, -0.194238, 0.005388), vec3(0.085928, -0.167529, 0.121446), vec3(0.035744, 0.264612, 0.218551), vec3(0.010980, 0.014685, 0.020474), vec3(-0.070881, 0.053770, 0.085137), vec3(0.190247, -0.205307, 0.058195), vec3(-0.128107, 0.048930, 0.050913), vec3(-0.414316, -0.126764, 0.022860), vec3(0.292767, -0.146901, 0.030233), vec3(0.011273, -0.010657, 0.008202), vec3(-0.331935, 0.039829, 0.017697), vec3(-0.152039, 0.111405, 0.150835), vec3(0.248028, -0.295074, 0.067144), vec3(-0.399653, 0.387673, 0.115775), vec3(0.095395, 0.077728, 0.078634), vec3(0.138522, 0.058387, 0.446292), vec3(-0.139391, 0.238982, 0.141845), vec3(0.291221, -0.412218, 0.372597), vec3(-0.057277, -0.063076, 0.079478), vec3(-0.468079, -0.235645, 0.473576), vec3(0.506897, -0.572697, 0.095597), vec3(-0.140104, 0.033207, 0.067720), vec3(0.002089, -0.006361, 0.002204), vec3(0.002283, 0.577194, 0.518092), vec3(-0.028116, 0.030414, 0.011354), vec3(0.325228, -0.451638, 0.287153), vec3(-0.515316, -0.485945, 0.523195), vec3(-0.004302, 0.027282, 0.024530) };\n"
		"\n"
		"		vec3 frag_pos   = textureSample(textures.position_tex, _input.uv).rgb;\n"
		"		vec3 normal     = textureSample(textures.normal_tex, _input.uv).rgb;\n"
		"		vec3 random_vec = vec3(textureSample(textures.noise_tex, _input.uv * noise_scale).xy, 0);\n"
		"\n"
		"		vec3 tangent = normalize(random_vec - normal * dot(random_vec, normal));\n"
		"		vec3 bitangent = cross(normal, tangent);\n"
		"		mat3 TBN = mat3(tangent, bitangent, normal);\n"
		"\n"
		"		float occlusion = 0;\n"
		"		for(int s = 0; s < uniforms.samples; ++s) {\n"
		"			vec3 sample = TBN * kernels[s]; // from tangent to view-space\n"
		"			sample = frag_pos + sample * uniforms.radius; \n"
		"\n"
		"			vec4 offset = vec4(sample, 1.0);\n"
		"			offset = uniforms.cam_proj * offset; // from view to clip-space\n"
		"			offset.xyz /= offset.w; // perspective divide\n"
		"			offset.xyz = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0\n"
		"\n"
		"			float sample_depth = textureSample(textures.position_tex, offset.xy).z;\n"
		"\n"
		"			if (sample_depth >= sample.z + uniforms.bias) {\n"
		"				float range_check = smoothstep(0.0, 1.0, uniforms.radius / abs(frag_pos.z - sample_depth));\n"
		"				occlusion += range_check;\n"
		"			}\n"
		"		}\n"
		"		\n"
		"		occlusion /= uniforms.samples;\n"
		"		_output.color = vec4(vec3(1 - occlusion), 1);\n"
		"	}\n"
		"}\n"
		);

	ztShaderID result = zt_shaderMake("AmbientOcclusion", buffer, zt_strLen(buffer));

	zt_freeArena(buffer, zt->mem_arena_stack);

	if (result != ztInvalidID && settings->generate_noise_tex) {
		ztRandom random;
		zt_randomInit(&random);

		settings->generated_noise_tex = zt_textureMakeRandom(&random, 4, 4);
	}

	zt_shaderSetVariableFloat(result, zt_strHash("radius" ), .5f);
	zt_shaderSetVariableFloat(result, zt_strHash("bias"   ), .025f);
	zt_shaderSetVariableInt  (result, zt_strHash("samples"), 64);

	return result;
}

// ================================================================================================================================================================================================

ztShaderID zt_shaderBuildTonemap(ztShaderTonemapSettings *settings)
{
	zt_returnValOnNull(settings, ztInvalidID);

	int buffer_len = zt_kilobytes(64);
	char *buffer = zt_mallocStructArrayArena(char, buffer_len, zt->mem_arena_stack);
	if (buffer == nullptr) {
		return ztInvalidID;
	}
	buffer[0] = 0;

	zt_strCat(buffer, buffer_len, 
		"struct VertexInput\n"
		"{\n"
		"	vec3 position : 0;\n"
		"	vec2 uv : 1;\n"
		"	vec3 normal : 2;\n"
		"	vec4 color : 3;\n"
		"}\n\n"
		"struct PixelInput\n"
		"{\n"
		"	vec4 position : position;\n"
		"	vec2 uv;\n"
		"	vec3 normal;\n"
		"	vec4 color;\n"
		"}\n\n"
		"struct PixelOutput\n"
		"{\n"
		"	vec4 color : color;\n"
		"}\n\n"
		"struct Textures\n"
		"{\n"
		"	texture2d diffuse_tex;\n"
		);

	if (settings->bloom_enabled) {
		zt_strCat(buffer, buffer_len,
			"\ttexture2d bloom_tex;\n"
			);
	}
	if (settings->ao_enabled) {
		zt_strCat(buffer, buffer_len,
			"\ttexture2d ao_tex;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"}\n\n"
		"struct Uniforms\n"
		"{\n"
		"	mat4 model;\n"
		"	mat4 view;\n"
		"	mat4 projection;\n"
		"	\n"
		"	float gamma;\n"
		"	float exposure;\n"
		);

	if (settings->ao_uniform_intensity != nullptr) {
		zt_strCatf(buffer, buffer_len,
			"	float %s;\n",
			settings->ao_uniform_intensity
			);
	}
	zt_strCat(buffer, buffer_len,
		"}\n\n\n"
		);

	zt_strCat(buffer, buffer_len,
		"program Tonemap\n"
		"{\n"
		"	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n"
		"	{\n"
		"		_output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(_input.position, 1.0);\n"
		"		_output.uv = _input.uv;\n"
		"		_output.normal = _input.normal;\n"
		"		_output.color = _input.color;\n"
		"	}\n"
		"\n"
		"	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n"
		"	{\n"
		"		vec3 color = (textureSample(textures.diffuse_tex, _input.uv) * _input.color).rgb;\n"
		);

	if (settings->ao_enabled) {
		zt_strCatf(buffer, buffer_len,
			"		vec3 ao_color = textureSample(textures.ao_tex, _input.uv).rgb;\n"
			"		color *= pow(ao_color.r, %s);\n",
			(settings->ao_uniform_intensity == nullptr ? "5" : settings->ao_uniform_intensity)
			);
	}
	if (settings->bloom_enabled) {
		zt_strCat(buffer, buffer_len,
			"		vec3 bloom_color = (textureSample(textures.bloom_tex, _input.uv) * _input.color).rgb;\n"
			"		color += bloom_color;\n"
			);
	}

	zt_strCat(buffer, buffer_len,
		"\n"
		"		vec3 mapped = vec3(1.0) - exp(-color * uniforms.exposure);\n"
		"		mapped = pow(mapped, vec3(1.0 / uniforms.gamma));\n"
		"		\n"
		"		_output.color = vec4(mapped, 1);\n"
		"	}\n"
		"}\n"
		);

	ztShaderID result = zt_shaderMake("Tonemap", buffer, zt_strLen(buffer));

	zt_freeArena(buffer, zt->mem_arena_stack);

	if (result != ztInvalidID) {
		//zt_shaderSetVariableFloat(result, zt_strHash("gamma"), 5.f * 0.0464514941f);
		//zt_shaderSetVariableFloat(result, zt_strHash("exposure"), 5.f * 0.805032253f);
		zt_shaderSetVariableFloat(result, zt_strHash("gamma"), 2.2f);
		zt_shaderSetVariableFloat(result, zt_strHash("exposure"), 1.5f);
	}

	return result;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(_zt_rendererTextureReload, ztInternal ZT_FUNC_ASSET_UPDATED(_zt_rendererTextureReload))
{
	// TODO(josh): Implement
}

// ================================================================================================================================================================================================

ztInternal void _zt_textureAdjustScreenTargets()
{
	int width = zt_game->win_game_settings[0].screen_w;
	int height = zt_game->win_game_settings[0].screen_h;

	zt_fiz(zt_game->textures_count) {
		if (zt_bitIsSet(zt_game->textures[i].flags, ztTextureFlags_RenderTargetScreen)) {
			switch (zt_game->textures[i].renderer)
			{
				case ztRenderer_OpenGL: {
#					if defined(ZT_OPENGL)
					ztgl_textureFree(zt_game->textures[i].gl_texture);
					zt_game->textures[i].gl_texture = ztgl_textureMakeRenderTarget(zt_game->win_details[0].gl_context, width, height, zt_game->textures[i].flags);
#					endif
				} break;

				case ztRenderer_DirectX: {
#					if defined(ZT_DIRECTX)
					ztdx_textureFree(zt_game->textures[i].dx_texture);
					zt_game->textures[i].dx_texture = ztdx_textureMakeRenderTarget(zt_game->win_details[0].dx_context, width, height, zt_game->textures[i].flags);
#					endif
				} break;
			}

			zt_game->textures[i].width = width;
			zt_game->textures[i].height = height;
		}
	}
}

// ================================================================================================================================================================================================

ztInternal ztTextureID _zt_textureGetNextID()
{
	zt_fiz(zt_game->textures_count) {
		if (zt_game->textures[i].renderer == ztRenderer_Invalid) {
			return i;
		}
	}

	zt_assert(zt_game->textures_count < zt_elementsOf(zt_game->textures));
	return zt_game->textures_count++;
}

// ================================================================================================================================================================================================

ztInternal ztTextureID _zt_textureMakeBase(byte *pixel_data, i32 width, i32 height, i32 depth, i32 flags, const char **error)
{
	ZT_PROFILE_RENDERING("_zt_textureMakeBase");

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	if (zt_bitIsSet(flags, ztTextureFlags_RenderTargetScreen)) {
		width = zt_game->win_game_settings[0].native_w;
		height = zt_game->win_game_settings[0].native_h;
	}

	texture->renderer = zt_currentRenderer();
	texture->width = width;
	texture->height = height;
	texture->flags = flags;
	texture->name[0] = 0;

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			if (pixel_data) {
				texture->gl_texture = ztgl_textureMakeFromPixelData(zt_game->win_details[0].gl_context, pixel_data, width, height, depth, flags);
			}
			else {
				texture->gl_texture = ztgl_textureMakeRenderTarget(zt_game->win_details[0].gl_context, width, height, flags);
			}
			if (texture->gl_texture == nullptr) {
				zt_game->textures_count -= 1;
				return ztInvalidID;
			}
			texture->width_actual = texture->gl_texture->wa;
			texture->height_actual = texture->gl_texture->ha;
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			if (pixel_data) {
				texture->dx_texture = ztdx_textureMakeFromPixelData(zt_game->win_details[0].dx_context, pixel_data, width, height, depth, flags);
			}
			else {
				texture->dx_texture = ztdx_textureMakeRenderTarget(zt_game->win_details[0].dx_context, width, height, flags);
			}
			if (texture->dx_texture == nullptr) {
				zt_game->textures_count -= 1;
				return ztInvalidID;
			}
			texture->width_actual = texture->width;
			texture->height_actual = texture->height;
#			endif
		} break;
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMake(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_textureMake");
	ztBlockProfiler bp_tex("zt_textureMake (from asset)");

	zt_returnValOnNull(asset_mgr, ztInvalidID);
	if(asset_id == ztInvalidID) {
		return ztInvalidID;
	}
	zt_assertReturnValOnFail(asset_id >= 0 && asset_id < asset_mgr->asset_count, ztInvalidID);

	zt_logInfo("loading texture asset: %s (%d)", asset_mgr->asset_name[asset_id], asset_id);

	zt_fize(zt_game->textures) {
		if (zt_game->textures[i].load_type == ztTextureLoadType_Asset && zt_game->textures[i].asset_id == asset_id) {
			zt_logDebug("returning preloaded texture asset: %s (asset id: %d; texture id: %d)", asset_mgr->asset_name[asset_id], asset_id, i);
			return i;
		}
	}

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImagePNG && asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImageJPG && asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImageHDR) {
		return ztInvalidID;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return ztInvalidID;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return ztInvalidID;
	}

	const char *error = nullptr;
	byte *pixel_data = nullptr;
	int width, height, depth;
	ztTextureID texture_id = ztInvalidID;

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	if (asset_mgr->asset_type[asset_id] == ztAssetManagerType_ImageHDR) {
		ztBlockProfiler bp_tex("stbi_loadf_from_memory");
		flags |= ztTextureFlags_HDR;
		stbi_set_flip_vertically_on_load(true);
		pixel_data = (byte*)stbi_loadf_from_memory((const stbi_uc*)data, size, &width, &height, &depth, 0);
	}
	else {
		ztBlockProfiler bp_tex("stbi_load_from_memory");
		stbi_set_flip_vertically_on_load(true);
		pixel_data = stbi_load_from_memory((const stbi_uc*)data, size, &width, &height, &depth, 4);
		depth = 4;
	}

	if (pixel_data == nullptr) {
		error = stbi_failure_reason();
		goto on_error;
	}

	texture_id = _zt_textureMakeBase(pixel_data, width, height, depth, flags, &error);

	if (texture_id != ztInvalidID) {
		ztTexture *texture = &zt_game->textures[texture_id];
		texture->load_type = ztTextureLoadType_Asset;
		texture->asset_mgr = asset_mgr;
		texture->asset_id = asset_id;
		zt_strCpy(texture->name, zt_elementsOf(texture->name), asset_mgr->asset_name[asset_id]);

		zt_assetAddReloadCallback(asset_mgr, asset_id, ZT_FUNCTION_POINTER_TO_VAR(_zt_rendererTextureReload), (void*)texture_id);
	}

	zt_freeArena(data, asset_mgr->arena);
	stbi_image_free(pixel_data);
	return texture_id;

on_error:
	zt_logCritical("Unable to load texture (%s). %s.", asset_mgr->asset_name[asset_id], error);
	zt_freeArena(data, asset_mgr->arena);
	if (pixel_data) {
		stbi_image_free(pixel_data);
	}
	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMake(byte *pixel_data, i32 width, i32 height, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_textureMake");
	ztBlockProfiler bp_tex("zt_textureMake (from dimensions)");

	zt_returnValOnNull(pixel_data, ztInvalidID);

	int depth = 4;
	const char *error = nullptr;
	ztTextureID texture_id = _zt_textureMakeBase(pixel_data, width, height, depth, flags, &error);
	if (texture_id != ztInvalidID) {
		ztTexture *texture = &zt_game->textures[texture_id];
		texture->load_type = ztTextureLoadType_Data;
		
		// we copy this so we can reload if necessary
		texture->arena = zt_memGetGlobalArena();
		texture->data_len = width * height * depth;
		texture->data = zt_mallocStructArray(byte, zt_game->textures[texture_id].data_len);
		zt_memCpy(texture->data, texture->data_len, pixel_data, texture->data_len);
	}
	else {
		zt_logCritical("Unable to load texture (%d x %d). %s.", width, height, error);
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeFromFile(const char *file, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_textureMakeFromFile");
	ztBlockProfiler bp_tex("zt_textureMake (from file)");

	i32 size = 0;
	void *data = zt_readEntireFile(file, &size);
	if (data == nullptr || size == 0) {
		return ztInvalidID;
	}

	ztTextureID tex_id = zt_textureMakeFromFileData(data, size, flags);

	if (tex_id != ztInvalidID) {
		const char *file_name = file;
		if (zt_striStartsWith(file_name, zt_game->game_details.data_path)) {
			file_name += zt_strLen(zt_game->game_details.data_path);
		}

		zt_strCpy(zt_game->textures[tex_id].file_name, zt_elementsOf(zt_game->textures[tex_id].file_name), file_name);
		zt_strCpy(zt_game->textures[tex_id].name, zt_elementsOf(zt_game->textures[tex_id].name), file_name);
	}

	zt_free(data);

	if (tex_id == ztInvalidID) {
		zt_logCritical("Unable to load texture (%s)", file);
	}

	return tex_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeFromFileData(void *data, i32 size, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_textureMakeFromFileData");
	ztBlockProfiler bp_tex("zt_textureMake (from file data)");

	const char *error = nullptr;

	int width, height, depth;
	stbi_set_flip_vertically_on_load(true);
	byte *pixel_data = stbi_load_from_memory((const stbi_uc*)data, size, &width, &height, &depth, 4);
	ztTextureID texture_id = ztInvalidID;

	if (pixel_data == nullptr) {
		error = stbi_failure_reason();
		goto on_error;
	}

	depth = 4; // we tell stb to use 4
	texture_id = _zt_textureMakeBase(pixel_data, width, height, depth, flags, &error);
	if (texture_id != ztInvalidID) {
		ztTexture *texture = &zt_game->textures[texture_id];
		texture->load_type = ztTextureLoadType_Data;

		// we copy this so we can reload if necessary
		//texture->arena = zt_memGetGlobalArena();
		//texture->data_len = width * height * depth;
		//texture->data = zt_mallocStructArray(byte, texture->data_len);
		//texture->file_name[0] = 0;
		//zt_memCpy(texture->data, texture->data_len, pixel_data, texture->data_len);
	}

	stbi_image_free(pixel_data);
	return texture_id;

on_error:
	zt_logCritical("Unable to load texture. %s.", error);
	if (pixel_data) {
		stbi_image_free(pixel_data);
	}
	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeFromPixelData(void *data, i32 width, i32 height, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_textureMakeFromPixelData");
	const char *error = nullptr;
	ztTextureID texture_id = _zt_textureMakeBase((byte*)data, width, height, 4, flags, &error);
	if (texture_id != ztInvalidID) {
		ztTexture *texture = &zt_game->textures[texture_id];
		texture->load_type = ztTextureLoadType_Data;

		// we copy this so we can reload if necessary
		//texture->arena = zt_memGetGlobalArena();
		//texture->data_len = width * height * 4;
		//texture->data = zt_mallocStructArray(byte, zt_game->textures[texture_id].data_len);
		//zt_memCpy(texture->data, texture->data_len, data, texture->data_len);
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeRenderTarget(i32 width, i32 height, i32 flags, r32 scale)
{
	ZT_PROFILE_RENDERING("zt_textureMakeRenderTarget");
	ztBlockProfiler bp_tex("zt_textureMakeRenderTarget");

	const char *error = nullptr;
	ztTextureID texture_id = _zt_textureMakeBase(nullptr, width, height, 4, flags, &error);
	if (texture_id != ztInvalidID) {
		zt_game->textures[texture_id].load_type = ztTextureLoadType_RenderTarget;
		zt_game->textures[texture_id].render_texture_scale = scale;
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeCubeMap(ztAssetManager *asset_mgr, const char *asset_format)
{
	ZT_PROFILE_RENDERING("zt_textureMakeCubeMap");
	ztAssetID asset_ids[ztTextureCubeMapFiles_MAX];

	char asset_name[1024];

	const char *names[ztTextureCubeMapFiles_MAX] = { "right", "left", "top", "bottom", "back", "front" };

	zt_fiz(ztTextureCubeMapFiles_MAX) {
		zt_strPrintf(asset_name, zt_elementsOf(asset_name), asset_format, names[i]);
		asset_ids[i] = zt_assetLoad(asset_mgr, asset_name);

		if(asset_ids[i] == ztInvalidID) {
			return ztInvalidID;
		}
	}

	return zt_textureMakeCubeMap(asset_mgr, asset_ids);
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeCubeMap(ztAssetManager *asset_mgr, ztAssetID files[ztTextureCubeMapFiles_MAX])
{
	ZT_PROFILE_RENDERING("zt_textureMakeCubeMap");
	ztBlockProfiler bp_tex("zt_textureMakeCubeMap");

	zt_returnValOnNull(asset_mgr, ztInvalidID);

	byte *tex_data[ztTextureCubeMapFiles_MAX];
	int tex_size[ztTextureCubeMapFiles_MAX];

	zt_fiz(ztTextureCubeMapFiles_MAX) {
		ztAssetID asset_id = files[i];
		if(asset_id == ztInvalidID) {
			return ztInvalidID;
		}
		zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);
		if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImagePNG && asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImageJPG) {
			return ztInvalidID;
		}

		tex_size[i] = zt_assetSize(asset_mgr, asset_id);
		if (tex_size[i] <= 0) {
			return ztInvalidID;
		}

		tex_data[i] = zt_mallocStructArrayArena(byte, tex_size[i], asset_mgr->arena);
		if (!tex_data[i]) {
			return ztInvalidID;
		}

		if (!zt_assetLoadData(asset_mgr, asset_id, tex_data[i], tex_size[i])) {
			zt_logCritical("Unable to load image asset: %s", asset_mgr->asset_name[asset_id]);
			zt_fjzr(i) zt_freeArena(tex_data[j], asset_mgr->arena);
			return ztInvalidID;
		}
	}

	int width, height, depth;
	byte *pixel_data[ztTextureGLCubeMapFiles_MAX];
	zt_fiz(ztTextureGLCubeMapFiles_MAX) {
		stbi_set_flip_vertically_on_load(true);
		pixel_data[i] = stbi_load_from_memory((const stbi_uc*)tex_data[i], tex_size[i], &width, &height, &depth, 4);
	}

	ztTextureID texture_id = zt_textureMakeCubeMapFromPixelData(pixel_data, width, height, depth);

	zt_fiz(ztTextureCubeMapFiles_MAX) {
		stbi_image_free(pixel_data[i]);
		zt_freeArena(tex_data[i], asset_mgr->arena);
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeCubeMapFromPixelData(byte *pixel_data[ztTextureCubeMapFiles_MAX], i32 width, i32 height, i32 depth)
{
	zt_returnValOnNull(pixel_data, ztInvalidID);

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();
	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakeCubeMapFromPixelData(zt_game->win_details[0].gl_context, pixel_data, width, height, depth);
			if (texture->gl_texture == nullptr) {
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			texture->dx_texture = ztdx_textureMakeCubeMapFromPixelData(zt_game->win_details[0].dx_context, pixel_data, width, height, depth);
			if (texture->dx_texture == nullptr) {
				return ztInvalidID;
			}
#			endif
		} break;
	}

	texture->width  = width;
	texture->height = height;
	texture->flags  = ztTextureFlags_CubeMap;

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeCubeMapFromHDR(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 w, i32 h)
{
	w = zt_max(w, 512);
	h = zt_max(h, 512);

	ztTextureID tex = zt_textureMake(asset_mgr, asset_id);
	if (tex == ztInvalidID) {
		return ztInvalidID;
	}

	ztTexture *texture_hdr = &zt_game->textures[tex];
	if (!zt_bitIsSet(texture_hdr->flags, ztTextureFlags_HDR)) {
		zt_textureFree(tex);
		return ztInvalidID;
	}

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakeCubeMapFromHDR(zt_game->win_details[0].gl_context, texture_hdr->gl_texture, w, h);
			if (texture->gl_texture == nullptr) {
				texture->renderer = ztRenderer_Invalid;
				zt_textureFree(tex);
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			zt_assert(false);
			return ztInvalidID;
#			endif
		} break;
	}

	zt_textureFree(tex);

	texture->width  = w;
	texture->height = h;
	texture->flags  = ztTextureFlags_CubeMap;

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeCubeMapForDepth(i32 dimension)
{
	dimension = zt_nextPow2(dimension);

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakeCubeMapForDepth(zt_game->win_details[0].gl_context, dimension);
			if (texture->gl_texture == nullptr) {
				texture->renderer = ztRenderer_Invalid;
				zt_textureFree(texture_id);
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			zt_assert(false);
			return ztInvalidID;
#			endif
		} break;
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeIrradianceCubeMapFromCubeMap(ztTextureID cube_map_texture_id)
{
	zt_assertReturnValOnFail(cube_map_texture_id != ztInvalidID, ztInvalidID);
	ztTexture *cube_map_texture = &zt_game->textures[cube_map_texture_id];
	if (cube_map_texture == nullptr) {
		return ztInvalidID;
	}

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakeIrradianceCubeMapFromCubeMap(zt_game->win_details[0].gl_context, cube_map_texture->gl_texture);
			if (texture->gl_texture == nullptr) {
				texture->renderer = ztRenderer_Invalid;
				zt_textureFree(texture_id);
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			zt_assert(false);
			return ztInvalidID;
#			endif
		} break;
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakePrefilterCubeMapFromCubeMap(ztTextureID cube_map_texture_id)
{
	zt_assertReturnValOnFail(cube_map_texture_id != ztInvalidID, ztInvalidID);
	ztTexture *cube_map_texture = &zt_game->textures[cube_map_texture_id];
	if (cube_map_texture == nullptr) {
		return ztInvalidID;
	}

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakePrefilterCubeMapFromCubeMap(zt_game->win_details[0].gl_context, cube_map_texture->gl_texture);
			if (texture->gl_texture == nullptr) {
				texture->renderer = ztRenderer_Invalid;
				zt_textureFree(texture_id);
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			zt_assert(false);
			return ztInvalidID;
#			endif
		} break;
	}

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeBidirectionalReflectanceDistributionFunctionLUT(i32 w, i32 h)
{
	const char *shader_src = "// shader-brdf\n\nstruct VertexInput\n{\n	vec3 position : 0;\n	vec2 uv : 1;\n}\n\nstruct PixelInput\n{\n	vec4 position : position;\n	vec2 uv;\n}\n\nstruct PixelOutput\n{\n	vec4 color : color;\n}\n\nstruct Textures\n{\n	textureCube spherical_map;\n}\n\nstruct Uniforms\n{\n}\n\nfloat radicalInverseVdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley(uint i, uint N)\n{\n	return vec2(float(i)/float(N), radicalInverseVdC(i));\n}\n\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n	float a = roughness*roughness;\n	\n	float phi = 2.0 * 3.14159265359 * Xi.x;\n	float cos_theta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n	float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n	\n	// from spherical coordinates to cartesian coordinates - halfway vector\n	vec3 H;\n	H.x = cos(phi) * sin_theta;\n	H.y = sin(phi) * sin_theta;\n	H.z = cos_theta;\n	\n	// from tangent-space H vector to world-space sample vector\n	vec3 up;\n	if (abs(N.z) < 0.999) {\n		up = vec3(0.0, 0.0, 1.0);\n	} else up = vec3(1.0, 0.0, 0.0);\n	\n	vec3 tangent   = normalize(cross(up, N));\n	vec3 bitangent = cross(N, tangent);\n	\n	vec3 sample_vec = tangent * H.x + bitangent * H.y + N * H.z;\n	return normalize(sample_vec);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = geometrySchlickGGX(NdotV, roughness);\n    float ggx1 = geometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec2 integrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0; \n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    \n    uint SAMPLE_COUNT = 1024u;\n    for (uint i = 0u; i < SAMPLE_COUNT; ++i) {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = hammersley(i, SAMPLE_COUNT);\n        vec3 H = importanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if (NdotL > 0.0) {\n            float G = geometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nprogram DefaultUnlit\n{\n	vertex_shader vertexShader(VertexInput _input :input, Uniforms uniforms : uniforms, PixelInput _output : output)\n	{\n		_output.position = vec4(_input.position, 1);\n		_output.uv = _input.uv;\n	}\n\n	pixel_shader pixelShader(PixelInput _input :input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput _output : output)\n	{\n		vec2 uv = _input.uv;\n		vec2 integratedBRDF = integrateBRDF(uv.x, uv.y);\n		_output.color = vec4(integratedBRDF, 0, 1);\n	}\n}";
	ztShaderID shader = zt_shaderMake("shader-brdf", shader_src, zt_strLen(shader_src));
	if (shader == ztInvalidID) {
		return ztInvalidID;
	}

	ztTextureID render_tex = zt_textureMakeRenderTarget(w, h);
	if (render_tex == ztInvalidID) {
		zt_shaderFree(shader);
		return ztInvalidID;
	}

	ztVertexDefault vertices[6];
	vertices[0].position = zt_vec3(-1, 1, 0);
	vertices[0].uv = zt_vec2(0, 1);
	vertices[1].position = zt_vec3(-1, -1, 0);
	vertices[1].uv = zt_vec2(0, 0);
	vertices[2].position = zt_vec3(1, -1, 0);
	vertices[2].uv = zt_vec2(1, 0);

	vertices[3].position = zt_vec3(-1, 1, 0);
	vertices[3].uv = zt_vec2(0, 1);
	vertices[4].position = zt_vec3(1, -1, 0);
	vertices[4].uv = zt_vec2(1, 0);
	vertices[5].position = zt_vec3(1, 1, 0);
	vertices[5].uv = zt_vec2(1, 1);

	ztVertexArrayID va = zt_vertexArrayMakeDefault(vertices, 6);
	if(va == ztInvalidID) {
		zt_textureFree(render_tex);
		zt_shaderFree(shader);
		return ztInvalidID;
	}

	zt_textureRenderTargetPrepare(render_tex, true);

	zt_rendererClear(ztColor_Green);
	zt_shaderBegin(shader);
	zt_vertexArrayDraw(va);
	zt_shaderEnd(shader);

	zt_textureRenderTargetCommit(render_tex);

	zt_vertexArrayFree(va);
	zt_shaderFree(shader);
	return render_tex;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeRandom(ztRandom *random, i32 w, i32 h)
{
	ztVec3 *pixels = zt_mallocStructArray(ztVec3, w * h);

	zt_fiz(w * h) {
		pixels[i] = zt_vec3(zt_randomVal(random), zt_randomVal(random), zt_randomVal(random));
	}

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();
	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureMakeFromPixelData(zt_game->win_details[0].gl_context, (byte*)pixels, w, h, 3, ztTextureFlags_Repeat | ztTextureFlags_HDR | ztTextureGLFlags_PixelPerfect);
			if (texture->gl_texture == nullptr) {
				zt_free(pixels);
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			texture->dx_texture = ztdx_textureMapFromPixelData(zt_game->win_details[0].dx_context, (byte*)pixels, w, h, 3, ztTextureFlags_Repeat | ztTextureFlags_HDR);
			if (texture->dx_texture == nullptr) {
				zt_free(pixels);
				return ztInvalidID;
			}
#			endif
		} break;
	}

	zt_free(pixels);

	texture->width  = w;
	texture->height = h;
	texture->flags = ztTextureFlags_Repeat | ztTextureFlags_HDR;

	return texture_id;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureMakeColorLUT()
{
	i32 lut_w = 32 * 32;
	i32 lut_h = 32;

	byte *lut_texture = zt_mallocStructArrayArena(byte, lut_w * lut_h * 4, zt_memGetTempArena());

	ztColor corners_beg[] = { zt_color(0, 0, 0, 1), zt_color(1, 0, 0, 1), zt_color(0, 1, 0, 1), zt_color(1, 1, 0, 1) };
	ztColor corners_end[] = { zt_color(0, 0, 1, 1), zt_color(1, 0, 1, 1), zt_color(0, 1, 1, 1), zt_color(1, 1, 1, 1) };

	zt_fvz(chunk, 32) {
		r32 pct = chunk / 31.f;

		ztColor corners[] = { ztVec4::lerp(corners_beg[0], corners_end[0], pct), ztVec4::lerp(corners_beg[1], corners_end[1], pct), ztVec4::lerp(corners_beg[2], corners_end[2], pct), ztVec4::lerp(corners_beg[3], corners_end[3], pct) };

		zt_fyz(32) {
			r32 y_pct = y / 31.f;
			ztColor beg = ztVec4::lerp(corners[0], corners[2], y_pct);
			ztColor end = ztVec4::lerp(corners[1], corners[3], y_pct);

			zt_fxz(32) {
				r32 x_pct = x / 31.f;
				ztColor color = ztVec4::lerp(beg, end, x_pct);

				i32 b_idx = ((y * 32 * 32) + (chunk * 32 + x)) * 4;

				lut_texture[b_idx++] = zt_convertToi32Floor(color.r * 255);
				lut_texture[b_idx++] = zt_convertToi32Floor(color.g * 255);
				lut_texture[b_idx++] = zt_convertToi32Floor(color.b * 255);
				lut_texture[b_idx] = 255;
			}
		}
	}

	ztTextureID texture = zt_textureMakeFromPixelData(lut_texture, 32 * 32, 32, ztTextureFlags_PixelPerfect | ztTextureFlags_FlipOnLoad);

	zt_freeArena(lut_texture, zt_memGetTempArena());

	return texture;
}

// ================================================================================================================================================================================================

byte *zt_textureLoadPixelData(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 *width, i32 *height, i32* depth, bool should_flip)
{
	zt_returnValOnNull(asset_mgr, nullptr);
	zt_returnValOnNull(width, nullptr);
	zt_returnValOnNull(height, nullptr);
	zt_returnValOnNull(depth, nullptr);
	zt_assertReturnValOnFail(asset_id >= 0 && asset_id < asset_mgr->asset_count, nullptr);

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImagePNG && asset_mgr->asset_type[asset_id] != ztAssetManagerType_ImageJPG) {
		return nullptr;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return nullptr;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return nullptr;
	}

	const char *error = nullptr;
	byte *pixel_data = nullptr;

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	*width = *height = *depth = 0;

	{
		ztBlockProfiler bp_tex("stbi_load_from_memory");
		stbi_set_flip_vertically_on_load(should_flip);
		pixel_data = stbi_load_from_memory((const stbi_uc*)data, size, width, height, depth, 4);
	}

	if (pixel_data == nullptr) {
		error = stbi_failure_reason();
		goto on_error;
	}

	zt_freeArena(data, asset_mgr->arena);
	return pixel_data;

on_error:
	zt_logCritical("Unable to load texture pixel data (%s). %s.", asset_mgr->asset_name[asset_id], error);
	zt_freeArena(data, asset_mgr->arena);
	if (pixel_data) {
		stbi_image_free(pixel_data);
	}
	return nullptr;
}

// ================================================================================================================================================================================================

byte *zt_textureLoadPixelData(byte *data, i32 data_size, i32 *width, i32 *height, i32* depth, bool should_flip)
{
	zt_returnValOnNull(width, nullptr);
	zt_returnValOnNull(height, nullptr);
	zt_returnValOnNull(depth, nullptr);

	const char *error = nullptr;

	byte *pixel_data = nullptr;

	*width = *height = *depth = 0;

	{
		ztBlockProfiler bp_tex("stbi_load_from_memory");
		stbi_set_flip_vertically_on_load(should_flip);
		pixel_data = stbi_load_from_memory((const stbi_uc*)data, data_size, width, height, depth, 4);
	}

	if (pixel_data == nullptr) {
		error = stbi_failure_reason();
		goto on_error;
	}

	return pixel_data;

on_error:
	zt_logCritical("Unable to load texture pixel data. %s.", error);
	if (pixel_data) {
		stbi_image_free(pixel_data);
	}
	return nullptr;
}

// ================================================================================================================================================================================================

void zt_textureFreePixelData(byte *pixel_data)
{
	zt_returnOnNull(pixel_data);
	stbi_image_free(pixel_data);
}

// ================================================================================================================================================================================================

void zt_textureFree(ztTextureID texture_id)
{
	ZT_PROFILE_RENDERING("zt_textureFree");
	if (texture_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(texture_id >= 0 && texture_id < zt_game->textures_count);

	if (zt_game->textures[texture_id].renderer == ztRenderer_Invalid) {
		return;
	}

	if (zt_game->textures[texture_id].renderer == ztRenderer_OpenGL) {
#		if defined(ZT_OPENGL)
		ztgl_textureFree(zt_game->textures[texture_id].gl_texture);
		zt_game->textures[texture_id].gl_texture = nullptr;
#		endif // ZT_OPENGL
	}
	else if (zt_game->textures[texture_id].renderer == ztRenderer_DirectX) {
#		if defined(ZT_DIRECTX)
		ztdx_textureFree(zt_game->textures[texture_id].dx_texture);
		zt_game->textures[texture_id].dx_texture = nullptr;
#		endif // ZT_DIRECTX
	}

	if (zt_game->textures[texture_id].load_type == ztTextureLoadType_Data) {
		zt_freeArena(zt_game->textures[texture_id].data, zt_game->textures[texture_id].arena);
	}
	else {
		zt_game->textures[texture_id].asset_id = ztInvalidID;
	}
	zt_memSet(&zt_game->textures[texture_id], sizeof(ztTexture), 0);
}

// ================================================================================================================================================================================================

void zt_textureSetName(ztTextureID texture_id, const char *name)
{
	ZT_PROFILE_RENDERING("zt_textureFree");
	if (texture_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(texture_id >= 0 && texture_id < zt_game->textures_count);

	if (zt_game->textures[texture_id].renderer == ztRenderer_Invalid) {
		return;
	}

	zt_strCpy(zt_game->textures[texture_id].name, zt_elementsOf(zt_game->textures[texture_id].name), name);
}

// ================================================================================================================================================================================================

void zt_textureRenderTargetPrepare(ztTextureID texture_id, bool clear)
{
	ZT_PROFILE_RENDERING("zt_textureRenderTargetPrepare");
	zt_assert(zt_game->textures_active_render_target == false); // cannot render to a render target if we're already doing that

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_textureRenderTargetPrepare(zt_game->textures[texture_id].gl_texture, clear));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_textureRenderTargetPrepare(zt_game->win_details[0].dx_context, zt_game->textures[texture_id].dx_texture));
		} break;
	}

	zt_game->textures_active_render_target = true;
}

// ================================================================================================================================================================================================

void zt_textureRenderTargetCommit(ztTextureID texture_id)
{
	ZT_PROFILE_RENDERING("zt_textureRenderTargetCommit");
	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_textureRenderTargetCommit(zt_game->textures[texture_id].gl_texture, zt_game->win_details[0].gl_context));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_textureRenderTargetCommit(zt_game->win_details[0].dx_context, zt_game->textures[texture_id].dx_texture));
		} break;
	}

	zt_game->textures_active_render_target = false;
}

// ================================================================================================================================================================================================

ztTextureID zt_textureRenderTargetAddAttachment(ztTextureID render_texture_id, ztTextureColorFormat_Enum color_format)
{
	ZT_PROFILE_RENDERING("zt_textureRenderTargetAddAttachment");
	zt_assertReturnValOnFail(render_texture_id > 0 && render_texture_id < zt_game->textures_count, ztInvalidID);

	zt_assert(!zt_bitIsSet(zt_game->textures[render_texture_id].flags, ztTextureFlags_RenderTargetScreen)); // the attachments will be lost when the render target is recreated

	ztTextureID texture_id = _zt_textureGetNextID();
	ztTexture *texture = &zt_game->textures[texture_id];

	texture->renderer = zt_currentRenderer();
	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			texture->gl_texture = ztgl_textureRenderTargetAddAttachment(zt_game->textures[render_texture_id].gl_texture, (ztTextureGLColorFormat_Enum)color_format);
			if (texture->gl_texture == nullptr) {
				texture->renderer = ztRenderer_Invalid;
				return ztInvalidID;
			}
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			texture->renderer = ztRenderer_Invalid;
			zt_assertReturnValOnFail(false, ztInvalidID);
#			endif
		} break;
	}

	texture->width  = zt_game->textures[render_texture_id].width;
	texture->height = zt_game->textures[render_texture_id].height;
	texture->flags  = 0;

	return texture_id;
}

// ================================================================================================================================================================================================

void zt_textureRenderTargetAttachmentEnable(ztTextureID texture_id, int attachment_idx, bool enable)
{
	ZT_PROFILE_RENDERING("zt_textureRenderTargetAttachmentEnable");
	zt_assertReturnOnFail(texture_id > 0 && texture_id < zt_game->textures_count);

	ztTexture *texture = &zt_game->textures[texture_id];

	switch (texture->renderer)
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztgl_textureRenderTargetAttachmentEnable(texture->gl_texture, attachment_idx, enable);
#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			zt_assertReturnOnFail(false);
#			endif
		} break;
	}
}

// ================================================================================================================================================================================================

ztVec2i zt_textureGetSize(ztTextureID texture_id)
{
	ZT_PROFILE_RENDERING("zt_textureGetSize");
	zt_assertReturnValOnFail(texture_id >= 0 && texture_id < zt_game->textures_count, zt_vec2i(0,0));
	return zt_vec2i(zt_game->textures[texture_id].width, zt_game->textures[texture_id].height);
}

// ================================================================================================================================================================================================

r32 zt_textureGetRenderTargetScale(ztTextureID texture_id)
{
	ZT_PROFILE_RENDERING("zt_textureGetSize");
	zt_assertReturnValOnFail(texture_id >= 0 && texture_id < zt_game->textures_count, 1);
	return zt_game->textures[texture_id].render_texture_scale;
}

// ================================================================================================================================================================================================

void zt_textureGetPixels(ztTextureID texture_id, byte *pixels)
{
	ZT_PROFILE_RENDERING("zt_textureGetPixels");
	zt_assertReturnOnFail(texture_id >= 0 && texture_id < zt_game->textures_count);

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_textureGetPixels(zt_game->textures[texture_id].gl_texture, zt_game->win_details[0].gl_context, pixels));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(zt_assert(false));
		} break;
	}
}

// ================================================================================================================================================================================================

bool zt_textureIsRenderTarget(ztTextureID texture_id)
{
	ZT_PROFILE_RENDERING("zt_textureIsRenderTarget");
	zt_assertReturnValOnFail(texture_id >= 0 && texture_id < zt_game->textures_count, false);

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(return zt_game->textures[texture_id].gl_texture == nullptr ? false : ztgl_textureIsRenderTarget(zt_game->textures[texture_id].gl_texture));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(return zt_game->textures[texture_id].dx_texture == nullptr ? false : ztdx_textureIsRenderTarget(zt_game->textures[texture_id].dx_texture));
		} break;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInline void zt_alignToPixel(r32 *val, r32 ppu)
{
	ZT_PROFILE_RENDERING("zt_alignToPixel");
#	if 1
	r32 abval = zt_abs(*val *ppu);
	r32 rem = abval - zt_convertToi32Floor(abval);
	//	r32 rem = zt_abs(*val *ppu) - zt_convertToi32Floor(zt_abs(*val *ppu));
	//if (rem >= .375f && rem <= .625f) {
	if (rem >= .25f && rem < .75f) {
		if (*val >= 0) {
			*val = zt_convertToi32Floor((*val * ppu)) / ppu;
		}
		else {
			*val = zt_convertToi32Ceil((*val * ppu)) / ppu;
		}
	}
#	else
	r32 abval = zt_abs(*val * ppu);
	r32 rem = abval - zt_convertToi32Floor(abval);

	r32 nval = zt_convertToi32Floor(((*val) * ppu)) / ppu;
	*val = nval;
#	endif
}

// ================================================================================================================================================================================================

ztInline void zt_alignToPixel(r32 *val, r32 ppu, r32 *offset)
{
	ZT_PROFILE_RENDERING("zt_alignToPixel");
#	if 1
	r32 abval = zt_abs(*val *ppu);
	r32 rem = abval - zt_convertToi32Floor(abval);
	//	r32 rem = zt_abs(*val *ppu) - zt_convertToi32Floor(zt_abs(*val *ppu));
	//if (rem >= .375f && rem <= .625f) {
	if (rem >= .25f && rem < .75f) {
		if (*val >= 0) {
			*val = zt_convertToi32Floor((*val * ppu)) / ppu;
			if (offset) *offset += rem / ppu;
		}
		else {
			*val = zt_convertToi32Ceil((*val * ppu)) / ppu;
			if (offset) *offset += (1.f - rem) / ppu;
		}
	}
#	else
	r32 abval = zt_abs(*val * ppu);
	r32 rem = abval - zt_convertToi32Floor(abval);

	r32 nval = zt_convertToi32Floor(((*val) * ppu)) / ppu;
	if (offset) *offset = rem / ppu;
	*val = nval;
#	endif
}

// ================================================================================================================================================================================================

ztInline void zt_alignToPixel(ztVec2 *val, r32 ppu)
{
	zt_alignToPixel(&val->x, ppu);
	zt_alignToPixel(&val->y, ppu);
}

// ================================================================================================================================================================================================

ztInline void zt_alignToPixel(ztVec3 *val, r32 ppu)
{
	zt_alignToPixel(&val->x, ppu);
	zt_alignToPixel(&val->y, ppu);
	zt_alignToPixel(&val->z, ppu);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_cameraMakeOrtho(ztCamera *camera, i32 width, i32 height, i32 native_w, i32 native_h, r32 near_z, r32 far_z, const ztVec3 &position)
{
	ZT_PROFILE_RENDERING("zt_cameraMakeOrtho");
	zt_returnOnNull(camera);

	camera->type = ztCameraType_Orthographic;
	camera->width = width;
	camera->height = height;
	camera->native_w = native_w;
	camera->native_h = native_h;
	camera->zoom = 1;
	camera->near_z = near_z;
	camera->far_z = far_z;
	camera->position = position;

	r32 aspect_w = native_w > native_h ? native_w / (r32)native_h : 1.f;
	r32 aspect_h = native_w > native_h ? 1.f : native_h / (r32)native_w;

	r32 scale = (zt_min(native_w, native_h) / (r32)zt_game->win_game_settings[0].pixels_per_unit) / 2;
	aspect_w *= scale;
	aspect_h *= scale;

	camera->mat_proj = ztMat4::makeOrthoProjection(-aspect_w, aspect_w, aspect_h, -aspect_h, near_z, far_z);
	camera->mat_view = ztMat4::identity;
}

// ================================================================================================================================================================================================

void zt_cameraMakePersp(ztCamera *camera, i32 width, i32 height, r32 fov, r32 near_z, r32 far_z, const ztVec3 &position, const ztQuat& rotation)
{
	ZT_PROFILE_RENDERING("zt_cameraMakePersp");
	zt_returnOnNull(camera);

	camera->width = width;
	camera->height = height;
	camera->type = ztCameraType_Perspective;
	camera->fov = fov;
	camera->near_z = near_z;
	camera->far_z = far_z;
	camera->position = position;
	camera->rotation = rotation;
	camera->direction = ztVec3::zero;

	camera->mat_proj = ztMat4::makePerspectiveProjection(fov, (r32)width, (r32)height, near_z, far_z);
}

// ================================================================================================================================================================================================

void zt_cameraRecalcMatrices(ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraRecalcMatrices");
	zt_returnOnNull(camera);

	if (camera->type == ztCameraType_Orthographic) {
		camera->mat_view = ztMat4::identity.getTranslate(camera->position * zt_vec3(-1,-1,-1));
	}
	else if (camera->type == ztCameraType_Perspective) {
		camera->mat_view = ztMat4::identity.getTranslate(-camera->position.x, -camera->position.y, -camera->position.z);
		camera->mat_view = camera->rotation.convertToMat4() * camera->mat_view; // put the rotation into the translation matrix

		ztMat4 mat_final = camera->mat_proj * camera->mat_view;
		camera->direction = zt_vec3(mat_final.values[2], mat_final.values[6], mat_final.values[10]).getNormal();
	}
	else {
		zt_assert(false && "Invalid camera type");
	}
}

// ================================================================================================================================================================================================

void zt_cameraCalcFinalMatrix(ztCamera *camera, ztMat4* final_mat)
{
	ZT_PROFILE_RENDERING("zt_cameraCalcFinalMatrix");
	zt_returnOnNull(camera);
	zt_returnOnNull(final_mat);

	if (camera->type == ztCameraType_Orthographic) {
		ztMat4 temp = camera->mat_proj * camera->mat_view;
		ztMat4 zoom = zt_mat4(camera->zoom, 0, 0, 0, 0, camera->zoom, 0, 0, 0, 0, camera->zoom, 0, 0, 0, 0, camera->zoom);

		*final_mat = temp * zoom;
	}
	else if (camera->type == ztCameraType_Perspective) {
		*final_mat = camera->mat_proj * camera->mat_view;
	}
	else {
		zt_assert(false && "Invalid camera type");
	}
}

// ================================================================================================================================================================================================

void zt_cameraSetMatrices(ztCamera *camera, ztMat4& proj, ztMat4& view)
{
	ZT_PROFILE_RENDERING("zt_cameraSetMatrices");
	zt_returnOnNull(camera);

	camera->mat_proj = proj;
	camera->mat_view = view;

	ztMat4 mat_final = camera->mat_proj * camera->mat_view;
	camera->direction = zt_vec3(mat_final.values[2], mat_final.values[6], mat_final.values[10]).getNormal();

	//mat_final.inverse();

	ztVec3 rot;
	view.extract(&camera->position, &rot, nullptr);

	camera->rotation = ztQuat::makeFromEuler(rot);
}

// ================================================================================================================================================================================================

void zt_cameraOrthoGetExtents(ztCamera *camera, ztVec2 *min_ext, ztVec2 *max_ext)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoGetExtents");
	zt_returnOnNull(min_ext);
	zt_returnOnNull(max_ext);

	ztVec2 size = zt_cameraOrthoGetViewportSize(camera);
	min_ext->x = size.x / -2;
	min_ext->y = size.y / -2;
	max_ext->x = size.x / 2;
	max_ext->y = size.y / 2;
}

// ================================================================================================================================================================================================

ztVec2 zt_cameraOrthoGetMaxExtent(ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoGetMaxExtent");
	ztVec2 ext = zt_cameraOrthoGetViewportSize(camera);
	ext.x /= 2;
	ext.y /= 2;
	return ext;
}

// ================================================================================================================================================================================================

ztVec2 zt_cameraOrthoGetMinExtent(ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoGetMinExtent");
	ztVec2 ext = zt_cameraOrthoGetViewportSize(camera);
	ext.x /= -2;
	ext.y /= -2;
	return ext;
}

// ================================================================================================================================================================================================

ztVec2 zt_cameraOrthoGetViewportSize(ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoGetViewportSize");
	zt_returnValOnNull(camera, ztVec2::zero);
	
	if (camera->type != ztCameraType_Orthographic) {
		return ztVec2::zero;
	}

	return zt_vec2(camera->native_w / (r32)zt_game->win_game_settings[0].pixels_per_unit, camera->native_h / (r32)zt_game->win_game_settings[0].pixels_per_unit);
}

// ================================================================================================================================================================================================

ztVec2 zt_cameraOrthoScreenToWorld(ztCamera *camera, int sx, int sy)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoScreenToWorld");
	zt_returnValOnNull(camera, ztVec2::zero);

	if (camera->type != ztCameraType_Orthographic) {
		return ztVec2::zero;
	}

	int c_w = camera->width;
	int c_h = camera->height;

	int n_w = camera->native_w;
	int n_h = camera->native_h;

	if (zt_game->win_game_settings[0].native_w != camera->native_w || zt_game->win_game_settings[0].native_h != camera->native_h) {
		r32 aspect_ratio_cam = camera->native_w / (r32)camera->native_h;
		r32 aspect_ratio_scr = zt_game->win_game_settings[0].native_w / (r32)zt_game->win_game_settings[0].native_h;

		if (!zt_real32Eq(aspect_ratio_cam, aspect_ratio_scr)) {
			if (aspect_ratio_cam > aspect_ratio_scr) {
				r32 pct = camera->native_w / (r32)zt_game->win_game_settings[0].native_w;

				i32 diff_y = zt_game->win_game_settings[0].native_h - zt_convertToi32Floor(camera->native_h / pct);
				sy -= zt_convertToi32Floor((diff_y / 2.f));

				c_w = zt_game->win_game_settings[0].native_w;
				c_h = zt_convertToi32Floor(zt_game->win_game_settings[0].native_w / aspect_ratio_cam);
			}
			else {
				r32 pct = camera->native_h / (r32)zt_game->win_game_settings[0].native_h;

				i32 diff_x = zt_game->win_game_settings[0].native_w - zt_convertToi32Floor(camera->native_w / pct);
				sx -= zt_convertToi32Floor(diff_x / 2.f);

				c_w = zt_convertToi32Floor(zt_game->win_game_settings[0].native_h * aspect_ratio_cam);
				c_h = zt_game->win_game_settings[0].native_h;
			}
		}
	}

	r32 spct_x = c_w / (r32)n_w;
	r32 spct_y = c_h / (r32)n_h;
	r32 x = (sx - (c_w / 2.0f)) / zt_game->win_game_settings[0].pixels_per_unit / (camera->zoom * spct_x);
	r32 y = (sy - (c_h / 2.0f)) / zt_game->win_game_settings[0].pixels_per_unit * -1 / (camera->zoom * spct_y);

	return zt_vec2(x + camera->position.x, y + camera->position.y);
}

// ================================================================================================================================================================================================

ztVec2i zt_cameraOrthoWorldToScreen(ztCamera *camera, ztVec2 pos)
{
	ZT_PROFILE_RENDERING("zt_cameraOrthoWorldToScreen");
	zt_returnValOnNull(camera, zt_vec2i(0,0));

	if (camera->type != ztCameraType_Orthographic) {
		return zt_vec2i(0,0);
	}

	r32 ppu = (r32)zt_game->win_game_settings[0].pixels_per_unit;
	ztVec2 diff = pos - camera->position.xy;

	r32 x = (diff.x + ((camera->native_w / ppu) / 2.f)) * ppu;
	r32 y = (((camera->native_h / ppu) / 2) + diff.y) * ppu;

	return zt_vec2i(x < 0 ? zt_convertToi32Floor(x) : zt_convertToi32Ceil(x),
					y < 0 ? zt_convertToi32Floor(y) : zt_convertToi32Ceil(y));
}

// ================================================================================================================================================================================================

void zt_cameraPerspGetMouseRay(ztCamera *camera, int sx, int sy, ztVec3 *point, ztVec3 *direction)
{
	ZT_PROFILE_RENDERING("zt_cameraPerspGetMouseRay");
	r32 x = zt_linearRemap((r32)sx, 0.f, (r32)camera->width , -1, 1);
	r32 y = zt_linearRemap((r32)sy, 0.f, (r32)camera->height, 1, -1);

	r32 near_height = zt_tan(camera->fov / 2.f) * camera->near_z;
	r32 far_height = zt_tan(camera->fov / 2.f) * camera->far_z;

	r32 aspect = (r32)camera->width / (r32)camera->height;
	r32 near_width = near_height * aspect;
	r32 far_width = far_height * aspect;

	ztVec3 pos_near = zt_vec3(near_width * x, near_height * y, -camera->near_z);
	ztVec3 pos_far = zt_vec3(far_width * x, far_height * y, -camera->far_z);

	ztMat4 inv_view = camera->mat_view.getInverse();
	pos_near = inv_view * pos_near;
	pos_far  = inv_view * pos_far;

	*point = pos_near;
	*direction = pos_far - pos_near;
	direction->normalize();
}

// ================================================================================================================================================================================================

void zt_cameraPerspGetMouseRayLocalToMatrix(ztCamera *camera, int sx, int sy, ztVec3 *point, ztVec3 *direction, ztMat4 *matrix_inv)
{
	ZT_PROFILE_RENDERING("zt_cameraPerspGetMouseRayLocalToMatrix");

	ztVec3 ray_pos, ray_dir;
	zt_cameraPerspGetMouseRay(camera, sx, sy, &ray_pos, &ray_dir);

	ztVec3 ray_pos_plus_dir = ray_pos + ray_dir;

	ray_pos = matrix_inv->getMultiply(ray_pos);
	ray_pos_plus_dir = matrix_inv->getMultiply(ray_pos_plus_dir);

	ray_dir = (ray_pos_plus_dir - ray_pos).getNormal();

	*point = ray_pos;
	*direction = ray_dir;
}

// ================================================================================================================================================================================================

ztVec2i zt_cameraPerspWorldToScreen(ztCamera *camera, ztVec3 pos)
{
	ZT_PROFILE_RENDERING("zt_cameraPerspWorldToScreen");
	ztMat4 mat_final = camera->mat_proj * camera->mat_view;

	ztVec4 result = mat_final.getMultiply(zt_vec4(pos, 1));
	result.xyz *= 1 / result.w;

	result.y *= -.5f;
	result.x *= .5f;
	result.x += .5f;
	result.y += .5f;
	
	return zt_vec2i(zt_convertToi32Floor(camera->width * result.x), zt_convertToi32Floor(camera->height * result.y));
}

// ================================================================================================================================================================================================

void zt_cameraLookAt(ztCamera *camera, const ztVec3 &target, const ztVec3 &up)
{
	ZT_PROFILE_RENDERING("zt_cameraLookAt");

	ztMat4 view = ztMat4::identity.getLookAt(camera->position, target, up);

	camera->rotation = ztQuat::makeFromMat4(view);

	zt_cameraRecalcMatrices(camera);
}

// ================================================================================================================================================================================================

#define ZT_CAMERA_SERIAL_GUID       zt_guidMake(0xe7e44f8a, 0xa1554b11, 0x966442d7, 0xa8f176ea)
#define ZT_CAMERA_SERIAL_VERSION    10001

// ================================================================================================================================================================================================

#define _serialCheck(code)	if(!code) { zt_logCritical("Camera serialization failed."); return false; }

bool zt_cameraSave(ztCamera *camera, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWrite(serial, ZT_CAMERA_SERIAL_GUID));
		_serialCheck(zt_serialWrite(serial, ZT_CAMERA_SERIAL_VERSION));

		_serialCheck(zt_serialWrite(serial, (i32)camera->type));
		_serialCheck(zt_serialWrite(serial, camera->position));
		_serialCheck(zt_serialWrite(serial, camera->width));
		_serialCheck(zt_serialWrite(serial, camera->height));
		_serialCheck(zt_serialWrite(serial, camera->near_z));
		_serialCheck(zt_serialWrite(serial, camera->far_z));
		_serialCheck(zt_serialWrite(serial, camera->mat_view));
		_serialCheck(zt_serialWrite(serial, camera->mat_proj));

		if (camera->type == ztCameraType_Orthographic) {
			_serialCheck(zt_serialWrite(serial, camera->native_w));
			_serialCheck(zt_serialWrite(serial, camera->native_h));
			_serialCheck(zt_serialWrite(serial, camera->zoom));
		}
		else {
			_serialCheck(zt_serialWrite(serial, camera->fov));
			_serialCheck(zt_serialWrite(serial, camera->rotation));
			_serialCheck(zt_serialWrite(serial, camera->direction));
		}
	}
	_serialCheck(zt_serialGroupPop(serial));

	return true;
}

// ================================================================================================================================================================================================

bool zt_cameraLoad(ztCamera *camera, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		ztGuid guid;
		i32 version = 0;
		_serialCheck(zt_serialRead(serial, &guid));
		_serialCheck(zt_serialRead(serial, &version));
		if (guid    != ZT_CAMERA_SERIAL_GUID   ) { zt_logCritical("Camera serialization GUID mismatch"); return false; }
		if (version != ZT_CAMERA_SERIAL_VERSION) { zt_logCritical("Camera serialization version mismatch"); return false; }

		i32 camera_type = 0;
		_serialCheck(zt_serialRead(serial, &camera_type));
		camera->type = (ztCameraType_Enum)camera_type;

		_serialCheck(zt_serialRead(serial, &camera->position));
		_serialCheck(zt_serialRead(serial, &camera->width));
		_serialCheck(zt_serialRead(serial, &camera->height));
		_serialCheck(zt_serialRead(serial, &camera->near_z));
		_serialCheck(zt_serialRead(serial, &camera->far_z));
		_serialCheck(zt_serialRead(serial, &camera->mat_view));
		_serialCheck(zt_serialRead(serial, &camera->mat_proj));

		if (camera->type == ztCameraType_Orthographic) {
			_serialCheck(zt_serialRead(serial, &camera->native_w));
			_serialCheck(zt_serialRead(serial, &camera->native_h));
			_serialCheck(zt_serialRead(serial, &camera->zoom));
		}
		else {
			_serialCheck(zt_serialRead(serial, &camera->fov));
			_serialCheck(zt_serialRead(serial, &camera->rotation));
			_serialCheck(zt_serialRead(serial, &camera->direction));
		}
	}
	_serialCheck(zt_serialGroupPop(serial));

	return true;
}

#undef _serialCheck

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztCameraShake zt_cameraShakeMake(r32 duration, r32 speed, r32 intensity, i32 seed, r32 ramp_up)
{
	ZT_PROFILE_RENDERING("zt_cameraShakeMake");
	ztCameraShake camera_shake;
	zt_memSet(&camera_shake, zt_sizeof(ztCameraShake), 0);

	zt_randomInit(&camera_shake.randomizer, seed);

	camera_shake.duration = duration;
	camera_shake.frequency = 60 * speed; // hertz
	camera_shake.amplitude = 16 * intensity / zt_pixelsPerUnit(); // units
	camera_shake.sample_count = zt_min(CAMERA_SHAKE_MAX_SAMPLES - 1, (int)camera_shake.frequency);
	camera_shake.ramp_up = ramp_up;
	camera_shake.ramp_up_progress = ramp_up;

	zt_fiz(camera_shake.sample_count) {
		camera_shake.samples_x[i] = zt_randomVal(&camera_shake.randomizer) * 2.0f - 1.0f;
		camera_shake.samples_y[i] = zt_randomVal(&camera_shake.randomizer) * 2.0f - 1.0f;
	}
	camera_shake.samples_x[camera_shake.sample_count] = 0;
	camera_shake.samples_y[camera_shake.sample_count] = 0;

	return camera_shake;
}

// ================================================================================================================================================================================================

void zt_cameraShakeStart(ztCameraShake *camera_shake)
{
	ZT_PROFILE_RENDERING("zt_cameraShakeStart");
	zt_returnOnNull(camera_shake);
	camera_shake->current_time = camera_shake->duration;
	camera_shake->ramp_up_progress = camera_shake->ramp_up;
}

// ================================================================================================================================================================================================

void zt_cameraShakeUpdate(ztCameraShake *camera_shake, r32 dt)
{
	zt_cameraShakeUpdateMultiple(camera_shake, 1, dt);
}

// ================================================================================================================================================================================================

void zt_cameraShakeUpdateMultiple(ztCameraShake *camera_shake, int camera_shake_count, r32 dt)
{
	ZT_PROFILE_RENDERING("zt_cameraShakeUpdateMultiple");
	zt_returnOnNull(camera_shake);

	zt_fiz(camera_shake_count) {
		if (camera_shake[i].current_time > 0) {
			camera_shake[i].current_time -= dt;
			if (camera_shake[i].current_time > 0) {
				r32 percent = 1 - camera_shake[i].current_time / camera_shake[i].duration;
				r32 frequency = percent * camera_shake[i].frequency;

				r32 sample_x = frequency;
				i32 sample_x_idx_0 = zt_convertToi32Floor(sample_x);
				i32 sample_x_idx_1 = sample_x_idx_0 + 1;
				r32 amplitude_x = (camera_shake[i].samples_x[sample_x_idx_0] + (sample_x - sample_x_idx_0) * (camera_shake[i].samples_x[sample_x_idx_1] - camera_shake[i].samples_x[sample_x_idx_0])) * (1 - percent);

				r32 sample_y = frequency;
				i32 sample_y_idx_0 = zt_convertToi32Floor(sample_y);
				i32 sample_y_idx_1 = sample_y_idx_0 + 1;
				r32 amplitude_y = (camera_shake[i].samples_y[sample_y_idx_0] + (sample_y - sample_y_idx_0) * (camera_shake[i].samples_y[sample_y_idx_1] - camera_shake[i].samples_y[sample_y_idx_0])) * (1 - percent);

				r32 ramp_percent = 1;
				if (camera_shake[i].ramp_up_progress > 0) {
					camera_shake[i].ramp_up_progress -= dt;
					if (camera_shake[i].ramp_up_progress <= 0) {
						camera_shake[i].ramp_up_progress = 0;
					}
					else {
						ramp_percent = 1 - (camera_shake[i].ramp_up_progress / camera_shake[i].ramp_up);
					}
				}

				camera_shake[i].offset.x = amplitude_x * camera_shake[i].amplitude * ramp_percent;
				camera_shake[i].offset.y = amplitude_y * camera_shake[i].amplitude * ramp_percent;
			}
		}
	}
}

// ================================================================================================================================================================================================

bool zt_cameraShakePreRender(ztCameraShake *camera_shake, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePreRender");
	zt_returnValOnNull(camera_shake, false);
	zt_returnValOnNull(camera, false);

	if (camera_shake->current_time <= 0) {
		return false;
	}

	camera_shake->original_position = camera->position;
	camera->position.x += camera_shake->offset.x;
	camera->position.y += camera_shake->offset.y;

	return true;
}

// ================================================================================================================================================================================================

void zt_cameraShakePreRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePreRenderMultiple");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(camera);

	zt_fiz(camera_shake_count) {
		if (camera_shake[i].current_time <= 0) {
			continue;
		}

		camera_shake[i].original_position = camera->position;
		camera->position.x += camera_shake[i].offset.x;
		camera->position.y += camera_shake[i].offset.y;
	}
}

// ================================================================================================================================================================================================

bool zt_cameraShakePostRender(ztCameraShake *camera_shake, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePostRender");
	zt_returnValOnNull(camera_shake, false);
	zt_returnValOnNull(camera, false);

	if (camera_shake->current_time <= 0) {
		return false;
	}

	camera->position = camera_shake->original_position;

	return true;
}

// ================================================================================================================================================================================================

void zt_cameraShakePostRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztCamera *camera)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePostRenderMultiple");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(camera);

	zt_fizr(camera_shake_count) {
		if (camera_shake->current_time <= 0) {
			continue;
		}

		camera->position = camera_shake->original_position;
	}
}

// ================================================================================================================================================================================================

void zt_cameraShakePreRender(ztCameraShake *camera_shake, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePreRender");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(draw_list);

	zt_drawListPushOffset(draw_list, zt_vec3(camera_shake->offset, 0));
}

// ================================================================================================================================================================================================

void zt_cameraShakePreRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePreRenderMultiple");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(draw_list);

	ztVec2 offset = ztVec2::zero;

	zt_fiz(camera_shake_count) {
		if (camera_shake[i].current_time <= 0) {
			continue;
		}

		offset += camera_shake[i].offset;
	}

	zt_drawListPushOffset(draw_list, zt_vec3(offset, 0));
}

// ================================================================================================================================================================================================

void zt_cameraShakePostRender(ztCameraShake *camera_shake, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePostRender");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(draw_list);

	zt_drawListPopOffset(draw_list);
}

// ================================================================================================================================================================================================

void zt_cameraShakePostRenderMultiple(ztCameraShake *camera_shake, int camera_shake_count, ztDrawList *draw_list)
{
	ZT_PROFILE_RENDERING("zt_cameraShakePostRenderMultiple");
	zt_returnOnNull(camera_shake);
	zt_returnOnNull(draw_list);

	zt_drawListPopOffset(draw_list);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztCameraControllerFPS zt_cameraControllerMakeFPS(ztCamera *camera, ztVec3 initial_rotation, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_cameraControllerMakeFPS");
	ztCameraControllerFPS controller;
	zt_memSet(&controller, zt_sizeof(ztCameraControllerFPS), 0);

	controller.camera = camera;
	controller.mouse_sensitivity = 0.005f;
	controller.speed = 10.f;
	controller.boosted_speed = 30.f;
	controller.sneaking_speed = 2.f;
	controller.flags = flags;

	if (initial_rotation != ztVec3::zero) {
		controller.rotation = initial_rotation;
		controller.camera->rotation = ztQuat::makeFromEuler(controller.rotation.x, 0, 0);
		controller.camera->rotation *= ztQuat::makeFromEuler(0, controller.rotation.y, 0);
	}
	else {
		//controller.rotation = (camera->rotation * ztQuat::makeFromEuler(180, 0, 0)).euler();
		//controller.rotation.y += 180;
		controller.rotation = camera->rotation.euler();// + zt_vec3(-90, -90, 0);
	}

	controller.mouse_delta_x = .001f;
	controller.mouse_delta_y = .001f;
	zt_cameraControlUpdateFPS(&controller, 0.f);

	zt_cameraRecalcMatrices(controller.camera);

	return controller;
}

// ================================================================================================================================================================================================

void zt_cameraControlUpdateFPS(ztCameraControllerFPS *controller, r32 dt)
{
	ZT_PROFILE_RENDERING("zt_cameraControlUpdateFPS");
	zt_returnOnNull(controller);

	bool cam_moved = false;

	if (controller->mouse_delta_x != 0 || controller->mouse_delta_y != 0) {
		cam_moved = true;

		r32 delta_x = controller->mouse_delta_x * controller->mouse_sensitivity;
		r32 delta_y = controller->mouse_delta_y * controller->mouse_sensitivity;

		controller->rotation.y += delta_x;
		if (controller->rotation.y <   0) controller->rotation.y += 360;
		if (controller->rotation.y > 360) controller->rotation.y -= 360;

		controller->rotation.x = zt_clamp(controller->rotation.x + delta_y, -89, 89);
		//controller->rotation.x += delta_y;

		controller->camera->rotation = zt_bitIsSet(controller->flags, ztCameraControllerFPSFlags_LockYAxis) ? ztQuat::identity : ztQuat::makeFromEuler(controller->rotation.x, 0, 0);
		controller->camera->rotation *= ztQuat::makeFromEuler(0, controller->rotation.y, 0);
	}

	r32 movement_speed = controller->is_boosted ? controller->boosted_speed : (controller->is_sneaking ? controller->sneaking_speed : controller->speed);

	ztVec3 movement_velocity = controller->velocity;

	controller->prev_pos = controller->camera->position;

	bool moved_x = false, moved_z = false;
	if (controller->move_forward) { movement_velocity.z = zt_approach(movement_velocity.z, -1, 2 * dt); moved_z = true; }
	if (controller->move_back   ) { movement_velocity.z = zt_approach(movement_velocity.z, +1, 2 * dt); moved_z = true; }
	if (controller->strafe_left ) { movement_velocity.x = zt_approach(movement_velocity.x, -1, 2 * dt); moved_x = true; }
	if (controller->strafe_right) { movement_velocity.x = zt_approach(movement_velocity.x, +1, 2 * dt); moved_x = true; }

	if (!moved_z && movement_velocity.z != 0) { movement_velocity.z = zt_approach(movement_velocity.z, 0, 4.75f * dt); }
	if (!moved_x && movement_velocity.x != 0) { movement_velocity.x = zt_approach(movement_velocity.x, 0, 4.75f * dt); }

	controller->velocity = movement_velocity;

	if (movement_velocity != ztVec3::zero) {
		cam_moved = true;
		if (movement_velocity.z != 0) {
			r32 z_move = -1 * movement_velocity.z * movement_speed * dt;

			if (zt_bitIsSet(controller->flags, ztCameraControllerFPSFlags_MoveYDirection)) {
				controller->camera->position.x += controller->camera->direction.x * z_move;
				controller->camera->position.y += controller->camera->direction.y * z_move;
				controller->camera->position.z += controller->camera->direction.z * z_move;
			}
			else {
				ztVec3 cam_dir = controller->camera->direction;
				cam_dir.y = 0;
				cam_dir.normalize();

				controller->camera->position.x += cam_dir.x * z_move;
				controller->camera->position.y += cam_dir.y * z_move;
				controller->camera->position.z += cam_dir.z * z_move;
			}
		}
		if (movement_velocity.x != 0) {
			ztVec3 side = zt_vec3(0, 1, 0).cross(controller->camera->direction);
			side.normalize();

			r32 x_move = -1 * movement_velocity.x * movement_speed * dt;

			controller->camera->position.x += side.x * x_move;
			controller->camera->position.y += side.y * x_move;
			controller->camera->position.z += side.z * x_move;
		}
	}

	if (cam_moved) {
		zt_cameraRecalcMatrices(controller->camera);
	}
}

// ================================================================================================================================================================================================

void zt_cameraControlUpdateWASD(ztCameraControllerFPS *camera, ztInputMouse *input_mouse, ztInputKeys *input_keys, r32 dt)
{
	ZT_PROFILE_RENDERING("zt_cameraControlUpdateWASD");
	zt_returnOnNull(camera);

	camera->mouse_delta_x = (r32)input_mouse->delta_x;
	camera->mouse_delta_y = (r32)input_mouse->delta_y;

	camera->move_forward = input_keys[ztInputKeys_W].pressed() ? 1.f : 0.f;
	camera->move_back    = input_keys[ztInputKeys_S].pressed() ? 1.f : 0.f;
	camera->strafe_left  = input_keys[ztInputKeys_A].pressed() ? 1.f : 0.f;
	camera->strafe_right = input_keys[ztInputKeys_D].pressed() ? 1.f : 0.f;

	camera->is_boosted  = input_keys[ztInputKeys_Control].pressed();
	camera->is_sneaking = input_keys[ztInputKeys_Shift].pressed();

	zt_cameraControlUpdateFPS(camera, dt);
}

// ================================================================================================================================================================================================

#define _serialCheck(code) if (!code) { zt_logCritical("CameraControllerFPS serialization failed"); return false; }

#define ZT_CAMERA_CONTROLLER_FPS_SERIAL_GUID       zt_guidMake(0xe7e44f8a, 0xa1554b11, 0x966442d7, 0xa8f176ea)
#define ZT_CAMERA_CONTROLLER_FPS_SERIAL_VERSION    10001

bool zt_cameraControllerFPSSave(ztCameraControllerFPS *controller, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWriteGuidVersion(serial, ZT_CAMERA_CONTROLLER_FPS_SERIAL_GUID, ZT_CAMERA_CONTROLLER_FPS_SERIAL_VERSION));

		_serialCheck(zt_cameraSave(controller->camera, serial));

		_serialCheck(zt_serialWrite(serial, controller->prev_pos));
		_serialCheck(zt_serialWrite(serial, controller->mouse_sensitivity));
		_serialCheck(zt_serialWrite(serial, controller->speed));
		_serialCheck(zt_serialWrite(serial, controller->boosted_speed));
		_serialCheck(zt_serialWrite(serial, controller->sneaking_speed));
		_serialCheck(zt_serialWrite(serial, controller->flags));
		_serialCheck(zt_serialWrite(serial, controller->mouse_delta_x));
		_serialCheck(zt_serialWrite(serial, controller->mouse_delta_y));
		_serialCheck(zt_serialWrite(serial, controller->is_boosted));
		_serialCheck(zt_serialWrite(serial, controller->is_sneaking));
		_serialCheck(zt_serialWrite(serial, controller->move_back));
		_serialCheck(zt_serialWrite(serial, controller->move_forward));
		_serialCheck(zt_serialWrite(serial, controller->strafe_left));
		_serialCheck(zt_serialWrite(serial, controller->strafe_right));
		_serialCheck(zt_serialWrite(serial, controller->rotation));
		_serialCheck(zt_serialWrite(serial, controller->velocity));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_cameraControllerFPSLoad(ztCameraControllerFPS *controller, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialReadAndCheckGuidVersion(serial, ZT_CAMERA_CONTROLLER_FPS_SERIAL_GUID, ZT_CAMERA_CONTROLLER_FPS_SERIAL_VERSION));

		_serialCheck(zt_cameraLoad(controller->camera, serial));

		_serialCheck(zt_serialRead(serial, &controller->prev_pos));
		_serialCheck(zt_serialRead(serial, &controller->mouse_sensitivity));
		_serialCheck(zt_serialRead(serial, &controller->speed));
		_serialCheck(zt_serialRead(serial, &controller->boosted_speed));
		_serialCheck(zt_serialRead(serial, &controller->sneaking_speed));
		_serialCheck(zt_serialRead(serial, &controller->flags));
		_serialCheck(zt_serialRead(serial, &controller->mouse_delta_x));
		_serialCheck(zt_serialRead(serial, &controller->mouse_delta_y));
		_serialCheck(zt_serialRead(serial, &controller->is_boosted));
		_serialCheck(zt_serialRead(serial, &controller->is_sneaking));
		_serialCheck(zt_serialRead(serial, &controller->move_back));
		_serialCheck(zt_serialRead(serial, &controller->move_forward));
		_serialCheck(zt_serialRead(serial, &controller->strafe_left));
		_serialCheck(zt_serialRead(serial, &controller->strafe_right));
		_serialCheck(zt_serialRead(serial, &controller->rotation));
		_serialCheck(zt_serialRead(serial, &controller->velocity));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

#undef _serialCheck

// ================================================================================================================================================================================================

ztCameraControllerArcball zt_cameraControllerMakeArcball(ztCamera *camera, ztVec3 target)
{
	ZT_PROFILE_RENDERING("zt_cameraControllerMakeArcball");
	ztCameraControllerArcball controller;
	zt_memSet(&controller, zt_sizeof(ztCameraControllerArcball), 0);

	controller.camera            = camera;
	controller.mouse_sensitivity = 0.05f;
	controller.target            = target;
	controller.rotation          = ztQuat::identity;

	if (controller.camera->position == target) {
		controller.camera->position.z -= 1;
		zt_cameraRecalcMatrices(controller.camera);
	}

	zt_cameraLookAt(camera, target);
//	controller.rotation = ztQuat::makeFromPoints(target, camera->position);
	controller.rotation = ztQuat::makeFromDirection((target - camera->position), zt_vec3(0,1,0));

	return controller;
}

// ================================================================================================================================================================================================

void zt_cameraControlUpdateArcball(ztCameraControllerArcball *controller, ztInputMouse *input_mouse, ztInputKeys *input_keys, r32 dt, i32 flags)
{
	ZT_PROFILE_RENDERING("zt_cameraControlUpdateArcball");
	zt_returnOnNull(controller);
	zt_returnOnNull(input_mouse);
	zt_returnOnNull(input_keys);

	bool ignore_keys = zt_bitIsSet(flags, ztCameraControllerArcballUpdateFlags_IgnoreKeys);
	bool middle_pressed = input_mouse->middlePressed();
	if (middle_pressed || (!ignore_keys && input_keys[ztInputKeys_Control].pressed()) || input_mouse->wheel_delta) {

		if (middle_pressed) {
			if (input_keys[ztInputKeys_Shift].pressed()) {
				ztVec3 xaxis = zt_vec3(0.f, 1.f, 0.f).cross(controller->camera->direction);
				ztVec3 yaxis = controller->camera->direction.cross(zt_vec3(0.f, 1.f, 0.f)).cross(controller->camera->direction);

				xaxis.normalize();
				yaxis.normalize();

				r32 distance = zt_abs(controller->camera->position.distance(controller->target));
				r32 x_move = input_mouse->delta_x * controller->mouse_sensitivity * dt * distance * .125f;
				r32 y_move = input_mouse->delta_y * controller->mouse_sensitivity * dt * distance * .125f;

				controller->target += yaxis * y_move;
				controller->target += xaxis * x_move;
			}
			else {

				ztVec3 xaxis = zt_vec3(1.f, 0.f, 0.f);
				ztVec3 yaxis = zt_vec3(0.f, 1.f, 0.f);

				xaxis = yaxis.cross(controller->camera->direction);

				xaxis.normalize();

				ztQuat qx = ztQuat::makeFromAxisAngle(xaxis, input_mouse->delta_y * controller->mouse_sensitivity);
				ztQuat qy = ztQuat::makeFromAxisAngle(yaxis, input_mouse->delta_x * -controller->mouse_sensitivity);
				ztQuat qr = qx * qy;
				ztQuat new_rotation = qr * controller->rotation;
				new_rotation.normalize();

				// make sure we haven't flipped poles
				ztVec3 prev_pos = controller->rotation.rotatePosition(zt_vec3(0.f, 1.f, 0.f));
				ztVec3 this_pos = new_rotation.rotatePosition(zt_vec3(0.f, 1.f, 0.f));

				if ((this_pos.x < 0 && prev_pos.x > 0) || (this_pos.x > 0 && prev_pos.x < 0)) {
					ztQuat qx = ztQuat::makeFromAxisAngle(xaxis, 0);
					ztQuat qy = ztQuat::makeFromAxisAngle(yaxis, input_mouse->delta_x * -controller->mouse_sensitivity);
					ztQuat qr = qx * qy;
					new_rotation = qr * controller->rotation;
					new_rotation.normalize();
				}

				controller->rotation = new_rotation;
				controller->rotation.normalize();
			}
		}

		r32 distance = zt_abs(controller->camera->position.distance(controller->target));

		if (input_mouse->wheel_delta) {
			distance *= input_mouse->wheel_delta < 0 ? 1.1f : 0.9f;
		}

		ztVec3 position = controller->rotation.rotatePosition(zt_vec3(0, distance, 0));

		controller->camera->position = position + controller->target;

		ztVec3 euler = controller->rotation.euler();
		ztVec3 up = zt_vec3(0, euler.x < 0 ? 1.f : 1.f, 0);
		zt_cameraLookAt(controller->camera, controller->target, up);
	}
}

// ================================================================================================================================================================================================

#define _serialCheck(code) if (!code) { zt_logCritical("CameraControllerArcball serialization failed"); return false; }

#define ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_GUID       zt_guidMake(0xf94a3f97, 0xab454407, 0xa8f60222, 0x9d88035c)
#define ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_VERSION    10001

bool zt_cameraControllerArcballSave(ztCameraControllerArcball *controller, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWriteGuidVersion(serial, ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_GUID, ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_VERSION));

		_serialCheck(zt_cameraSave(controller->camera, serial));

		_serialCheck(zt_serialWrite(serial, controller->mouse_sensitivity));
		_serialCheck(zt_serialWrite(serial, controller->target));
		_serialCheck(zt_serialWrite(serial, controller->rotation));
		_serialCheck(zt_serialWrite(serial, controller->mouse_delta_x));
		_serialCheck(zt_serialWrite(serial, controller->mouse_delta_y));
		_serialCheck(zt_serialWrite(serial, controller->is_boosted));
		_serialCheck(zt_serialWrite(serial, controller->is_sneaking));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_cameraControllerArcballLoad(ztCameraControllerArcball *controller, ztSerial *serial)
{
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialReadAndCheckGuidVersion(serial, ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_GUID, ZT_CAMERA_CONTROLLER_ARCBALL_SERIAL_VERSION));

		_serialCheck(zt_cameraLoad(controller->camera, serial));

		_serialCheck(zt_serialRead(serial, &controller->mouse_sensitivity));
		_serialCheck(zt_serialRead(serial, &controller->target));
		_serialCheck(zt_serialRead(serial, &controller->rotation));
		_serialCheck(zt_serialRead(serial, &controller->mouse_delta_x));
		_serialCheck(zt_serialRead(serial, &controller->mouse_delta_y));
		_serialCheck(zt_serialRead(serial, &controller->is_boosted));
		_serialCheck(zt_serialRead(serial, &controller->is_sneaking));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

#undef _serialCheck

// ================================================================================================================================================================================================

ztFrustum zt_cameraCalcViewFrustum(ztCamera *camera, r32 far_z, r32 near_z, const ztVec3 &world_offset)
{
	ztFrustum result;
	zt_cameraCalcViewFrustum(&result, camera, far_z, near_z, world_offset);
	return result;
}

// ================================================================================================================================================================================================

void zt_cameraCalcViewFrustum(ztFrustum *frustum, ztCamera *camera, r32 far_z, r32 near_z, const ztVec3 &world_offset)
{
	ZT_PROFILE_RENDERING("zt_cameraCalcViewFrustum");

	zt_returnOnNull(frustum);
	zt_returnOnNull(camera);

	ztVec3 near_center = zt_vec3(0, 0, near_z == 0 ? -camera->near_z : -near_z);
	ztVec3 far_center = zt_vec3(0, 0, far_z == 0 ? -camera->far_z : -far_z);

	if (camera->type == ztCameraType_Perspective) {
		r32 near_half_height = zt_tan(camera->fov / 2.f) * camera->near_z;
		r32 far_half_height = zt_tan(camera->fov / 2.f) * (far_z == 0 ? camera->far_z : far_z);

		r32 aspect = (r32)camera->width / (r32)camera->height;

		r32 near_half_width = near_half_height * aspect;
		r32 far_half_width = far_half_height * aspect;

		frustum->near_nw = zt_vec3(near_center.x - near_half_width, near_center.y + near_half_height, near_center.z);
		frustum->near_ne = zt_vec3(near_center.x + near_half_width, near_center.y + near_half_height, near_center.z);
		frustum->near_se = zt_vec3(near_center.x + near_half_width, near_center.y - near_half_height, near_center.z);
		frustum->near_sw = zt_vec3(near_center.x - near_half_width, near_center.y - near_half_height, near_center.z);

		frustum->far_nw = zt_vec3(far_center.x - far_half_width, far_center.y + far_half_height, far_center.z);
		frustum->far_ne = zt_vec3(far_center.x + far_half_width, far_center.y + far_half_height, far_center.z);
		frustum->far_se = zt_vec3(far_center.x + far_half_width, far_center.y - far_half_height, far_center.z);
		frustum->far_sw = zt_vec3(far_center.x - far_half_width, far_center.y - far_half_height, far_center.z);
	}
	else {
		r32 half_height = camera->height / 2.f;
		r32 half_width = camera->width / 2.f;

		frustum->near_nw = zt_vec3(near_center.x - half_width, near_center.y + half_height, near_center.z);
		frustum->near_ne = zt_vec3(near_center.x + half_width, near_center.y + half_height, near_center.z);
		frustum->near_se = zt_vec3(near_center.x + half_width, near_center.y - half_height, near_center.z);
		frustum->near_sw = zt_vec3(near_center.x - half_width, near_center.y - half_height, near_center.z);

		frustum->far_nw = zt_vec3(far_center.x - half_width, far_center.y + half_height, far_center.z);
		frustum->far_ne = zt_vec3(far_center.x + half_width, far_center.y + half_height, far_center.z);
		frustum->far_se = zt_vec3(far_center.x + half_width, far_center.y - half_height, far_center.z);
		frustum->far_sw = zt_vec3(far_center.x - half_width, far_center.y - half_height, far_center.z);
	}

	ztMat4 cam_view_inv = camera->mat_view.getInverse();
	zt_fiz(8) {
		frustum->points[i] = cam_view_inv * frustum->points[i] + world_offset;
	}

//	frustum->plane_left   = zt_planeMake(frustum->near_sw, frustum->far_sw , frustum->far_nw );
//	frustum->plane_top    = zt_planeMake(frustum->near_nw, frustum->far_nw , frustum->far_ne );
//	frustum->plane_right  = zt_planeMake(frustum->near_se, frustum->near_ne, frustum->far_ne );
//	frustum->plane_bottom = zt_planeMake(frustum->near_se, frustum->far_se , frustum->far_sw );
//	frustum->plane_near   = zt_planeMake(frustum->near_se, frustum->near_sw, frustum->near_nw);
//	frustum->plane_far    = zt_planeMake(frustum->far_se , frustum->far_sw , frustum->far_nw );

	ztMat4 mat_final = camera->mat_proj * camera->mat_view;
	r32 *m =  mat_final.values;
	frustum->plane_right.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row0]);
	frustum->plane_right.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row0];

	frustum->plane_left.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row0]);
	frustum->plane_left.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row0];

	frustum->plane_bottom.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row1]);
	frustum->plane_bottom.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row1];

	frustum->plane_top.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row1]);
	frustum->plane_top.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row1];

	frustum->plane_far.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row2]);
	frustum->plane_far.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row2];

	frustum->plane_near.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row2]);
	frustum->plane_near.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row2];

	zt_fize(frustum->planes) {
		zt_planeNormalize(&frustum->planes[i]);
		//frustum->planes[i].normal.normalize();
	}
}

// ================================================================================================================================================================================================

ztFrustum zt_mat4CalcViewFrustumPersp(ztMat4 *mat_view, ztMat4 *mat_proj, r32 fov, r32 width, r32 height, r32 near_z, r32 far_z)
{
	ztFrustum result;
	zt_mat4CalcViewFrustumPersp(&result, mat_view, mat_proj, fov, width, height, near_z, far_z);
	return result;
}

// ================================================================================================================================================================================================

void zt_mat4CalcViewFrustumPersp(ztFrustum *frustum, ztMat4 *mat_view, ztMat4 *mat_proj, r32 fov, r32 width, r32 height, r32 near_z, r32 far_z)
{
	ZT_PROFILE_RENDERING("zt_cameraCalcViewFrustum");

	zt_returnOnNull(frustum);
	zt_returnOnNull(mat_view);
	zt_returnOnNull(mat_proj);

	ztVec3 near_center = zt_vec3(0, 0, -near_z);
	ztVec3 far_center = zt_vec3(0, 0, -far_z);

	r32 near_half_height = zt_tan(fov / 2.f) * near_z;
	r32 far_half_height = zt_tan(fov / 2.f) * far_z;

	r32 aspect = width / height;

	r32 near_half_width = near_half_height * aspect;
	r32 far_half_width = far_half_height * aspect;

	frustum->near_nw = zt_vec3(near_center.x - near_half_width, near_center.y + near_half_height, near_center.z);
	frustum->near_ne = zt_vec3(near_center.x + near_half_width, near_center.y + near_half_height, near_center.z);
	frustum->near_se = zt_vec3(near_center.x + near_half_width, near_center.y - near_half_height, near_center.z);
	frustum->near_sw = zt_vec3(near_center.x - near_half_width, near_center.y - near_half_height, near_center.z);

	frustum->far_nw = zt_vec3(far_center.x - far_half_width, far_center.y + far_half_height, far_center.z);
	frustum->far_ne = zt_vec3(far_center.x + far_half_width, far_center.y + far_half_height, far_center.z);
	frustum->far_se = zt_vec3(far_center.x + far_half_width, far_center.y - far_half_height, far_center.z);
	frustum->far_sw = zt_vec3(far_center.x - far_half_width, far_center.y - far_half_height, far_center.z);

	ztMat4 cam_view_inv = mat_view->getInverse();
	zt_fiz(8) {
		frustum->points[i] = cam_view_inv * frustum->points[i];
	}

	ztMat4 mat_final = (*mat_proj) * (*mat_view);

	r32 *m = mat_final.values;
	frustum->plane_right.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row0]);
	frustum->plane_right.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row0];

	frustum->plane_left.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row0]);
	frustum->plane_left.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row0];

	frustum->plane_bottom.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row1]);
	frustum->plane_bottom.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row1];

	frustum->plane_top.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row1]);
	frustum->plane_top.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row1];

	frustum->plane_far.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row2]);
	frustum->plane_far.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row2];

	frustum->plane_near.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row2]);
	frustum->plane_near.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row2];

	zt_fize(frustum->planes) {
		zt_planeNormalize(&frustum->planes[i]);
	}
}

// ================================================================================================================================================================================================

ztFrustum zt_mat4CalcViewFrustumOrtho(ztMat4 *mat_view, ztMat4 *mat_proj, r32 width, r32 height, r32 near_z, r32 far_z)
{
	ztFrustum result;
	zt_mat4CalcViewFrustumOrtho(&result, mat_view, mat_proj, width, height, near_z, far_z);
	return result;
}

// ================================================================================================================================================================================================

void zt_mat4CalcViewFrustumOrtho(ztFrustum *frustum, ztMat4 *mat_view, ztMat4 *mat_proj, r32 width, r32 height, r32 near_z, r32 far_z)
{
	ZT_PROFILE_RENDERING("zt_cameraCalcViewFrustum");

	zt_returnOnNull(frustum);
	zt_returnOnNull(mat_view);
	zt_returnOnNull(mat_proj);

	ztVec3 near_center = zt_vec3(0, 0, -near_z);
	ztVec3 far_center = zt_vec3(0, 0, -far_z);

	r32 half_height = height / 2.f;
	r32 half_width = width / 2.f;

	frustum->near_nw = zt_vec3(near_center.x - half_width, near_center.y + half_height, near_center.z);
	frustum->near_ne = zt_vec3(near_center.x + half_width, near_center.y + half_height, near_center.z);
	frustum->near_se = zt_vec3(near_center.x + half_width, near_center.y - half_height, near_center.z);
	frustum->near_sw = zt_vec3(near_center.x - half_width, near_center.y - half_height, near_center.z);

	frustum->far_nw = zt_vec3(far_center.x - half_width, far_center.y + half_height, far_center.z);
	frustum->far_ne = zt_vec3(far_center.x + half_width, far_center.y + half_height, far_center.z);
	frustum->far_se = zt_vec3(far_center.x + half_width, far_center.y - half_height, far_center.z);
	frustum->far_sw = zt_vec3(far_center.x - half_width, far_center.y - half_height, far_center.z);

	ztMat4 cam_view_inv = mat_view->getInverse();
	zt_fiz(8) {
		frustum->points[i] = cam_view_inv * frustum->points[i];
	}


	ztMat4 mat_final = (*mat_proj) * (*mat_view);
	r32 *m = mat_final.values;
	frustum->plane_right.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row0]);
	frustum->plane_right.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row0];

	frustum->plane_left.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row0], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row0], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row0]);
	frustum->plane_left.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row0];

	frustum->plane_bottom.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row1]);
	frustum->plane_bottom.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row1];

	frustum->plane_top.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row1], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row1], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row1]);
	frustum->plane_top.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row1];

	frustum->plane_far.normal = zt_vec3(m[ztMat4_Col0Row3] - m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] - m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] - m[ztMat4_Col2Row2]);
	frustum->plane_far.distance = m[ztMat4_Col3Row3] - m[ztMat4_Col3Row2];

	frustum->plane_near.normal = zt_vec3(m[ztMat4_Col0Row3] + m[ztMat4_Col0Row2], m[ztMat4_Col1Row3] + m[ztMat4_Col1Row2], m[ztMat4_Col2Row3] + m[ztMat4_Col2Row2]);
	frustum->plane_near.distance = m[ztMat4_Col3Row3] + m[ztMat4_Col3Row2];

	zt_fize(frustum->planes) {
		zt_planeNormalize(&frustum->planes[i]);
	}
}

// ================================================================================================================================================================================================

ztFrustum& ztFrustum::operator=(const ztFrustum& f)
{
	zt_fize(f.points) this->points[i] = f.points[i];
	zt_fize(f.planes) {
		this->planes[i].normal = f.planes[i].normal;
		this->planes[i].distance = f.planes[i].distance;
	}
	return *this;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_characterControllerMake(ztCharacterController *controller, ztMovingBody *moving_body, i32 flags)
{
	zt_memSet(controller, zt_sizeof(ztCharacterController), 0);

	controller->moving_body = moving_body;
	controller->flags = flags;
	controller->state_flags = 0;
	controller->state_time = 0;
	controller->state_flags_prev = 0;

	moving_body->flags |= ztMovingBodyFlags_TrackCollisions;

	controller->speed_walk = 3.f;
	controller->speed_run = 6.f;
	controller->speed_sneak = .5f;
	controller->velocity_jump = 8.f;
	controller->slowdown_speed = 10.f;
	controller->velocity_damping = .05f;
	controller->min_ramp_dot = .6f;// -1;
}

// ================================================================================================================================================================================================

ztInternal ztInline r32 _zt_characterControllerGetSpeed(ztCharacterController *ctrl)
{
	return ctrl->sneaking_time ? ctrl->speed_sneak : (ctrl->running_time ? ctrl->speed_run : ctrl->speed_walk);
}

// ================================================================================================================================================================================================

void zt_characterControllerUpdatePrePhysics(ztCharacterController *controllers, int controllers_count, ztPhysics *physics, r32 dt, const ztVec3 &gravity)
{
	zt_fvz(cidx, controllers_count) {
		ztCharacterController *ctrl = &controllers[cidx];

		ztVec3 prev_pos = ctrl->moving_body->transform->position;
		r32 speed = _zt_characterControllerGetSpeed(ctrl);

		ztVec3 movement = ctrl->velocity;
		if (ctrl->move_z < 0) { movement.z = zt_approach(zt_min(0, movement.z), -1, 2 * dt); }
		if (ctrl->move_z > 0) { movement.z = zt_approach(zt_max(0, movement.z), 1, 2 * dt); }
		if (ctrl->move_x < 0) { movement.x = zt_approach(zt_min(0, movement.x), -1, 2 * dt); }
		if (ctrl->move_x > 0) { movement.x = zt_approach(zt_max(0, movement.x), 1, 2 * dt); }

		if (ctrl->move_y && zt_bitIsSet(ctrl->flags, ztCharacterControllerFlags_CanFly)) {
			if (ctrl->move_y < 0) { movement.y = zt_min(0, zt_approach(movement.y, -1, 2 * dt)); }
			if (ctrl->move_y > 0) { movement.y = zt_max(0, zt_approach(movement.y, 1, 2 * dt)); }
		}

		if (zt_real32Eq(ctrl->move_x, 0)) {
			movement.x = zt_approach(movement.x, 0, 4.75f * dt);
			if (zt_real32Close(movement.x, 0)) movement.x = 0;
		}
		if (zt_real32Eq(ctrl->move_z, 0)) {
			movement.z = zt_approach(movement.z, 0, 4.75f * dt);
			if (zt_real32Close(movement.z, 0)) movement.z = 0;
		}

		ctrl->move_x = ctrl->move_y = ctrl->move_z = 0;

		if (ctrl->jumping > 0) {
			if (zt_bitIsSet(ctrl->state_flags, ztCharacterControllerStateFlags_Grounded) && !zt_bitIsSet(ctrl->state_flags, ztCharacterControllerStateFlags_OnSlope)) {
				ztVec3 jump_dir = zt_vec3(0, 1, 0);// ctrl->grounded_normal;
				movement += jump_dir * ctrl->velocity_jump;
				zt_bitRemove(ctrl->state_flags, ztCharacterControllerStateFlags_Grounded);
			}
			ctrl->jumping = 0;
		}

		bool model_recalc = false;
		if (ctrl->rotate_horz || ctrl->rotate_vert) {
			model_recalc = true;

			r32 delta_x = ctrl->rotate_horz;
			r32 delta_y = ctrl->rotate_vert;

			ctrl->rotation.y += delta_x;
			if (ctrl->rotation.y <   0) ctrl->rotation.y += 360;
			if (ctrl->rotation.y > 360) ctrl->rotation.y -= 360;

			ctrl->rotation.x = zt_clamp(ctrl->rotation.x + delta_y, -89, 89);

			ctrl->moving_body->transform->rotation = zt_bitIsSet(ctrl->flags, ztCharacterControllerFlags_IgnoreXRotation) ? ztQuat::identity : ztQuat::makeFromEuler(ctrl->rotation.x, 0, 0);
			ctrl->moving_body->transform->rotation *= ztQuat::makeFromEuler(0, -ctrl->rotation.y, 0);
			ctrl->moving_body->transform->rotation.normalize();

			ctrl->rotate_horz = 0;
			ctrl->rotate_vert = 0;
		}

		ctrl->velocity = movement;

		if (!zt_bitIsSet(ctrl->flags, ztCharacterControllerFlags_CanFly)) {
			ctrl->velocity += gravity * dt;
		}

		if (ctrl->velocity != ztVec3::zero) {
			ztVec3 dir = ctrl->moving_body->transform->rotation.rotatePosition(zt_vec3(0, 0, 1));
			dir.y = 0;
			r32 len = dir.length();
			dir.normalize();
			ctrl->last_dir = dir;

			if (ctrl->velocity.y != 0) {
				ctrl->moving_body->transform->position.y += ctrl->velocity.y * dt;
			}

			if (ctrl->velocity.z != 0) {
				r32 z_move = -1 * ctrl->velocity.z * dt * speed;// *z_speed;

				ctrl->moving_body->transform->position.x += dir.x * z_move;
				ctrl->moving_body->transform->position.y += dir.y * z_move;
				ctrl->moving_body->transform->position.z += dir.z * z_move;
			}
			if (ctrl->velocity.x != 0) {
				ztVec3 side = zt_vec3(0, 1, 0).cross(dir);
				side.normalize();

				r32 x_move = -1 * ctrl->velocity.x * dt * speed;

				ctrl->moving_body->transform->position.x += side.x * x_move;
				ctrl->moving_body->transform->position.y += side.y * x_move;
				ctrl->moving_body->transform->position.z += side.z * x_move;
			}

			zt_bitRemove(ctrl->moving_body->flags, ztMovingBodyFlags_AllowPenetration);
			zt_bitRemove(ctrl->flags, ztCharacterControllerStateFlags_CollidingWall);

			zt_flink(collision, ctrl->moving_body->collisions) {
				if (collision->moving_bodies[1] == nullptr) {
					if (!zt_between(collision->contact_normal.dot(zt_vec3(0, 1, 0)), zt_max(.25f, ctrl->min_ramp_dot), 1)) {
						r32 min_y = ztReal32Max;
						zt_fiz(ctrl->moving_body->cg_details_count) {
							switch (ctrl->moving_body->cg_details[i].type)
							{
								case ztCollisionGeometryType_AxisAlignedBox: {
									min_y = zt_min(min_y, ctrl->moving_body->cg_details[i].aabb_extents.y / -2.f * ctrl->moving_body->transform->scale.y);
								} break;

								case ztCollisionGeometryType_OrientedBox: {
									min_y = zt_min(min_y, ctrl->moving_body->cg_details[i].obb_extents.y / -2.f * ctrl->moving_body->transform->scale.y); // todo: should this take rotation into account?
								} break;

								case ztCollisionGeometryType_Sphere: {
									min_y = zt_min(min_y, ctrl->moving_body->cg_details[i].sphere_radius * -1.f * ctrl->moving_body->transform->scale.y);
								} break;
							}
						}

						if (collision->contact_point.y > ctrl->moving_body->transform->position.y + min_y + .125f) {

							ztVec3 collision_dir = collision->contact_point - ctrl->moving_body->transform->position;
							collision_dir.y = 0;
							collision_dir.normalize();

							if (collision_dir.dot(dir) > .25f) {
								ctrl->flags |= ztCharacterControllerStateFlags_CollidingWall;
							}
						}
					}
				}
			}

			if (zt_bitIsSet(ctrl->flags, ztCharacterControllerFlags_FloatsOverGround) && ctrl->velocity.y <= 0.f) {

				struct FloatCollisionCheck
				{
					static void perform(ztCharacterController *ctrl, ztPhysics *physics, const ztVec3 &prev_pos, const ztVec3 &dir, bool *facing_slope)
					{
						if (physics == nullptr) {
							return;
						}

						ztVec3 contact_points[16];
						ztVec3 contact_normals[16];
						i32    contact_triangles[16];
						i32    contacts = 0;

						bool collided = false;

						zt_fvz(sb_idx, physics->static_bodies_count) {
							ztStaticBody *static_body = physics->static_bodies[sb_idx];

							contacts = 0;
							zt_fiz(ctrl->moving_body->cg_details_count) {
								switch (ctrl->moving_body->cg_details[i].type) {
									case ztCollisionGeometryType_AxisAlignedBox: {
										contacts += zt_staticBodyHasCollisionsAABB(static_body, ctrl->moving_body->transform->position + ctrl->moving_body->cg_details[i].aabb_center * ctrl->moving_body->transform->scale, ctrl->moving_body->cg_details[i].aabb_extents * ctrl->moving_body->transform->scale, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_points) - contacts);
									} break;

									case ztCollisionGeometryType_OrientedBox: {
										ztQuat quat = ctrl->moving_body->transform->rotation * ctrl->moving_body->cg_details[i].obb_rotation;
										contacts += zt_staticBodyHasCollisionsOBB(static_body, ctrl->moving_body->transform->position + ctrl->moving_body->cg_details[i].obb_center * ctrl->moving_body->transform->scale, ctrl->moving_body->cg_details[i].obb_extents * ctrl->moving_body->transform->scale, quat, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_points) - contacts);
									} break;

									case ztCollisionGeometryType_Sphere: {
										contacts += zt_staticBodyHasCollisionsSphere(static_body, ctrl->moving_body->transform->position + ctrl->moving_body->cg_details[i].sphere_center * ctrl->moving_body->transform->scale, ctrl->moving_body->cg_details[i].sphere_radius * ctrl->moving_body->transform->scale.x, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_points) - contacts);
									} break;
								}
							}

							ctrl->state_flags |= ztCharacterControllerStateFlags_OnSlope;

							if (contacts > 1) {
								contacts = zt_min(contacts, zt_elementsOf(contact_points));

								bool matching_normals = true;
								zt_fiz(contacts - 1) {
									if (contact_normals[i] != contact_normals[i + 1]) {
										matching_normals = false;
									}
									if (contact_normals[i].dot(ztVec3::up) <= ctrl->min_ramp_dot) {
										ctrl->flags |= ztCharacterControllerStateFlags_CollidingWall;
									}
								}

								if (!matching_normals) {
									// we are contacting triangles with differing angles
									// if the angle facing upward the most is the top angle and we are facing towards it, then we need to eliminate penetration on the moving body in order to prevent the
									// physics update from processing collisions and moving the body away from the direction we're heading (this causes a noticeable delay when walking up a ramp)

									r32 flat_dot = -1;
									i32 flat_idx = -1;
									r32 topmost_y = ztReal32Min;
									i32 topmost_idx = -1;


									zt_fiz(contacts) {
										r32 dot = contact_normals[i].dot(ztVec3::up);
										if (dot > flat_dot) {
											flat_dot = dot;
											flat_idx = i;
										}
									}

									zt_fiz(contacts) {
										r32 y = contact_points[i].y;

										if (i == flat_idx) {
											y += .001f; // fudge a little to make sure if this is equal to (or very close) a slope, this counts as topmost
										}

										if (y > topmost_y) {
											topmost_y = y;
											topmost_idx = i;
										}
									}

									ztVec3 dist_to_flat = contact_points[flat_idx] - ctrl->moving_body->transform->position;
									r32 towards_flat_dot = dir.dot(dist_to_flat);
									bool heading_towards_flatmost = towards_flat_dot > .15f;

									if (flat_idx == topmost_idx && zt_bitIsSet(ctrl->flags, ztCharacterControllerStateFlags_CollidingWall)) {
										zt_bitRemove(ctrl->flags, ztCharacterControllerStateFlags_CollidingWall);
									}
								}
							}

							bool on_slope = false;
							bool slope_above = false;
							bool has_moved_upward = false;
							bool moved = false;

							ztVec3 pos_before = ctrl->moving_body->transform->position;

							zt_fvz(contact_idx, contacts) {
								r32 highest_y = ztReal32Min;
								i32 highest_idx = -1;


								bool move_upward = true;
								zt_fiz(contacts) {
									if (contact_points[i].y > highest_y) {
										r32 dot = contact_normals[i].dot(zt_vec3(0, 1, 0));
										if (dot <= 0) continue;
										if (prev_pos.y < contact_points[i].y) continue;

										move_upward = dot > ctrl->min_ramp_dot;
										highest_y = contact_points[i].y;
										highest_idx = i;
									}
								}

								if (highest_idx != -1) {
									if (move_upward) {
										has_moved_upward = true;
										zt_bitRemove(ctrl->state_flags, ztCharacterControllerStateFlags_OnSlope);
									}
									else {
										move_upward = has_moved_upward;
										ctrl->grounded_normal = contact_normals[highest_idx];

										if (facing_slope) {
											ztVec3 contact_dir = ctrl->moving_body->transform->position - contact_points[highest_idx];
											contact_dir.y = 0;
											contact_dir.normalize();
											*facing_slope = contact_dir.dot(dir) < 0;
										}
									}

									collided = true;
									struct Triangle
									{
										static bool colliding(ztTriangle *tri, ztMovingBody *moving_body, ztQuat mb_rot, const ztVec3 &current_pos)
										{
											bool collision = false;

											zt_fjz(moving_body->cg_details_count) {
												ztCollisionGeometry *cg = &moving_body->cg_details[j];
												switch (cg->type)
												{
													case ztCollisionGeometryType_AxisAlignedBox: {
														collision = collision || zt_collisionTriangleInAABB(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->aabb_center * moving_body->transform->scale, cg->aabb_extents * moving_body->transform->scale);
													}; break;

													case ztCollisionGeometryType_OrientedBox: {
														ztQuat rot = mb_rot * cg->obb_rotation;
														collision = collision || zt_collisionTriangleInOBB(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->obb_center * moving_body->transform->scale, cg->obb_extents * moving_body->transform->scale, rot);
													}; break;

													case ztCollisionGeometryType_Sphere: {
														collision = collision || zt_collisionTriangleInSphere(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->sphere_center * moving_body->transform->scale, cg->sphere_radius * moving_body->transform->scale.x);
													}; break;

													case ztCollisionGeometryType_Capsule: {
													}; break;

													case ztCollisionGeometryType_Triangles: {
													}; break;
												}
											}

											return collision;
										}
									};

									static const r32 iteration_amt = zt_inchesToUnits(1.f);

									ztTriangle *tri = &static_body->triangles[contact_triangles[highest_idx]];
									ztQuat quat = ctrl->moving_body->transform->rotation;

									bool error_backing_out = false;
									if (Triangle::colliding(tri, ctrl->moving_body, quat, ctrl->moving_body->transform->position)) {
										moved = true;
										bool backward = true;
										bool backward_last = !backward;
										r32 dist = iteration_amt;
										ztVec3 direction = move_upward ? zt_vec3(0, 1, 0) : contact_normals[highest_idx] * zt_vec3(1, -1, 1);
										zt_fvz(splits, 32) {
											if (backward != backward_last) dist *= .5f;
											backward_last = backward;

											ztVec3 to_move = direction * dist * (backward ? 1.f : -1.f);
											ctrl->moving_body->transform->position += to_move;

											backward = Triangle::colliding(tri, ctrl->moving_body, quat, ctrl->moving_body->transform->position);

											if (splits >= 8 && !backward) break;
											if (splits == 31) {
												error_backing_out = true;
												//zt_logDebug("[%d] could not back out of collision!", zt_game->game_details.current_frame);
											}
										}
									}
									contact_points[highest_idx].y = ztReal32Min;

									if (error_backing_out) {
										ctrl->moving_body->transform->position = pos_before = ctrl->moving_body->transform_prev.position;
										break;
									}
								}
								//break; // only process the highest contact point [THIS MUST REMAIN COMMENTED OUT - THINGS GO THROUGH FLOORS WITHOUT IT]
							}

							if (has_moved_upward) {
								ctrl->moving_body->transform_prev.position.y = ctrl->moving_body->transform->position.y;
							}

							int non_upward_normals = 0;
							r32 highest_y_up = ztReal32Min;
							r32 highest_y_slope = ztReal32Min;
							zt_fiz(contacts) {
								if (contact_normals[i] == ztVec3::up) {
									highest_y_up = zt_max(highest_y_up, contact_points[i].y);
									ctrl->grounded_normal = zt_vec3(0, 1, 0);
								}
								else {
									highest_y_slope = zt_max(highest_y_slope, contact_points[i].y);
									non_upward_normals += 1;
								}
							}

							if (contacts > 1 && non_upward_normals > 1 && non_upward_normals != contacts && highest_y_up > highest_y_slope) {
								// there's a problem with collisions involving multiple triangles.  the physics update will sometimes move the object in the wrong direction, so we lift up just slightly to avoid these collisions
								//ctrl->moving_body->flags |= ztMovingBodyFlags_AllowPenetration;
							}
						}

						if (collided || ctrl->velocity.y == 0) {
							ctrl->state_flags |= ztCharacterControllerStateFlags_Grounded;
							ctrl->velocity.y = zt_max(ctrl->velocity.y, 0);
						}
						else {
							zt_bitRemove(ctrl->state_flags, ztCharacterControllerStateFlags_Grounded);
						}
					}
				};


				bool perform_collision_check = true;

				if (ctrl->state_time < (1.f / 30.f) && ctrl->grounded_normal != zt_vec3(0, 1, 0)) {
					// we're potentially moving down a slope, so do a collision test if we move straight down to determine if we are
					// if we're going down a slope, we want to stick to the slope instead of "hopping" down it which is what happens if we rely on gravity

					ztVec3 pos = ctrl->moving_body->transform->position;
					i32    flags = ctrl->state_flags;
					ztVec3 vel = ctrl->velocity;
					ztVec3 moved_pos = ctrl->moving_body->transform->position = pos + zt_vec3(0, -.065f, 0);
					bool   facing_slope = false;

					FloatCollisionCheck::perform(ctrl, physics, prev_pos, dir, &facing_slope);

					if (ctrl->moving_body->transform->position != moved_pos && zt_abs(ctrl->moving_body->transform->position.y - prev_pos.y) > 0.001f && !facing_slope) {
						perform_collision_check = false;
						ctrl->state_time = 0;
					}
					else {
						ctrl->moving_body->transform->position = pos;
						ctrl->velocity = vel;
						ctrl->state_flags = flags;
					}
				}

				if (perform_collision_check) {
					FloatCollisionCheck::perform(ctrl, physics, prev_pos, dir, nullptr);
				}
			}
		}
	}
}

// ================================================================================================================================================================================================

void zt_characterControllerUpdatePostPhysics(ztCharacterController *controllers, int controllers_count, r32 dt)
{
	zt_fiz(controllers_count) {
		ztCharacterController *ctrl = &controllers[i];

		bool collision_with_ground = false;
		zt_flink(collision, ctrl->moving_body->collisions) {
			if (collision->moving_bodies[1] == nullptr) {
				if (zt_between(collision->contact_normal.dot(zt_vec3(0, 1, 0)), zt_max(.25f, ctrl->min_ramp_dot), 1)) {
					collision_with_ground = true;
					ctrl->velocity.y = zt_max(ctrl->velocity.y, 0);
					ctrl->grounded_normal = collision->contact_normal;
				}
			}
		}

		if (collision_with_ground && ctrl->velocity.y == 0) {
			ctrl->state_flags |= ztCharacterControllerStateFlags_Grounded;
			zt_bitRemove(ctrl->state_flags, ztCharacterControllerStateFlags_OnSlope);
		}
		else if (!zt_bitIsSet(ctrl->flags, ztCharacterControllerFlags_FloatsOverGround)) {
			zt_bitRemove(ctrl->state_flags, ztCharacterControllerStateFlags_Grounded);

			if (ctrl->state_time > .25f) {
				ctrl->grounded_normal = zt_vec3(0, 1, 0);
			}
		}

		if (ctrl->state_flags != ctrl->state_flags_prev) {
			ctrl->state_time = 0;
			ctrl->state_flags_prev = ctrl->state_flags;
		}
		else {
			ctrl->state_time += dt;
		}
	}
}

// ================================================================================================================================================================================================

void zt_characterCameraControllerMake(ztCharacterCameraController *char_cam_ctrl, ztCharacterController *character_controller, ztMovingBody *moving_body, ztCamera *camera, r32 player_height, const ztVec3 &offset_from_center, ztPhysics *physics)
{
	char_cam_ctrl->ctrl = character_controller;
	char_cam_ctrl->camera = camera;
	char_cam_ctrl->offset_from_center = offset_from_center;
	char_cam_ctrl->mouse_sensitivity = .005f;

	{
		char_cam_ctrl->transform.position = camera->position;
		char_cam_ctrl->transform.rotation = camera->rotation;
		char_cam_ctrl->transform.scale = ztVec3::one;

		ztCollisionGeometry cg = {};

		zt_movingBodyMake(moving_body, nullptr, 1, cg, cg);
		moving_body->cg_bounding.type = ztCollisionGeometryType_AxisAlignedBox;
		moving_body->cg_bounding.aabb_center = ztVec3::zero;
		moving_body->cg_bounding.aabb_extents = zt_vec3(1, player_height, 1);
		moving_body->cg_details[0].type = ztCollisionGeometryType_OrientedBox;
		moving_body->cg_details[0].obb_center = ztVec3::zero;
		moving_body->cg_details[0].obb_extents = zt_vec3(.5f, player_height, .5f);
		moving_body->cg_details[0].obb_rotation = ztQuat::identity;
		moving_body->cg_details_count = 1;
		moving_body->transform = &char_cam_ctrl->transform;

		zt_characterControllerMake(character_controller, moving_body, ztCharacterControllerFlags_FloatsOverGround | ztCharacterControllerFlags_IgnoreXRotation);

		char_cam_ctrl->ctrl->rotation = camera->rotation.euler();
		char_cam_ctrl->ctrl->rotation = zt_vec3(0, char_cam_ctrl->ctrl->rotation.y + 180, 0);

		char_cam_ctrl->ctrl->rotate_vert = .0001f;
		zt_characterControllerUpdatePrePhysics(char_cam_ctrl->ctrl, 1, nullptr, 0.001f, ztVec3::zero);
		zt_characterCameraControllerSync(char_cam_ctrl);

		zt_physicsAddMovingBody(physics, moving_body);
	}
}

// ================================================================================================================================================================================================

void zt_characterCameraControllerPlayerInput(ztCharacterCameraController *char_cam_ctrl, ztInputKeys *input_keys, ztInputMouse *input_mouse, ztInputController *input_controller, r32 dt)
{
	if (input_keys[ztInputKeys_W].pressed()) {
		char_cam_ctrl->ctrl->move_z = zt_approach(char_cam_ctrl->ctrl->move_z, -1, _zt_characterControllerGetSpeed(char_cam_ctrl->ctrl) * dt);
	}
	if (input_keys[ztInputKeys_S].pressed()) {
		char_cam_ctrl->ctrl->move_z = zt_approach(char_cam_ctrl->ctrl->move_z, 1, _zt_characterControllerGetSpeed(char_cam_ctrl->ctrl) * dt);
	}
	if (input_keys[ztInputKeys_A].pressed()) {
		char_cam_ctrl->ctrl->move_x = zt_approach(char_cam_ctrl->ctrl->move_x, -1, _zt_characterControllerGetSpeed(char_cam_ctrl->ctrl) * dt);
	}
	if (input_keys[ztInputKeys_D].pressed()) {
		char_cam_ctrl->ctrl->move_x = zt_approach(char_cam_ctrl->ctrl->move_x, 1, _zt_characterControllerGetSpeed(char_cam_ctrl->ctrl) * dt);
	}

	if (input_keys[ztInputKeys_Space].justPressedOrRepeated()) {
		char_cam_ctrl->ctrl->jumping = 1;
	}

	if (input_keys[ztInputKeys_Shift].pressed()) {
		char_cam_ctrl->ctrl->sneaking_time += dt;
	}
	else char_cam_ctrl->ctrl->sneaking_time = 0;

	if (input_keys[ztInputKeys_Control].pressed()) {
		char_cam_ctrl->ctrl->running_time += dt;
	}
	else char_cam_ctrl->ctrl->running_time = 0;

	if (input_mouse->delta_x != 0 || input_mouse->delta_y != 0) {
		r32 delta_x = input_mouse->delta_x * char_cam_ctrl->mouse_sensitivity;
		r32 delta_y = input_mouse->delta_y * char_cam_ctrl->mouse_sensitivity;

		char_cam_ctrl->ctrl->rotate_horz += delta_x;
		char_cam_ctrl->ctrl->rotate_vert += delta_y;
	}
}

// ================================================================================================================================================================================================

void zt_characterCameraControllerSync(ztCharacterCameraController *char_cam_ctrl)
{
	char_cam_ctrl->camera->rotation = ztQuat::makeFromEuler(char_cam_ctrl->ctrl->rotation.x, 0, 0) * ztQuat::makeFromEuler(0, char_cam_ctrl->ctrl->rotation.y + 180, 0);
	char_cam_ctrl->camera->position = char_cam_ctrl->ctrl->moving_body->transform->position + char_cam_ctrl->offset_from_center;

	zt_cameraRecalcMatrices(char_cam_ctrl->camera);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal byte *_zt_fontLoadFontPng(i32 *size)
{
	// base64 is a space efficient way to store binary data inline
	const char *data = "iVBORw0KGgoAAAANSUhEUgAABAAAAACACAYAAACV4htIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAO3BJREFUeNrsnUl2K8mVpi+fokt1IX+SSlmVqRw4J3mqTo38TWruXAKwBGAJwBKAJQBLIJZAn9eEPqw6NaEPUqlUm88VoZAUoWhQcIVd+cWldd4ABPn+7xw7BAFvrf+vXTO72u/3BAAAAAAAAAAAgBdHeggV//Oq44mNtWBm+S03v00O4f4Q7izH3B7Cynx+a47VbEyQZOb4t+YzmWe4V8c8mGdovk8c79D8voh415V5X/l+ixeUCWYqHRMTb/tAGj9Y0ofjX55/a7nfQ+D68ti9iv9bcS4H/RwL8du9uEdqOXev8mgaeP6Y+LlkchX/d6qMJCqO7xxlaGb5fmOJ25WjbMv0ySzptjfPOXOkqw6+9H3wvN+9yF8bU7fovPRWvKvt+nlEPOQmLu/VsfeinuL8njnS7s6S11Nx/Y16VlkfJ47yuQrE770qf7p8LALn6/yj7y9/f/CkL7/fvaO9Sc35tvz2Vjxb7qjjby1pze/0YL67U3mJ34fbu1kgf8rn3VviMHU8PwXO3zjyymxAmxDbPtrOS0asrxaWMhnTP7mPqMNccZsHjktMPgjFz61qP0Llmxz54l0kV/XOS+M20Id4sHy/CLSr7yxXV1fW0PxktE0TvnMI7x3C+4fw4SH8wyF89xC+dwjfN3//wfz2vjn2O+L8q29v5bwXOA/JO/COaaCdGKP+OWrDuhgAsoiEqE1wJWBt/ibSCmFe/E4IUykQmkpvfQhbUQE2L7BUne/yEF6bay8GJMC96dgl6r1mJgJfQgM1U++xMu/72sTrRv1+Z0LqiLM7E0dNjfjGYjCZmPS7clxf5pGV4/slV8YmzNX1V+a7K5O3SvNbpc57bb4v1PuTeP6JaohvxfvNzfNnzyStM5M+W/F+WnTcifS/EmXK1jG3Ge4KEb835riFir/M3PvKxKXsoMvzS3Nv2SHXaXglnpO5Ub9dq/dLzXd8fyly60BdJq/H9ynU8XPx/VYdU6u6KjHXqdX9YsvrzFI+Zo53SFT5vDHH6jpSl487FX+1J31l+uj8pe//WhhkSKTJlYpHV/xptpZ3z809tubZZFsihXdp2pZaXIPbD/5+bY7NVfw35+5EWl+pPLy19VlFWKu2xSfcC3Vu4RBPQwzVlbhOH+qR662u11uIOozzWNbj/X0d0DSiI5o52jbf+9jqs3eNhaknqhf8fpmo77aR561FvRqqJ95p9vv91SG8soh/NgB8oIwAzd+PTPjQ/G41AjTXRgw/qWHwwdH3fJQNOoYxz+9zP1sdmJ8gDm9F/P29H9TFAFB3aDwrh1CsRANaqQ5mZSrFrbnXRnXUKvN5Zj4XqnEuzXmFR6TXEZFUm05uKb4vzXcZ+a2wbwMdsJgRhHOJ/60SD7LDW6mGZu3peHK63oi42qrCeiM6vFtPR3PV0/q3EHmnYarST1cmZDrv8ruteP5CdB4z8/tSPH954oZ4Ro9HYV2sPAYVfp+piH8WLtKbRgvSqUm/1NKxDVVOhbl+LuJ2YuKvFPmhdDzz1FxjrHLC73Ej6pypyOfn7gTOzP3rHu/hE/sLcntt8Dtz+qw9x0vRm4r8YTvfld+kKM+EAY+vP1UGvCEUFrGXm+9r1ebIEUbpCifjY2bO24rry/yYCIOmq+xmorzFtKu7EeqTjbln0vNahQjPkVSkeW0E05jvwkauZeC4a3Nv0I3kBYt/WSf1fcfShAxZxS7+hSGNhf8HJnxEj0f+m/ADE74nDAIfivPeF4YAGAGertzcUjtwfA6uIkPXc2PrwduRjQC3FuPJpK8BoPb8VplQK3HP7prsgiDFMnc0d0owzsW1uRNZUzs6oytHKThKTyNeeTrnqblv5Tj3hh6PsmQqHuoLL1ATE9eVQxBPLEKvCHQcu3R4Ekc+yk3Hdek4x+dZklG8RX0iDEoybXN1vUo9b6Xe+RQNMQv/lUgjm2v5XpSpHbWeKy5DwM5htOF434kysKfW/TZV8VbRY++YkKEtF0YVUmXcVU631I7ijtXxqi0i95yw8XDpeW9ffGqBqstg7RDltve3iWZf+nU9X9fN2uBXjdjZZ8NvbnlmEoYmft7MUga2Iv8vLHUJ58dciOutpx3palxaRxrXfPUGmby17mk8YwPf1vFOb8k9RUrWHS73e1mPPVjS60H8llnqK9cULXaxz+l4OgZZjuHpLeyKrdtx1zRC+ewLR/y7ppfZDBUPgWNI9Z/uRNwsxOeEjqdfup7fNwVITv1wpV8uzn8r4kOnvZ6Gl4p7vFXXT8W196L/padYzSzpuRHxt6HHU3Qm1E5LcU2/uDPxMKPHU0DkVEfXFKG36vn3HfIAOJ1wk+L/IyH6G6H/w0P4EbWeQiwqf2R++wG10wI+shkBEMWDhWiXtkmK/2dpl+p5XhcjAHtbph3Ef9M3mfY1ALh+Y9fruRJxN9S6lV6bG7M1fS06gyuV0KXo1KxM4GO1mFiKToSvc//GIoY4wmM6bpU5ZmZpQPn5UmX0uDRrmh6dkm7QqWn4dgOf3WeEWVDrqaEb9aUj/hPVubAZYCYUniuXKMEr889EdLYqOnbR1WK4tlRKoTm0E8/vueiQ7Ew54fvPPRZFnupwY8oVd5QXnkpzZu63VkJoYs67EdfWBgD2EpkEhMRExHHaQ+xVljjvS3oBRjmuE9Y9DQ87IfAXjmusRSda37t0iPLUU0YrkQdc52eOMjahY/d9rsNPNYVKehzxPLpC1Ws5tcZkNghUlvizifudKCMzTxpyuVv3yO87GjZ1bS3eo+phoMzJ7pnCdSZPwbo2195Y6rfX1E4B2ahOSE7tFKCdyAs8MLAVfYKJur+eYibvL6fbyOkYMm42oh7lwYIrlU4r8/7X5hyZFnJqmSv/8X23EfVAQa3HXGz6XgsDID/jRD3/3PL8eooeTwFaOdLvWqQJic+lOH/iaeOuTZDeNxsRR9d0PE2zEPEmp7oUHcq+njubCcOgHBy6p2NPHul1KgU/0bHHX6I647J+0dNzlur8c7BQhrWE3FM2Xxxi9P8Vte7+LP5/IET/jw/hJ4fw00P4Lyb81ISfmPz/I2q9Aj4ieAGMKf55qm5MO/fcxf9QYowAXLcvHOXdJf7/7g37qseDVT1fhkSHUl9jKhqQTFXmsoJ1uVbKzt+0x/Oxh0FMo1OoBmduOiXcSOTimfUILltr9h0MBGNamBf0ePRbi/C1OaZvwXO5wHIjNTNxVqvOC3k6T4nogMwdlQh3MHmOsmshQ1s6V6KjkKnfOb60C3AXA5mPjSmohRD+fa5VCEMAG8MySz7f0PEUiUQIBukCrBfBZG+DreX9ZR69p+M50EmP96lVvWFb6E9zR/FzrWwVaWgRw6EGgISGuXWthTAvHB3hylIukoh6meixZ8k0kH6VI/7einpRPvuc2lHWsRv2UtTh7OEj1wDhNmUrDFjaU22njC22+J/RY281mxG5T/mVXgZdWaq60+dd48tfpaMs3ojrV+JZ9TPUdDwFjPP8xKS/NOpPhVGF6HiKWKHa9oT8U8xCbXslnn/tyHtrUdfvaHwPLyn+u05/2Yn8uiO7B82SWhdzPcVL9rFcU4CWQrSvRVs5UeW59PST5uLZbkT+qVUfcGoRyH0NtVzWJ6o92on78UhvRseefpUS6xtq15ySHq87Op6ClTvqAJeXVyqMEkMo6LFnXGbS8o157ltTB9f0sqdUSFj88+j/h0r8/9iI/X88hP96CP9Nheb7n5ljfmLi94cwAowu/mV/f/GCxb/sg/bpj2ojQOaJ11S1L2ms+O9qABhSmaSqU19bKvE31Fpz2Z1ZC0tb5zen1npfUmu57rIickrHC8fFiJNMPT93fnQHUY7gVnS8mF1MnGoLs1xsrauRIyf/6JX0nqh7pjM3oJWlg3UlGqlMNWBLzz2vRAdmS4+9MEh0MAvH7yQa4dIiHuUIh17kbErtyt9vHXl4R49HlWJ+r5QRymYg8E0BsKWBHAHRabxTZagW5TNTBjVZxtgN3NYJkXl0TseLwNU9KnI9TcS2CKDmhuLmW8lV53PH9ccevSmpHTntO8rLwnQbEHF6wcA6oi4jeryAYhlpRJDxdyM61JVF4F5T6611O2L8ctzMLAa8SrQfXD/MLM83UYLTJtClALMZPonipyLZ8khBl7nIV0bHK5jbXA610VTWRWRpt6Wh0eVhIo1n2kCXdIhXOb1i5ki/U699wJ21PvkjZrHQ0pN2ui0oHX0Y2+9ZIH1ivuepkzx9wGVUrAeU/5l6ZrmmDxvWatF2yYEo9lKaUetJoq8/UUbcwtFWF6qN5x1FigF1g6zfKxOPM/F+r4Vh7LXqL71oLKP/7PrfiPePhfhn4f9Ph/DPlvBP5hg2AjSGg2Y6AK8L8B4d7wwA+on/GCNARs975F/2QYcu8OqbVl5Z+v53seK/qwGgryHgLbVzytgFmt2hM0dlPhWdOVmRsuVaznOTKzKzGzS7TpRnSnBenXVqKuHbC8yU3LgVjvRcUGvl77MgD7udFQEBxSMVC9Vx5g7mnRBqM08e1Cu4605S4okD3fFPxTPbDAgs4Lgw72g86/raGL94ZXrduQ1NAZAi/V4YU24sz5hYykRFx6OjvMVYreItV+njSputuf9C5KOuo5ppoEPZVVjJeoRdVM9JLYx/vvlaoWu8DnQibV4ANdmnBcR2uF1lyTZix/XLJJDf5xS/5VesKCiEkXNnESXs+VPSYy80OXpP5PYAcTXGbPBa0rDpJmu6vK3QeP449RAXY029Kan/oko8aMAeQjMabwHKLvDo/KWObJ1ymhS3n1Nqt9Tt4qkUYwBgb4UZHXvxcF8hFW3cjB6PkKfqr83AOBEGxtoiaFJL3lpTO21i6MJe3Cd+M4Ix4aWIf9tWfzznPzFi/mdG/DdC/+dC9P9c/WVvgJ+auk56AXwgjADwAhgm/kNGgDWddwrNpVI5+vHMlOzre01ir9PVABA7ai15LUTflRCIV+SeS1paKj52gVuZa9ZKZPCL8hzCdQcBIRuJGKGrn5Hvx/cfsqDTKeBMsXV0TLjQ1UJMdh0R4XmGXS3PWuDeCKHm2jFAig/bImC2EYbMIYCTDqJH5sdy5II+p2P3/UWHtGWrXxHoHMjdGKRo5JXeeY7uayE2ecREG0BiFygpyD5tIgvE727Ezmd2RlHlm/KwFiLgVKzVu+7IvgJsTfFTnnJH2lWOzrL2QsgdYiPWAJE5yn/leE+bkatU71yp/MZxZ/OiCMFTM4Z2ytlAcUl7wfN0Cbk+QOowFMjPNR171eWeui9zGKhk+icDymMu6q/X9DQ7HSyFAN6c8b6lJf4ySznJHL/bVp7vs74E5+8p2T30QqNcmSN/SCPPhI7XnyHR/vg8gHjNBJ7vbzMAboWBwTaIwAMoladcD+0T5uJa4Nj1Xy/697EyAEgPAA62/6UBgL0AvquMAH+bDgAjQLDdiJmm5Vqv6iUYAYbkj5D49xkBoq/zqmOC7nt2TqRI1yNHvACabBA2qvOgF77SiwXmopMvXTm7NJJ15Dk5PZ4uIIVV7elkXJPbRXw2IH5l+kwc164cGUXOceOGMusowHhU48YhAuVoft7RwMD5YyP+1wtxbaldAC0zv289nRCbAWQlOhpagG5EB4RHx7cdy0eqruMSAG+oHUGfRVagJM7z7ZbwYBGfvG2f3H9UzpXkBd202HKNVKZCEJXi+htxTV7FObU8I3vvjLVK/47aqUFpQIz0gXdukKvMFwGD15CpACG2lrRiAx2/O3d2YwQ4j6xPVJ4rHR1R7YUwM3E/E/ljRfZRNFf6ER1vC7uw1E+FOl7X74Wq6+UuH3Lu/prsaym4yMi/MGCf/Dqhy/ECYGNoKtLeJpBk/Sl3UrCV/4UoM1uVvrnKa5yf5Mr0mw7pk5ygzA8R43MhGM/BVrTRsvzrtSo2og6T9YMuf7OOfauJ6t8log9Fln4c/75R5XUm7p97yk2t6gD22knp2AOoVHm3pnYB64WlnZZT33aWdn0d6DP1mQpny8uXvsvUOWHx/z4du/7zav+vqV3w72dG3PN8fx3kb805PzbX+JiOpwJgV4D4duw6MvgGTJ6bEWDvCWOL/5ARIHidV2eKFHa51HOvuGJdm0qUXemlmJQLX/E8pwdqXbp4pP/efM/uZl0afe74LQKVdEr2baLG6mgN6ajIBdP097PAM7PbGs/Rm1O8lTkXHVa51c+DyIRbahc/vKPHi1aFBAi7DPP5W9Xh5jnHDyYfbB0GANsCX3J7R7mI3VzFK2+DlJF7texQR2gW2fHj+dIxRpJ1h8oicQgLnrpyJ+JALqpWWCp3aTDLVbpXyhg0FUYGnns/peOtCHl9hZQeL2JmWwTwoUPZuBH5g400y8j4TdX9pCuxFJ5vTbyFrlsIg5XsZD4MeD9bnpD5m0ceufzsOjSs/Ly3wnAzIb8bNXuVyDp6o/JHrKcQH5uL80vL/bnjXziuUap3qpQBbavib0ZxI50zIZB0Hu1Tl7PgndBlsDVxx/nT5knGxhyuO/Q0sCk9dsPfCnEm03dF7UhsQsdeZW9FHVx0yD+1JX26CHC5q89qQNpy3bk218lV3Ubi+mN5CcSW/0LUYZX4XZe/rt5ZfK+VqONrS/ndijS+o2MvoSm1BnbOO6mjTXJ5OZbq90oZNObiOXbCIKLrDN2HWNDjXYpsa/QkI6XlO7GyfyRy7v+HRqR/XxkAeOV/Dj824bX43XYMbxP4Q2q9AKQBYOjc7neBKiKEDFrPyQhwFRFCGrCr+HcZAaKu08xluaQI3ChBem7uA51T30j3GNzR40VkxjC+LJ4wTsGxyCvpHVmgB7wo2COl7mA8Aa2B665Dh5GN4GtPO1FF1ukPHtEwp5c/l9jWp+BFXl+f4H63okP2HJiZOLrqWBes3kEBdC8MOH3OLQNl9sFce/tE/c/nxgcmfNeIdOny34zmS5f+5rcfGCPBB9SO4H99CF8dwueH8Jlp335/CL8+hF+Z8JtD+J357dND+PMh/NWc9xWS4SzoqT0uugraK8v5sfVal2NjGerlw56u0xgjwqsLS+T5EwtVXu2dR0AZ/i494fPxFIaxO2QVQfxfEltEAXiGsKdV7NoBwN5h4LAJ1BFrZUDo61kg1+7Q4V2oixJ6vAZI3y3nXAJaTq+ZoHy8KNgYNxnYP+OtCvtuL9l16uS7AHsANIGnATQCnxcBlOH75vvvmmOa8JH4/F113g/N3+/R8U4A37lA3fQusDvjvfaR4RQMbZcaDfuGIj0IkJEfi+U39Nj9neeMRUdszwp+Spjj9VJZkdtFGYDnYgRgV+K3iI5obFu5zs94/rsMr4sip9jwNK4xKOnYvX5LMPK+JCamrrsd2D9bUjtVVU4hC7EQeatA3vIaAuROACzqpeD/0BgJ3lfhA/PbR5bz9OJ/cPu//LzQJYx9/vOKrAubAgAAAAAAAAAALj40oRndb+b8N67+eru/ZgpAM6f/YyPqP1BCvhFAzTSALw/hL4fwR/rW4NNMAfjlIfzChP84hN/Stwag5phmygCmADw9p3DDf2d4D1EAAAAAAAAAeKbwqCzvDiDDK3KP3r5S5+jPWPH/eYv/cxkJ9pF5VBOzsCcvmAsDAAAAAAAAAADQ8Lna+ni4Rz9/8X9urjoaCJopRreRBgDflomhBfQzsuzwhjUAAAAAAAAAAM9Z+H9jAq/uL/9+I4LtHHken/O1OB5cnvh/7umyo7gFDtcB8T+jdkcXm/i/U39hAAAAAAAAAAD0olmocHIBovAbI9ybLfq+MOFz838TvlTC/msh+L9U53Hg82AIuEzx/xKmZkwDRoAlubceZfHPaCMAi/7E/J+Y/9NLNwAsyL9V0jlpIu3eUslNzPcJyqWTNPDbjPpvjQMuK50n1G6X9NR565xkqAPAC+Phgtrfl05+QXUZAF1ZUfyuBjYBw7vKrEQ7uqF2e80Y4f+1EPGN6P/zIfxJhL+Y778QBoG/CtH/uTlGnvdn890XMAJA/Hd8zq7TUFxGAJ/4d8FGgFyJ/0d0MQAk5qIbS+MlX3ThOH9iHob3ML4l99yHibmOy6WB77lSBoNbTwW1N52a1NPh2XsiNPN0/mcBQ8bDM+zspSJONoHKf+9Io7fmGjYjSWq+3ziMKzoOXc/xEJH/NuY4W2HYRBRWfta9J49xXl28wIqX5w+tHJXJysQvl+kHVTZtlaOrzNyJY+4c5ZUNcg8mj+U9r3OnQhb4PXc8x715jonnOXKR1yaeeIn9Xl534YjTXLy/r/N1L/Jw6H6ZuO7GUVZC9cZedfps3Abq7IW4zr0jD+SBZ8kjGmsZz3yt1NN2zCxtUyaeIRG/Z45n43ydiOstHPdMRB08c8RPKG/Z8uSO4kb1fNewxXM+crvVpzO+GfFZ0kAZC8F1y6LnufuA8WBjKWOJo63KIzqs+2fQnwHjkpq89rZDPpfHpwHDQVPXVKKvfG++LyLrHh75/8KI9s/o25X6PxXhj+Z7FvZ/FoLfds4n5u9n5vfPhRHg1HvBg3jxvz/BfboEG323C9RGgBjx38zp3zr0iE3vNNMIbkx56+wBMPM08mXg3NyEWoj81GNo4GvOLA31wvy2UM9W"
	                   "OO7Lx6eeTmnFkeLobJYWC83O8hwSrsgSUxle4kg3jz4Ulg54KuJ2YUknX8eFO7uVee+FJS8l4r6LQL7ry0LcK6e4BTds75KZvDuxPOuEWlecFb2skTN2IeI8sHGUr8JULDfm88JSbjPVqYjJm7eONM1M3koi4jt3dFxyFZLA76nnOahDuo/tLTAzeXM7II2TDmniI1Rv6HhYWI6RLqVpRJnNzDGJ41lqaufInYJKPEdqaQ9r8S6p5XNlaVe4vuJ40PVzIe6ZOY6JoTbn1Y5nCBkBCvH8iacO5lWMX6KBtC+cxhXFzQPtWzdMLPedjWyMeVdFybtgDOHRxLJDHVOY43NPu5gakdMInzfmL7fpMeKHxf+XRvz/xQj8Rrj/wdQ3b0Xd8wcj7D8RIv8T8/0fxHFvxfFsBNCeABD/lyH+x/YCuOoYxoaNAF1G/ueRfT8W/70WAazVX935cf2uO/yVp+PDx7EwnHsiobaI2J2jc8jWlIK6u9pNzPO4GmjZWdOszW98fnWhBoBavV8iBO9NZMdfdzC44z23iD/ZWVwHOo9ZRJpVokCuHYLF9Rxzc961J09mgWtM1O+nmg/HBqyh17/vkJ4sjG+EAcRWrtdCaKcOkZ86jAE2boTxKPGkR6HElO06dcQxN+Q2YvLvO89zVB1E9CkMeEMFREZxBso8UO671Bs3QqTY7sFp55tiUZi6XdfBqThnKvKSPvdKNJ7zno16FRD1laoXQwaArYgXFog6b5bKSKUN2GvzLtOAcaAURjv9fRVR19wEOioT83xrUUeMVT9uexo9xjLGDTXkTUT6Vyd6jxuRB2R+vDHl5lSGjdg4upSpU4njuwlhiqKs02NFyVrV3y6xs1Z96TemLxZznz21c/jZAPCZMAA0Qv4/D+F3KvzefP+f5vPvLb+zEeATar0AvqDjBQVhBHhZ4v9SmFJ3t/+QEaC29XHHXAOg8lQeC1EJyFGhhB6PCMjRklIIdx8z8/J1QDxlnmNc+yzmonJyGQBcoq9Wx/iej102zy0gJpb4TSKeV3byKeJ82wjTnMKeI7GdxdA87Nrk0dpzvisf6/dJHL/7RsJc7qoxbqzs5vtA9lHMhB6PVstgKwsut3ZbQ/7avHsS6KgulDghjwEg7VCnDO0kloF7FmQfBY39/SmZKNH41AYA6hBPRUReqCPygC19a5XXlnS6UdaQAYD/1x4AiefYMtD2FMp4UgTyRx+hvKPho8Qrar1TuI1ejWj8cuV7dvP3zYHckHvqDv/umjrGU9zuAuWB5zLPHNcnj1FETtHxrYnE75E70n/iELZ5oE/VZZqEjO+31E7teyD71Cp5rKuN8k3fuRVpY/OuzET68PQ0V5+Lp3Dp8/k82xTFW/WctriYkHt6yF60v3tLmeBnn4hnu7M8p3x/W1y9Fc8np3vpZ917+p/JgLavPqGRR67aL+f+/1EYABpB/9tD+PUh/MqEX6sgv/utMBD8gdqpAzYPABgAnl787y/wmYduR9mXXaCv9ahf3tUAYLNU16ZztTV/S0sDJOcOywVDckvDWJmHzSLFHzdmu0DnkJ/B1WHYOqwumRCPrjhxWTmb97g2Qnd+gQWMR9fH7hjziPy1iJfSEjdynmnp6cCGGp9UdDZSzzE31I70u8Rp6clDWeBZx4aF/1vTWWEL+c4SR3eeoLk2ZTUj9/x3Xca5gxIzalQGjCx1hAEgjSh7/Dw39PTeNUtqPQFcaXmKjpDPm6qrmEo6HDtW/u5iMOgSB7XIh1x2ihOlfakMADZjMnuIZOLdfUbHXaBhr8Q1XQJfuvD3qeMLipsG4BORbHypRV8hpXGmY7gWTuLpHmxEWQWMSzPPNTi/LxyGlZBRn9cP2ljq2K3IP6Xj/nIKXRXI/xPHe/SZAjARfbE+ZXom/s97PPeK2kEg1zukwpA2sby3PsbXD6osaZeIPuFsQP3m6iOFjIDy2bmv5poutHKU81IZHktHf5tGqovPLbakEUBPA3hrxHwj7P/jEH5pwr+bID//uznmV8YI0Jz7iTEA2BYC/Obq6goGgKcX/5fkBfAUUwZkHXYbqM83Qw0ArkZ0bSqWtaWC2dKxG6J0pZ3TY/c0KTI2jkqUG/ZKNVSJoxPDVsjCYwAoHJ2JNKJzXXkETe2pVOXIbSoSMqfzzM8b0jnseo/SkWk3qjNkM1AUkfkw8TTUPJozC4jT0mEcItHI9hltnZLdY+LaUTHwgjhS+E8dz1cII5MOU0+ZlYaAezqev23Lp+XAvJIqseIzOnDZDxkcusxLdOFbtDDm9yTCUHFLp90qaUh9UXc8f6y66X6E+ofnmNaWfLAU+W51wriXawAkjjJaWeIu87QPhTiv9LRZ5DEA5OK3PgaiguKmAfjSZqfqyy2N41ngEytcr6xVveOq12OukfW4Bhuvp45ys/PUYXraWU1ut9D1ieqTPu3c0vG563OzKF8G0jA0hXAd+czXDvHOU2SWlvacy+d1zzojCQjzVPULXQYATi9bHajrncoSP3PVV34WGAEuFwHktQCkF0BjAPiNEfeNyP+FCfozGwR+Y86pzTX+LMT/393/If4h/i8IvdWfi0eL6nc1APSpHKTbdamE+o7cI648r/PWUWGzoOJVRNmNa+Z57pJaz4LY0a4Y96e+bk5y5HYmhIJr5PYU4vyU4j8VDXkR8Syu74pA/ipFg5wFOgKLgDitPB3p2tGRK4VoHUuoroQAnpLf64DFpy2EpnHIuXout9BsJENRSsdeRGkgvohOt3Cbfq5kwO8zUWb7GALHagSGCliKEIoljTcnVk7zGsrOEr/S4Lug083lrVQaVJ5jZHvim1KTRuS9wtLGdq0/Y+K1r1ifkt0A6fp+LHgth3SktF3SsCk2z3UOeU3vBrXHsLMhvxGuL6UyAFSBOsUl4KXoLzztqG+AY+YxZg31MItp64caAb6h460AG8EuvQCaaQA+L4Bfmt94CkDj/s9z/5tpBX814v9v8/4h/i9K/L/raeES/zW5veM2QwwAXSsCOU+O51zl4reZR7AV5B4NZ9enTHRKS4uQXNDjValvO1RIMeK+7xypHbULjG1F54i/i0HO4eqacU7h/q/jnsjvdXETMADUZF84i2nOfxPxLKH5xr4GcmK+dy3ytz5BPLI7+YrC2yR2nQIgG3eeq5lEvEdsHnd5ESQqrn1lcEmt+2sWyMdDRxNDixtdjyBSpycqa6ERytjOKEV2csd0o39jwhChsQvkpaW4/im9AMqAEaV0xGHlKdOkOv+u8uhat2QMD6+h0wCeAt6hZjViGdsNeJYVPU/e5V0CdtQu4nxP40/fkgLfZhzW65rknjraV3+HPABkP8tWtz+odqZv+3Tq3RL0doC8IOAndLwWQDPC/ysVfm2+/x0dz/3Hwn+XL/5jvABesqfAhtxb/U3JvUXgpI8BoE/jV9JjDwASFU5pOYdHPbaBhoi3/vPtQDARHcFEVHaxFt2K4uYr97GQchxIF81SfBf7fF2O1/FyqnmxGbXbk60dccZu5ZWjgeV8sBD5ILd0UvIRnjUkgHwjuKnJq29GjL8ttetH8FZoLkNA1ykALPx5SkRzr9dKLA0RY7b5sZlKd6K43R0o0PlakX/kPVbkVIHnqAOdnKdag4DrvyFloOpg4BmzvihHvEbmaB8yUf90Weegbxy63qtWv9cBA4DeMreveCsG5k3OX8/JAMDz28dyjc+pv4GtMnXrTUcjgly/Yqyy0qVf8q4bALjPuDuREUfWW2Wg7SvJvVaArB9yz314bZLKkrd5IMg3Falv/h+yRWkUEVMBeKs/XhNArvrP/8tV/5tzGg+Cz6l1/cfo//MU/y+dOT1ebF2u9m/bHYCn4XU2AHTZm1A+DBf+Gzqeb2TbemtmhElM4zOhsGteRsfrFHStjLSrlkuklk+UAdiF+6bjeRNPpT8GoUXjFvR48TndOZ/S8VaQNkPHGNMlYtzcYkToKVw9pThnQ8DE0lnYOoKt0ymF/7WlErGVgZgO7NQ8K69rsLPEsVxHIIsouzRCHs0i0vc5Uw7spFUd4qe6wHh01dELao2MMeW4q0ByGQBCHgBy0TfXlKNE1M99hNiYBt6x5uyfi9DOPV3bhqHeBOym2cWIshVpX9Hptuwjj+h7im1NL0mQ3Iv+ZeqoB/rWJyGDYaXKn6tukdsk2wyccuDCZzxwlRWfh2aXeujmlImlpgLIXQH+YgwBnxlh/6kwCHD4lNrV/v9E7aJ/fyWx6j/E/0WK/3c9TbhvXpNjqz9lBNgKDd7ZACBXxu0jsOoIscWNz0Y0ukWPikt3Djd0vOpsbGd5F6gAx1pIj/dtrgIFpYsrlWuLudDiepVIq5WnkfKldy7S0bYVTiXiLyX7KCsvIFV4xEepOn2uuXQ+F7iQBwC7oq8c16gj7nHrMFQ8RFZictG+oYKYFxWcR4q51FNmSiW2MvHZVgesqfVK8HUueV6Tbw/0Ddn3QLddpwwc08eAU4v8c4qR5btIYV6o/GcTRA+euoMbj1hhf6p6w5a+acSzuQwglWmvVgHxHvOut556Sr9nFcgvVcDoIsU7u+B3FeAcFysavg3RruczPDUh0T6LKNt5IN/MAiJP7njQJe/JVeindF6jWx1Rp5ya2LgLCdO+wpV3otoERLprnSpOQwrUua46QNbJpeUc/X5bz/v6pghMxLP6FhLr274l58owwgjwNbU7A7A3wBfKGCADi/7PLcKfF/37Bjr9dEk30ud32QjA0yld/S32Bj7aja6PAaBPhZrS4zlNledlpqLyWDo6nDM63kaHreWF5cVrat3Rl+R2OXc1BHXAAFDTCV2cTkCM0WIuOpIVjb/S8Faki2zA+nROZWO7c9xnIQSoy0DlKjzLQFxs1TO4djQY2pliT5aheS20qKDt2WceA8DavBsLaZ8BoFKGuSRQ9m4cxpBSiMN5RGfWt+gYTyNJeuRhFhpJx3SMrTdD7+cTwPpaoUUXy45l7lT1xpqOp16FxKfr/Zfq+5Cni2sxMM6rvrSoIgweJR0v2OlqB6X7fsgAPZSYUV5fG5jSGTv5HfNnGhAhiae+3qp33jnukQTyMaedbQcVrpuqgCEgtMXtKbz4yjMYAOrIuKs8dU4WSJ+s53NMRTu7dtRjLtG9C/RxdRz7+sJVhICvRV038dRNlacM9G0DL0tJttMBpBGADQHSGPC5EPxS9PPxfD5G/sFzIMYz81EderXfd8rbfUe75d7I3OkPPSwv3jf3NN61pSNTOo7N6Ni1rUvDuTCdfL2QVxMft9R9akRfNqqT3Zd7at1FQukWuw1fH9KIBj42X3LaF4778Ehx33eRC07WHoHvehceJS4seSunE7vIjZBOeUAkyn3NSzrPCtKuPddjyR0CzSbEfNfguiWjYauFh+q458JY9QaXmQ2183H7ltuhUxdSenlTSPbKcLMNtD1NPft6wDXOCdfVoToiofA2vaVHPNUnKgvsubKjdiHUbY+239ZnS41BoXgG7Y4r7u5M2rzxiONM9HdO9a4u78FLqrtXpp/RdyHaPfm3O9x74pcNV6OP1B6EefjB93s+SP69ctRhf/eUihX9HfUTABfF1QVnYF6c5BI6FLyq8NpiAFhQOwfj1DxQ99HbUwgnMB535J6rDwAAp0JuW7oNtCu5OV63P12u0cUgYeNchvZLQK6+zh5YaxpnLYCFMC5Mn2n8sAHgmvyGuedi7Dil+Gcvy+uefb4H0wd+44hrlwGgiXsebLpGdQsADABgmCECoh1pCgAAL9kgYWNHz2uq3RginZGLPQ2FO32n2poUBoDLgcX7fEBaswcBOeLRZgDg9GkYy3AFAIABAAAAAADgxcLTV7psWxzDc1y3yBY3MVNJ2Qjwrno8dp3u6sszPMVxHWEA4Cm8ch0TAAAMAAAAAAAAAAAAAIABAAAAAAAAAAAAADAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAwAAAAAAAAAAAAADAAOA9lr5d7fNKfLcX3wMAAAAAAACADd5RQNPsLlAhegA4D+85vn91CN85hA8O4aND+L75+4E656tD+OshfH4In5m/zf9fH8I3iF4AAAAAANBBHGL7uHhm9O12kSEacb2lp90OsdkecEWPt2Xk7QrnA66dmnioTKiRNQBwY/MAeGVEfiP6f3oIPz+EfzV/m/+/Z35vxP+fDuF3h/CLQ/h/5u/vjDHgKxgBAAAAAAAuWnQn4v/diOIp6XCtW/MstTlvSY/3nAePRe8DhUfOU2EEuKGnGWmX4n+nxH7zDkUPA0DzXjOTb1LxfXOP0uSf4gnTJxGGCX6mMeJ+Zv5uI4/PzXOEynbqeT79W5djbfEyMccUHdK66lDXDHk+V/xpth2PkceeKl9m1BoEvfnD5QHQjP5/eAgfH8I/H8L/PIT/bowAPzqE9w/hy0P4gxH9/9eI/k9N+IsxAAAAAAAAgPHF39ARz3t6PHrcCLU3IxgBFiY0Hd1pRKd1YgTb2gjFBT39iPWp0i2POK6LOFp7OvtsJFga4XjnMAKkJs5zcf9dB5EZI/6XQrwOpXnOW/O5oGNjEQvMO/P8c4dgvKNj41cXtuQ2UHFcTizXLwbGaxN/m4DA1M9yJ8qZy8hya55t67kG55vUk484bXJPuV+JfHBNcQYs3/0W5nrXkceHns8Vf7bflpHH6OsV5vty5PrlVhkitl0NAA3N3H72BnjPiP4PjGHgffPbB+YzH/OKjtcIAAAAAAAA/ViZTlxlxMTMhKEjnhMjCJZCZCeicz5k9J0FH9/nNtDZzoTo5HeZUTcPAi3++Lq5uUZl/t+pDnnMdTiOi4EGicQYXWJFZ2nibYxR49oIojuHONqYuKqUSEoj4mshxEbtEf9rjwEgVcJWGkLWDvFfGkHLacv5aKcMSYkl/yUUN3XCJwx9honE83sXAaqfeaHidgyPHfa+KTwCOO0oymPKfWw833nim/NX9QTPlww4JjfPx3m1bxnPzftPLfkyFW1Ioo0/70VcfN8hAAAAAACA4ciRxLX5nDo6mSwq1g7BlghRzuK4tlyvthgYunRQM4uw6tvZ7uqqq8UCu5vzqDsbFniqwdIhehZCONpEdN9Ru8SEtTBOMDwyzOm0pnYUeyy3/UoZAd6IPMBuyTdCWGxMPNQOgxAbo1iE3tOx9wiLs0LkK5+QqS1ill3XKxGHG/EuKdk9WXhKQS2MWluVliX19wDYBcQ/573C3Ic9drhs9SkTM4vAG2qsY/HfR3yfWmTHin96oucbSiLqI/bi6WLMkfnt3pFfclE2jgxh7xEAAAAAALhkQ8BGiRc5Gi3nn7KRYOroMCbiGjU9dkevReeY/491V2bhPFfX4M8T6ra43x21XgFSTLk60+xy/Ub8Pxdie23iMRXiRwt6HmUtLMYBFhw3IwjxxPLd1jzbyiLWhxoBUjqeOy49PTgvZMLowlM37oVAkfloZs7hfLZSAkaOVucqn5WWPMnPcK0EzMYhgm+EwEvMvUtxzYk5dmn+X1gMAG9GFnMb8S5TlX94qs5MlYlZZPnSo/8yT/adKjNE/J9aZA8V/8/FCMBpy94qS+q2tkMirmG7buYoazAAAAAAAAA8E9iFvbIIo5UQvrYRz0ZcxS64xi7h1x3EPwvXjcUIUFnEOxsudCefR6JZkGais29bHFCOhPF99BQJKZB4ZPjBPJ82ACRknw/NaxVsHHGwpXHn9LpG7LvA0x8WDnHEx7DLPM+b39HxyGEiRChPCyjNMRtz/s4Sj0uL0adS6VY4jFHkEGxsnGFjzlylVUHH8++35j6nXHxNjs7PLfexeackFsOEi5UylMg4XlH3BRTHEP+nEtljif/nZASQRqSZpTzZYONW7FSWuaw/YAAAAAAAAHgeZB7xWVO7MFpoZFG6ffNq5TtzXleRxB3yUogSaQTILJ1vXyeeR0sL9bwzcZ9CdJpvhSiUBoel+LwVneZaibAuxpfcI1QnNGyKQEp2z4DmmvfUz92bR7r1dfWiZWtqXZJXIm3Y++JBxONc5LEZ+dcpqMm9EBun29RjVNECKRVxkKu0lXF2LdK5FPlQ5pshiwBqkT8RxoddQNByHtyocujLFxORBzn+WSyyh0ash8iY4t8msmmAyB5b/I/9fOeq47lsuBYKtK1hUQvDgV7UU5afCgYAAAAAAIDnQ2o6h28cArWgdlTIJyxyIdL52FIJ9z7iPxWdTb6W9liQbvZz0Vn1wYvBzdR76RH7RHWIbYK0LwW5PSISsnsU+IS5hMW07XeeBpH2fO468r15tF6vXj8RBqZCiM+E+rnRZ8JQxUI4ZhST05rjwrdGRGUxKKUBAdWFicqDqcgjIfHPxpaVeI4iUMZcLt6yPMWUW5/4T3qKf/2u24DIrnuK/1lEPTHG812CEYDraNtCgVzX6DzBu6jIPC8XHd2I45YwAAAAAAAAXB6V6Yzqjp5PYPIoNUUIi6G4xL8Unra9z6Vot432nwMpJseARXbsiPKS/KPmuyfKcyW16wGUQqDK+es8l3jZ8x4z8Z56IcTYtKs7pJ3NWDB0EcDKkpe04cYl/nV+SQMicKb+l4YUGae7QBxOAu+7GBAf8p0XgWeoPcaJNCLfnPr5VgPy9inqKfbyeEPt+iGJo97QedRWJ/3tfxgAAAAAAAAukyFCMD3hc4XEP7uuVw7xtDPn5xS/H3ZG7Tz/ofGV"
	                   "RlxL3ndB4RFjXn+BRZpvr3j+/ZLgxSZzJSqW1O4aMRHGCx6577MKvV7wL1Z0V9Qu6MhTPvR0F14VneM/tYj2sRcBPBJXAfGvjQZVoJx1KZM+A0BB7boarrITMhLEpOvOI9Z5jQ6bF8KS/FsobmmYB0Ds811auSwoboqHTeg70xIGAAAAAACAl0d1ousOEf/MlNpdA+7o2H3VJ8T16DgLChY/se+ci8516LjbjsYF7nzr9Qo0MWJrjH3eY+ODxVdJ7UKKvM84i/6J+Z4XatzQed2mWbzxQoT8fImIZ724JG9lWJywnFUivnYB8c/PGDIATMi+3sTMk4a+nTZ4G0uXm31pzr3taQTg3Q9STzzdeEQ8rwfhuj9PQ1n1TKfY56voMijNO7vWuODdLWQ+Z28qOcVEGlj+7m0FAwAAAAAAwMsgP7EBgMU/z8NOBnSiee/rjejU+4wAPL9eC2IeOeyyXV4mhJsLXm+hNMKhixCXi+j54jFEI/benCHf8LPIFfWb93+g460gd8poMzfPeE/2xQAn9NhzYsjc+y21CxVOqV1AcGXJh1shopeWtFhR/9Fu7W7PWyvmEeJfinifYcK1c8MmUD53AWOFzwgQEuEhcV04DBSx9ULo/muVX8/9fOeAF/NbB9KR87dcd4XXWEgcBoW/5zUYAAAAAAAALp/Qyv6ZMACERjzrgEB1CeIVte7XtyN0orljLrcR3DnunZF9bm5hRPJdByNAzPoI3Jmed4wnXqzMN7WB56SHDB7pGfJVKuJjq+5P9Hg/+zm1o49yBfrGCMCr73M62lzOh6y9wPe/NWFu0j6nY1d/nh6wonYRNf3OQ93JtQGA59CHxP+tKKdrR1zMHIYSmWcWlrjNIuqJsY0AUlzTCOJ6bCPA2M93SuG/9eQJm7HH5iHiSrMNia1EYQAAAAAAALhsboUgtIlgXtU/CQgLZmfEmlyArxbfhbZlq1UnfWgnmlf4nzk6sGnAYCFFzZ3s6DrEf0r+dQdYzE07vlPmEZ02QgadcxgAeEG6TIhi3u7QZaTgbRdnIg/oPDf1CJF8wPPuTBlonvXB3LcUhqOJENk7x3N0XbTRlt/09dgwQeLauTh2QsceEa48kgSME1uRR115NzR1ZCwjwKnE9VhGgOci/ln4d3mOUuVhW36W3x15T8EAAAAAAABwufDcXu7c8zZ4lRAZuRJIPvEp50frrdEoQnSyON4KITVWJzofIA55dPiO2lXRXfeggEBK6fFe7yF4ygCLweeCNOaslAibB9KV5yiPuaNCDLzf+Ybsq9eXdDydwfbO1yMaALjczamdWrDwiPSdx0Ayo2Gr4afmmHXEOwwxApxaXA81AjwH8c8L/BUD4qcpAzy//95iVOD4OcpvMAAAAAAAAFwuBbUjnrwtW9ZDWHCnsOkQPkTcdxsQIbMzdaJ5tHkVeWxpjvUdXzoMBDUdbzEXu/UYb9fV/H0TEMOJEmsxhoVz5LFGEE9E/JQdzu8q/pPIPBgjYBM6XlU+9tlrGt9osTVxyTsk2AwTW0/ZCo3+h9YAYBYUt5q9NAKERPhTiGvX/bURYPbMxH8oH3Qtt/K9UnGPytUeXO33e/3dq0P40GTCfzmE/3EI/8v8/Rfz/fuH8KWJ4H87hP9zCP/b/P038/0Xh/AN2m0AAAAAgMGkA4SFJHarr61D+OsO6Fid6AeH2GWhlppOe2i0TAtCl6HEJf7kivhdO/Vzj/hk0dt31LkRO0uVHx56xn9C7Yj1uckj0kcKmvUzLa/snZN0MEwMzSOyzPB6DFzefWXVtlWiJFPPnpF/fQsK3Cunxzt6+MgCcZeremHI88XWlzI+Y46R19udKM/J5/DWzTAAAAAAAAC8bGHxHAgJw3OKwaSHCIvdfaDvKvg2g8yC+nsIdJ1zDM4DC+QhFEhb4AMGAAAAAAAAAAAA4B3gFaIAAAAAAAAAAACAAQAAAAAAAAAAAAAwAAAAAAAAAAAAAAAGAAAAAAAAAAAAAMAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAMAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAAAAAAAAIABAAAAAAAAAAAAADAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAwAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAwAAAAAAAAAAAABgAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAgAEAAAAAAAAAAAAAMAAAAAAAAAAAAAAABgAAAAAAAAAAAADAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAACAAQAAAAAAAAAAAAAwAAAAAAAAAAAAAAAGAAAAAAAAAAAAAMAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAwAAAAAAAAAAAABgAAAAAAAAAAAAAAAMAAAAAAAAAAAAAIABAAAAAAAAAAAAADAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAwAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAgAEAAAAAAAAAAAAAMAAAAAAAAAAAAAAABgAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAMAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAACAAQAAAAAAAAAAAABnNQBcRQQAAAAAAAAAAABcKO85vt8fwleH8PkhfHoIvz2Ej833tTnvK/PbL83vn5rjvzLHAQAAAAAAAAAA4EK42u8fafVmNL/xDPjoEL53CMkh/KP5+/1D+ND8/s0hfHEInxmjwK/N3z8ZQ8A3MAQAAAAAAAAAAACXawDQhoDm73fEZw57ERqx/7X4DOEPAAAAAAAAAAA8EwMAAAAAAAAAAAAAYAAAAAAAAAAAAAAADAAAAAAAAAAAAACAAQAAAAAAAAAAAAAwAAAAAAAAAAAAAGBE/r8AAwDnoOHDAAp0ZgAAAABJRU5ErkJggg==";
	*size = 15310;
	byte *result = zt_mallocStructArray(byte, *size);
	i32 decoded_size = 	zt_base64Decode(data, 20417, result, *size);
	zt_assertReturnValOnFail(decoded_size == 15310, nullptr);
	return result;
}

// ================================================================================================================================================================================================

ztInternal void _zt_fontMakeDefaults()
{
	i32 tex_data_size = 0;
	byte *tex_data = _zt_fontLoadFontPng(&tex_data_size);
	ztTextureID tex = zt_textureMakeFromFileData(tex_data, tex_data_size, ztTextureFlags_PixelPerfect);
	zt_debugOnly(zt_textureSetName(tex, "Default Font"));

	{
		// default
		const char *data = "info face=ZeroToleranceGui size=16 bold=0 italic=0 charset=unicode=stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=0,0 outline=0\ncommon lineHeight=16 base=13 scaleW=512 scaleH=64 pages=1 packed=0\npage id=0 file=\".\"\nchars count=94\nchar id=33 x=11 y=0 width=5 height=16 xoffset=0 yoffset=0 xadvance=5 page=0 chnl=15\nchar id=34 x=15 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=35 x=23 y=0 width=11 height=16 xoffset=0 yoffset=0 xadvance=11 page=0 chnl=15\nchar id=36 x=35 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=37 x=44 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=38 x=55 y=0 width=9 height=16 xoffset=0 yoffset=0 xadvance=9 page=0 chnl=15\nchar id=39 x=65 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=40 x=71 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=41 x=78 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=42 x=86 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=43 x=94 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=44 x=106 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=45 x=111 y=0 width=5 height=16 xoffset=0 yoffset=0 xadvance=5 page=0 chnl=15\nchar id=46 x=118 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=47 x=124 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=48 x=133 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=49 x=142 y=0 width=5 height=16 xoffset=0 yoffset=0 xadvance=5 page=0 chnl=15\nchar id=50 x=149 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=51 x=157 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=52 x=166 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=53 x=175 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=54 x=183 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=55 x=191 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=56 x=200 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=57 x=208 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=58 x=217 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=59 x=223 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=60 x=230 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=61 x=240 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=62 x=252 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=63 x=263 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=64 x=271 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=65 x=281 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=66 x=291 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=67 x=300 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=68 x=309 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=69 x=318 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=70 x=326 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=71 x=334 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=72 x=343 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=73 x=353 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=74 x=358 y=0 width=5 height=16 xoffset=0 yoffset=0 xadvance=5 page=0 chnl=15\nchar id=75 x=365 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=76 x=374 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=77 x=382 y=0 width=9 height=16 xoffset=0 yoffset=0 xadvance=9 page=0 chnl=15\nchar id=78 x=393 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=79 x=403 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=80 x=412 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=81 x=420 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=82 x=429 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=83 x=438 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=84 x=447 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=85 x=455 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=86 x=464 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=87 x=473 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=88 x=484 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=89 x=493 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=90 x=501 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=91 x=510 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=92 x=517 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=93 x=527 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=94 x=535 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=95 x=547 y=0 width=9 height=16 xoffset=0 yoffset=0 xadvance=9 page=0 chnl=15\nchar id=96 x=558 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=97 x=564 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=98 x=572 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=99 x=581 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=100 x=589 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=101 x=598 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=102 x=606 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=103 x=613 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=104 x=622 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=105 x=631 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=106 x=636 y=0 width=5 height=16 xoffset=0 yoffset=0 xadvance=5 page=0 chnl=15\nchar id=107 x=642 y=0 width=8 height=16 xoffset=0 yoffset=0 xadvance=8 page=0 chnl=15\nchar id=108 x=651 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=109 x=657 y=0 width=10 height=16 xoffset=0 yoffset=0 xadvance=10 page=0 chnl=15\nchar id=110 x=668 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=111 x=677 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=112 x=685 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=113 x=693 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=114 x=702 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=115 x=709 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=116 x=717 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=117 x=724 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=118 x=734 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=119 x=741 y=0 width=9 height=16 xoffset=0 yoffset=0 xadvance=9 page=0 chnl=15\nchar id=120 x=751 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=121 x=759 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=122 x=767 y=0 width=6 height=16 xoffset=0 yoffset=0 xadvance=6 page=0 chnl=15\nchar id=123 x=775 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=124 x=784 y=0 width=4 height=16 xoffset=0 yoffset=0 xadvance=4 page=0 chnl=15\nchar id=125 x=789 y=0 width=7 height=16 xoffset=0 yoffset=0 xadvance=7 page=0 chnl=15\nchar id=126 x=798 y=0 width=11 height=16 xoffset=0 yoffset=0 xadvance=11 page=0 chnl=15\n";
		//ztFontID font = 
		zt_fontMakeFromBmpFontData(data, tex, zt_vec2i(0, 20));
		zt_game->fonts_count_system += 1;
	}

	{
		// monospaced default
		const char *data = "info face=ZeroToleranceDefaultMono size=16 bold=0 italic=0 charset=unicode stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=0,0 outline=0\ncommon lineHeight=16 base=13 scaleW=1024 scaleH=32 pages=1 packed=0\npage id=0 file=\".\"\nchars count=94\nchar id=33 x=8 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=34 x=16 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=35 x=24 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=36 x=32 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=37 x=40 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=38 x=48 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=39 x=56 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=40 x=64 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=41 x=72 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=42 x=80 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=43 x=88 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=44 x=96 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=45 x=104 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=46 x=112 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=47 x=120 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=48 x=128 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=49 x=136 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=50 x=144 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=51 x=152 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=52 x=160 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=53 x=168 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=54 x=176 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=55 x=184 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=56 x=192 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=57 x=200 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=58 x=208 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=59 x=216 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=60 x=224 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=61 x=232 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=62 x=240 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=63 x=248 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=64 x=256 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=65 x=264 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=66 x=272 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=67 x=280 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=68 x=288 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=69 x=296 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=70 x=304 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=71 x=312 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=72 x=320 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=73 x=328 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=74 x=336 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=75 x=344 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=76 x=352 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=77 x=360 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=78 x=368 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=79 x=376 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=80 x=384 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=81 x=392 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=82 x=400 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=83 x=408 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=84 x=416 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=85 x=424 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=86 x=432 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=87 x=440 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=88 x=448 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=89 x=456 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=90 x=464 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=91 x=472 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=92 x=480 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=93 x=488 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=94 x=496 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=95 x=504 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=96 x=512 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=97 x=520 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=98 x=528 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=99 x=536 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=100 x=544 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=101 x=552 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=102 x=560 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=103 x=568 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=104 x=576 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=105 x=584 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=106 x=592 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=107 x=600 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=108 x=608 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=109 x=616 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=110 x=624 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=111 x=632 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=112 x=640 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=113 x=648 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=114 x=656 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=115 x=664 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=116 x=672 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=117 x=680 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=118 x=688 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=119 x=696 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=120 x=704 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=121 x=712 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=122 x=720 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=123 x=728 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=124 x=736 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=125 x=744 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\nchar id=126 x=744 y=0 width=8 height=16 xoffset=0 yoffset=3 xadvance=8 page=0 chnl=15\n";
		//ztFontID font = 
		zt_fontMakeFromBmpFontData(data, tex, zt_vec2i(0, 1));
		zt_game->fonts_count_system += 1;
	}
	zt_free(tex_data);
}

// ================================================================================================================================================================================================

const char *zt_fontGetCharsetStandard(i32 *size)
{
	zt_returnValOnNull(size, nullptr);

	const char *charset = " !\"#$%&'()*+'-.,/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
	*size = zt_strLen(charset);
	return charset;
}

// ================================================================================================================================================================================================

ztFontID _zt_fontMakeFromSTB(const char *name, void *data, i32 data_size, i32 size_in_pixels, const char *charset, i32 charset_size); // defined after stb_truetype.h below

// ================================================================================================================================================================================================

ztFontID zt_fontMakeFromTrueTypeAsset(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 size_in_pixels, const char *charset, i32 charset_size)
{
	ZT_PROFILE_RENDERING("zt_fontMakeFromTrueTypeAsset");
	if(asset_id == ztInvalidID) {
		return ztInvalidID;
	}

	if (charset == nullptr || charset_size == 0) {
		charset = zt_fontGetCharsetStandard(&charset_size);
	}

	void *data = nullptr;
	i32 size = 0;

	ztAssetManagerType_Enum verify[] = { ztAssetManagerType_Font };
	if (!_zt_assetLoadData(asset_mgr, asset_id, verify, zt_elementsOf(verify), &data, &size)) {
		return ztInvalidID;
	}

	ztFontID font_id = _zt_fontMakeFromSTB(asset_mgr->asset_name[asset_id], data, size, size_in_pixels, charset, charset_size);
	_zt_assetFreeData(asset_mgr, data);
	return font_id;
}

// ================================================================================================================================================================================================

ztFontID zt_fontMakeFromTrueTypeFile(const char *file_name, i32 size_in_pixels, const char *charset, i32 charset_size)
{
	ZT_PROFILE_RENDERING("zt_fontMakeFromTrueTypeFile");
	if (charset == nullptr || charset_size == 0) {
		if (charset) {
			charset_size = zt_strLen(charset);
		}
		else {
			charset = zt_fontGetCharsetStandard(&charset_size);
		}
	}

	i32 size = 0;
	void *data = zt_readEntireFile(file_name, &size);

	if (data == nullptr || size == 0) {
		return ztInvalidID;
	}

	const char *last = zt_strFindLast(file_name, ztFilePathSeparatorStr);
	if (last == nullptr) {
		last = file_name;
	}
	else {
		last += 1;
	}

	ztFontID font_id = _zt_fontMakeFromSTB(last, data, size, size_in_pixels, charset, charset_size);
	zt_free(data);
	return font_id;
}

// ================================================================================================================================================================================================

ztInternal ztFontID _zt_fontMakeFromBmpFontBase(ztAssetManager *asset_mgr, ztAssetID asset_id, ztAssetID texture_override_asset_id, const char *font_data, ztTextureID texture_override_tex_id, const ztVec2i& override_offset)
{
	ZT_PROFILE_RENDERING("_zt_fontMakeFromBmpFontBase");
	void *data = nullptr;
	i32 size = 0;
	ztVec2i offset = override_offset;
	
	if (asset_mgr) {
		ztAssetManagerType_Enum verify[] = { ztAssetManagerType_Font, ztAssetManagerType_Xml };
		if (!_zt_assetLoadData(asset_mgr, asset_id, verify, zt_elementsOf(verify), &data, &size)) {
			return ztInvalidID;
		}
	}
	else {
		data = (void*)font_data;
		size = zt_strSize(font_data);
	}

	ztFontID font_id = ztInvalidID;
	const char *error = nullptr;

	if (zt_strFindPos((char*)data, "<?xml", 0) != ztStrPosNotFound) {
		ztToken nodes_tok[4096];
		int nodes = zt_strTokenize((char*)data, ">", nodes_tok, zt_elementsOf(nodes_tok), ztStrTokenizeFlags_TrimWhitespace);
		if (nodes < 4) {
			error = "bitmap font file has an invalid header";
			goto on_error;
		}
		if (nodes > zt_elementsOf(nodes_tok)) {
			error = "font glyph count exceeds maximum supported";
			goto on_error;
		}

		font_id = zt_game->fonts_count++;
		ztFont *font = &zt_game->fonts[font_id];

		zt_memSet(font, zt_sizeof(ztFont), 0);

		if (asset_mgr) {
			font->arena = asset_mgr->arena;
			font->texture = texture_override_asset_id;
		}
		else {
			font->arena = zt_memGetGlobalArena();
			font->texture = texture_override_tex_id;
		}

		struct local
		{
			static i32 getIntBetween(const char *str, const char *beg, const char *end)
			{
				char value[128] = { 0 };
				zt_strGetBetween(value, zt_elementsOf(value), str, beg, end);
				return zt_strToInt(value, 0);
			}

			static i32 getCodepoint(const char *str, const char *beg, const char *end)
			{
				char id[6] = { 0 };
				zt_strGetBetween(id, zt_elementsOf(id), str, beg, end);
				if (id[0] == '&') {
					if (zt_strStartsWith(id, "&amp;")) id[0] = '&';
					if (zt_strStartsWith(id, "&quo")) id[0] = '\"';
					if (zt_strStartsWith(id, "&lt;")) id[0] = '<';
					if (zt_strStartsWith(id, "&gt;")) id[0] = '>';
				}
				return (i32)id[0];
			}
		};

		char node_buff[1024];

		int chars = 0;
		int chars_line = 0;
		int kernings = 0;
		int ascender = 0;
		int descender = 0;

		zt_fiz(nodes) {
			if (nodes_tok[i].len >= zt_elementsOf(node_buff)) {
				continue;
			}

			zt_strCpy(node_buff, zt_elementsOf(node_buff), (char*)data + nodes_tok[i].beg, nodes_tok[i].len);
			node_buff[nodes_tok[i].len] = 0;

			if (zt_strStartsWith(node_buff, "<font ")) {
				char type[16];
				zt_strGetBetween(type, zt_elementsOf(type), node_buff, "type=\"", "\"");
				if(!zt_strEquals(type, "NGL")) {
					error = "unsupported xml bitmap format";
					goto on_error;
				}
			}

			if (zt_strStartsWith(node_buff, "<char ")) {
				if (chars_line == 0) {
					chars_line = i;
				}
				chars += 1;
			}
			else if (zt_strStartsWith(node_buff, "<kerning ")) {
				kernings += 1;
			}
			else if(zt_strStartsWith(node_buff, "<description ")) {
				zt_strGetBetween(font->name, zt_elementsOf(font->name), node_buff, "family=\"", "\"");
				font->size_pixels = local::getIntBetween(node_buff, "size=\"", "\"");
			}
			else if (zt_strStartsWith(node_buff, "<metrics ")) {
				font->line_height = local::getIntBetween(node_buff, "height=\"", "\"") / zt_pixelsPerUnit();
				ascender = local::getIntBetween(node_buff, "ascender=\"", "\"");
				descender = local::getIntBetween(node_buff, "descender=\"", "\"");
			}
			else if (zt_strStartsWith(node_buff, "<texture ")) {
				if (font->texture == ztInvalidID) {
					char tex_file[ztFileMaxPath];
					zt_strGetBetween(tex_file, zt_elementsOf(tex_file), node_buff, "file=\"", "\"");

					char bmp_dir[ztFileMaxPath] = "";
					int pos_sep = zt_strFindLastPos(asset_mgr->asset_name[asset_id], "/");
					if (pos_sep != ztStrPosNotFound) {
						zt_strCpy(bmp_dir, zt_elementsOf(bmp_dir), asset_mgr->asset_name[asset_id], pos_sep);
					}

					char tex_file_full[ztFileMaxPath];
					zt_strPrintf(tex_file_full, zt_elementsOf(tex_file_full), "%s/%s", bmp_dir, tex_file);
					i32 tex_asset_hash = 0;
					if (zt_assetFileExistsAsAsset(asset_mgr, tex_file_full, &tex_asset_hash)) {
						font->texture = zt_textureMake(asset_mgr, zt_assetLoad(asset_mgr, tex_asset_hash), 0);
					}
					else if (zt_fileExists(tex_file_full)) {
						// TODO(josh): should this support loading non-asset files?
						zt_assert(false);
					}
					else {
						zt_assert(false);
					}

					if (font->texture == ztInvalidID) {
						error = "unable to load bitmap font texture";
						goto on_error;
					}
				}
			}
			else if (zt_strStartsWith(node_buff, "<char ")) {
				chars += 1;
			}
		}

		font->glyph_count = chars;
		font->glyph_code_point = zt_mallocStructArrayArena(i32, chars, font->arena);
		font->glyphs = zt_mallocStructArrayArena(ztFont::Glyph, chars, font->arena);
		font->kernings_count = kernings;
		font->kernings = kernings > 0 ? zt_mallocStructArrayArena(ztFont::Kerning, kernings, font->arena) : nullptr;

		r32 tex_w = (r32)zt_game->textures[font->texture].width;
		r32 tex_h = (r32)zt_game->textures[font->texture].height;

		r32 ppu = zt_pixelsPerUnit();

		int glyph_idx = 0;
		i32 x_adv_ttl = 0;
		r32 base_offset = (-descender / ppu);// base == 0 ? 0 : base / (r32)zt_game->win_game_settings[0].pixels_per_unit;

		font->space_width = 0;

		int kidx = 0;

		int* codepoint = nullptr;
		ztFont::Glyph *glyph = nullptr;

		for (int i = chars_line; i < nodes; ++i) {
			zt_strCpy(node_buff, zt_elementsOf(node_buff), (char*)data + nodes_tok[i].beg, nodes_tok[i].len);

			if (zt_strStartsWith(node_buff, "<char ")) {
				if (glyph_idx >= chars) {
					break;
				}

				if (i < nodes - 1 && *((char*)data + nodes_tok[i+1].beg) != '<') {
					zt_strCat(node_buff, zt_elementsOf(node_buff), ">", 1);
					zt_strCat(node_buff, zt_elementsOf(node_buff), (char*)data + nodes_tok[i + 1].beg, nodes_tok[i + 1].len);
					i += 1;
				}

				codepoint = &font->glyph_code_point[glyph_idx];
				glyph = &font->glyphs[glyph_idx];
				glyph->kerning = nullptr;
				glyph_idx += 1;
				
				*codepoint = local::getCodepoint(node_buff, "id=\"", "\"");

				glyph->tex_uv.x = (offset.x + (r32)local::getIntBetween(node_buff, "rect_x=\"", "\"")) / tex_w;
				glyph->tex_uv.y = (offset.y + (r32)local::getIntBetween(node_buff, "rect_y=\"", "\"")) / tex_h;

				r32 w = (r32)local::getIntBetween(node_buff, "rect_w=\"", "\"");
				r32 h = (r32)local::getIntBetween(node_buff, "rect_h=\"", "\"");
				glyph->tex_uv.z = w / tex_w;
				glyph->tex_uv.w = h / tex_h;
				glyph->size.x = w / ppu;
				glyph->size.y = h / ppu;
				glyph->offset.x = ((local::getIntBetween(node_buff, "offset_x=\"", "\"") / 1.f) / ppu);
				glyph->offset.y = -((local::getIntBetween(node_buff, "offset_y=\"", "\"") / 1.f) / ppu) - base_offset;
				i32 x_adv = local::getIntBetween(node_buff, "advance=\"", "\"");
				glyph->x_adv = x_adv / ppu;
				x_adv_ttl += x_adv;

				glyph->tex_uv.z += glyph->tex_uv.x;
				glyph->tex_uv.w += glyph->tex_uv.y;

				if (*codepoint == ' ') {
					font->space_width = glyph->x_adv;
				}
			}
			else if (zt_strStartsWith(node_buff, "<kerning ")) {
				zt_assert(codepoint != nullptr && glyph != nullptr);

				i32 advance = local::getIntBetween(node_buff, "advance=\"", "\"");
				i32 codepoint = local::getCodepoint(node_buff, "id=\"", "\"");

				ztFont::Kerning *kerning = &font->kernings[kidx++];

				kerning->next_code = codepoint;
				kerning->spacing = (r32)advance / ppu;
				kerning->next = nullptr;

				zt_singleLinkAddToEnd(glyph->kerning, kerning);

			}
		}

		font->line_spacing = ((r32)font->size_pixels * .1f) / ppu;
		if (font->space_width == 0) {
			font->space_width = (x_adv_ttl / (r32)(glyph_idx - 1)) / ppu;
		}

		// make sure we don't have glyphs representing formatting characters (\r, \n, \t, ' ')
		zt_fiz(font->glyph_count) {
			switch(font->glyph_code_point[i])
			{
				case '\r': case '\n': case '\t': case ' ': {
					font->glyph_code_point[i] = -1;
				} break;
			}
		}

		if (asset_mgr) {
			zt_freeArena(data, asset_mgr->arena);
		}
		return font_id;
	}
	else {
		ztToken lines_tok[4096];
		int lines = zt_strTokenize((char*)data, "\r\n", lines_tok, zt_elementsOf(lines_tok), 0);
		if (lines < 4) {
			error = "bitmap font file has an invalid header";
			goto on_error;
		}
		if (lines > zt_elementsOf(lines_tok)) {
			error = "font glyph count exceeds maximum supported";
			goto on_error;
		}

		font_id = zt_game->fonts_count++;
		ztFont *font = &zt_game->fonts[font_id];

		zt_memSet(font, zt_sizeof(ztFont), 0);

		if (asset_mgr) {
			font->arena = asset_mgr->arena;
			font->texture = texture_override_asset_id;
		}
		else {
			font->arena = zt_memGetGlobalArena();
			font->texture = texture_override_tex_id;
		}

		struct local
		{
			static int32 getIntAfterEquals(char* str, int len)
			{
				int idx = 0;
				while (str[idx]) {
					if (str[idx] != '=') {
						idx++;
					}
					else {
						idx++;
						int str_len = len - idx;
						char buffer[128] = { 0 };
						zt_strCpy(buffer, zt_elementsOf(buffer), &str[idx], str_len);

						i32 result = zt_strToInt(buffer, 0);
						return result;
					}
				}
				return 0;
			}
		};

		char line_buff[1024];

		int chars = 0;
		int chars_line = 0;
		int base = 0;
		int kernings = 0;

		zt_fiz(lines) {
			if (lines_tok[i].len >= zt_elementsOf(line_buff)) {
				continue;
			}

			zt_strCpy(line_buff, zt_elementsOf(line_buff), (char*)data + lines_tok[i].beg, lines_tok[i].len);
			line_buff[lines_tok[i].len] = 0;

			if (zt_strStartsWith(line_buff, "info face")) {
			}

			if (zt_strStartsWith(line_buff, "char id")) {
				if (chars_line == 0) {
					chars_line = i;
				}
			}
			else if (zt_strStartsWith(line_buff, "kerning ")) {
				kernings += 1;
			}
			else {
				ztToken toks[32];
				int toks_cnt = zt_strTokenize(line_buff, " ", toks, zt_elementsOf(toks), ztStrTokenizeFlags_ProcessQuotes | ztStrTokenizeFlags_KeepQuotes);
				if (toks_cnt > zt_elementsOf(toks)) {
					continue;
				}

				zt_fjz(toks_cnt) {
					char* start = line_buff + toks[j].beg;
					if (zt_strStartsWith(start, "face=")) {
						int find_beg = 5;
						int find_end = -1;
						if (start[find_beg] == '\"') {
							find_beg += 1;
							find_end = zt_strFindPos(start, "\"", find_beg);
						}
						else {
							find_end = zt_strFindPos(start, " ", find_beg);
						}

						if (find_end != ztStrPosNotFound) {
							zt_strCpy(font->name, zt_elementsOf(font->name), start + find_beg, find_end - find_beg);
						}
					}
					else if (zt_strStartsWith(start, "size=")) {
						font->size_pixels = local::getIntAfterEquals(start, toks[j].len);
					}
					else if (zt_strStartsWith(start, "lineHeight=")) {
						font->line_height = local::getIntAfterEquals(start, toks[j].len) / (r32)zt_game->win_game_settings[0].pixels_per_unit;
					}
					else if (zt_strStartsWith(start, "base=")) {
						base = local::getIntAfterEquals(start, toks[j].len);
					}
					else if (zt_strStartsWith(start, "count=") && zt_strStartsWith(line_buff, "chars count")) {
						chars = local::getIntAfterEquals(start, toks[j].len);
					}
					else if (zt_strStartsWith(start, "pages=")) {
						int pages = local::getIntAfterEquals(start, toks[j].len);
						if (pages != 1) {
							error = "bitmap fonts with more than one page are not supported";
							goto on_error;
						}
					}
					else if (zt_strStartsWith(start, "file=")) {
						if (font->texture == ztInvalidID) {
							char tex_file[ztFileMaxPath];
							if (zt_strStartsWith(start, "file=\"")) {
								zt_strCpy(tex_file, zt_elementsOf(tex_file), start + 6, toks[j].len - 7);
							}
							else {
								zt_strCpy(tex_file, zt_elementsOf(tex_file), start + 5, toks[j].len - 5);
							}

							char bmp_dir[ztFileMaxPath] = "";
							int pos_sep = zt_strFindLastPos(asset_mgr->asset_name[asset_id], "/");
							if (pos_sep != ztStrPosNotFound) {
								zt_strCpy(bmp_dir, zt_elementsOf(bmp_dir), asset_mgr->asset_name[asset_id], pos_sep);
							}

							char tex_file_full[ztFileMaxPath];
							zt_strPrintf(tex_file_full, zt_elementsOf(tex_file_full), "%s/%s", bmp_dir, tex_file);
							i32 tex_asset_hash = 0;
							if (zt_assetFileExistsAsAsset(asset_mgr, tex_file_full, &tex_asset_hash)) {
								font->texture = zt_textureMake(asset_mgr, zt_assetLoad(asset_mgr, tex_asset_hash), 0);
								zt_debugOnly(zt_textureSetName(font->texture, "Bitmap Font Texture"));
							}
							else if (zt_fileExists(tex_file_full)) {
								// TODO(josh): should this support loading non-asset files?
								zt_assert(false);
							}
							else {
								zt_assert(false);
							}

							if (font->texture == ztInvalidID) {
								error = "unable to load bitmap font texture";
								goto on_error;
							}
						}
					}
				}
			}
		}

		font->glyph_count = chars;
		font->glyph_code_point = zt_mallocStructArrayArena(i32, chars, font->arena);
		font->glyphs = zt_mallocStructArrayArena(ztFont::Glyph, chars, font->arena);
		font->kernings_count = kernings;
		font->kernings = kernings > 0 ? zt_mallocStructArrayArena(ztFont::Kerning, kernings, font->arena) : nullptr;

		r32 tex_w = (r32)zt_game->textures[font->texture].width;
		r32 tex_h = (r32)zt_game->textures[font->texture].height;

		int glyph_idx = 0;
		i32 x_adv_ttl = 0;
		r32 base_offset = font->line_height;// base == 0 ? 0 : base / (r32)zt_game->win_game_settings[0].pixels_per_unit;

		font->space_width = 0;

		for (int i = chars_line; i < lines; ++i) {
			zt_strCpy(line_buff, zt_elementsOf(line_buff), (char*)data + lines_tok[i].beg, lines_tok[i].len);
			line_buff[lines_tok[i].len] = 0;

			if (!zt_strStartsWith(line_buff, "char id")) {
				continue;
			}

			ztToken toks[32];
			int toks_cnt = zt_strTokenize(line_buff, " ", toks, zt_elementsOf(toks), ztStrTokenizeFlags_ProcessQuotes);
			if (toks_cnt > zt_elementsOf(toks)) {
				continue;
			}

			if (glyph_idx >= chars) {
				break;
			}

			int* codepoint = &font->glyph_code_point[glyph_idx];
			ztFont::Glyph *glyph = &font->glyphs[glyph_idx];
			glyph->kerning = nullptr;
			glyph_idx += 1;
			*codepoint = -1;

			zt_fjz(toks_cnt) {
				char* start = line_buff + toks[j].beg;
				int val = local::getIntAfterEquals(start, toks[j].len);

				if (zt_strStartsWith(start, "id=")) {
					*codepoint = val;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "x=")) {
					glyph->tex_uv.x = (offset.x + (r32)val) / tex_w;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "y=")) {
					glyph->tex_uv.y = (offset.y + (r32)val) / tex_h;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "width=")) {
					glyph->tex_uv.z = (r32)val / tex_w;
					glyph->size.x = val / (r32)zt_game->win_game_settings[0].pixels_per_unit;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "height=")) {
					glyph->tex_uv.w = (r32)val / tex_h;
					glyph->size.y = val / (r32)zt_game->win_game_settings[0].pixels_per_unit;
					//font->line_height = zt_max(font->line_height, glyph->size.y);
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "xoffset=")) {
					glyph->offset.x = (val / 1.f) / zt_game->win_game_settings[0].pixels_per_unit;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "yoffset=")) {
					glyph->offset.y = ((val / 1.f) / zt_game->win_game_settings[0].pixels_per_unit) - base_offset;
				}
				else if (*codepoint != -1 && zt_strStartsWith(start, "xadvance=")) {
					glyph->x_adv = val / (r32)zt_game->win_game_settings[0].pixels_per_unit;
					x_adv_ttl += val;
				}
			}
			if (*codepoint != -1) {
				glyph->tex_uv.z += glyph->tex_uv.x;
				glyph->tex_uv.w += glyph->tex_uv.y;

				if (*codepoint == ' ') {
					font->space_width = glyph->x_adv;
				}

				//font->line_height = zt_max(font->line_height, glyph->size.y - glyph->offset.y));
			}
		}

		font->line_spacing = ((r32)font->size_pixels * .1f) / zt_game->win_game_settings[0].pixels_per_unit;
		if (font->space_width == 0) {
			font->space_width = (x_adv_ttl / (r32)(glyph_idx - 1)) / zt_game->win_game_settings[0].pixels_per_unit;
		}

		if (kernings > 0) {
			int kidx = 0;
			for (int i = chars_line; i < lines; ++i) {
				zt_strCpy(line_buff, zt_elementsOf(line_buff), (char*)data + lines_tok[i].beg, lines_tok[i].len);
				line_buff[lines_tok[i].len] = 0;

				if (!zt_strStartsWith(line_buff, "kerning ")) {
					continue;
				}

				ztToken toks[32];
				int toks_cnt = zt_strTokenize(line_buff, " ", toks, zt_elementsOf(toks), ztStrTokenizeFlags_ProcessQuotes);
				if (toks_cnt > zt_elementsOf(toks)) {
					continue;
				}

				int first = -1, second = -1, amount = 0;

				zt_fjz(toks_cnt) {
					char* start = line_buff + toks[j].beg;
					int val = local::getIntAfterEquals(start, toks[j].len);

					if (zt_strStartsWith(start, "first=")) {
						first = val;
					}
					else if (zt_strStartsWith(start, "second=")) {
						second = val;
					}
					else if (zt_strStartsWith(start, "amount=")) {
						amount = val;
					}
				}

				if (first != -1 && second != -1 && amount != 0) {
					zt_fjz(font->glyph_count) {
						if (font->glyph_code_point[j] == first) {
							ztFont::Kerning *kerning = &font->kernings[kidx++];

							kerning->next_code = second;
							kerning->spacing = (r32)amount / zt_game->win_game_settings[0].pixels_per_unit;
							kerning->next = nullptr;

							zt_singleLinkAddToEnd(font->glyphs[j].kerning, kerning);
							break;
						}
					}
				}
			}
		}

		// make sure we don't have glyphs representing formatting characters (\r, \n, \t, ' ')
		zt_fiz(font->glyph_count) {
			switch(font->glyph_code_point[i])
			{
				case '\r': case '\n': case '\t': case ' ': {
					font->glyph_code_point[i] = -1;
				} break;
			}
		}

		if (asset_mgr) {
			zt_freeArena(data, asset_mgr->arena);
		}
		return font_id;
	}

on_error:
	if (error) {
		if (asset_mgr) {
			zt_logCritical("Unable to load bitmap font from asset '%s' (error: %s)", asset_mgr->asset_name[asset_id], error);
		}
		else {
			zt_logCritical("Unable to load bitmap font (error: %s)", error);
		}
	}
	if (font_id != ztInvalidID) {
		zt_fontFree(font_id);
	}

	if (asset_mgr) {
		_zt_assetFreeData(asset_mgr, data);
	}
	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztFontID zt_fontMakeFromBmpFontAsset(ztAssetManager *asset_mgr, ztAssetID asset_id, ztAssetID texture_override_asset_id, const ztVec2i& override_offset)
{
	ZT_PROFILE_RENDERING("zt_fontMakeFromBmpFontAsset");
	return _zt_fontMakeFromBmpFontBase(asset_mgr, asset_id, texture_override_asset_id, nullptr, ztInvalidID, override_offset);
}

// ================================================================================================================================================================================================

ztFontID zt_fontMakeFromBmpFontFile(const char *file_name, ztTextureID texture_override_id, const ztVec2i& override_offset)
{
	ZT_PROFILE_RENDERING("zt_fontMakeFromBmpFontFile");
	i32 size;
	void *data = zt_readEntireFile(file_name, &size);
	if (data == nullptr) {
		zt_logCritical("Unable to load bitmap font file: %s", file_name);
		return ztInvalidID;
	}

	ztFontID font_id = _zt_fontMakeFromBmpFontBase(nullptr, ztInvalidID, ztInvalidID, (char*)data, texture_override_id, override_offset);
	zt_free(data);
	return font_id;
}

// ================================================================================================================================================================================================

ztFontID zt_fontMakeFromBmpFontData(const char *file_data, ztTextureID texture_override_id, const ztVec2i& override_offset)
{
	ZT_PROFILE_RENDERING("zt_fontMakeFromBmpFontData");
	return _zt_fontMakeFromBmpFontBase(nullptr, ztInvalidID, ztInvalidID, file_data, texture_override_id, override_offset);
}

// ================================================================================================================================================================================================

void zt_fontFree(ztFontID font_id)
{
	ZT_PROFILE_RENDERING("zt_fontFree");
	if (font_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(font_id >= 0 && font_id < zt_game->fonts_count);

	ztFont *font = &zt_game->fonts[font_id];

	if (font->texture != ztInvalidID) {
		zt_textureFree(font->texture);
	}

	if (font->glyph_code_point) {
		zt_freeArena(font->glyph_code_point, font->arena);
	}
	if (font->glyphs) {
		zt_freeArena(font->glyphs, font->arena);
	}
	if (font->kernings) {
		zt_freeArena(font->kernings, font->arena);
	}

	zt_memSet(font, zt_sizeof(ztFont), 0);
}

// ================================================================================================================================================================================================

void zt_fontMakeMonoSpaced(ztFontID font_id)
{
	ZT_PROFILE_RENDERING("zt_fontFree");
	if (font_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(font_id >= 0 && font_id < zt_game->fonts_count);

	ztFont *font = &zt_game->fonts[font_id];

	r32 max_width = 0;
	zt_fiz(font->glyph_count) {
		max_width = zt_max(max_width, font->glyphs[i].size.x);
	}

	zt_fiz(font->glyph_count) {
		font->glyphs[i].x_adv = max_width;// -font->glyphs[i].size.x;
	}

	font->space_width = max_width;
}

// ================================================================================================================================================================================================

const char *zt_fontGetName(ztFontID font_id)
{
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);
	return zt_game->fonts[font_id].name;
}

// ================================================================================================================================================================================================

i32 zt_fontGetSizeInPixels(ztFontID font_id)
{
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);
	return zt_game->fonts[font_id].size_pixels;
}
// ================================================================================================================================================================================================

ztTextureID zt_fontGetTexture(ztFontID font_id)
{
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);
	return zt_game->fonts[font_id].texture;
}

// ================================================================================================================================================================================================

ztInternal int _zt_fontGetRowCount(const char *text, int text_len)
{
	ZT_PROFILE_RENDERING("_zt_fontGetRowCount");
	int rows = 1;
	zt_fiz(text_len) {
		i32 codepoint;
		text = zt_strCodepoint(text, &codepoint);
		if (codepoint == '\n') {
			rows += 1;
		}
	}

	return rows;
}

// ================================================================================================================================================================================================

ztInternal void _zt_fontGetRowInfo(const char *text, int text_len, int row, int *start_char, int *length)
{
	ZT_PROFILE_RENDERING("_zt_fontGetRowInfo");
	int current_row = 0;
	*start_char = 0;
	*length = 0;
	zt_fiz(text_len) {
		i32 codepoint = 0;
		text = zt_strCodepoint(text, &codepoint);
		if (codepoint == '\n') {
			current_row += 1;

			if (current_row > row) {
				return;
			}
			else if (current_row == row) {
				*start_char = i + 1;
				*length = 0;
			}
		}
		else if (current_row == row) {
			*length += 1;
		}
	}
}

// ================================================================================================================================================================================================

ztInternal void _zt_fontGetGlyphsFromText(ztFontID font_id, const char *text, int text_len, i32 *glyphs_idx, int glyphs_size)
{
	ZT_PROFILE_RENDERING("_zt_fontGetGlyphsFromText");
	ztFont *font = &zt_game->fonts[font_id];

	if (text_len > glyphs_size) {
		text_len = glyphs_size;
	}

	zt_fiz(text_len) {
		i32 codepoint = 0;
		text = zt_strCodepoint(text, &codepoint);
		glyphs_idx[i] = -1;
		zt_fjz(font->glyph_count) {
			if (font->glyph_code_point[j] == codepoint) {
				glyphs_idx[i] = j;
				break;
			}
		}
	}
}

// ================================================================================================================================================================================================

ztInternal void _zt_fontGetExtents(ztFontID font_id, const char *text, int text_len, int row, i32 *glyphs_idx, int glyphs_size, r32 *width, r32 *height, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("_zt_fontGetExtents");
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);

	if (text_len == 0) {
		// we should return a valid height for empty lines
		_zt_fontGetExtents(font_id, "A", 1, row, glyphs_idx, glyphs_size, width, height, text_anim, text_anim_user_data);
		*width = 0;
		return;
	}

	ztFont *font = &zt_game->fonts[font_id];

	r32 total_width = 0;
	r32 total_height = 0;
	r32 row_width = 0;
	r32 row_height = 0;
	r32 last_xadv = 0;

	int current_row = 0;

	zt_fiz(text_len) {
		int glyph_idx = glyphs_idx[i];

		if (glyph_idx < 0) {
			if (row_height == 0) {
				row_height = font->line_height;
			}

			i32 codepoint = zt_strCodepoint(text, i);
			if (codepoint == '\n') {
				if (current_row == row) {
					*width = row_width;
					*height = row_height;
					return;
				}
				total_height += row_height + (font->line_spacing);
				total_width = zt_max(total_width, row_width);
				row_height = row_width = 0;
				current_row += 1;
			}
			else if (codepoint == ' ') {
				row_width += font->space_width;
			}
			else if (codepoint == '\t') {
				row_width += font->space_width * 4; // TODO(josh): fix this
			}
			continue;
		}

		r32 x = font->glyphs[glyph_idx].x_adv;
		//r32 y = font->glyphs[glyph_idx].size.y;
		r32 y = font->line_height;

		if (text_anim) {
			ztVec2 units_size = font->glyphs[glyph_idx].size;
			ztFont::Glyph *glyph = &font->glyphs[glyph_idx];

			ztVec3 dl_pos[4];
			ztVec2 dl_uvs[4];

			// points in ccw order
			dl_pos[0].x = 0; dl_pos[1].x = 0;                dl_pos[2].x = 0 + units_size.x; dl_pos[3].x = 0 + units_size.x;
			dl_pos[0].y = 0; dl_pos[1].y = 0 - units_size.y; dl_pos[2].y = 0 - units_size.y; dl_pos[3].y = 0;

			dl_uvs[0].x = glyph->tex_uv.x; dl_uvs[1].x = glyph->tex_uv.x; dl_uvs[2].x = glyph->tex_uv.z; dl_uvs[3].x = glyph->tex_uv.z;
			dl_uvs[0].y = glyph->tex_uv.y; dl_uvs[1].y = glyph->tex_uv.w; dl_uvs[2].y = glyph->tex_uv.w; dl_uvs[3].y = glyph->tex_uv.y;

			bool should_skip, pop_color;
			text_anim(nullptr, font->glyph_code_point[glyph_idx], i, text_len, current_row, dl_pos, dl_uvs, &x, &y, &should_skip, &pop_color, text_anim_user_data);
		}
		last_xadv = x - font->glyphs[glyph_idx].size.x;
		row_width += x;
		row_height = y;// zt_max(zt_max(row_height, font->line_height), y);
	}
	row_width -= last_xadv;

	total_height +=  row_height;
	total_width = zt_max(total_width, row_width);

	if (row == current_row) {
		*width = row_width;
		*height = row_height;
	}
	else {
		*width = total_width;
		*height = total_height;
	}
}

// ================================================================================================================================================================================================

ztVec2 zt_fontGetExtents(ztFontID font_id, const char *text, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	return zt_fontGetExtents(font_id, text, zt_strLen(text), text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

ztVec2 zt_fontGetExtents(ztFontID font_id, const char *text, int text_len, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("zt_fontGetExtents");
	if (text == nullptr || text_len <= 0) {
		return ztVec2::zero;
	}

	i32 glyphs_idx[1024 * 64];
	_zt_fontGetGlyphsFromText(font_id, text, text_len, glyphs_idx, zt_elementsOf(glyphs_idx));

	ztVec2 result;
	_zt_fontGetExtents(font_id, text, text_len, -1, glyphs_idx, zt_elementsOf(glyphs_idx), &result.x, &result.y, text_anim, text_anim_user_data);
	return result;
}

// ================================================================================================================================================================================================

void zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddText2D(draw_list, font_id, text, zt_strLen(text), pos, ztVec2::one, align_flags, anchor_flags, extents, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddText2D(draw_list, font_id, text, text_len, pos, ztVec2::one, align_flags, anchor_flags, extents, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, ztVec2 scale, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddText2D(draw_list, font_id, text, zt_strLen(text), pos, scale, align_flags, anchor_flags, extents, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, ztVec2 scale, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("zt_drawListAddText2D");
	zt_returnOnNull(draw_list);
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);
	if (text_len <= 0) return;

	ztFont *font = &zt_game->fonts[font_id];

	i32 glyphs_idx[1024 * 64];
	_zt_fontGetGlyphsFromText(font_id, text, text_len, glyphs_idx, zt_elementsOf(glyphs_idx));

	r32 total_width = 0;
	r32 total_height = 0;

	int rows = _zt_fontGetRowCount(text, text_len);
	_zt_fontGetExtents(font_id, text, text_len, -1, glyphs_idx, zt_elementsOf(glyphs_idx), &total_width, &total_height, text_anim, text_anim_user_data);

	total_width *= scale.x;
	total_height *= scale.y;

	if (extents) {
		extents->x = total_width;
		extents->y = total_height;
	}

	r32 true_total_height = total_height;

	ztVec2 size = ztVec2::zero; // TODO(josh): add support for setting area for font to fit to
	if (size.x > total_width) total_width = size.x;
	if (size.y > total_height) total_height = size.y;

	ztVec2 position = pos;
	if (zt_bitIsSet(anchor_flags, ztAnchor_Left)) { position.x += total_width / 2.f; }
	else if (zt_bitIsSet(anchor_flags, ztAnchor_Right)) { position.x -= total_width / 2.f; }
	if (zt_bitIsSet(anchor_flags, ztAnchor_Top)) { position.y -= total_height / 2.f; }
	else if (zt_bitIsSet(anchor_flags, ztAnchor_Bottom)) { position.y += total_height / 1.f; }

	r32 start_pos_y = (position.y + (true_total_height / 2)); // initially start out at the top left corner.  each row needs to subtract its height to get the proper start pos

	if (zt_bitIsSet(align_flags, ztAlign_Top)) { start_pos_y += (total_height - true_total_height) / 2.f; }
	else if (zt_bitIsSet(align_flags, ztAlign_Bottom)) { start_pos_y -= (total_height - true_total_height) / 2.f; }

	zt_drawListPushTexture(draw_list, font->texture);
	
	if (transform) {
		zt_drawListPushTransform(draw_list, *transform);
	}

	r32 ppu = zt_pixelsPerUnit();

	for (int r = 0; r < rows; ++r) {
		r32 row_width = 0;
		r32 row_height = 0;
		if (size.x == 0 && size.y == 0 && rows == 1) {
			row_width = total_width;
			row_height = total_height;
		}
		else {
			_zt_fontGetExtents(font_id, text, text_len, r, glyphs_idx, zt_elementsOf(glyphs_idx), &row_width, &row_height, text_anim, text_anim_user_data);
			row_width *= scale.x;
			row_height *= scale.y;
		}

		int start_char = 0, length = 0;
		_zt_fontGetRowInfo(text, text_len, r, &start_char, &length);

		start_pos_y -= row_height;

		r32 start_pos_x = position.x - (total_width / 2.f);

		if (zt_bitIsSet(align_flags, ztAlign_Center)) {
			start_pos_x = position.x - (row_width / 2.f);
		}
		else if (zt_bitIsSet(align_flags, ztAlign_Right)) {
			start_pos_x = position.x + (total_width / 2.f - row_width);
		}

		ztVec2 position;
		ztVec2 units_size;

		r32 scale_x = scale.x;
		r32 scale_y = scale.y;

		ztVec3 dl_pos[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };
		ztVec2 dl_uvs[4];
		ztVec3 dl_nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

		ztFont::Glyph *prev_glyph = nullptr;

		r32 y_adv = font->line_spacing * scale_y;

		for (int i = start_char; i < start_char + length; ++i) {
			int glyph_idx = glyphs_idx[i];
			if (glyph_idx < 0) {
				if (text[i] == ' ') {
					start_pos_x += font->space_width * scale_x;
				}
				else if (text[i] == '\t') {
					start_pos_x += font->space_width * 4 * scale_x; // TODO(josh): fix
				}
				continue;
			}

			ztFont::Glyph* glyph = &font->glyphs[glyph_idx];

			units_size.x = glyph->size.x * scale_x;
			units_size.y = glyph->size.y * scale_y;
			row_height = zt_max(row_height, units_size.y);

			position.x = glyph->offset.x + start_pos_x;
			position.y = start_pos_y - glyph->offset.y * scale_y;

			if (prev_glyph) {
				zt_flink(kerning, prev_glyph->kerning) {
					if (kerning->next_code == font->glyph_code_point[glyph_idx]) {
						position.x += kerning->spacing * scale_x;
						break;
					}
				}
			}

			if (zt_bitIsSet(align_flags, ztAlign_ToPixel)) {
				zt_alignToPixel(&position.x, ppu);
				zt_alignToPixel(&position.y, ppu);
			}

			// points in ccw order
			dl_pos[0].x = position.x; dl_pos[1].x = position.x;                dl_pos[2].x = position.x + units_size.x; dl_pos[3].x = position.x + units_size.x;
			dl_pos[0].y = position.y; dl_pos[1].y = position.y - units_size.y; dl_pos[2].y = position.y - units_size.y; dl_pos[3].y = position.y;

			dl_uvs[0].x = glyph->tex_uv.x; dl_uvs[1].x = glyph->tex_uv.x; dl_uvs[2].x = glyph->tex_uv.z; dl_uvs[3].x = glyph->tex_uv.z;
			dl_uvs[0].y = glyph->tex_uv.y; dl_uvs[1].y = glyph->tex_uv.w; dl_uvs[2].y = glyph->tex_uv.w; dl_uvs[3].y = glyph->tex_uv.y;

			r32 x_adv = glyph->x_adv * scale_x;
			if (text_anim) {
				bool should_skip = false, pop_color = false;
				i32 codepoint = font->glyph_code_point[glyph_idx];
				text_anim(draw_list, codepoint, i, text_len, r, dl_pos, dl_uvs, &x_adv, &y_adv, &should_skip, &pop_color, text_anim_user_data);
				if (!should_skip) {
					zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
				}

				if (pop_color) {
					zt_drawListPopColor(draw_list);

				}
			}
			else {
				zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
			}

			start_pos_x += x_adv;

			prev_glyph = glyph;
		}

		start_pos_y -= font->line_spacing * scale_y; // TODO(josh): should this be using y_adv?
	}

	if (transform) {
		zt_drawListPopTransform(draw_list);
	}

	zt_drawListPopTexture(draw_list);
}

// ================================================================================================================================================================================================

ztInternal int _zt_fontGetFancyTextLen(const char *text, int text_len, ztFont *font, i32 *glyphs_idx, int glyphs_size)
{
	int result = 0;

	bool in_format = false;
	char format[128];
	char *format_ptr = format;

	zt_fiz(text_len) {
		int glyph_idx = glyphs_idx[i];
		char ch;
		if (glyph_idx < 0) {
			ch = (char)zt_strCodepoint(text, i);
		}
		else {
			ch = (char)font->glyph_code_point[glyph_idx];
		}

		if (in_format) {
			if (ch == '>') {
				in_format = false;
				*format_ptr = 0;
				format_ptr = format;
				continue;
			}
			else if (ch == '<') {
				in_format = false;
			}
			else {
				*format_ptr++ = ch;
				if (format_ptr - format == zt_elementsOf(format) - 1) {
					format_ptr = format;
					in_format = false;
				}
				continue;
			}
		}
		else if (ch == '<') {
			in_format = true;
			continue;
		}
		result += 1;
	}

	return result;
}

// ================================================================================================================================================================================================

ztInternal void _zt_fontGetExtentsFancy(ztFontID font_id, const char *text, int text_len, int row, i32 *glyphs_idx, int glyphs_size, r32 *width, r32 *height, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("_zt_fontGetExtentsFancy");
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);

	if (text_len == 0) {
		// we should return a valid height for empty lines
		_zt_fontGetExtentsFancy(font_id, "A", 1, row, glyphs_idx, glyphs_size, width, height, text_anim, text_anim_user_data);
		*width = 0;
		return;
	}

	ztFont *font = &zt_game->fonts[font_id];

	r32 total_width = 0;
	r32 total_height = 0;
	r32 row_width = 0;
	r32 row_height = 0;
	r32 last_xadv = 0;

	int current_row = 0;

	bool in_format = false;
	char format[128];
	char *format_ptr = format;

	int actl_text_len = _zt_fontGetFancyTextLen(text, text_len, font, glyphs_idx, glyphs_size);
	int actl_letter = -1;

	zt_fiz(text_len) {
		int glyph_idx = glyphs_idx[i];
		char ch;
		if (glyph_idx < 0) {
			ch = (char)zt_strCodepoint(text, i);
		}
		else {
			ch = (char)font->glyph_code_point[glyph_idx];
		}

		if (in_format) {
			if (ch == '>') {
				in_format = false;
				*format_ptr = 0;
				format_ptr = format;

				if (zt_strStartsWith(format, "sprite=")) {
					ztToken tokens[7];
					char *sprite_str = format + 7;
					int tokens_count = zt_strTokenize(sprite_str, ",", tokens, zt_elementsOf(tokens));

					if (tokens_count >= 5) {
						i32 id = zt_strToInt(sprite_str + tokens[0].beg, tokens[0].len, 0);
//						i32 x  = zt_strToInt(sprite_str + tokens[1].beg, tokens[1].len, 0);
//						i32 y  = zt_strToInt(sprite_str + tokens[2].beg, tokens[2].len, 0);
						i32 w  = zt_strToInt(sprite_str + tokens[3].beg, tokens[3].len, 0);
						i32 h  = zt_strToInt(sprite_str + tokens[4].beg, tokens[4].len, 0);

						r32 sx = tokens_count >= 6 ? zt_strToReal32(sprite_str + tokens[5].beg, tokens[5].len, 0) : 1.f;
//						r32 sy = tokens_count >= 7 ? zt_strToReal32(sprite_str + tokens[6].beg, tokens[6].len, 0) : 1.f;

						ztVec2i ts = zt_textureGetSize(id);
						if (ts.x > 0 && ts.y > 0) {
							r32 ppu = zt_pixelsPerUnit();
							r32 sprite_w = w / ppu;

							r32 scale_diff_x = sprite_w - (sprite_w * sx);

							last_xadv = 0;
							row_width += sprite_w - scale_diff_x;
							row_height = zt_max(zt_max(row_height, font->line_height), h / ppu);
						}
					}
				}

				continue;
			}
			else if (ch == '<') {
				in_format = false;
			}
			else {
				*format_ptr++ = ch;
				if (format_ptr - format == zt_elementsOf(format) - 1 ) {
					format_ptr = format;
					in_format = false;
				}
				continue;
			}
		}
		else if (ch == '<') {
			in_format = true;
			continue;
		}

		actl_letter += 1;

		if (glyph_idx < 0) {
			if (row_height == 0) {
				row_height = font->line_height;
			}

			if (ch == '\n') {
				if (current_row == row) {
					*width = row_width;
					*height = row_height;
					return;
				}
				total_height += row_height + (font->line_spacing);
				total_width = zt_max(total_width, row_width);
				row_height = row_width = 0;
				current_row += 1;
			}
			else if (ch == ' ') {
				row_width += font->space_width;
			}
			else if (ch == '\t') {
				row_width += font->space_width * 4; // TODO(josh): fix this
			}
			continue;
		}

		r32 x = font->glyphs[glyph_idx].x_adv;
		r32 y = zt_max(row_height, font->line_height);

		if (text_anim) {
			ztFont::Glyph *glyph = &font->glyphs[glyph_idx];
			ztVec2 units_size = glyph->size;
			ztVec3 dl_pos[4];
			ztVec2 dl_uvs[4];

			// points in ccw order
			dl_pos[0].x = 0; dl_pos[1].x = 0;                dl_pos[2].x = 0 + units_size.x; dl_pos[3].x = 0 + units_size.x;
			dl_pos[0].y = 0; dl_pos[1].y = 0 - units_size.y; dl_pos[2].y = 0 - units_size.y; dl_pos[3].y = 0;

			dl_uvs[0].x = glyph->tex_uv.x; dl_uvs[1].x = glyph->tex_uv.x; dl_uvs[2].x = glyph->tex_uv.z; dl_uvs[3].x = glyph->tex_uv.z;
			dl_uvs[0].y = glyph->tex_uv.y; dl_uvs[1].y = glyph->tex_uv.w; dl_uvs[2].y = glyph->tex_uv.w; dl_uvs[3].y = glyph->tex_uv.y;

			bool should_skip, pop_color;
			text_anim(nullptr, font->glyph_code_point[glyph_idx], actl_letter, actl_text_len, current_row, dl_pos, dl_uvs, &x, &y, &should_skip, &pop_color, text_anim_user_data);
		}

		last_xadv = x - font->glyphs[glyph_idx].size.x;
		row_width += x;
		row_height = zt_max(zt_max(row_height, font->line_height), y);
	}
	row_width -= last_xadv;
	total_height += row_height;
	total_width = zt_max(total_width, row_width);

	if (row == current_row) {
		*width = row_width;
		*height = row_height;
	}
	else {
		*width = total_width;
		*height = total_height;
	}
}

// ================================================================================================================================================================================================

ztVec2 zt_fontGetExtentsFancy(ztFontID font_id, const char *text, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	return zt_fontGetExtentsFancy(font_id, text, zt_strLen(text));
}

// ================================================================================================================================================================================================

ztVec2 zt_fontGetExtentsFancy(ztFontID font_id, const char *text, int text_len, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("zt_fontGetExtentsFancy");
	if (text == nullptr || text_len <= 0) {
		return ztVec2::zero;
	}

	i32 glyphs_idx_lcl[1024];
	i32 *glyphs_idx = text_len > zt_elementsOf(glyphs_idx_lcl) - 1 ? zt_mallocStructArray(i32, text_len) : glyphs_idx_lcl;

	_zt_fontGetGlyphsFromText(font_id, text, text_len, glyphs_idx, text_len);

	ztVec2 result;
	_zt_fontGetExtentsFancy(font_id, text, text_len, -1, glyphs_idx, zt_elementsOf(glyphs_idx), &result.x, &result.y, text_anim, text_anim_user_data);

	if (text_len > zt_elementsOf(glyphs_idx_lcl)) {
		zt_free(glyphs_idx);
	}

	return result;
}

// ================================================================================================================================================================================================

void zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztColor default_color, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddFancyText2D(draw_list, font_id, text, zt_strLen(text), pos, ztVec2::one, align_flags, anchor_flags, extents, default_color, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztColor default_color, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddFancyText2D(draw_list, font_id, text, text_len, pos, ztVec2::one, align_flags, anchor_flags, extents, default_color, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, ztVec2 pos, ztVec2 scale, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztColor default_color, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	zt_drawListAddFancyText2D(draw_list, font_id, text, zt_strLen(text), pos, scale, align_flags, anchor_flags, extents, default_color, transform, text_anim, text_anim_user_data);
}

// ================================================================================================================================================================================================

void zt_drawListAddFancyText2D(ztDrawList *draw_list, ztFontID font_id, const char *text, int text_len, ztVec2 pos, ztVec2 scale, i32 align_flags, i32 anchor_flags, ztVec2 *extents, ztColor default_color, ztMat4 *transform, ztTextAnim_Func *text_anim, void *text_anim_user_data)
{
	ZT_PROFILE_RENDERING("zt_drawListAddFancyText2D");
	zt_returnOnNull(draw_list);
	zt_assert(font_id >= 0 && font_id < zt_game->fonts_count);
	if (text_len <= 0) return;

	ztFont *font = &zt_game->fonts[font_id];

	i32 glyphs_idx[1024 * 64];
	_zt_fontGetGlyphsFromText(font_id, text, text_len, glyphs_idx, zt_elementsOf(glyphs_idx));

	r32 total_width = 0;
	r32 total_height = 0;

	int rows = _zt_fontGetRowCount(text, text_len);
	_zt_fontGetExtentsFancy(font_id, text, text_len, -1, glyphs_idx, zt_elementsOf(glyphs_idx), &total_width, &total_height, text_anim, text_anim_user_data);

	total_width *= scale.x;
	total_height *= scale.y;

	if (extents) {
		extents->x = total_width;
		extents->y = total_height;
	}

	r32 true_total_height = total_height;

	ztVec2 size = ztVec2::zero; // TODO(josh): add support for setting area for font to fit to
	if (size.x > total_width) total_width = size.x;
	if (size.y > total_height) total_height = size.y;

	ztVec2 position = pos;
	if (zt_bitIsSet(anchor_flags, ztAnchor_Left)) { position.x += total_width / 2.f; }
	else if (zt_bitIsSet(anchor_flags, ztAnchor_Right)) { position.x -= total_width / 2.f; }
	if (zt_bitIsSet(anchor_flags, ztAnchor_Top)) { position.y -= total_height / 2.f; }
	else if (zt_bitIsSet(anchor_flags, ztAnchor_Bottom)) { position.y += total_height / 1.f; }

	r32 start_pos_y = (position.y + (true_total_height / 2)); // initially start out at the top left corner.  each row needs to subtract its height to get the proper start pos

	if (zt_bitIsSet(align_flags, ztAlign_Top)) { start_pos_y += (total_height - true_total_height) / 2.f; }
	else if (zt_bitIsSet(align_flags, ztAlign_Bottom)) { start_pos_y -= (total_height - true_total_height) / 2.f; }

	zt_drawListPushTexture(draw_list, font->texture);

	if (transform) {
		zt_drawListPushTransform(draw_list, *transform);
	}

	r32 ppu = zt_pixelsPerUnit();

	bool in_format = false;
	char format[128];
	char *format_ptr = format;

	zt_drawListPushColor(draw_list, default_color);
	int colors_pushed = 0;

	int actl_text_len = _zt_fontGetFancyTextLen(text, text_len, font, glyphs_idx, zt_elementsOf(glyphs_idx));
	int actl_letter = -1;

	for (int r = 0; r < rows; ++r) {
		real32 row_width = 0;
		real32 row_height = 0;
		if (size.x == 0 && size.y == 0 && rows == 1) {
			row_width = total_width;
			row_height = total_height;
		}
		else {
			_zt_fontGetExtentsFancy(font_id, text, text_len, r, glyphs_idx, zt_elementsOf(glyphs_idx), &row_width, &row_height, text_anim, text_anim_user_data);
			row_width *= scale.x;
			row_height *= scale.y;
		}

		int start_char = 0, length = 0;
		_zt_fontGetRowInfo(text, text_len, r, &start_char, &length);

		start_pos_y -= row_height;

		r32 start_pos_x = position.x - (total_width / 2.f);

		if (zt_bitIsSet(align_flags, ztAlign_Center)) {
			start_pos_x = position.x - (row_width / 2.f);
		}
		else if (zt_bitIsSet(align_flags, ztAlign_Right)) {
			start_pos_x = position.x + (total_width / 2.f - row_width);
		}

		ztVec2 position;
		ztVec2 units_size;

		r32 scale_x = scale.x;
		r32 scale_y = scale.y;

		ztVec3 dl_pos[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };
		ztVec2 dl_uvs[4];
		ztVec3 dl_nml[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero, ztVec3::zero };

		ztFont::Glyph *prev_glyph = nullptr;

		r32 y_adv = font->line_spacing * scale_y;

		for (int i = start_char; i < start_char + length; ++i) {
			int glyph_idx = glyphs_idx[i];
			char ch;

			if (glyph_idx < 0) {
				ch = (char)zt_strCodepoint(text, i);
			}
			else {
				ch = (char)font->glyph_code_point[glyph_idx];
			}

			if (in_format) {
				if (ch == '>') {
					in_format = false;
					*format_ptr = 0;
					format_ptr = format;

					int str_len = zt_strLen(format);
					if (zt_strStartsWith(format, "color=") && (str_len == 12 || str_len == 14) ) {
						r32 r = zt_strToIntHex(format + 6, 2, 1) / 255.f;
						r32 g = zt_strToIntHex(format + 8, 2, 1) / 255.f;
						r32 b = zt_strToIntHex(format + 10, 2, 1) / 255.f;
						r32 a = str_len == 12 ? default_color.a : (zt_strToIntHex(format + 12, 2, 1) / 255.f);
						zt_drawListPushColor(draw_list, zt_color(r, g, b, a));
						colors_pushed += 1;
					}
					else if (zt_strStartsWith(format, "/color")) {
						zt_drawListPopColor(draw_list);
						colors_pushed -= 1;
					}
					else if (zt_strStartsWith(format, "sprite=")) {
						ztToken tokens[7];
						char *sprite_str = format + 7;
						int tokens_count = zt_strTokenize(sprite_str, ",", tokens, zt_elementsOf(tokens));

						if (tokens_count >= 5) {
							i32 id = zt_strToInt(sprite_str + tokens[0].beg, tokens[0].len, 0);
							i32 x = zt_strToInt(sprite_str + tokens[1].beg, tokens[1].len, 0);
							i32 y = zt_strToInt(sprite_str + tokens[2].beg, tokens[2].len, 0);
							i32 w = zt_strToInt(sprite_str + tokens[3].beg, tokens[3].len, 0);
							i32 h = zt_strToInt(sprite_str + tokens[4].beg, tokens[4].len, 0);

							r32 sx = scale_x * (tokens_count >= 6 ? zt_strToReal32(sprite_str + tokens[5].beg, tokens[5].len, 0) : 1.f);
							r32 sy = scale_y * (tokens_count >= 7 ? zt_strToReal32(sprite_str + tokens[6].beg, tokens[6].len, 0) : 1.f);

							ztVec2i ts = zt_textureGetSize(id);
							if (ts.x > 0 && ts.y > 0) {
								r32 ppu = zt_pixelsPerUnit();
								r32 sprite_w = w / ppu;
								r32 sprite_h = h / ppu;

								r32 uv_x = x / (r32)ts.x;
								r32 uv_y = y / (r32)ts.y;
								r32 uv_w = w / (r32)ts.x + uv_x;
								r32 uv_h = h / (r32)ts.y + uv_y;

								r32 scale_diff_x = sprite_w - (sprite_w * sx);
								r32 scale_diff_y = sprite_h - (sprite_h * sy);

								zt_drawListPushTexture(draw_list, id);
								{
									position.x = start_pos_x;
									position.y = start_pos_y + (scale_diff_y / 2.f);

									// points in ccw order
									dl_pos[0].x = position.x; dl_pos[1].x = position.x;                 dl_pos[2].x = position.x + sprite_w * sx; dl_pos[3].x = position.x + sprite_w * sx;
									dl_pos[0].y = position.y + sprite_h * sy; dl_pos[1].y = position.y; dl_pos[2].y = position.y; dl_pos[3].y = position.y + sprite_h * sy;

									dl_uvs[0].x = uv_x; dl_uvs[1].x = uv_x; dl_uvs[2].x = uv_w; dl_uvs[3].x = uv_w;
									dl_uvs[0].y = uv_y; dl_uvs[1].y = uv_h; dl_uvs[2].y = uv_h; dl_uvs[3].y = uv_y;

									r32 x_adv = sprite_w - scale_diff_x;

									if (text_anim) {
										bool should_skip = false, pop_color = false;
										text_anim(draw_list, 0, actl_letter, actl_text_len, r, dl_pos, dl_uvs, &x_adv, &y_adv, &should_skip, &pop_color, text_anim_user_data);
										if (!should_skip) {
											zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
										}

										if (pop_color) {
											zt_drawListPopColor(draw_list);

										}
									}
									else {
										zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
									}

									start_pos_x += x_adv;
								}
								zt_drawListPopTexture(draw_list);
							}
						}
					}

					continue;
				}
				else if (ch == '<') {
					in_format = false;
				}
				else {
					*format_ptr++ = ch;
					if (format_ptr - format == zt_elementsOf(format) - 1) {
						in_format = false;
						format_ptr = format;
					}
					continue;
				}
			}
			else if (ch == '<') {
				in_format = true;
				continue;
			}

			actl_letter += 1;

			if (glyph_idx < 0) {
				if (ch == ' ') {
					start_pos_x += font->space_width * scale_x;
				}
				else if (ch == '\t') {
					start_pos_x += font->space_width * 4 * scale_x; // TODO(josh): fix
				}
				continue;
			}

			ztFont::Glyph* glyph = &font->glyphs[glyph_idx];

			units_size.x = glyph->size.x * scale_x;
			units_size.y = glyph->size.y * scale_y;
			row_height = zt_max(row_height, units_size.y);

			position.x = glyph->offset.x + start_pos_x;
			position.y = start_pos_y - glyph->offset.y * scale_y;

			if (prev_glyph) {
				zt_flink(kerning, prev_glyph->kerning) {
					if (kerning->next_code == font->glyph_code_point[glyph_idx]) {
						position.x += kerning->spacing * scale_x;
						break;
					}
				}
			}

			if (zt_bitIsSet(align_flags, ztAlign_ToPixel)) {
				zt_alignToPixel(&position.x, ppu);
				zt_alignToPixel(&position.y, ppu);
			}

			r32 x_adv = glyph->x_adv * scale_x;

			// points in ccw order
			dl_pos[0].x = position.x; dl_pos[1].x = position.x;                dl_pos[2].x = position.x + units_size.x; dl_pos[3].x = position.x + units_size.x;
			dl_pos[0].y = position.y; dl_pos[1].y = position.y - units_size.y; dl_pos[2].y = position.y - units_size.y; dl_pos[3].y = position.y;

			dl_uvs[0].x = glyph->tex_uv.x; dl_uvs[1].x = glyph->tex_uv.x; dl_uvs[2].x = glyph->tex_uv.z; dl_uvs[3].x = glyph->tex_uv.z;
			dl_uvs[0].y = glyph->tex_uv.y; dl_uvs[1].y = glyph->tex_uv.w; dl_uvs[2].y = glyph->tex_uv.w; dl_uvs[3].y = glyph->tex_uv.y;


			if (text_anim) {
				bool should_skip = false, pop_color = false;
				text_anim(draw_list, font->glyph_code_point[glyph_idx], actl_letter, actl_text_len, r, dl_pos, dl_uvs, &x_adv, &y_adv, &should_skip, &pop_color, text_anim_user_data);
				if (!should_skip) {
					zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
				}

				if (pop_color) {
					zt_drawListPopColor(draw_list);

				}
			}
			else {
				zt_drawListAddFilledQuad(draw_list, dl_pos, dl_uvs, dl_nml);
			}

			start_pos_x += x_adv;

			//start_pos_x = position.x + (glyph->x_adv * scale_x);
			//start_pos_x = position.x + units_size.x;

			prev_glyph = glyph;
		}

		start_pos_y -= y_adv;
	}
	zt_fiz(colors_pushed) {
		zt_drawListPopColor(draw_list);
	}
	zt_drawListPopColor(draw_list);

	if (transform) {
		zt_drawListPopTransform(draw_list);
	}

	zt_drawListPopTexture(draw_list);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztMaterial zt_materialMake(ztTextureID diffuse_tex, const ztVec4 &diffuse_color, i32 diffuse_flags,
						   ztTextureID specular_tex, const ztVec4 &specular_color, i32 specular_flags,
						   ztTextureID normal_tex, i32 normal_flags, 
						   ztTextureID height_tex, i32 height_flags,
						   ztTextureID roughness_tex, i32 roughness_flags,
						   ztTextureID emissive_tex, i32 emissive_flags, r32 emissive_strength,
						   r32 shininess)
{
	ZT_PROFILE_RENDERING("zt_materialMake");
	ztMaterial result;

	result.name[0] = 0;

	result.diffuse_tex                = diffuse_tex;
	result.diffuse_color              = diffuse_color;
	result.diffuse_flags              = diffuse_flags;
	result.diffuse_tex_override       = 0;
	result.diffuse_color_override     = 0;

	result.specular_tex               = specular_tex;
	result.specular_color             = specular_color;
	result.specular_flags             = specular_flags;
	result.specular_tex_override      = 0;
	result.specular_color_override    = 0;

	result.normal_tex                 = normal_tex;
	result.normal_flags               = normal_flags;
	result.normal_tex_override        = 0;

	result.height_tex                 = height_tex;
	result.height_flags               = height_flags;
	result.height_tex_override        = 0;

	result.roughness_tex              = roughness_tex;
	result.roughness_flags            = roughness_flags;
	result.roughness_tex_override     = 0;

	result.emissive_tex               = emissive_tex;
	result.emissive_flags             = emissive_flags;
	result.emissive_tex_override      = 0;
	result.emissive_strength          = emissive_strength;
	result.emissive_strength_override = 0;

	result.shininess                  = shininess;
	result.shininess_override         = 0;

	return result;
}

// ================================================================================================================================================================================================

ztInternal int _zt_materialLoadFromFileDataBase(char *data, int data_size, ztMaterial *materials_arr, int materials_arr_size, ztAssetManager *asset_mgr, ztAssetID asset_id, char *file_name)
{
	ZT_PROFILE_RENDERING("_zt_materialLoadFromFileDataBase");
	zt_returnValOnNull(data, 0);

	int lines = zt_strTokenize(data, data_size, "\r\n", nullptr, 0, ztStrTokenizeFlags_TrimWhitespace);

	ztToken *tokens = zt_mallocStructArray(ztToken, lines);
	zt_strTokenize(data, "\r\n", tokens, lines, ztStrTokenizeFlags_TrimWhitespace);

	int curr_mtl_idx = -1;
	ztMaterial *curr_mtl = nullptr;

	zt_fiz(materials_arr_size) {
		materials_arr[i] = zt_materialMake();
	}

	zt_fiz(lines) {
		char line[1024];
		zt_strCpy(line, zt_elementsOf(line), data + tokens[i].beg, tokens[i].len);

		if (line[0] == '#') continue;

		if (zt_strStartsWith(line, "newmtl")) {
			curr_mtl_idx += 1;

			curr_mtl = curr_mtl_idx < materials_arr_size ? &materials_arr[curr_mtl_idx] : nullptr;
			if (curr_mtl) {
				*curr_mtl = zt_materialMake();

				int space = zt_strFindPos(line, " ", 0);
				if (space != ztStrPosNotFound) {
					zt_strCpy(curr_mtl->name, zt_elementsOf(curr_mtl->name), line + space + 1);
				}
			}
		}
		else if (curr_mtl != nullptr) {
			struct local
			{
				static ztVec4 parseReflectivity(char *line)
				{
					ztVec4 result = ztVec4::one;
					ztToken tokens[3];
					if (zt_strTokenize(line, " ", tokens, zt_elementsOf(tokens)) == 3) {
						result.r = zt_strToReal32(line + tokens[0].beg, tokens[0].len, 1);
						result.g = zt_strToReal32(line + tokens[1].beg, tokens[1].len, 1);
						result.b = zt_strToReal32(line + tokens[2].beg, tokens[2].len, 1);
					}
					// should support spectral curve and CIEXYZ color space
					return result;
				}

				static r32 parseValue(char *line)
				{
					return zt_strToReal32(line, 0);
				}

				static ztTextureID parseTexture(char *line, ztAssetManager *asset_mgr, ztAssetID asset_id, char *file_name)
				{
					char *file = line + zt_strFindLastPos(line, " ") + 1;

					if (asset_mgr) {
						ztAssetID tex_asset_id = zt_assetLoad(asset_mgr, file, asset_id);
						if (tex_asset_id != ztInvalidID) {
							return zt_textureMake(asset_mgr, tex_asset_id);
						}
					}
					else {
						char tex_file_name[ztFileMaxPath];
						zt_fileGetFileInOtherFileDirectory(tex_file_name, ztFileMaxPath, file, file_name);
						zt_logInfo("Loading material image: %s", tex_file_name);
						return zt_textureMakeFromFile(tex_file_name);
					}
					return ztInvalidID;
				}
			};
			if (zt_strStartsWith(line, "Ka ")) {	// ambient reflectivity
			}
			else if (zt_strStartsWith(line, "Kd ")) {	// diffuse reflectivity
				curr_mtl->diffuse_color = local::parseReflectivity(line + 3);
			}
			else if (zt_strStartsWith(line, "Ks ")) {	// specular reflectivity
				curr_mtl->specular_color = local::parseReflectivity(line + 3);
			}
			else if (zt_strStartsWith(line, "Ni ")) {	// optical density
			}
			else if (zt_strStartsWith(line, "Ns ")) {	// specular exponent
				curr_mtl->shininess = local::parseValue(line) / 1000.f;
			}
			else if (zt_strStartsWith(line, "d ")) {	// dissolve
			}
			else if (zt_strStartsWith(line, "illum ")) { // illumination model
			}
			else if (zt_strStartsWith(line, "sharpness ")) {	// sharpness of reflections
			}
			else if (zt_strStartsWith(line, "map_Ka ")) {
			}
			else if (zt_strStartsWith(line, "map_Kd ")) {
				if (curr_mtl->diffuse_tex != ztInvalidID) {
					zt_assert(false);
				}
				curr_mtl->diffuse_tex = local::parseTexture(line, asset_mgr, asset_id, file_name);
				curr_mtl->diffuse_flags |= ztMaterialFlags_OwnsTexture;
			}
			else if (zt_strStartsWith(line, "map_Ks ")) {
				if (curr_mtl->specular_tex != ztInvalidID) {
					zt_assert(false);
				}
				curr_mtl->specular_tex = local::parseTexture(line, asset_mgr, asset_id, file_name);
				curr_mtl->specular_flags |= ztMaterialFlags_OwnsTexture;
			}
			else if (zt_strStartsWith(line, "map_Ns ") || zt_strStartsWith(line, "map_bump ")) {
				if (curr_mtl->normal_tex != ztInvalidID) {
					zt_assert(false);
				}
				curr_mtl->normal_tex = local::parseTexture(line, asset_mgr, asset_id, file_name);
				curr_mtl->normal_flags |= ztMaterialFlags_OwnsTexture;
			}
			else if (zt_strStartsWith(line, "map_d ")) {
			}
			else if (zt_strStartsWith(line, "disp ")) {
			}
			else if (zt_strStartsWith(line, "decal ")) {
			}
			else if (zt_strStartsWith(line, "bump ")) {
			}
			else if (zt_strStartsWith(line, "refl ")) {
			}
		}
	}

	zt_free(tokens);

	return curr_mtl_idx + 1;
}

// ================================================================================================================================================================================================

int zt_materialLoad(ztAssetManager *asset_mgr, ztAssetID asset_id, ztMaterial *materials_arr, int materials_arr_size)
{
	ZT_PROFILE_RENDERING("zt_materialLoad");
	zt_returnValOnNull(asset_mgr, 0);
	if(asset_id == ztInvalidID) {
		return 0;
	}
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_Material) {
		zt_logCritical("Asset is not a material: %s", asset_mgr->asset_name[asset_id]);
		return 0;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		zt_logCritical("Unable to determine asset size: %s", asset_mgr->asset_name[asset_id]);
		return 0;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		zt_logCritical("Unable to allocate memory: %s (%d bytes)", asset_mgr->asset_name[asset_id], size);
		return 0;
	}

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		zt_logCritical("Unable to load asset contents: %s", asset_mgr->asset_name[asset_id]);
		zt_free(data);
		return 0;
	}
	int result = _zt_materialLoadFromFileDataBase(data, size, materials_arr, materials_arr_size, asset_mgr, asset_id, nullptr);
	zt_freeArena(data, asset_mgr->arena);
	return result;
}

// ================================================================================================================================================================================================

int zt_materialLoadFromFile(char *file_name, ztMaterial *materials_arr, int materials_arr_size)
{
	ZT_PROFILE_RENDERING("zt_materialLoadFromFile");
	int size = zt_fileSize(file_name);
	if (size <= 0) {
		zt_logCritical("Unable to determine size of file: %s", file_name);
		return 0;
	}

	char *data = zt_mallocStructArray(char, size);
	if (!data) {
		zt_logCritical("Unable to allocate memory: %s (%d bytes)", file_name, size);
		return 0;
	}

	zt_readEntireFile(file_name, data, size);

	int result = _zt_materialLoadFromFileDataBase(data, size, materials_arr, materials_arr_size, nullptr, ztInvalidID, file_name);
	zt_free(data);
	return result;
}

// ================================================================================================================================================================================================

void zt_materialFree(ztMaterial *material)
{
	ZT_PROFILE_RENDERING("zt_materialFree");
	zt_returnOnNull(material);

	if (zt_bitIsSet(material->diffuse_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->diffuse_tex);
	}
	material->diffuse_tex = ztInvalidID;
	material->diffuse_flags = 0;
	material->diffuse_color = ztVec4::one;
	material->diffuse_tex_override = 0;
	material->diffuse_color_override = 0;

	if (zt_bitIsSet(material->specular_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->specular_tex);
	}
	material->specular_tex = ztInvalidID;
	material->specular_flags = 0;
	material->specular_color = ztVec4::one;
	material->specular_tex_override = 0;
	material->specular_color_override = 0;

	if (zt_bitIsSet(material->normal_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->normal_tex);
	}
	material->normal_tex = ztInvalidID;
	material->normal_flags = 0;
	material->normal_tex_override = 0;

	if (zt_bitIsSet(material->height_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->height_tex);
	}
	material->height_tex = ztInvalidID;
	material->height_flags = 0;
	material->height_tex_override = 0;

	material->shininess_override = 0;

	if (zt_bitIsSet(material->roughness_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->roughness_tex);
	}
	material->roughness_tex = ztInvalidID;
	material->roughness_flags = 0;
	material->roughness_tex_override = 0;

	if (zt_bitIsSet(material->emissive_flags, ztMaterialFlags_OwnsTexture)) {
		zt_textureFree(material->emissive_tex);
	}
	material->emissive_tex = ztInvalidID;
	material->emissive_flags = 0;
	material->emissive_tex_override = 0;

	material->shininess_override = 0;
}

// ================================================================================================================================================================================================

bool zt_materialIsEmpty(ztMaterial *material)
{
	if (material->diffuse_tex != ztInvalidID || material->diffuse_color != ztVec4::one ||
		material->specular_tex != ztInvalidID || material->specular_color != ztVec4::one ||
		material->normal_tex != ztInvalidID || material->height_tex != ztInvalidID) {
		return false;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_materialIsEqual(ztMaterial *material1, ztMaterial *material2)
{
	return 0 == zt_memCmp(material1, material2, zt_sizeof(ztMaterial));
}

// ================================================================================================================================================================================================

void zt_materialPrepare(ztMaterial *material, ztShaderID shader, ztTextureID *additional_tex, u32 *additional_tex_name_hashes, int additional_tex_count)
{
	ZT_PROFILE_RENDERING("zt_materialPrepare");
	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			ztgl_textureBindReset(zt_game->shaders[shader].gl_shader);

			int tex_count = 0;
			ztTextureID diffuse_tex = zt_max(material->diffuse_tex, ztTextureDefaultWhite);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 diffuse_tex_hash = zt_strHash("diffuse_tex");
			zt_shaderSetVariableTex(shader, material->diffuse_tex_override ? material->diffuse_tex_override : diffuse_tex_hash, diffuse_tex);

			ztTextureID specular_tex = zt_max(material->specular_tex, ztTextureDefaultBlack);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 specular_tex_hash = zt_strHash("specular_tex");
			ztgl_textureBind(zt_game->textures[specular_tex].gl_texture, tex_count);
			zt_shaderSetVariableTex(shader, material->specular_tex_override ? material->specular_tex_override : specular_tex_hash, specular_tex);

			ztTextureID normal_tex = zt_max(material->normal_tex, ztTextureDefaultWhite);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 normal_tex_hash = zt_strHash("normal_tex");
			zt_shaderSetVariableTex(shader, material->normal_tex_override ? material->normal_tex_override : normal_tex_hash, normal_tex);

			ztTextureID height_tex = zt_max(material->height_tex, ztTextureDefaultWhite);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 height_tex_hash = zt_strHash("height_tex");
			zt_shaderSetVariableTex(shader, material->height_tex_override ? material->height_tex_override : height_tex_hash, height_tex);

			ztTextureID roughness_tex = zt_max(material->roughness_tex, ztTextureDefaultWhite);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 roughness_tex_hash = zt_strHash("roughness_tex");
			zt_shaderSetVariableTex(shader, material->roughness_tex_override ? material->roughness_tex_override : roughness_tex_hash, roughness_tex);

			ztTextureID emissive_tex = zt_max(material->emissive_tex, ztTextureDefaultBlack);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 emissive_tex_hash = zt_strHash("emissive_tex");
			zt_shaderSetVariableTex(shader, material->emissive_tex_override ? material->emissive_tex_override : emissive_tex_hash, emissive_tex);

			static u32 emissive_strength_hash = zt_strHash("emissive_strength");
			zt_shaderSetVariableFloat(shader, material->emissive_strength_override ? material->emissive_strength_override : emissive_strength_hash, material->emissive_strength);

			zt_fiz(additional_tex_count) {
				if (additional_tex[i] != ztInvalidID) {
					zt_game->game_details.curr_frame.texture_switches += 1;
					zt_shaderSetVariableTex(shader, additional_tex_name_hashes[i], additional_tex[i]);
					tex_count += 1;
				}
			}

			zt_game->shaders[shader].textures_bound = tex_count;

#			endif
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)

			ztTextureID diffuse_tex = zt_max(material->diffuse_tex, 0);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 diffuse_tex_hash = zt_strHash("diffuse_tex");
			zt_shaderSetVariableTex(shader, material->diffuse_tex_override ? material->diffuse_tex_override : diffuse_tex_hash, diffuse_tex);

			ztTextureID specular_tex = zt_max(material->specular_tex, 0);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 specular_tex_hash = zt_strHash("specular_tex");
			zt_shaderSetVariableTex(shader, material->specular_tex_override ? material->specular_tex_override : specular_tex_hash, specular_tex);

			ztTextureID normal_tex = zt_max(material->normal_tex, 0);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 normal_tex_hash = zt_strHash("normal_tex");
			zt_shaderSetVariableTex(shader, material->normal_tex_override ? material->normal_tex_override : normal_tex_hash, normal_tex);

			ztTextureID height_tex = zt_max(material->height_tex, 0);
			zt_game->game_details.curr_frame.texture_switches += 1;
			static u32 height_tex_hash = zt_strHash("height_tex");
			zt_shaderSetVariableTex(shader, material->height_tex_override ? material->height_tex_override : height_tex_hash, height_tex);

			zt_fiz(additional_tex_count) {
				if (additional_tex[i] != ztInvalidID) {
					zt_game->game_details.curr_frame.texture_switches += 1;
					zt_shaderSetVariableTex(shader, additional_tex_name_hashes[i], additional_tex[i]);
				}
			}
#			endif
		} break;

		default: {
			zt_assert(false);
		}
	}

	static u32 diffuse_color_hash = zt_strHash("diffuse_color");
	static u32 specular_color_hash = zt_strHash("specular_color");
	static u32 shininess_hash = zt_strHash("shininess");

	zt_shaderSetVariableVec4(shader, material->diffuse_color_override ? material->diffuse_color_override : diffuse_color_hash, material->diffuse_color);
	zt_shaderSetVariableVec4(shader, material->specular_color_override ? material->specular_color_override : specular_color_hash, material->specular_color);
	zt_shaderSetVariableFloat(shader, material->shininess_override ? material->shininess_override : shininess_hash, material->shininess);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztMeshID zt_meshMake(ztVec3 *verts, ztVec2 *uvs, ztVec3 *normals, i32 vert_count, u32 *indices, i32 indices_count, void *additional_data, ztVertexArrayEntry *add_entries, int entries_count, ztColor color)
{
	ZT_PROFILE_RENDERING("zt_meshMake");
#	pragma pack(push, 1)
	struct ztVertex
	{
		ztVec3 pos;
		ztVec2 uv;
		ztVec3 normals;
		ztVec4 colors;
		ztVec4 tangent;
		ztVec4 bitangent;
	};
#	pragma pack(pop)

	int stride = zt_sizeof(ztVertex);

	zt_fiz(entries_count) {
		stride += add_entries[i].count * zt_vertexArrayDataSize(add_entries[i].type);
	}

	u32* t_indices = nullptr;
	if (indices_count == 0) {
		t_indices = zt_mallocStructArray(u32, vert_count);
		indices_count = vert_count;
		indices = t_indices;

		zt_fiz(indices_count) indices[i] = i;
	}

	// todo(josh): should be updated to actually use the indices instead of making multiple copies of shared vertices

	byte *vertices = zt_mallocStructArray(byte, indices_count * stride);

	ztVec3 *t_normals = nullptr;
	if (normals == nullptr) {
		// calculate the vertex normals
		t_normals = zt_mallocStructArray(ztVec3, vert_count);
		zt_fiz(vert_count) t_normals[i] = ztVec3::zero;

		// for each vertex, we need to find the faces that surround it and add them to
		for (int i = 0; i < indices_count; i += 3) {
			ztVec3 u = verts[indices[i + 1]] - verts[indices[i + 0]];
			ztVec3 v = verts[indices[i + 2]] - verts[indices[i + 0]];

			for (int j = 0; j < 3; ++j) {
				t_normals[indices[i + j]].x += u.y * v.z - u.z * v.y;
				t_normals[indices[i + j]].y += u.z * v.x - u.x * v.z;
				t_normals[indices[i + j]].z += u.x * v.y - u.y * v.x;
			}
		}

		zt_fiz(vert_count) {
			t_normals[i].normalize();
		}

		normals = t_normals;
	}
	
	int add_data_size = stride - zt_sizeof(ztVertex);

	zt_fiz(indices_count) {
		ztVertex *vertex = (ztVertex*)(vertices + stride * i);
		vertex->pos     = verts[indices[i]];
		vertex->uv      = uvs == nullptr ? ztVec2::zero : uvs[indices[i]];
		vertex->normals = normals[indices[i]];
		vertex->colors  = color;

		if (add_data_size) {
			byte *add_data_dst = ((byte*)vertex) + zt_sizeof(ztVertex);
			byte *add_data_src = ((byte*)additional_data) + add_data_size * indices[i];
			zt_memCpy(add_data_dst, add_data_size, add_data_src, add_data_size);
		}

		indices[i] = i;

		vertex->uv.y = 1 - vertex->uv.y;
	}

	int triangles = indices_count / 3;
	zt_logDebug("mesh: creating mesh with %d triangles", triangles);
	int idx = 0;
	zt_fiz(triangles) {
		ztVertex& v1 = *(ztVertex*)(vertices + stride * idx++);
		ztVertex& v2 = *(ztVertex*)(vertices + stride * idx++);
		ztVertex& v3 = *(ztVertex*)(vertices + stride * idx++);

		ztVec3 edge1 = v2.pos - v1.pos;
		ztVec3 edge2 = v3.pos - v1.pos;
		ztVec2 duv1 = v2.uv - v1.uv;
		ztVec2 duv2 = v3.uv - v1.uv;

		r32 f = 1.f / (duv1.x * duv2.y - duv2.x * duv1.y);

		ztVec3 tangent   = zt_vec3(f * ( duv2.y * edge1.x - duv1.y * edge2.x), f * ( duv2.y * edge1.y - duv1.y * edge2.y), f * ( duv2.y * edge1.z - duv1.y * edge2.z));
		ztVec3 bitangent = zt_vec3(f * (-duv2.x * edge1.x + duv1.x * edge2.x), f * (-duv2.x * edge1.y + duv1.x * edge2.y), f * (-duv2.x * edge1.z + duv1.x * edge2.z));

		tangent.z *= -1;
		bitangent.z *= -1;

		tangent.normalize();
		bitangent.normalize();

		v1.tangent = v2.tangent = v3.tangent = zt_vec4(tangent, 0);
		v1.bitangent = v2.bitangent = v3.bitangent = zt_vec4(bitangent, 0);
	}

	zt_assert(zt_game->meshes_count < zt_elementsOf(zt_game->meshes));
	ztMeshID mesh_id = zt_game->meshes_count++;
	ztMesh *mesh = &zt_game->meshes[mesh_id];
	zt_memSet(mesh, zt_sizeof(ztMesh), 0);

	mesh->triangles = indices_count / 3;
	mesh->indices = indices_count;

	{
		// calculate aabb / obb

		ztVec3 ext_min = ztVec3::max, ext_max = ztVec3::min;
		zt_fiz(vert_count) {
			ext_min.x = zt_min(ext_min.x, verts[i].x);
			ext_min.y = zt_min(ext_min.y, verts[i].y);
			ext_min.z = zt_min(ext_min.z, verts[i].z);

			ext_max.x = zt_max(ext_max.x, verts[i].x);
			ext_max.y = zt_max(ext_max.y, verts[i].y);
			ext_max.z = zt_max(ext_max.z, verts[i].z);
		}



//		r32 aabb_dist = zt_max(zt_max(zt_max(ext_max.x, ext_max.y), ext_max.z), zt_abs(zt_min(zt_min(ext_min.x, ext_min.y), ext_min.z)));
//		ztVec2 dist_min(-aabb_dist, -aabb_dist), dist_max(aabb_dist, aabb_dist);
//
//		r32 aabb_dist_min = zt_abs(dist_min.distance(ztVec2::zero));
//		r32 aabb_dist_max = zt_abs(dist_max.distance(ztVec2::zero));
//		aabb_dist = zt_max(aabb_dist_min, aabb_dist_max);

//		mesh->aabb = zt_vec3(aabb_dist * 2, aabb_dist * 2, aabb_dist * 2);

		mesh->obb_size = ext_max - ext_min;
		mesh->obb_center = zt_vec3(ext_min.x + mesh->obb_size.x / 2, ext_min.y + mesh->obb_size.y / 2, ext_min.z + mesh->obb_size.z / 2);
	}

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
#			if defined(ZT_OPENGL)
			
			ztVertexEntryGL *entries = zt_mallocStructArray(ztVertexEntryGL, 6 + entries_count);
			entries[0] = { GL_FLOAT, 3 * sizeof(GLfloat) };
			entries[1] = { GL_FLOAT, 2 * sizeof(GLfloat) };
			entries[2] = { GL_FLOAT, 3 * sizeof(GLfloat) };
			entries[3] = { GL_FLOAT, 4 * sizeof(GLfloat) };
			entries[4] = { GL_FLOAT, 4 * sizeof(GLfloat) };
			entries[5] = { GL_FLOAT, 4 * sizeof(GLfloat) };
			
			zt_fiz(entries_count) {
				switch(add_entries[i].type)
				{
					case ztVertexArrayDataType_Float: {
						entries[i + 6].type = GL_FLOAT;
						entries[i + 6].size = add_entries[i].count * sizeof(float);
					} break;

					case ztVertexArrayDataType_Int: {
						entries[i + 6].type = GL_INT;
						entries[i + 6].size = add_entries[i].count * sizeof(int);
					} break;

					default: zt_assert(false);
				}

			}

			bool result = ztgl_vertexArrayMake(&mesh->gl_vertex_array, entries, 6 + entries_count, vertices, indices_count);

			zt_free(entries);

			if (!result) {
				return ztInvalidID;
			}

#			endif // ZT_OPENGL
		} break;

		case ztRenderer_DirectX: {
#			if defined(ZT_DIRECTX)
			ztWindowDetails *win_details = &zt_game->win_details[0];

			ztVertexEntryDX *entries = zt_mallocStructArray(ztVertexEntryDX, 6 + entries_count);
			entries[0] = { 3 * sizeof(r32) };
			entries[1] = { 2 * sizeof(r32) };
			entries[2] = { 3 * sizeof(r32) };
			entries[3] = { 4 * sizeof(r32) };
			entries[4] = { 4 * sizeof(r32) };
			entries[5] = { 4 * sizeof(r32) };

			for(int i = 6; i < entries_count; ++i) {
				entries[i].size = add_entries[i - 6].count * zt_vertexArrayDataSize(add_entries[i - 6].type);
			}

			mesh->dx_vertex_array = ztdx_vertexArrayMake(win_details->dx_context, entries, 6 + entries_count, vertices, indices_count);

			zt_free(entries);

			if (mesh->dx_vertex_array == nullptr) {
				return ztInvalidID;
			}
#			endif // ZT_DIRECTX
		} break;
	}

	if (t_indices != nullptr) {
		zt_free(t_indices);
	}
	if (t_normals != nullptr) {
		zt_free(t_normals);
	}

	zt_free(vertices);

	return mesh_id;
}

// ================================================================================================================================================================================================

ztMeshID zt_meshMake(ztVec3 *verts, ztVec2 *uvs, ztVec3 *normals, i32 vert_count, u32 *indices, i32 indices_count, ztColor color)
{
	return zt_meshMake(verts, uvs, normals, vert_count, indices, indices_count, nullptr, nullptr, 0, color);
}

// ================================================================================================================================================================================================

void zt_meshFree(ztMeshID mesh_id)
{
	ZT_PROFILE_RENDERING("zt_meshFree");
	if (mesh_id == ztInvalidID) {
		return;
	}
	zt_assertReturnOnFail(mesh_id >= 0 && mesh_id < zt_game->meshes_count);

	ztMesh *mesh = &zt_game->meshes[mesh_id];

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_vertexArrayFree(&mesh->gl_vertex_array));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_vertexArrayFree(mesh->dx_vertex_array));
		} break;
	}
}

// ================================================================================================================================================================================================

ztMeshID zt_meshMakePrimitiveBox(r32 width, r32 height, r32 depth, ztColor color)
{
	ZT_PROFILE_RENDERING("zt_meshMakePrimitiveBox");
	ztVec3 vertices[] = {
		/* front face  */ zt_vec3(-.5f * width,  .5f * height,  .5f * depth), zt_vec3(-.5f * width, -.5f * height,  .5f * depth), zt_vec3( .5f * width, -.5f * height,  .5f * depth), zt_vec3( .5f * width,  .5f * height,  .5f * depth),
		/* back face   */ zt_vec3( .5f * width,  .5f * height, -.5f * depth), zt_vec3( .5f * width, -.5f * height, -.5f * depth), zt_vec3(-.5f * width, -.5f * height, -.5f * depth), zt_vec3(-.5f * width,  .5f * height, -.5f * depth),
		/* top face    */ zt_vec3(-.5f * width,  .5f * height, -.5f * depth), zt_vec3(-.5f * width,  .5f * height,  .5f * depth), zt_vec3( .5f * width,  .5f * height,  .5f * depth), zt_vec3( .5f * width,  .5f * height, -.5f * depth),
		/* bottom face */ zt_vec3(-.5f * width, -.5f * height,  .5f * depth), zt_vec3(-.5f * width, -.5f * height, -.5f * depth), zt_vec3( .5f * width, -.5f * height, -.5f * depth), zt_vec3( .5f * width, -.5f * height,  .5f * depth),
		/* right face  */ zt_vec3( .5f * width,  .5f * height,  .5f * depth), zt_vec3( .5f * width, -.5f * height,  .5f * depth), zt_vec3( .5f * width, -.5f * height, -.5f * depth), zt_vec3( .5f * width,  .5f * height, -.5f * depth),
		/* left face   */ zt_vec3(-.5f * width,  .5f * height, -.5f * depth), zt_vec3(-.5f * width, -.5f * height, -.5f * depth), zt_vec3(-.5f * width, -.5f * height,  .5f * depth), zt_vec3(-.5f * width,  .5f * height,  .5f * depth)
	};

	ztVec2 uvs[] = {
		zt_vec2(0.0f, 0.0f), zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
		zt_vec2(0.0f, 0.0f),	zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
		zt_vec2(0.0f, 0.0f), zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
		zt_vec2(0.0f, 0.0f), zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
		zt_vec2(0.0f, 0.0f),	zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
		zt_vec2(0.0f, 0.0f),	zt_vec2(0.0f, 1.0f), zt_vec2(1.0f, 1.0f), zt_vec2(1.0f, 0.0f),
	};

	ztVec3 normals[] = {
		zt_vec3(0, 0, 1), zt_vec3(0, 0, 1), zt_vec3(0, 0, 1), zt_vec3(0, 0, 1),
		zt_vec3(0, 0, -1), zt_vec3(0, 0, -1), zt_vec3(0, 0, -1), zt_vec3(0, 0, -1),
		zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0), zt_vec3(0, 1, 0),
		zt_vec3(0, -1, 0), zt_vec3(0, -1, 0), zt_vec3(0, -1, 0), zt_vec3(0, -1, 0),
		zt_vec3(1, 0, 0), zt_vec3(1, 0, 0), zt_vec3(1, 0, 0), zt_vec3(1, 0, 0),
		zt_vec3(-1, 0, 0), zt_vec3(-1, 0, 0), zt_vec3(-1, 0, 0), zt_vec3(-1, 0, 0),
	};

	u32 indices[] = {
		/* front face  */ 0, 1, 2, 0, 2, 3,
		/* back face   */ 4, 5, 6, 4, 6, 7,
		/* top face    */ 8, 9, 10, 8, 10, 11,
		/* bottom face */ 12, 13, 14, 12, 14, 15,
		/* right face  */ 16, 17, 18, 16, 18, 19,
		/* left face   */ 20, 21, 22, 20, 22, 23,
	};

	zt_assert(zt_elementsOf(vertices) == zt_elementsOf(normals) && zt_elementsOf(vertices) == zt_elementsOf(uvs));

	return zt_meshMake(vertices, uvs, normals, zt_elementsOf(vertices), indices, zt_elementsOf(indices), color);
}

// ================================================================================================================================================================================================

ztMeshID zt_meshMakePrimitivePlane(r32 width, r32 depth, int grid_w, int grid_d, ztColor color)
{
	ZT_PROFILE_RENDERING("zt_meshMakePrimitivePlane");
	int verts_count = (grid_w * grid_d) * 4 * 2;
	ztVec3 *vertices = zt_mallocStructArray(ztVec3, verts_count);
	ztVec2 *uvs = zt_mallocStructArray(ztVec2, verts_count);
	ztVec3 *normals = zt_mallocStructArray(ztVec3, verts_count);
	int indices_count = (grid_w * grid_d) * 6 * 2;
	u32* indices = zt_mallocStructArray(u32, indices_count);

	real32 x_offset = (width / -2.0f);
	real32 z_offset = (depth / -2.0f);

	int vrt_idx = 0;
	int ind_idx = 0;

	r32 sec_w = (width / grid_w) * .5f;
	r32 sec_d = (depth / grid_d) * .5f;

	for (int k = 0; k < 2; ++k) {
		r32 normal_dir = k == 0 ? 1.f : -1.f;

		for (int z = 0; z < grid_d; ++z) {
			for (int x = 0; x < grid_w; ++x) {
				r32 x_pos = sec_w + x_offset + (x * (width / grid_w));
				r32 z_pos = sec_d + z_offset + (z * (depth / grid_d));

				vertices[vrt_idx] = zt_vec3(-sec_w + x_pos, 0, -sec_d + z_pos);
				uvs[vrt_idx] = zt_vec2(0.0f, 0.0f);
				normals[vrt_idx++] = zt_vec3(0, normal_dir, 0);

				vertices[vrt_idx] = zt_vec3(-sec_w + x_pos, 0, sec_d + z_pos);
				uvs[vrt_idx] = zt_vec2(0.0f, 1.0f);
				normals[vrt_idx++] = zt_vec3(0, normal_dir, 0);

				vertices[vrt_idx] = zt_vec3(sec_w + x_pos, 0, sec_d + z_pos);
				uvs[vrt_idx] = zt_vec2(1.0f, 1.0f);
				normals[vrt_idx++] = zt_vec3(0, normal_dir, 0);

				vertices[vrt_idx] = zt_vec3(sec_w + x_pos, 0, -sec_d + z_pos);
				uvs[vrt_idx] = zt_vec2(1.0f, 0.0f);
				normals[vrt_idx++] = zt_vec3(0, normal_dir, 0);

				if (k == 0) {
					indices[ind_idx++] = vrt_idx - 4;
					indices[ind_idx++] = vrt_idx - 3;
					indices[ind_idx++] = vrt_idx - 2;
					indices[ind_idx++] = vrt_idx - 4;
					indices[ind_idx++] = vrt_idx - 2;
					indices[ind_idx++] = vrt_idx - 1;
				}
				else {
					indices[ind_idx++] = vrt_idx - 1;
					indices[ind_idx++] = vrt_idx - 2;
					indices[ind_idx++] = vrt_idx - 4;
					indices[ind_idx++] = vrt_idx - 2;
					indices[ind_idx++] = vrt_idx - 3;
					indices[ind_idx++] = vrt_idx - 4;
				}
			}
		}
	}

	ztMeshID result = zt_meshMake(vertices, uvs, normals, verts_count, indices, indices_count, color);

	zt_free(indices);
	zt_free(normals);
	zt_free(uvs);
	zt_free(vertices);

	return result;
}

// ================================================================================================================================================================================================

ztMeshID zt_meshMakePrimitiveDiamond(r32 width, r32 top, r32 bottom, int sides, ztColor color)
{
	ZT_PROFILE_RENDERING("zt_meshMakePrimitiveDiamond");
	int verts_count = 6 * sides;

	ztVec3 *vertices = zt_mallocStructArray(ztVec3, verts_count);

	r32 angle = zt_degreesToRadians(360.f / sides);

	ztVec3 vtop = zt_vec3(0, top, 0);
	ztVec3 vbtm = zt_vec3(0, -bottom, 0);

	int vert_idx = 0;
	zt_fiz(sides) {
		ztVec3 side_a = zt_vec3(width * zt_cos(angle * i), 0, width * zt_sin(angle * i));
		ztVec3 side_b = zt_vec3(width * zt_cos(angle * ((i + 1) % sides)), 0, width * zt_sin(angle * ((i + 1) % sides)));

		vertices[vert_idx++] = vtop;
		vertices[vert_idx++] = side_b;
		vertices[vert_idx++] = side_a;

		vertices[vert_idx++] = vbtm;
		vertices[vert_idx++] = side_a;
		vertices[vert_idx++] = side_b;
	}

	ztMeshID result = zt_meshMake(vertices, nullptr, nullptr, verts_count, nullptr, 0, color);

	zt_free(vertices);

	return result;
}

// ================================================================================================================================================================================================

ztMeshID zt_meshMakePrimitiveSphere(r32 radius, int rings, ztMeshPrimativeSphere_Enum texture, ztColor color)
{
	ZT_PROFILE_RENDERING("zt_meshMakePrimitiveSphere");
	int verts_count = rings * rings * 6 * 6;
	ztVec3 *vertices  = zt_mallocStructArray(ztVec3, verts_count);
	ztVec2 *uvs       = zt_mallocStructArray(ztVec2, verts_count);
	
	r32 grid_size = radius * 2 / rings;

	int vert_idx = 0;

	//                           front,        bottom,          back,            top,          left,         right

	r32 y_add_vert_2[6] = { -grid_size,             0,     grid_size,              0,    -grid_size,    -grid_size };
	r32 z_add_vert_2[6] = {          0,    -grid_size,             0,      grid_size,             0,             0 };

	r32 x_add_vert_3[6] = {  grid_size,     grid_size,     grid_size,      grid_size,             0,             0 };
	r32 y_add_vert_3[6] = { -grid_size,             0,     grid_size,              0,    -grid_size,    -grid_size };
	r32 z_add_vert_3[6] = {          0,    -grid_size,             0,      grid_size,     grid_size,    -grid_size };

	r32 x_add_vert_5[6] = {  grid_size,     grid_size,     grid_size,      grid_size,             0,             0 };
	r32 y_add_vert_5[6] = { -grid_size,             0,     grid_size,              0,    -grid_size,    -grid_size };
	r32 z_add_vert_5[6] = {          0,    -grid_size,             0,      grid_size,     grid_size,    -grid_size };

	r32 x_add_vert_6[6] = {  grid_size,     grid_size,     grid_size,      grid_size,             0,             0 };
	r32 z_add_vert_6[6] = {          0,             0,             0,              0,     grid_size,    -grid_size };

	r32 x_start[6]      = {    -radius,       -radius,       -radius,        -radius,       -radius,        radius };
	r32 y_start[6]      = {     radius,       -radius,       -radius,         radius,        radius,        radius };
	r32 z_start[6]      = {     radius,        radius,       -radius,        -radius,       -radius,        radius };

	r32 y_add_1[6]      = { -grid_size,             0,     grid_size,              0,    -grid_size,    -grid_size };
	r32 z_add_1[6]      = {          0,    -grid_size,             0,      grid_size,             0,             0 };

	r32 x_add_2[6]      = { grid_size ,     grid_size,     grid_size,      grid_size,             0,             0 };
	r32 y_add_2[6]      = { radius * 2,             0,   -radius * 2,              0,    radius * 2,    radius * 2 };
	r32 z_add_2[6]      = {          0,    radius * 2,             0,    -radius * 2,     grid_size,    -grid_size };

	r32 uv_x_beg[6]     = {       .25f,          .25f,          .25f,           .25f,         .000f,           .5f };
	r32 uv_y_beg[6]     = {      .000f,          .25f,           .5f,           .75f,         .000f,         .000f };

	zt_fkz(6) {
		r32 x_pos = x_start[k];
		r32 y_pos = y_start[k];
		r32 z_pos = z_start[k];

		zt_fiz(rings) {
			zt_fjz(rings) {
				vertices[vert_idx + 0] = zt_vec3(x_pos                  , y_pos                  , z_pos);
				vertices[vert_idx + 1] = zt_vec3(x_pos                  , y_pos + y_add_vert_2[k], z_pos + z_add_vert_2[k]);
				vertices[vert_idx + 2] = zt_vec3(x_pos + x_add_vert_3[k], y_pos + y_add_vert_3[k], z_pos + z_add_vert_3[k]);

				vertices[vert_idx + 3] = zt_vec3(x_pos                  , y_pos                  , z_pos);
				vertices[vert_idx + 4] = zt_vec3(x_pos + x_add_vert_5[k], y_pos + y_add_vert_5[k], z_pos + z_add_vert_5[k]);
				vertices[vert_idx + 5] = zt_vec3(x_pos + x_add_vert_6[k], y_pos                  , z_pos + z_add_vert_6[k]);

				if (texture == ztMeshPrimitiveSphere_TexDuplicatedPerFace) {
					uvs[vert_idx + 0] = zt_vec2((i + 0) / (r32)rings, (j + 0) / (r32)rings);
					uvs[vert_idx + 1] = zt_vec2((i + 0) / (r32)rings, (j + 1) / (r32)rings);
					uvs[vert_idx + 2] = zt_vec2((i + 1) / (r32)rings, (j + 1) / (r32)rings);

					uvs[vert_idx + 3] = zt_vec2((i + 0) / (r32)rings, (j + 0) / (r32)rings);
					uvs[vert_idx + 4] = zt_vec2((i + 1) / (r32)rings, (j + 1) / (r32)rings);
					uvs[vert_idx + 5] = zt_vec2((i + 1) / (r32)rings, (j + 0) / (r32)rings);
				}
				else {
					uvs[vert_idx + 0] = zt_vec2(uv_x_beg[k] + ((i + 0) / (r32)rings * .25f), uv_y_beg[k] + ((j + 0) / (r32)rings * .25f));
					uvs[vert_idx + 1] = zt_vec2(uv_x_beg[k] + ((i + 0) / (r32)rings * .25f), uv_y_beg[k] + ((j + 1) / (r32)rings * .25f));
					uvs[vert_idx + 2] = zt_vec2(uv_x_beg[k] + ((i + 1) / (r32)rings * .25f), uv_y_beg[k] + ((j + 1) / (r32)rings * .25f));

					uvs[vert_idx + 3] = zt_vec2(uv_x_beg[k] + ((i + 0) / (r32)rings * .25f), uv_y_beg[k] + ((j + 0) / (r32)rings * .25f));
					uvs[vert_idx + 4] = zt_vec2(uv_x_beg[k] + ((i + 1) / (r32)rings * .25f), uv_y_beg[k] + ((j + 1) / (r32)rings * .25f));
					uvs[vert_idx + 5] = zt_vec2(uv_x_beg[k] + ((i + 1) / (r32)rings * .25f), uv_y_beg[k] + ((j + 0) / (r32)rings * .25f));
				}

				vert_idx += 6;

				y_pos += y_add_1[k];
				z_pos += z_add_1[k];
			}
			x_pos += x_add_2[k];
			y_pos += y_add_2[k];
			z_pos += z_add_2[k];
		}
	}

	zt_fiz(vert_idx) {
		vertices[i].normalize();
		vertices[i] *= radius;
	}

	verts_count = vert_idx;

	ztMeshID result = zt_meshMake(vertices, uvs, nullptr, verts_count, nullptr, 0, color);

	zt_free(vertices);
	zt_free(uvs);

	return result;
}

// ================================================================================================================================================================================================

ztInternal int _zt_meshLoadOBJBase(ztAssetManager *asset_mgr, ztAssetID asset_id, char *data, int size, const char *mtl_search_dir, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale, const ztVec3 &offset)
{
	ZT_PROFILE_RENDERING("_zt_meshLoadOBJBase");

	{
		bool has_cr = zt_strFindPos(data, zt_min(1024, size), "\r", 1) != ztStrPosNotFound;
		const char *end_search = has_cr ? "\\\r" : "\\n";
		int replace_chars = has_cr ? 3 : 2;

		zt_fiz(size - replace_chars) {
			if (data[i] == end_search[0] && data[i + 1] == end_search[1]) {
				data[i] = ' ';
				data[i + 1] = ' ';
				if (has_cr) data[i + 2] = ' ';
			}
		}
	}

	int lines = 0;
	zt_fiz(size) {
		if (data[i] == '\n') {
			lines += 1;
		}
	}

	ztToken *tokens = zt_mallocStructArray(ztToken, lines + 1);
	int tokens_count = zt_strTokenize(data, "\r\n", tokens, lines + 1, 0);

	if (tokens_count > lines + 1) {
		tokens_count = zt_min(tokens_count, lines + 1);
	}

	ztMaterial *mats = nullptr;
	int mats_count = 0;

	int verts_count = 0;
	int normals_count = 0;
	int tex_coords_count = 0;
	int indices_count = 0;
	bool has_uv_indices = false;
	bool has_norm_indices = false;

	ztToken l_tokens[128], i_tokens[128];

	bool first_face_entry = true;
	zt_fiz(tokens_count) {
		if (tokens[i].len <= 2) continue;

		char* line = data + tokens[i].beg;

		if (line[0] == 'v' && line[1] == ' ') verts_count += 1;
		else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') normals_count += 1;
		else if (line[0] == 'v' && line[1] == 't' && line[2] == ' ') tex_coords_count += 1;
		else if (line[0] == 'f' && line[1] == ' ') {
			int f_tokens = zt_strTokenize(line, tokens[i].len, " ", l_tokens, zt_elementsOf(l_tokens), 0);
			if (f_tokens < 4) {
				zt_assert(false);
			}
			int triangles = f_tokens - 3;
			indices_count += 3 * triangles;

			if (first_face_entry && f_tokens > 3) {
				first_face_entry = false;
				if (zt_strFindPos(line + l_tokens[1].beg, l_tokens[1].len, "//", 0) == ztStrPosNotFound) {
					has_norm_indices = true;
				}
				int count = zt_strCount(line + l_tokens[1].beg, l_tokens[1].len, "/");
				if (count >= 1) {
					has_uv_indices = true;
				}
			}
		}
		else if (line[0] == 'g' && line[1] == ' ') {
			//break;
		}
		else if (zt_strStartsWith(line, tokens[i].len, "mtllib ", 7)) {
			char mtl_name[128];
			zt_strCpy(mtl_name, zt_elementsOf(mtl_name), line + 7, tokens[i].len - 7);

			if (asset_mgr) {
				ztAssetID mtl_asset_id = zt_assetLoad(asset_mgr, mtl_name, asset_id);
				if (mtl_asset_id != ztInvalidID) {
					mats_count = zt_materialLoad(asset_mgr, mtl_asset_id, nullptr, 0);
					if (mats_count) {
						mats = zt_mallocStructArray(ztMaterial, mats_count);
						zt_fiz(mats_count) {
							mats[i] = zt_materialMake();
						}

						zt_materialLoad(asset_mgr, mtl_asset_id, mats, mats_count);
					}
				}
				else {
					zt_logCritical("Unable to locate material file '%s' while loading OBJ '%s'", mtl_name, asset_mgr->asset_name[asset_id]);
				}
			}
			else if (mtl_search_dir) {
				zt_strMakePrintf(mtl_file, ztFileMaxPath, "%s/%s", mtl_search_dir, mtl_name);

				mats_count = zt_materialLoadFromFile(mtl_file, nullptr, 0);
				if (mats_count) {
					mats = zt_mallocStructArray(ztMaterial, mats_count);
					zt_fiz(mats_count) {
						mats[i] = zt_materialMake();
					}

					zt_materialLoadFromFile(mtl_file, mats, mats_count);
				}
			}
		}
	}

	struct local
	{
		static r32 parseReal(const char* src, ztToken& token)
		{
			static char buffer[128];
			zt_strCpy(buffer, zt_elementsOf(buffer), src + token.beg, token.len);

			return zt_strToReal32(src + token.beg, token.len, 0.f);
		}

		static int parseInt(const char* src, ztToken& token)
		{
			static char buffer[128];
			zt_strCpy(buffer, zt_elementsOf(buffer), src + token.beg, token.len);

			return zt_strToInt(src + token.beg, token.len, 0);
		}

		static ztMeshID applyToMesh(bool has_norm_indices, bool has_uv_indices, int indices_idx, int verts_idx, ztVec3 *verts, ztVec2 *uvs, ztVec3 *normals, u32 *uv_indices, u32 *normal_indices, u32 *indices, int indices_count)
		{
			if (has_norm_indices || has_uv_indices) {
				// we need to redo the vert/normal/uv arrays
				ztVec3* new_verts = zt_mallocStructArray(ztVec3, indices_idx);
				ztVec2* new_uvs = has_uv_indices ? zt_mallocStructArray(ztVec2, indices_idx) : nullptr;
				ztVec3* new_normals = has_norm_indices && normals ? zt_mallocStructArray(ztVec3, indices_idx) : nullptr;

				for (int i = 0; i < indices_idx; ++i) {
					new_verts[i] = verts[indices[i]];
					if (new_uvs) {
						new_uvs[i] = uvs ? uvs[uv_indices[i]] : ztVec2::zero;
					}
					if (new_normals) {
						new_normals[i] = normals[normal_indices[i]];
					}
				}

				zt_logDebug("obj contains %d triangles", indices_idx / 3);

				ztMeshID mesh = zt_meshMake(new_verts, new_uvs, new_normals, indices_idx, nullptr, 0);

				zt_free(new_normals);
				zt_free(new_uvs);
				zt_free(new_verts);

				return mesh;
			}
			else {
				zt_logDebug("obj contains %d triangles", indices_idx / 3);
				return zt_meshMake(verts, uvs, normals, verts_idx, indices, indices_count);
			}
		}
	};

	if (verts_count == 0 || indices_count <= 0) {
		zt_logCritical("Invalid vertices or indices count");
		zt_free(data);
		return ztInvalidID;
	}

	ztVec3* verts = zt_mallocStructArray(ztVec3, verts_count);
	ztVec3* normals = normals_count > 0 ? zt_mallocStructArray(ztVec3, normals_count) : nullptr;
	ztVec2* uvs = tex_coords_count > 0 ? zt_mallocStructArray(ztVec2, tex_coords_count) : nullptr;
	u32* indices = zt_mallocStructArray(u32, indices_count);
	u32* normal_indices = has_norm_indices ? zt_mallocStructArray(u32, indices_count) : nullptr;
	u32* uv_indices = has_uv_indices ? zt_mallocStructArray(u32, indices_count) : nullptr;

	int verts_idx = 0;
	int normals_idx = 0;
	int uvs_idx = 0;
	int indices_idx = 0;

	int group_idx = 0;

	ztMeshID *curr_mesh_id = group_idx < mesh_mat_size ? &mesh_ids[group_idx] : nullptr;
	ztMaterial *curr_mat = group_idx < mesh_mat_size ? &materials[group_idx] : nullptr;

	if (curr_mat) {
		*curr_mat = zt_materialMake();
	}

	// first time around, get the verts/normals/uvs
	bool failed = false;
	for (int i = 0; i < tokens_count && !failed; ++i) {
		if (tokens[i].len <= 2) continue;
		char* line = data + tokens[i].beg;

		if (line[0] == '#') continue;

		int l_tokens_count = zt_strTokenize(line, tokens[i].len, " ", l_tokens, zt_elementsOf(l_tokens), 0);

		if (line[0] == 'v' && line[1] == ' ') {
			if (l_tokens_count < 4) {
				failed = true;
			}
			else {
				verts[verts_idx].x = offset.x + (scale.x * local::parseReal(line, l_tokens[1]));
				verts[verts_idx].y = offset.y + (scale.y * local::parseReal(line, l_tokens[2]));
				verts[verts_idx++].z = offset.z + (scale.z * local::parseReal(line, l_tokens[3]));
			}
		}
		else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') {
			if (l_tokens_count < 4) {
				failed = true;
			}
			else {
				normals[normals_idx].x = local::parseReal(line, l_tokens[1]);
				normals[normals_idx].y = local::parseReal(line, l_tokens[2]);
				normals[normals_idx++].z = local::parseReal(line, l_tokens[3]);
			}
		}
		else if (line[0] == 'v' && line[1] == 't' && line[2] == ' ') {
			if (l_tokens_count < 3) {
				failed = true;
			}
			else {
				uvs[uvs_idx].x = local::parseReal(line, l_tokens[1]);
				uvs[uvs_idx++].y = 1 - local::parseReal(line, l_tokens[2]);
			}
		}
	}

	// second time around, populate the groups
	failed = false;
	int group_mtls = 0;
	for (int i = 0; i < tokens_count && !failed; ++i) {
		if (tokens[i].len <= 2) continue;
		char* line = data + tokens[i].beg;

		if (line[0] == '#') continue;

		int l_tokens_count = zt_strTokenize(line, tokens[i].len, " ", l_tokens, zt_elementsOf(l_tokens), 0);

		if (line[0] == 'f' && line[1] == ' ') {
			if (l_tokens_count < 4) {
				failed = true;
			}
			else if (l_tokens_count <= 64) {
				int triangles = l_tokens_count - 3;
				int vert_indexes[64] = { 0 };
				int norm_indexes[64] = { 0 };
				int uv_indexes[64] = { 0 };

				int indexes_idx = 0;

				for (int j = 1; j < l_tokens_count; ++j) {
					char* i_token_str = line + l_tokens[j].beg;
					int i_tokens_count = zt_strTokenize(i_token_str, l_tokens[j].len, "/", i_tokens, zt_elementsOf(i_tokens), 0);
					switch (i_tokens_count)
					{
						case 3: {	// vertex / uv / normal
							norm_indexes[indexes_idx] = local::parseInt(i_token_str, i_tokens[2]) - 1;
							uv_indexes[indexes_idx] = local::parseInt(i_token_str, i_tokens[1]) - 1;
							vert_indexes[indexes_idx++] = local::parseInt(i_token_str, i_tokens[0]) - 1;
						} break;

						case 2: {	// either vertex / uv or vertex // normal
							if (has_uv_indices) {
								uv_indexes[indexes_idx] = local::parseInt(i_token_str, i_tokens[1]) - 1;
							}
							else {
								norm_indexes[indexes_idx] = local::parseInt(i_token_str, i_tokens[1]) - 1;
							}
							vert_indexes[indexes_idx++] = local::parseInt(i_token_str, i_tokens[0]) - 1;
						} break;

						case 1: {	// vertex
							vert_indexes[indexes_idx++] = local::parseInt(i_token_str, i_tokens[0]) - 1;
						} break;
					}
				}

#				define _zt_assignIndexesToIndices(INDEX_IDX) \
					if (has_norm_indices) { normal_indices[indices_idx] = norm_indexes[INDEX_IDX]; } \
					if (has_uv_indices) { uv_indices[indices_idx] = uv_indexes[INDEX_IDX]; } \
					indices[indices_idx++] = vert_indexes[INDEX_IDX];

				for (int i = 0; i < triangles; ++i) {
					_zt_assignIndexesToIndices(0);
					_zt_assignIndexesToIndices(1 + i);
					_zt_assignIndexesToIndices(2 + i);
				}

#				undef _zt_assignIndexesToIndices
			}
		}
		else if (line[0] == 'g' && line[1] == ' ') {
			if (indices_idx != 0) {
				if (curr_mesh_id) {
					*curr_mesh_id = local::applyToMesh(has_norm_indices, has_uv_indices, indices_idx, verts_idx, verts, uvs, normals, uv_indices, normal_indices, indices, indices_count);
					indices_idx = 0;
				}
				group_idx += 1;
				group_mtls = 0;
				curr_mesh_id = group_idx < mesh_mat_size ? &mesh_ids[group_idx] : nullptr;
				curr_mat = group_idx < mesh_mat_size ? &materials[group_idx] : nullptr;

				if (curr_mat) {
					*curr_mat = zt_materialMake();
				}
			}
		}
		else if (tokens[i].len > 8) {
			if (zt_strStartsWith(line, tokens[i].len, "usemtl ", 7) && l_tokens_count > 1) {
				if (++group_mtls > 1 && indices_idx != 0) {
					if (curr_mesh_id) {
						*curr_mesh_id = local::applyToMesh(has_norm_indices, has_uv_indices, indices_idx, verts_idx, verts, uvs, normals, uv_indices, normal_indices, indices, indices_count);
						indices_idx = 0;
					}
					group_idx += 1;
					//group_mtls = 0; // this is causing materials to be reused, mistakenly
					curr_mesh_id = group_idx < mesh_mat_size ? &mesh_ids[group_idx] : nullptr;
					curr_mat = group_idx < mesh_mat_size ? &materials[group_idx] : nullptr;

					if (curr_mat) {
						*curr_mat = zt_materialMake();
					}
				}

				char mtl_name[128];
				zt_strCpy(mtl_name, zt_elementsOf(mtl_name), line + l_tokens[1].beg, l_tokens[1].len);

				zt_fkz(mats_count) {
					if (zt_strEquals(mats[k].name, mtl_name)) {
						if (curr_mat) {
							*curr_mat = mats[k];
						}
						break;
					}
				}
			}
		}
	}
	if (curr_mesh_id) {
		*curr_mesh_id = local::applyToMesh(has_norm_indices, has_uv_indices, indices_idx, verts_idx, verts, uvs, normals, uv_indices, normal_indices, indices, indices_count);
		group_idx += 1;
	}

	zt_free(indices);
	if (uvs != nullptr) zt_free(uvs);
	if (uv_indices != nullptr) zt_free(uv_indices);
	if (normals != nullptr) zt_free(normals);
	if (normal_indices != nullptr) zt_free(normal_indices);
	if (mats != nullptr) zt_free(mats);
	zt_free(verts);

	zt_free(tokens);

	return group_idx;
}

// ================================================================================================================================================================================================

int zt_meshLoadOBJ(ztAssetManager *asset_mgr, ztAssetID asset_id, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale, const ztVec3 &offset)
{
	ZT_PROFILE_RENDERING("zt_meshLoadOBJ(asset)");

	zt_returnValOnNull(asset_mgr, ztInvalidID);

	if(asset_id == ztInvalidID) {
		return 0;
	}

	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_MeshOBJ) {
		return ztInvalidID;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);

	zt_logInfo("loading obj file: %s (%d bytes)", asset_mgr->asset_name[asset_id], size);
	if (size <= 0) {
		return ztInvalidID;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return ztInvalidID;
	}

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		zt_logCritical("Unable to load asset contents");
		zt_free(data);
		return ztInvalidID;
	}

	int result = _zt_meshLoadOBJBase(asset_mgr, asset_id, data, size, nullptr, mesh_ids, materials, mesh_mat_size, scale, offset);

	zt_freeArena(data, asset_mgr->arena);

	return result;
}

// ================================================================================================================================================================================================

int zt_meshLoadOBJ(char *data, i32 data_len, const char *mtl_search_dir, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale, const ztVec3 &offset)
{
	ZT_PROFILE_RENDERING("zt_meshLoadOBJ(data)");

	zt_returnValOnNull(data, ztInvalidID);
	zt_assertReturnValOnFail(data_len > 0, ztInvalidID);

	return _zt_meshLoadOBJBase(nullptr, ztInvalidID, data, data_len, mtl_search_dir, mesh_ids, materials, mesh_mat_size, scale, offset);
}

// ================================================================================================================================================================================================

int zt_meshLoadOBJ(char *file_name, ztMeshID *mesh_ids, ztMaterial *materials, int mesh_mat_size, const ztVec3 &scale, const ztVec3 &offset)
{
	char file_path[ztFileMaxPath];
	zt_fileGetFullPath(file_name, file_path, zt_elementsOf(file_path));

	i32 file_size = 0;
	char *file_data = (char*)zt_readEntireFile(file_name, &file_size);

	int result = 0;
	if (file_size) {
		result = zt_meshLoadOBJ(file_data, file_size, file_path, mesh_ids, materials, mesh_mat_size, scale, offset);
		zt_free(file_data);
	}

	return result;
}

// ================================================================================================================================================================================================

void zt_meshGetOBB(ztMeshID mesh_id, ztVec3 *center, ztVec3 *size)
{
	zt_assertReturnOnFail(mesh_id >= 0 && mesh_id < zt_game->meshes_count);
	zt_returnOnNull(center);
	zt_returnOnNull(size);

	ztMesh *mesh = &zt_game->meshes[mesh_id];
	*center = mesh->obb_center;
	*size   = mesh->obb_size;
}

// ================================================================================================================================================================================================

void zt_meshRender(ztMeshID mesh_id)
{
	ZT_PROFILE_RENDERING("zt_meshRender");
	zt_assertReturnOnFail(mesh_id >= 0 && mesh_id < zt_game->meshes_count);

	ztMesh *mesh = &zt_game->meshes[mesh_id];
	zt_game->game_details.curr_frame.triangles_drawn += mesh->triangles;
	zt_game->game_details.curr_frame.draw_calls += 1;

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(ztgl_vertexArrayDraw(&mesh->gl_vertex_array));
		} break;

		case ztRenderer_DirectX: {
			zt_directxSupport(ztdx_vertexArrayDraw(zt_game->win_details[0].dx_context, mesh->dx_vertex_array));
		} break;

		default: {
			zt_assert(false);
		}
	}
}

// ================================================================================================================================================================================================

i32 zt_meshGetVertices(ztMeshID mesh_id, ztVec3 *vertices, i32 vertices_size)
{
	ZT_PROFILE_RENDERING("zt_meshGetVertices");
	zt_assertReturnValOnFail(mesh_id >= 0 && mesh_id < zt_game->meshes_count, 0);

	ztMesh *mesh = &zt_game->meshes[mesh_id];

	switch (zt_currentRenderer())
	{
		case ztRenderer_OpenGL: {
			zt_openGLSupport(return ztgl_vertexArrayGetVertices(&mesh->gl_vertex_array, vertices, vertices_size));
		} break;

		case ztRenderer_DirectX: {
			zt_assert(false);
		} break;

		default: {
			zt_assert(false);
		}
	}

	return 0;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztTransform zt_transformMake(const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale)
{
	ztTransform transform;
	zt_transformMake(&transform, position, rotation, scale);
	return transform;
}

// ================================================================================================================================================================================================

void zt_transformMake(ztTransform *transform, const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale)
{
	transform->position = position;
	transform->rotation = rotation;
	transform->scale = scale;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4(ztTransform *transform)
{
	zt_returnValOnNull(transform, ztMat4::identity);

	ztMat4 mat;
	zt_transformToMat4(transform, &mat);
	return mat;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation)
{
	ztMat4 mat;
	zt_transformToMat4(position, rotation, &mat);
	return mat;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale)
{
	ztMat4 mat;
	zt_transformToMat4(position, rotation, scale, &mat);
	return mat;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4SRT(ztTransform *transform)
{
	zt_returnValOnNull(transform, ztMat4::identity);

	ztMat4 mat;
	zt_transformToMat4SRT(transform, &mat);
	return mat;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4RT(ztTransform *transform)
{
	zt_returnValOnNull(transform, ztMat4::identity);

	ztMat4 mat;
	zt_transformToMat4RT(transform, &mat);
	return mat;
}

// ================================================================================================================================================================================================

ztMat4 zt_transformToMat4TR(ztTransform *transform)
{
	zt_returnValOnNull(transform, ztMat4::identity);

	ztMat4 mat;
	zt_transformToMat4TR(transform, &mat);
	return mat;
}

// ================================================================================================================================================================================================

void zt_transformToMat4(ztTransform *transform, ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	(*mat) = ztMat4::identity;

	(*mat) *= ztMat4::identity.getTranslate(transform->position);

	if (transform->rotation != ztQuat::identity) {
		ztMat4 rmat = transform->rotation.convertToMat4();
		(*mat) *= rmat;
	}

	if (transform->scale != ztVec3::one) {
		ztMat4 scale = ztMat4::identity;
		scale.scale(transform->scale);
		(*mat) *= scale;
	}
}

// ================================================================================================================================================================================================

void zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, ztMat4 *mat)
{
	(*mat) = ztMat4::identity;

	(*mat) *= ztMat4::identity.getTranslate(position);

	if (rotation != ztQuat::identity) {
		ztMat4 rmat = rotation.convertToMat4();
		(*mat) *= rmat;
	}
}

// ================================================================================================================================================================================================

void zt_transformToMat4(const ztVec3 &position, const ztQuat &rotation, const ztVec3 &scale, ztMat4 *mat)
{
	(*mat) = ztMat4::identity;

	(*mat) *= ztMat4::identity.getTranslate(position);

	if (rotation != ztQuat::identity) {
		ztMat4 rmat = rotation.convertToMat4();
		(*mat) *= rmat;
	}

	if (scale != ztVec3::one) {
		ztMat4 smat = ztMat4::identity;
		smat.scale(scale);
		(*mat) *= smat;
	}
}

// ================================================================================================================================================================================================

void zt_transformToMat4SRT(ztTransform *transform, ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	(*mat) = ztMat4::identity;

	if (transform->scale != ztVec3::one) {
		ztMat4 scale = ztMat4::identity;
		scale.scale(transform->scale);
		(*mat) *= scale;
	}

	if (transform->rotation != ztQuat::identity) {
		ztMat4 rmat = transform->rotation.convertToMat4();
		(*mat) *= rmat;
	}

	(*mat) *= ztMat4::identity.getTranslate(transform->position);
}

// ================================================================================================================================================================================================

void zt_transformToMat4RT(ztTransform *transform, ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	(*mat) = ztMat4::identity;

	if (transform->rotation != ztQuat::identity) {
		ztMat4 rmat = transform->rotation.convertToMat4();
		(*mat) *= rmat;
	}

	(*mat) *= ztMat4::identity.getTranslate(transform->position);
}

// ================================================================================================================================================================================================

void zt_transformToMat4TR(ztTransform *transform, ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	(*mat) = ztMat4::identity.getTranslate(transform->position);

	if (transform->rotation != ztQuat::identity) {
		ztMat4 rmat = transform->rotation.convertToMat4();
		(*mat) *= rmat;
	}
}

// ================================================================================================================================================================================================

ztTransform zt_transformFromMat4(const ztMat4 *mat)
{
	ztTransform transform = { ztVec3::zero, ztQuat::identity, ztVec3::one };
	zt_returnValOnNull(mat, transform);

	mat->extract(&transform.position, &transform.rotation, &transform.scale);
	return transform;
}

// ================================================================================================================================================================================================

void zt_transformFromMat4(ztTransform *transform, const ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	mat->extract(&transform->position, &transform->rotation, &transform->scale);
}

// ================================================================================================================================================================================================

void zt_transformApplyMat4(ztTransform *transform, const ztMat4 *mat)
{
	zt_returnOnNull(transform);
	zt_returnOnNull(mat);

	ztMat4 tmat;
	zt_transformToMat4(transform, &tmat);

	ztMat4 nmat = tmat * (*mat);
	zt_transformFromMat4(transform, &nmat);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztPlane zt_planeMake(const ztVec3 &p0, const ztVec3 &p1, const ztVec3 &p2)
{
	ztPlane result;
	result.normal = (p1 - p0).cross(p2 - p0).getNormal();
	result.distance = result.normal.dot(p0);

	zt_planeNormalize(&result);

	return result;
}

// ================================================================================================================================================================================================

void zt_planeNormalize(ztPlane *plane)
{
	zt_returnOnNull(plane);

	r32 scale = 1.f / plane->normal.length();
	plane->normal.x /= scale;
	plane->normal.y /= scale;
	plane->normal.z /= scale;
	plane->distance /= scale;
}

// ================================================================================================================================================================================================

r32 zt_planeDistanceFromPoint(const ztPlane *plane, const ztVec3 &point)
{
	return zt_vec4(point, 1).dot(zt_vec4(plane->normal, plane->distance));
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal bool _zt_rendererRequestProcess()
{
	ZT_PROFILE_RENDERING("_zt_rendererRequestProcess");
	int count = zt_game->renderer_requests_count;
	zt_game->renderer_requests_count = 0;

	zt_fiz(count) {
		ztRendererRequest* request = &zt_game->renderer_requests[i];
		switch(request->type)
		{
			case ztRendererRequest_Change: {
				zt_fiz(zt_game->win_count) {
					_zt_rendererFreeContext(&zt_game->win_details[i]);
				}

				if (request->change_to == ztRenderer_OpenGL) {
					zt_logInfo("Switching to OpenGL renderer");
				}
				else if (request->change_to == ztRenderer_DirectX) {
					zt_logInfo("Switching to DirectX renderer");
				}
				else {
					zt_assert(false && "Unknown renderer");
				}

				if (!_zt_rendererSetRendererFuncs(request->change_to)) {
					return false;
				}

				zt_fiz(zt_game->win_count) {
					zt_game->win_game_settings[i].renderer = request->change_to;
					if (!_zt_rendererMakeContext(&zt_game->win_details[i], &zt_game->win_game_settings[i], zt_game->win_game_settings[i].renderer_flags)) {
						zt_logCritical("Failed to switch renderer");
						return false;
					}
				}

			} break;

			case ztRendererRequest_Windowed: {
				zt_logInfo("Switching to windowed mode");
				zt_fiz(zt_game->win_count) {
					zt_bitRemove(zt_game->win_game_settings[i].renderer_flags, ztRendererFlags_Fullscreen);
					zt_game->win_game_settings[i].renderer_flags |= ztRendererFlags_Windowed;

					if (!_zt_rendererToggleFullscreen(&zt_game->win_details[i], &zt_game->win_game_settings[i], false)) {
						return false;
					}
					zt_game->win_details[i].resize_cooldown = .25f;
				}
			} break;

			case ztRendererRequest_Fullscreen: {
				zt_logInfo("Switching to fullscreen mode");
				zt_fiz(zt_game->win_count) {
					zt_bitRemove(zt_game->win_game_settings[i].renderer_flags, ztRendererFlags_Windowed);
					zt_game->win_game_settings[i].renderer_flags |= ztRendererFlags_Fullscreen;

					if (!_zt_rendererToggleFullscreen(&zt_game->win_details[i], &zt_game->win_game_settings[i], true)) {
						return false;
					}
					zt_game->win_details[i].resize_cooldown = .25f;
				}
			} break;

			case ztRendererRequest_Resolution: {
				zt_logInfo("Switching resolution to %d x %d", request->resolution.x, request->resolution.y);

				zt_fiz(zt_game->win_count) {
					if (!_zt_rendererChangeResolution(&zt_game->win_details[0], &zt_game->win_game_settings[0], request->resolution.x, request->resolution.y)) {
						return false;
					}
					zt_game->win_details[i].resize_cooldown = .25f;
				}

#if 0
#				if defined(ZT_WINDOWS)
				bool back_to_fullscreen = false;
//				if (!zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_Fullscreen)) {
//					back_to_fullscreen = true;
//
//					if (!_zt_rendererToggleFullscreen(window_details, game_settings, false)) {
//						return false;
//					}
//				}

				RECT client_rect = { 0, 0, request->resolution.x, request->resolution.y };

				DWORD style = WS_OVERLAPPEDWINDOW | WS_VISIBLE;

				if (AdjustWindowRect(&client_rect, style, FALSE) == FALSE) {
					zt_logCritical("win: failed to adjust window rect");
					return false;
				}

				RECT win_rect;
				GetWindowRect(window_details->handle, &win_rect);

				window_details->client_rect_buffer = zt_vec4((r32)client_rect.left, (r32)client_rect.top, (r32)client_rect.right - game_settings->native_w, (r32)client_rect.bottom - game_settings->native_h);

				int screen_x = GetSystemMetrics(SM_CXSCREEN);
				int screen_y = GetSystemMetrics(SM_CYSCREEN);
				int pos_x = (screen_x - (client_rect.right - client_rect.left)) / 2;
				int pos_y = (screen_y - (client_rect.bottom - client_rect.top)) / 2;

				SetWindowPos(window_details->handle, HWND_TOP, pos_x, pos_y, client_rect.right - client_rect.left, client_rect.bottom - client_rect.top, SWP_SHOWWINDOW);

				GetClientRect(window_details->handle, &window_details->client_rect);
				GetWindowRect(window_details->handle, &window_details->window_rect);

				window_details->aspect_ratio = (window_details->window_rect.right - window_details->window_rect.left) / (r32)(window_details->window_rect.bottom - window_details->window_rect.top);

				_zt_winUpdateTitle(game_settings, window_details);


				if (back_to_fullscreen) {
					if (!_zt_rendererToggleFullscreen(window_details, game_settings, true)) {
						return false;
					}
				}

#				endif
#endif
			} break;

			case ztRendererRequest_UpdatePixelsPerUnit: {
				zt_game->win_game_settings[0].pixels_per_unit = zt_convertToi32Floor(request->ppu);
				zt_logInfo("Switching ppu to %d", zt_game->win_game_settings[0].pixels_per_unit);
				_zt_rendererSetViewport(&zt_game->win_details[0], &zt_game->win_game_settings[0], true);
			} break;
		}
	}

	return true;
}

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererSetViewport(ztWindowDetails* win_details, ztGameSettings *game_settings, bool force)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererSetViewport");
#if defined(ZT_DIRECTX)
	return ztdx_setViewport(win_details->dx_context);
#else
	return false;
#endif
}

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererMakeContext(ztWindowDetails *win_details, ztGameSettings *game_settings, i32 renderer_flags)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererMakeContext");
#	if defined(ZT_DIRECTX)
	win_details->dx_context = ztdx_contextMake(win_details->handle, game_settings->native_w, game_settings->native_h, game_settings->pixels_per_unit, renderer_flags);
	if (win_details->dx_context == nullptr) {
		return false;
	}
	
	ztVertexEntryDX entries[] = {
		3 * zt_sizeof(r32), // pos
		2 * zt_sizeof(r32), // uv
		3 * zt_sizeof(r32), // normals
		4 * zt_sizeof(r32), // color
	};

	win_details->dx_tri_verts_array = ztdx_vertexArrayMake(win_details->dx_context, entries, zt_elementsOf(entries), nullptr, ztRenderDrawListVertexArraySize);
	if (win_details->dx_tri_verts_array == nullptr) {
		return false;
	}
	
	return true;
#	endif
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererFreeContext(ztWindowDetails *win_details)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererFreeContext");
#	if defined(ZT_DIRECTX)
	ztdx_contextFree(win_details->dx_context);
	win_details->dx_context = nullptr;

	ztdx_vertexArrayFree(win_details->dx_tri_verts_array);
	win_details->dx_tri_verts_array = nullptr;

	return true;
#else
	return false;
#endif
}

// ================================================================================================================================================================================================

ztInternal ztInline void _ztdx_rendererSwapBuffers(ztWindowDetails* win_details)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererSwapBuffers");
	zt_directxSupport(ztdx_contextDisplay(win_details->dx_context));
}

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererToggleFullscreen(ztWindowDetails* win_details, ztGameSettings *game_settings, bool fullscreen)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererToggleFullscreen");
#if defined(ZT_DIRECTX)
	return _ztdx_rendererSetViewport(win_details, game_settings, true);
#else
	return false;
#endif
}

// ================================================================================================================================================================================================

ztInternal bool _ztdx_rendererChangeResolution(ztWindowDetails* win_details, ztGameSettings *game_settings, i32 w, i32 h)
{
	ZT_PROFILE_RENDERING("_ztdx_rendererChangeResolution");
#if defined(ZT_DIRECTX)
	zt_assert(false); // not yet implemented
	return false;
#else
	return false;
#endif
}

// ================================================================================================================================================================================================

ztInternal void _ztgl_rendererSwapBuffers(ztWindowDetails* wd)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererSwapBuffers");
	ztgl_contextDisplay(wd->gl_context);
}

// ================================================================================================================================================================================================

ztInternal bool _ztgl_rendererSetViewport(ztWindowDetails* wd, ztGameSettings* settings, bool)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererSetViewport");
	wd->gl_context->pixels_per_unit = settings->pixels_per_unit;
	return ztgl_setViewport(wd->gl_context);
}

// ================================================================================================================================================================================================

ztInternal bool _ztgl_rendererMakeContext(ztWindowDetails* wd, ztGameSettings* gs, i32 flags)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererMakeContext");
	wd->gl_context = ztgl_contextMake(zt_memGetGlobalArena(), wd->handle, gs->native_w, gs->native_h, gs->pixels_per_unit, flags);
#if !defined(ZT_DLL) && defined(ZT_LOADER)
	if (wd->gl_context && zt_game->zt_dllSetOpenGLGlobals) {
		zt_dllSendOpenGLGlobals(zt_game->zt_dllSetOpenGLGlobals);
	}
#endif
	ztVertexEntryGL entries[] = {
		{GL_FLOAT, 3 * zt_sizeof(r32)}, // pos
		{GL_FLOAT, 2 * zt_sizeof(r32)}, // uv
		{GL_FLOAT, 3 * zt_sizeof(r32)}, // normals
		{GL_FLOAT, 4 * zt_sizeof(r32)}, // color
	};

	if (!ztgl_vertexArrayMake(&wd->gl_tri_verts_array, entries, zt_elementsOf(entries), nullptr, ztRenderDrawListVertexArraySize)) {
		return false;
	}

	return wd->gl_context != nullptr;
}

// ================================================================================================================================================================================================

ztInternal bool _ztgl_rendererFreeContext(ztWindowDetails* wd)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererFreeContext");
	ztgl_contextFree(wd->gl_context);
	wd->gl_context = nullptr;
	return true;
}

// ================================================================================================================================================================================================

ztInternal bool _ztgl_rendererToggleFullscreen(ztWindowDetails* wd, ztGameSettings* gs, bool fullscreen)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererToggleFullscreen");
	return ztgl_contextToggleFullscreen(wd->gl_context, fullscreen);
}

// ================================================================================================================================================================================================

ztInternal bool _ztgl_rendererChangeResolution(ztWindowDetails* wd, ztGameSettings* gs, i32 w, i32 h)
{
	ZT_PROFILE_RENDERING("_ztgl_rendererToggleFullscreen");
	return ztgl_contextChangeResolution(wd->gl_context, w, h);
}

// ================================================================================================================================================================================================

ztInternal bool _zt_rendererSetRendererFuncs(ztRenderer_Enum renderer)
{
	if (renderer == ztRenderer_OpenGL) {
#		if defined(ZT_OPENGL)
		_zt_rendererSwapBuffers      = _ztgl_rendererSwapBuffers;
		_zt_rendererSetViewport      = _ztgl_rendererSetViewport;
		_zt_rendererMakeContext      = _ztgl_rendererMakeContext;
		_zt_rendererFreeContext      = _ztgl_rendererFreeContext;
		_zt_rendererToggleFullscreen = _ztgl_rendererToggleFullscreen;
		_zt_rendererChangeResolution = _ztgl_rendererChangeResolution;
#		else
		zt_logFatal("OpenGL is not supported in this configuration");
		return false;
#		endif
	}
	else if (renderer == ztRenderer_DirectX) {
#		if defined(ZT_DIRECTX)
		_zt_rendererSwapBuffers      = _ztdx_rendererSwapBuffers;
		_zt_rendererSetViewport      = _ztdx_rendererSetViewport;
		_zt_rendererMakeContext      = _ztdx_rendererMakeContext;
		_zt_rendererFreeContext      = _ztdx_rendererFreeContext;
		_zt_rendererToggleFullscreen = _ztdx_rendererToggleFullscreen;
		_zt_rendererChangeResolution = _ztdx_rendererChangeResolution;
#		else
		zt_logFatal("DirectX is not supported in this configuration");
		return false;
#		endif
	}
	else {
		return false;
	}

	return true;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_COLLISION_DEBUG_GUID		zt_guidMake(0xb3b0835b, 0x073d4c7d, 0x9e0c648a, 0xc883cb62)

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_collisionGeometryMakeAABB(ztCollisionGeometry *geo, const ztVec3& center, const ztVec3 &extents)
{
	geo->type = ztCollisionGeometryType_AxisAlignedBox;
	geo->aabb_center = center;
	geo->aabb_extents = extents;
}

// ================================================================================================================================================================================================

void zt_collisionGeometryMakeOBB(ztCollisionGeometry *geo, const ztVec3 &center, const ztVec3 &extents, const ztQuat &rotation)
{
	geo->type = ztCollisionGeometryType_OrientedBox;
	geo->obb_center = center;
	geo->obb_extents = extents;
	geo->obb_rotation = rotation;
}

// ================================================================================================================================================================================================

void zt_collisionGeometryMakeSphere(ztCollisionGeometry *geo, const ztVec3 &center, r32 radius)
{
	geo->type = ztCollisionGeometryType_Sphere;
	geo->sphere_center = center;
	geo->sphere_radius = radius;
}

// ================================================================================================================================================================================================

void zt_collisionGeometryMakeCapsule(ztCollisionGeometry *geo, const ztVec3 &center, r32 radius, r32 height)
{
	geo->type = ztCollisionGeometryType_Capsule;
	geo->capsule_center = center;
	geo->capsule_radius = radius;
	geo->capsule_height = height;
}

// ================================================================================================================================================================================================

void zt_collisionGeometryMakeTriangles(ztCollisionGeometry *geo, ztVec3 *vertices, i32 vertices_count)
{
	geo->type = ztCollisionGeometryType_Triangles;
	geo->vertices_count = vertices_count;

	geo->vertices = zt_mallocStructArray(ztVec3, vertices_count);

	zt_fiz(vertices_count) {
		geo->vertices[i] = vertices[i];
	}
}

// ================================================================================================================================================================================================

void zt_collisionGeometryFree(ztCollisionGeometry *geo)
{
	if(geo->type == ztCollisionGeometryType_Triangles) {
		zt_free(geo->vertices);
		geo->vertices_count = 0;
	}
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_AABB_AABB(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_AxisAlignedBox && geo_two->type == ztCollisionGeometryType_AxisAlignedBox, false);

	return zt_collisionAABBInAABB(curr_tran_one->position + geo_one->aabb_center, geo_one->aabb_extents, curr_tran_two->position + geo_two->aabb_center, geo_two->aabb_extents);
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_AABB_OBB(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_AxisAlignedBox && geo_two->type == ztCollisionGeometryType_OrientedBox, false);

	ztVec3 obb_pos_1 = curr_tran_one->position + geo_one->aabb_center;
	ztVec3 obb_ext_1 = geo_one->aabb_extents;
	ztQuat obb_rot_1 = ztQuat::identity;
	ztVec3 obb_pos_2 = curr_tran_two->position + geo_two->obb_center;
	ztVec3 obb_ext_2 = geo_two->obb_extents;
	ztQuat obb_rot_2 = curr_tran_two->rotation * geo_two->obb_rotation;

	if (zt_collisionOBBInOBB(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2)) {
		ztVec3 contacts[16];
		r32 penetrations[16];

		int contacts_count = zt_collisionOBBInOBBGetContactPoints(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2, contact_normal, contacts, penetrations, zt_elementsOf(contacts));
		if(contacts_count == 0) {
			// this technically shouldn't happen, so place a breakpoint here and find out why it did
			contacts_count = zt_collisionOBBInOBBGetContactPoints(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2, contact_normal, contacts, penetrations, zt_elementsOf(contacts));
			return false;
		}

		ztVec3 average = zt_vec3(0, 0, 0);
		*penetration = 0;
		zt_fiz(contacts_count) {
			average += contacts[i];
			*penetration += penetrations[i];
		}
		if (contacts_count) {
			average *= 1.f / contacts_count;
			*penetration /= contacts_count;
		}

		*contact_point = average;
		*contact_normal *= contact_normal_direction * -1.f;
		*penetration = zt_abs(*penetration);

		return true;
	}
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_AABB_Sphere(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_AxisAlignedBox && geo_two->type == ztCollisionGeometryType_Sphere, false);

	return zt_collisionSphereInAABB(curr_tran_two->position + geo_two->sphere_center, geo_two->sphere_radius, curr_tran_one->position + geo_one->aabb_center, geo_one->aabb_extents);
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_AABB_Capsule(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_AxisAlignedBox && geo_two->type == ztCollisionGeometryType_Capsule, false);
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_AABB_Triangles(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_AxisAlignedBox && geo_two->type == ztCollisionGeometryType_Triangles, false);

	r32 closest_dist = ztReal32Max;
	i32 closest_idx = -1;

	ztVec3 one_pos = (curr_tran_one->position + geo_one->aabb_center) - curr_tran_two->position; // most poisition into vertices' local space so we can avoid adding the triangle's transform for each triangle

	if(curr_tran_two->rotation != ztQuat::identity) {
		for(int i = 0; i < geo_two->vertices_count; i += 3) {
			ztVec3 p1 = curr_tran_two->rotation.rotatePosition(geo_two->vertices[i]);
			ztVec3 p2 = curr_tran_two->rotation.rotatePosition(geo_two->vertices[i+1]);
			ztVec3 p3 = curr_tran_two->rotation.rotatePosition(geo_two->vertices[i+2]);

			if (zt_collisionTriangleInAABB(p1, p2, p3, one_pos, geo_one->aabb_extents)) {
				ztVec3 tri_center = (p1 + p2 + p3) * .3333f;
				ztVec3 distance = tri_center - curr_tran_one->position;
				r32 dist = distance.length();

				if (dist < closest_dist) {
					closest_dist = dist;
					closest_idx = i;
					*contact_normal = (distance * contact_normal_direction).getNormal();
				}
			}
		}
	}
	else {
		for(int i = 0; i < geo_two->vertices_count; i += 3) {
			if (zt_collisionTriangleInAABB(geo_two->vertices[i], geo_two->vertices[i+1], geo_two->vertices[i+2], one_pos, geo_one->aabb_extents)) {
				ztVec3 tri_center = (geo_two->vertices[i] + geo_two->vertices[i+1] + geo_two->vertices[i+2]) * .3333f;
				ztVec3 distance = tri_center - curr_tran_one->position;
				r32 dist = distance.length();

				if (dist < closest_dist) {
					closest_dist = dist;
					closest_idx = i;
					*contact_normal = (distance * contact_normal_direction).getNormal();
				}
			}
		}
	}

	if (closest_idx >= 0) {
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_OBB_OBB(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_OrientedBox && geo_two->type == ztCollisionGeometryType_OrientedBox, false);

	ztVec3 obb_pos_1 = curr_tran_one->position + geo_one->obb_center;
	ztVec3 obb_ext_1 = geo_one->obb_extents;
	ztQuat obb_rot_1 = curr_tran_one->rotation * geo_one->obb_rotation;
	ztVec3 obb_pos_2 = curr_tran_two->position + geo_two->obb_center;
	ztVec3 obb_ext_2 = geo_two->obb_extents;
	ztQuat obb_rot_2 = curr_tran_two->rotation * geo_two->obb_rotation;

	if (zt_collisionOBBInOBB(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2)) {
		ztVec3 contacts[16];
		r32 penetrations[16];

		int contacts_count = zt_collisionOBBInOBBGetContactPoints(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2, contact_normal, contacts, penetrations, zt_elementsOf(contacts));
		if (contacts_count == 0) {
			// this technically shouldn't happen, so place a breakpoint here and find out why it did
			contacts_count = zt_collisionOBBInOBBGetContactPoints(obb_pos_1, obb_ext_1, obb_rot_1, obb_pos_2, obb_ext_2, obb_rot_2, contact_normal, contacts, penetrations, zt_elementsOf(contacts));
			return false;
		}

		ztVec3 average = zt_vec3(0, 0, 0);
		*penetration = 0;
		zt_fiz(contacts_count) {
			average += contacts[i];
			*penetration += penetrations[i];
		}
		if (contacts_count) {
			average *= 1.f / contacts_count;
			*penetration /= contacts_count;
		}

		*contact_point = average;
		*contact_normal *= contact_normal_direction * -1.f;
		*penetration = zt_abs(*penetration);

		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_OBB_Sphere(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_OrientedBox && geo_two->type == ztCollisionGeometryType_Sphere, false);

	if (zt_collisionSphereInOBB(curr_tran_two->position + geo_two->sphere_center, geo_two->sphere_radius, curr_tran_one->position + geo_one->obb_center, geo_one->obb_extents, curr_tran_one->rotation * geo_one->obb_rotation)) {
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_OBB_Capsule(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_OrientedBox && geo_two->type == ztCollisionGeometryType_Capsule, false);

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_OBB_Triangles(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_OrientedBox && geo_two->type == ztCollisionGeometryType_Triangles, false);

	r32 closest_dist = ztReal32Min;
	i32 closest_idx = -1;

	// this will likely need to use the model->calculated_mat instead of the rotation and needs to multiply the obb_rotation

	ztTransform transform;
	transform.position = (curr_tran_one->position + geo_one->obb_center);
	transform.rotation = (curr_tran_one->rotation * geo_one->obb_rotation) * curr_tran_two->rotation;
	transform.scale    = curr_tran_one->scale;

	ztMat4 mat_to_obb = zt_transformToMat4(&transform);
	mat_to_obb.inverse();

	transform.position = curr_tran_two->position;
	transform.rotation = curr_tran_two->rotation;
	transform.scale    = curr_tran_two->scale;

	ztMat4 mat_from_tri = zt_transformToMat4(&transform);
	//mat_from_tri.inverse();

	ztVec3 p1, p2, p3, intersection_point = ztVec3::zero;

	for(int i = 0; i < geo_two->vertices_count; i += 3) {
		p1 = mat_from_tri.getMultiply(geo_two->vertices[i]);
		p2 = mat_from_tri.getMultiply(geo_two->vertices[i+1]);
		p3 = mat_from_tri.getMultiply(geo_two->vertices[i+2]);

		p1 = mat_to_obb.getMultiply(p1);
		p2 = mat_to_obb.getMultiply(p2);
		p3 = mat_to_obb.getMultiply(p3);

		if (zt_collisionTriangleInAABB(p1, p2, p3, ztVec3::zero, geo_one->obb_extents, &intersection_point)) {
			ztVec3 dir = intersection_point - transform.position;
			ztVec3 outside = transform.position + (dir * geo_one->obb_extents.length());
			ztVec3 closest = zt_closestPointAABBPoint(ztVec3::zero, geo_one->obb_extents, outside);
			ztVec3 diff = closest - intersection_point;

			*penetration = diff.length() * 1.f;

			if (*penetration > closest_dist) {
				closest_dist = *penetration;
				closest_idx = i;
				*contact_point = intersection_point;
				zt_triangleCalculateNormal(p1, p2, p3, contact_normal);
				//break; // debug
			}
		}
	}

	if (closest_idx >= 0) {
		mat_to_obb.inverse();
		mat_from_tri.inverse();

		*contact_point = mat_to_obb.getMultiply(*contact_point);
		*contact_normal = zt_mat3(mat_to_obb).getMultiply(*contact_normal * contact_normal_direction * 1).getNormal();

		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Sphere_Sphere(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Sphere && geo_two->type == ztCollisionGeometryType_Sphere, false);

	r32 distance = (curr_tran_one->position + geo_one->sphere_center).distance(curr_tran_two->position + geo_two->sphere_center);

	if (distance < geo_one->sphere_radius + geo_two->sphere_radius) {
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Sphere_Capsule(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Sphere && geo_two->type == ztCollisionGeometryType_Capsule, false);

	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Sphere_Triangles(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Sphere && geo_two->type == ztCollisionGeometryType_Triangles, false);

	zt_assert(false);
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Capsule_Capsule(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Capsule && geo_two->type == ztCollisionGeometryType_Capsule, false);

	zt_assert(false);
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Capsule_Triangles(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Capsule && geo_two->type == ztCollisionGeometryType_Triangles, false);

	zt_assert(false);
	return false;
}

// ================================================================================================================================================================================================

ztInternal bool _zt_collisionGeometryIntersecting_Triangles_Triangles(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point, r32 contact_normal_direction)
{
	zt_assertReturnValOnFail(geo_one->type == ztCollisionGeometryType_Triangles && geo_two->type == ztCollisionGeometryType_Triangles, false);

	zt_assert(false);
	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionGeometryIntersecting(ztCollisionGeometry *geo_one, ztTransform *curr_tran_one, ztTransform *prev_tran_one, ztCollisionGeometry *geo_two, ztTransform *curr_tran_two, ztTransform *prev_tran_two, r32 *penetration, ztVec3 *contact_normal, ztVec3 *contact_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionGeometryIntersecting");
	zt_returnValOnNull(geo_one, false);
	zt_returnValOnNull(curr_tran_one, false);
	//zt_returnValOnNull(prev_tran_one, false); // these aren't used...
	zt_returnValOnNull(geo_two, false);
	zt_returnValOnNull(curr_tran_two, false);
	//zt_returnValOnNull(prev_tran_two, false);
	zt_returnValOnNull(penetration, false);
	zt_returnValOnNull(contact_normal, false);

	switch(geo_one->type)
	{
		case ztCollisionGeometryType_AxisAlignedBox: {
			switch(geo_two->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: { return _zt_collisionGeometryIntersecting_AABB_AABB     (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_OrientedBox   : { return _zt_collisionGeometryIntersecting_AABB_OBB      (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Sphere        : { return _zt_collisionGeometryIntersecting_AABB_Sphere   (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Capsule       : { return _zt_collisionGeometryIntersecting_AABB_Capsule  (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Triangles     : { return _zt_collisionGeometryIntersecting_AABB_Triangles(geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;

				default: {
					zt_assert(false);
				}
			}
		} break;

		case ztCollisionGeometryType_OrientedBox: {
			switch(geo_two->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: { return _zt_collisionGeometryIntersecting_AABB_OBB     (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_OrientedBox   : { return _zt_collisionGeometryIntersecting_OBB_OBB      (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Sphere        : { return _zt_collisionGeometryIntersecting_OBB_Sphere   (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Capsule       : { return _zt_collisionGeometryIntersecting_OBB_Capsule  (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Triangles     : { return _zt_collisionGeometryIntersecting_OBB_Triangles(geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;

				default: {
					zt_assert(false);
				}
			}
		} break;

		case ztCollisionGeometryType_Sphere: {
			switch (geo_two->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: { return _zt_collisionGeometryIntersecting_AABB_Sphere     (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_OrientedBox   : { return _zt_collisionGeometryIntersecting_OBB_Sphere      (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Sphere        : { return _zt_collisionGeometryIntersecting_Sphere_Sphere   (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Capsule       : { return _zt_collisionGeometryIntersecting_Sphere_Capsule  (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Triangles     : { return _zt_collisionGeometryIntersecting_Sphere_Triangles(geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;

				default: {
					zt_assert(false);
				}
			}
		} break;

		case ztCollisionGeometryType_Capsule: {
			switch (geo_two->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: { return _zt_collisionGeometryIntersecting_AABB_Capsule     (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_OrientedBox   : { return _zt_collisionGeometryIntersecting_OBB_Capsule      (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Sphere        : { return _zt_collisionGeometryIntersecting_Sphere_Capsule   (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Capsule       : { return _zt_collisionGeometryIntersecting_Capsule_Capsule  (geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;
				case ztCollisionGeometryType_Triangles     : { return _zt_collisionGeometryIntersecting_Capsule_Triangles(geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;

				default: {
					zt_assert(false);
				}
			} 
		} break;

		case ztCollisionGeometryType_Triangles: {
			switch (geo_two->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: { return _zt_collisionGeometryIntersecting_AABB_Triangles     (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_OrientedBox   : { return _zt_collisionGeometryIntersecting_OBB_Triangles      (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Sphere        : { return _zt_collisionGeometryIntersecting_Sphere_Triangles   (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Capsule       : { return _zt_collisionGeometryIntersecting_Capsule_Triangles  (geo_two, curr_tran_two, prev_tran_two, geo_one, curr_tran_one, prev_tran_one, penetration, contact_normal, contact_point, -1); } break;
				case ztCollisionGeometryType_Triangles     : { return _zt_collisionGeometryIntersecting_Triangles_Triangles(geo_one, curr_tran_one, prev_tran_one, geo_two, curr_tran_two, prev_tran_two, penetration, contact_normal, contact_point, 1); } break;

				default: {
					zt_assert(false);
				}
			}
		} break;

		default: {
			zt_assert(false);
		}
	}

	return false;
}

// ================================================================================================================================================================================================

#define ZT_COLLISION_GEOMETRY_FILE_GUID          zt_guidMake(0x23e17e86, 0x28d4433b, 0x9e88c1db, 0x372b004d)
#define ZT_COLLISION_GEOMETRY_FILE_VERSION       10001

#define _serialCheck(code) if(!(code)) { zt_logCritical("ztCollisionGeometry serialization failed."); return false; }

bool zt_collisionGeometrySave(ztSerial *serial, ztCollisionGeometry *geo)
{
	ZT_PROFILE_GAME("zt_collisionGeometrySave");
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWrite(serial, ZT_COLLISION_GEOMETRY_FILE_GUID));
		_serialCheck(zt_serialWrite(serial, ZT_COLLISION_GEOMETRY_FILE_VERSION));

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, (i32)geo->type));

			switch(geo->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: {
					_serialCheck(zt_serialWrite(serial, geo->aabb_center));
					_serialCheck(zt_serialWrite(serial, geo->aabb_extents));
				} break;

				case ztCollisionGeometryType_OrientedBox: {
					_serialCheck(zt_serialWrite(serial, geo->obb_center));
					_serialCheck(zt_serialWrite(serial, geo->obb_extents));
					_serialCheck(zt_serialWrite(serial, geo->obb_rotation));
				} break;

				case ztCollisionGeometryType_Sphere: {
					_serialCheck(zt_serialWrite(serial, geo->sphere_center));
					_serialCheck(zt_serialWrite(serial, geo->sphere_radius));
				} break;

				case ztCollisionGeometryType_Capsule: {
					_serialCheck(zt_serialWrite(serial, geo->capsule_center));
					_serialCheck(zt_serialWrite(serial, geo->capsule_radius));
					_serialCheck(zt_serialWrite(serial, geo->capsule_height));
				} break;

				case ztCollisionGeometryType_Triangles: {
					_serialCheck(zt_serialWrite(serial, geo->vertices_count));
					zt_fiz(geo->vertices_count) {
						_serialCheck(zt_serialWrite(serial, geo->vertices[i]));
					}
				} break;
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}

	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionGeometryLoad(ztSerial *serial, ztCollisionGeometry *geo)
{
	ZT_PROFILE_GAME("zt_collisionGeometryLoad");
	_serialCheck(zt_serialGroupPush(serial));
	{
		ztGuid guid;
		_serialCheck(zt_serialRead(serial, &guid));
		if (guid != ZT_COLLISION_GEOMETRY_FILE_GUID) {
			zt_logCritical("ztCollisionGeometry guid mismatch");
			return false;
		}
		i32 version = 0;
		_serialCheck(zt_serialRead(serial, &version));
		if (version > ZT_COLLISION_GEOMETRY_FILE_VERSION) {
			zt_logCritical("ztCollisionGeometry version newer than supported");
			return false;
		}

		_serialCheck(zt_serialGroupPush(serial));
		{
			i32 geo_type = 0;
			_serialCheck(zt_serialRead(serial, &geo_type));
			geo->type = (ztCollisionGeometryType_Enum)geo_type;

			switch(geo->type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: {
					_serialCheck(zt_serialRead(serial, &geo->aabb_center));
					_serialCheck(zt_serialRead(serial, &geo->aabb_extents));
				} break;

				case ztCollisionGeometryType_OrientedBox: {
					_serialCheck(zt_serialRead(serial, &geo->obb_center));
					_serialCheck(zt_serialRead(serial, &geo->obb_extents));
					_serialCheck(zt_serialRead(serial, &geo->obb_rotation));

					if (geo->obb_rotation == zt_quat(0, 0, 0, 0)) {
						geo->obb_rotation = ztQuat::identity;
					}
				} break;

				case ztCollisionGeometryType_Sphere: {
					_serialCheck(zt_serialRead(serial, &geo->sphere_center));
					_serialCheck(zt_serialRead(serial, &geo->sphere_radius));
				} break;

				case ztCollisionGeometryType_Capsule: {
					_serialCheck(zt_serialRead(serial, &geo->capsule_center));
					_serialCheck(zt_serialRead(serial, &geo->capsule_radius));
					_serialCheck(zt_serialRead(serial, &geo->capsule_height));
				} break;

				case ztCollisionGeometryType_Triangles: {
					_serialCheck(zt_serialRead(serial, &geo->vertices_count));
					geo->vertices = zt_mallocStructArray(ztVec3, geo->vertices_count);
					zt_fiz(geo->vertices_count) {
						_serialCheck(zt_serialRead(serial, &geo->vertices[i]));
					}
				} break;
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}

	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

#undef _serialCheck

// ================================================================================================================================================================================================

void zt_collisionGeometryRenderDebug(ztCollisionGeometry *geo, ztDrawList *draw_list, ztVec3 position, ztMat4 mat)
{
	ZT_PROFILE_GAME("zt_collisionGeometryRenderDebug");

	switch (geo->type)
	{
		case ztCollisionGeometryType_AxisAlignedBox: {
			zt_drawListAddEmptyCubeFromCenterSize(draw_list, position + geo->aabb_center, geo->aabb_extents);
		} break;

		case ztCollisionGeometryType_OrientedBox: {
			zt_drawListPushTransform(draw_list, geo->obb_rotation.convertToMat4() * mat);
			zt_drawListAddEmptyCubeFromCenterSize(draw_list, geo->obb_center, geo->obb_extents);
			zt_drawListPopTransform(draw_list);
		} break;

		case ztCollisionGeometryType_Sphere: {
			zt_drawListAddEmptySimpleSphere(draw_list, position + geo->sphere_center, geo->sphere_radius, zt_max(16, zt_convertToi32Floor(geo->sphere_radius * 16)), 4);
		} break;

		case ztCollisionGeometryType_Capsule: {
		} break;

		case ztCollisionGeometryType_Triangles: {
			zt_drawListPushTransform(draw_list, mat);
			for (int i = 0; i < geo->vertices_count; i += 3) {
				zt_drawListAddEmptyTriangle(draw_list, geo->vertices[i], geo->vertices[i + 1], geo->vertices[i + 2]);
			}
			zt_drawListPopTransform(draw_list);
		} break;
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal ztInline void zt_rigidBody_makeInertiaTensorCoeff(ztMat3 *mat, r32 ix, r32 iy, r32 iz, r32 ixy = 0, r32 ixz = 0, r32 iyz = 0)
{
	mat->values[ztMat3_Col0Row0] = ix;
	mat->values[ztMat3_Col1Row0] = mat->values[ztMat3_Col0Row1] = -ixy;
	mat->values[ztMat3_Col2Row0] = mat->values[ztMat3_Col0Row2] = -ixz;
	mat->values[ztMat3_Col1Row1] = iy;
	mat->values[ztMat3_Col2Row1] = mat->values[ztMat3_Col1Row2] = -iyz;
	mat->values[ztMat3_Col2Row2] = iz;

	mat->inverse();
}

// ================================================================================================================================================================================================

ztInternal ztInline void zt_rigidBody_makeBlockInertiaTensor(ztMat3 *mat, const ztVec3 &size, r32 mass)
{
	mass = zt_max(mass, 1.f);
	ztVec3 squares = (size *.5f) * (size * .5f);
	zt_rigidBody_makeInertiaTensorCoeff(mat, .3f * mass * (squares.y + squares.z), .3f * mass * (squares.x + squares.z), .3f * mass * (squares.x + squares.z));
}

// ================================================================================================================================================================================================

ztInternal ztInline void zt_rigidBody_transformInertiaTensor(ztMat3 *inverse_inertia_tensor_world, ztMat3 *inverse_inertia_tensor, ztMat4 *model_mat)
{
	r32 t04 = model_mat->values[ztMat4_Col0Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row0] + model_mat->values[ztMat4_Col0Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row0] + model_mat->values[ztMat4_Row2Col0] * inverse_inertia_tensor->values[ztMat3_Col2Row0];
	r32 t09 = model_mat->values[ztMat4_Col0Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row1] + model_mat->values[ztMat4_Col0Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row1] + model_mat->values[ztMat4_Row2Col0] * inverse_inertia_tensor->values[ztMat3_Col2Row1];
	r32 t14 = model_mat->values[ztMat4_Col0Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row2] + model_mat->values[ztMat4_Col0Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row2] + model_mat->values[ztMat4_Row2Col0] * inverse_inertia_tensor->values[ztMat3_Col2Row2];
	r32 t28 = model_mat->values[ztMat4_Col1Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row0] + model_mat->values[ztMat4_Col1Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row0] + model_mat->values[ztMat4_Row2Col1] * inverse_inertia_tensor->values[ztMat3_Col2Row0];
	r32 t33 = model_mat->values[ztMat4_Col1Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row1] + model_mat->values[ztMat4_Col1Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row1] + model_mat->values[ztMat4_Row2Col1] * inverse_inertia_tensor->values[ztMat3_Col2Row1];
	r32 t38 = model_mat->values[ztMat4_Col1Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row2] + model_mat->values[ztMat4_Col1Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row2] + model_mat->values[ztMat4_Row2Col1] * inverse_inertia_tensor->values[ztMat3_Col2Row2];
	r32 t52 = model_mat->values[ztMat4_Col2Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row0] + model_mat->values[ztMat4_Col2Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row0] + model_mat->values[ztMat4_Row2Col2] * inverse_inertia_tensor->values[ztMat3_Col2Row0];
	r32 t57 = model_mat->values[ztMat4_Col2Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row1] + model_mat->values[ztMat4_Col2Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row1] + model_mat->values[ztMat4_Row2Col2] * inverse_inertia_tensor->values[ztMat3_Col2Row1];
	r32 t62 = model_mat->values[ztMat4_Col2Row0] * inverse_inertia_tensor->values[ztMat3_Col0Row2] + model_mat->values[ztMat4_Col2Row1] * inverse_inertia_tensor->values[ztMat3_Col1Row2] + model_mat->values[ztMat4_Row2Col2] * inverse_inertia_tensor->values[ztMat3_Col2Row2];

	inverse_inertia_tensor_world->values[ztMat3_Col0Row0] = t04 * model_mat->values[ztMat4_Col0Row0] + t09 * model_mat->values[ztMat4_Col0Row1] + t14 * model_mat->values[ztMat4_Col0Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col0Row1] = t04 * model_mat->values[ztMat4_Col1Row0] + t09 * model_mat->values[ztMat4_Col1Row1] + t14 * model_mat->values[ztMat4_Col1Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col0Row2] = t04 * model_mat->values[ztMat4_Col2Row0] + t09 * model_mat->values[ztMat4_Col2Row1] + t14 * model_mat->values[ztMat4_Col2Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col1Row0] = t28 * model_mat->values[ztMat4_Col0Row0] + t33 * model_mat->values[ztMat4_Col0Row1] + t38 * model_mat->values[ztMat4_Col0Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col1Row1] = t28 * model_mat->values[ztMat4_Col1Row0] + t33 * model_mat->values[ztMat4_Col1Row1] + t38 * model_mat->values[ztMat4_Col1Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col1Row2] = t28 * model_mat->values[ztMat4_Col2Row0] + t33 * model_mat->values[ztMat4_Col2Row1] + t38 * model_mat->values[ztMat4_Col2Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col2Row0] = t52 * model_mat->values[ztMat4_Col0Row0] + t57 * model_mat->values[ztMat4_Col0Row1] + t62 * model_mat->values[ztMat4_Col0Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col2Row1] = t52 * model_mat->values[ztMat4_Col1Row0] + t57 * model_mat->values[ztMat4_Col1Row1] + t62 * model_mat->values[ztMat4_Col1Row2];
	inverse_inertia_tensor_world->values[ztMat3_Col2Row2] = t52 * model_mat->values[ztMat4_Col2Row0] + t57 * model_mat->values[ztMat4_Col2Row1] + t62 * model_mat->values[ztMat4_Col2Row2];
}

// ================================================================================================================================================================================================

ztInternal ztInline void zt_rigidBody_setSkewSymmetric(ztMat3 *mat, ztVec3 *vec)
{
	mat->values[ztMat3_Col0Row0] = mat->values[ztMat3_Col1Row1] = mat->values[ztMat3_Col2Row2] = 0;
	mat->values[ztMat3_Col1Row0] = -vec->z;
	mat->values[ztMat3_Col2Row0] = vec->y;
	mat->values[ztMat3_Col0Row1] = vec->z;
	mat->values[ztMat3_Col2Row1] = -vec->x;
	mat->values[ztMat3_Col0Row2] = -vec->y;
	mat->values[ztMat3_Col1Row2] = vec->x;
}

// ================================================================================================================================================================================================

void zt_rigidBodyMake(ztRigidBody *rigid_body, ztModel *model, r32 one_over_mass_in_kg, ztCollisionGeometry cg_bounding, ztCollisionGeometry details, r32 damping, ztVec3 force_gravity)
{
	zt_rigidBodyMake(rigid_body, model, one_over_mass_in_kg, cg_bounding, &details, 1, damping, force_gravity);
}

// ================================================================================================================================================================================================

void zt_rigidBodyMake(ztRigidBody *rigid_body, ztModel *model, r32 one_over_mass_in_kg, ztCollisionGeometry cg_bounding, ztCollisionGeometry *details, int details_count, r32 damping, ztVec3 force_gravity)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyMake");
	rigid_body->model                  = model;
	rigid_body->damping                = damping;
	rigid_body->angular_damping        = damping;
	rigid_body->inverse_mass           = one_over_mass_in_kg;
	rigid_body->force_gravity          = force_gravity;

	zt_rigidBody_makeBlockInertiaTensor(&rigid_body->inverse_inertia_tensor, ztVec3::one, 1.f / zt_max(0.1f, one_over_mass_in_kg));

	rigid_body->velocity               = ztVec3::zero;
	rigid_body->angular_velocity       = ztVec3::zero;
	rigid_body->acceleration           = ztVec3::zero;
	rigid_body->prev_acceleration      = ztVec3::zero;
	rigid_body->force_accum            = ztVec3::zero;
	rigid_body->torque_accum           = ztVec3::zero;
	rigid_body->motion                 = ztReal32Min;

	rigid_body->flags                  = 0;
	rigid_body->collision_layer        = 0;
	rigid_body->collides_with_layers   = 0;

	rigid_body->cg_bounding = cg_bounding;
	rigid_body->cg_details_count = details_count;

	zt_fiz(details_count) {
		rigid_body->cg_details[i] = details[i];
	}

	if (model->calculated_mat == ztMat4::identity) {
		rigid_body->flags |= ztRigidBodyFlags_NeedsMatrixCalc;
	}
}

// ================================================================================================================================================================================================

void zt_rigidBodyFree(ztRigidBody *rigid_body)
{
	if (rigid_body == nullptr) {
		return;
	}

	zt_collisionGeometryFree(&rigid_body->cg_bounding);
	zt_fiz(rigid_body->cg_details_count) {
		zt_collisionGeometryFree(&rigid_body->cg_details[i]);
	}
}

// ================================================================================================================================================================================================

void zt_rigidBodyAddForce(ztRigidBody *rigid_body, const ztVec3 &force)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyAddForce");
	zt_returnOnNull(rigid_body);
	rigid_body->force_accum += force;
}

// ================================================================================================================================================================================================

void zt_rigidBodyAddForceAtWorldPoint(ztRigidBody *rigid_body, const ztVec3 &force, const ztVec3 &point)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyAddForceAtWorldPoint");
	zt_returnOnNull(rigid_body);

	ztVec3 conv_point = rigid_body->model->calculated_mat.getInverse().getMultiply(point);

	rigid_body->force_accum += force;
	rigid_body->torque_accum += conv_point.cross(force);
}

// ================================================================================================================================================================================================

void zt_rigidBodyAddForceAtBodyPoint(ztRigidBody *rigid_body, const ztVec3 &force, const ztVec3 &point)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyAddForceAtBodyPoint");
	zt_returnOnNull(rigid_body);

	ztVec3 point_world = rigid_body->model->calculated_mat * point;
	zt_rigidBodyAddForceAtWorldPoint(rigid_body, force, point_world);
}

// ================================================================================================================================================================================================

#define ZT_RIGID_BODY_FILE_GUID          zt_guidMake(0x975928d8, 0xdc8d4a6b, 0x8af0fe63, 0x1590c680)
#define ZT_RIGID_BODY_FILE_VERSION_1     10001
#define ZT_RIGID_BODY_FILE_VERSION_2     10002
#define ZT_RIGID_BODY_FILE_VERSION       10002

#define _serialCheck(code) if(!(code)) { zt_logCritical("ztRigidBody serialization failed."); return false; }

// ================================================================================================================================================================================================

bool zt_rigidBodySave(ztSerial *serial, ztRigidBody *rigid_body)
{
	ZT_PROFILE_GAME("zt_rigidBodySave");
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWrite(serial, ZT_RIGID_BODY_FILE_GUID));
		_serialCheck(zt_serialWrite(serial, ZT_RIGID_BODY_FILE_VERSION));

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, rigid_body->velocity));
			_serialCheck(zt_serialWrite(serial, rigid_body->angular_velocity));
			_serialCheck(zt_serialWrite(serial, rigid_body->acceleration));
			_serialCheck(zt_serialWrite(serial, rigid_body->force_accum));
			_serialCheck(zt_serialWrite(serial, rigid_body->torque_accum));
			_serialCheck(zt_serialWrite(serial, rigid_body->damping));
			_serialCheck(zt_serialWrite(serial, rigid_body->angular_damping));
			_serialCheck(zt_serialWrite(serial, rigid_body->inverse_mass));
			_serialCheck(zt_serialWrite(serial, rigid_body->force_gravity));
			_serialCheck(zt_serialWrite(serial, rigid_body->prev_acceleration));
			_serialCheck(zt_serialWrite(serial, rigid_body->flags));
			_serialCheck(zt_serialWrite(serial, rigid_body->collision_layer));
			_serialCheck(zt_serialWrite(serial, rigid_body->collides_with_layers));

			_serialCheck(zt_serialWrite(serial, rigid_body->inverse_inertia_tensor));
			_serialCheck(zt_serialWrite(serial, rigid_body->inverse_inertia_tensor_world));
			_serialCheck(zt_serialWrite(serial, rigid_body->motion));

			_serialCheck(zt_collisionGeometrySave(serial, &rigid_body->cg_bounding));

			_serialCheck(zt_serialWrite(serial, rigid_body->cg_details_count));
			zt_fiz(rigid_body->cg_details_count) {
				_serialCheck(zt_collisionGeometrySave(serial, &rigid_body->cg_details[i]));
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_rigidBodyLoad(ztSerial *serial, ztRigidBody *rigid_body)
{
	ZT_PROFILE_GAME("zt_rigidBodyLoad");
	_serialCheck(zt_serialGroupPush(serial));
	{
		ztGuid guid;
		_serialCheck(zt_serialRead(serial, &guid));
		if (guid != ZT_RIGID_BODY_FILE_GUID) {
			zt_logCritical("ztRigidBody guid mismatch");
			return false;
		}

		i32 version = 0;
		_serialCheck(zt_serialRead(serial, &version));
		if (version > ZT_RIGID_BODY_FILE_VERSION) {
			zt_logCritical("ztRigidBody version newer than supported");
			return false;
		}

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialRead(serial, &rigid_body->velocity));
			_serialCheck(zt_serialRead(serial, &rigid_body->angular_velocity));
			_serialCheck(zt_serialRead(serial, &rigid_body->acceleration));
			_serialCheck(zt_serialRead(serial, &rigid_body->force_accum));
			_serialCheck(zt_serialRead(serial, &rigid_body->torque_accum));
			_serialCheck(zt_serialRead(serial, &rigid_body->damping));
			_serialCheck(zt_serialRead(serial, &rigid_body->angular_damping));
			_serialCheck(zt_serialRead(serial, &rigid_body->inverse_mass));
			_serialCheck(zt_serialRead(serial, &rigid_body->force_gravity));
			_serialCheck(zt_serialRead(serial, &rigid_body->prev_acceleration));
			_serialCheck(zt_serialRead(serial, &rigid_body->flags));
			_serialCheck(zt_serialRead(serial, &rigid_body->collision_layer));
			_serialCheck(zt_serialRead(serial, &rigid_body->collides_with_layers));

			if (version >= ZT_RIGID_BODY_FILE_VERSION_2) {
				_serialCheck(zt_serialRead(serial, &rigid_body->inverse_inertia_tensor));
				_serialCheck(zt_serialRead(serial, &rigid_body->inverse_inertia_tensor_world));
				_serialCheck(zt_serialRead(serial, &rigid_body->motion));
			}
			else {
				zt_rigidBody_makeBlockInertiaTensor(&rigid_body->inverse_inertia_tensor, ztVec3::one, 1.f / zt_max(1.f, rigid_body->inverse_mass));
				rigid_body->motion = ztReal32Min;
			}

			_serialCheck(zt_collisionGeometryLoad(serial, &rigid_body->cg_bounding));

			_serialCheck(zt_serialRead(serial, &rigid_body->cg_details_count));
			zt_fiz(rigid_body->cg_details_count) {
				_serialCheck(zt_collisionGeometryLoad(serial, &rigid_body->cg_details[i]));
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

#undef _serialCheck

// ================================================================================================================================================================================================

void zt_rigidBodyRenderDebug(ztRigidBody *rigid_body, ztDrawList *draw_list)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyRenderDebug");
	ztColor color = zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_HadCollision) ? ztColor_Green : ztColor_Yellow;

	if (zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_Sleeping)) {
		color *= zt_vec4(.25f, .25f, .25f, 1.f);
	}

	ztVec3 position = rigid_body->model ? rigid_body->model->transform.position : ztVec3::zero;
	ztMat4 mat = rigid_body->model ? rigid_body->model->calculated_mat : ztMat4::identity;

	zt_drawListPushColor(draw_list, color);
	zt_collisionGeometryRenderDebug(&rigid_body->cg_bounding, draw_list, position, mat);
	zt_drawListPopColor(draw_list);

	zt_drawListPushColor(draw_list, color);
	zt_fiz(rigid_body->cg_details_count) {
		zt_collisionGeometryRenderDebug(&rigid_body->cg_details[i], draw_list, position, mat);
	}
	zt_drawListPopColor(draw_list);
}

// ================================================================================================================================================================================================

void zt_rigidBodiesUpdatePreCollision(ztRigidBody **rbs, int rbs_count, r32 dt)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodiesUpdatePreCollision");
	if (dt <= 0) return;

	r32 sleep_bias = zt_pow(.5f, dt);

	zt_fiz(rbs_count) {
		ztRigidBody *rigid_body = rbs[i];

		zt_bitRemove(rigid_body->flags, ztRigidBodyFlags_HadCollision);

		if (rigid_body->inverse_mass != 0 && !zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_Static) && !zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_Sleeping)) {
			// apply gravity
			if (rigid_body->force_gravity != ztVec3::zero) {
				rigid_body->force_accum += rigid_body->force_gravity * (1.f / rigid_body->inverse_mass);
			}

			rigid_body->prev_acceleration = rigid_body->acceleration;
			rigid_body->acceleration = (rigid_body->force_accum * rigid_body->inverse_mass);

			if (zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_NeedsMatrixCalc)) {
				zt_modelCalcMatrix(rigid_body->model);
				zt_bitRemove(rigid_body->flags, ztRigidBodyFlags_NeedsMatrixCalc);
			}

			ztVec3 angular_acceleration = rigid_body->inverse_inertia_tensor_world.getMultiply(rigid_body->torque_accum);

			rigid_body->velocity += rigid_body->acceleration * dt;
			rigid_body->angular_velocity += angular_acceleration * dt;

			// apply drag
			rigid_body->velocity *= zt_pow(rigid_body->damping, dt);
			rigid_body->angular_velocity *= zt_pow(rigid_body->angular_damping, dt);

			// apply velocities
			rigid_body->model->transform.position += rigid_body->velocity * dt;
			rigid_body->model->transform.rotation = ztQuat::makeFromEuler(zt_radiansToDegrees(rigid_body->angular_velocity) * dt) * rigid_body->model->transform.rotation;
			rigid_body->model->transform.rotation.normalize();

			//zt_fize(rigid_body->model->transform.rotation.values) {
			//	if (rigid_body->model->transform.rotation.values[i] > 180) {
			//		rigid_body->model->transform.rotation.values[i] -= 360;
			//	}
			//	else if(rigid_body->model->transform.rotation.values[i] < -180) {
			//		rigid_body->model->transform.rotation.values[i] += 360;
			//	}
			//}

			zt_modelCalcMatrix(rigid_body->model);

			// clear force accumulators
			rigid_body->force_accum = ztVec3::zero;
			rigid_body->torque_accum = ztVec3::zero;
		}
	}
}

// ================================================================================================================================================================================================

void zt_rigidBodiesUpdatePostCollision(ztRigidBody **rbs, int rbs_count, r32 dt)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodiesUpdatePostCollision");
	if (dt <= 0) return;

	r32 sleep_bias = zt_pow(.5f, dt);

	zt_fiz(rbs_count) {
		ztRigidBody *rigid_body = rbs[i];

		if (rigid_body->inverse_mass != 0 && !zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_Static) && !zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_Sleeping)) {
			if (!zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_NeverSleep) && zt_bitIsSet(rigid_body->flags, ztRigidBodyFlags_HadCollision)) {
				r32 vel_dot = rigid_body->velocity.dot(rigid_body->velocity);
				r32 rot_dot = rigid_body->angular_velocity.dot(rigid_body->angular_velocity);
				r32 current_motion = vel_dot + rot_dot;

				bool first_frame = rigid_body->motion == ztReal32Min;
				rigid_body->motion = (sleep_bias * rigid_body->motion) + ((1.f - sleep_bias) * current_motion);

				r32 sleep_epsilon = .3f;
				if (rigid_body->motion < sleep_epsilon && !first_frame) {
					rigid_body->flags |= ztRigidBodyFlags_Sleeping;
				}
				else if (rigid_body->motion > sleep_epsilon * 10.f || first_frame) {
					rigid_body->motion = sleep_epsilon * 10.f;
				}

				//zt_logDebug("motion = %.4f, current_motion = %.4f, vel_dot = %.4f", rigid_body->motion, current_motion, vel_dot);
				
				if (vel_dot < .0025f) {
					ztVec3 last_pos = rigid_body->prev_mat.getMultiply(ztVec3::one);
					ztVec3 this_pos = rigid_body->model->calculated_mat.getMultiply(ztVec3::one);
					rigid_body->prev_mat = rigid_body->model->calculated_mat;
				
					r32 dist = this_pos.distance(last_pos);
				
					if (dist < .025f && current_motion < .125f) {
						rigid_body->time_with_minimal_movement += dt;
						if(rigid_body->time_with_minimal_movement >= .05f) {
							rigid_body->flags |= ztRigidBodyFlags_Sleeping;
						}
					}
					else {
						rigid_body->time_with_minimal_movement = 0;
					}
				}
			}
		}
	}
}

// ================================================================================================================================================================================================

void zt_rigidBodyCollisionsResolve(ztRigidBodyCollision *collisions, int collisions_count, r32 dt, int max_iterations)
{
	ZT_PROFILE_PHYSICS("zt_rigidBodyCollisionsResolve");

	zt_fiz(collisions_count) {
		ztRigidBodyCollision *collision = &collisions[i];
		if (collision->rigid_bodies[0] && collision->rigid_bodies[1]) {
			if (collision->rigid_bodies[0]->velocity == ztVec3::zero && collision->rigid_bodies[0]->angular_velocity == ztVec3::zero) {
				zt_swap(collision->rigid_bodies[0], collision->rigid_bodies[1]);
				collision->contact_normal *= -1;
			}
			if (collision->rigid_bodies[1]->inverse_mass == 0) {
				collision->rigid_bodies[1] = nullptr;
			}
		}
	}

	int iterations = 0;
	while (iterations++ < max_iterations) {
		int max_idx = -1;
		r32 max_separating_velocity = ztReal32Max;

		zt_fiz(collisions_count) {
			ztRigidBodyCollision *collision = &collisions[i];

			ztVec3 relative_velocity = collision->rigid_bodies[0]->velocity;
			if (collision->rigid_bodies[1]) relative_velocity -= collision->rigid_bodies[1]->velocity;

			r32 separating_velocity = relative_velocity.dot(collision->contact_normal);

			if (separating_velocity < max_separating_velocity) {
				max_separating_velocity = separating_velocity;
				max_idx = i;
			}
		}

		if (max_idx < 0) {
			break;
		}

		ztRigidBodyCollision *collision = &collisions[max_idx];
		r32 separating_velocity = max_separating_velocity;

		//if (collision->rigid_bodies[0]->cg_details[0].type == ztCollisionGeometryType_OrientedBox) {
		//	zt_debugDisplayCube(collision->rigid_bodies[0]->cg_details[0].obb_extents, collision->rigid_bodies[0]->model->calculated_mat, ztColor_Red)->guid = ZT_COLLISION_DEBUG_GUID;
		//}
		//if (collision->rigid_bodies[1] && collision->rigid_bodies[1]->cg_details[0].type == ztCollisionGeometryType_OrientedBox) {
		//	zt_debugDisplayCube(collision->rigid_bodies[1]->cg_details[0].obb_extents, collision->rigid_bodies[1]->model->calculated_mat, ztColor_Red)->guid = ZT_COLLISION_DEBUG_GUID;
		//}

		if (separating_velocity <= ztReal32Max) {
			r32 new_separating_velocity = -separating_velocity * collision->restitution;

			ztVec3 accel_caused_velocity = collision->rigid_bodies[0]->acceleration;
			if (collision->rigid_bodies[1]) accel_caused_velocity -= collision->rigid_bodies[1]->acceleration;
			r32 accel_caused_sep_velocity = accel_caused_velocity.dot(collision->contact_normal) * dt;

			if (accel_caused_sep_velocity < 0) {
				new_separating_velocity += collision->restitution * accel_caused_sep_velocity;
				if (new_separating_velocity < 0) {
					new_separating_velocity = 0;
				}
			}

			r32 delta_velocity = new_separating_velocity - separating_velocity;
			r32 total_inverse_mass = collision->rigid_bodies[0]->inverse_mass;
			if (collision->rigid_bodies[1]) total_inverse_mass += collision->rigid_bodies[1]->inverse_mass;

			if (total_inverse_mass > 0) {
				r32 impulse_val = delta_velocity / total_inverse_mass;
				ztVec3 impulse_per_invmass = collision->contact_normal * impulse_val;

				ztVec3 contact_tangents[2];

				if (zt_abs(collision->contact_normal.x) > zt_abs(collision->contact_normal.y)) {
					r32 s = 1.f / zt_sqrt(collision->contact_normal.z * collision->contact_normal.z + collision->contact_normal.x * collision->contact_normal.x);
					contact_tangents[0].x = collision->contact_normal.z * s;
					contact_tangents[0].y = 0;
					contact_tangents[0].z = -collision->contact_normal.x * s;

					contact_tangents[1].x = collision->contact_normal.y * contact_tangents[0].x;
					contact_tangents[1].y = collision->contact_normal.z * contact_tangents[0].x - collision->contact_normal.x * contact_tangents[0].z;
					contact_tangents[1].z = -collision->contact_normal.y * contact_tangents[0].x;
				}
				else {
					r32 s = 1.f / zt_sqrt(collision->contact_normal.z * collision->contact_normal.z + collision->contact_normal.y * collision->contact_normal.y);
					contact_tangents[0].x = 0;
					contact_tangents[0].y = -collision->contact_normal.z * s;
					contact_tangents[0].z = collision->contact_normal.y * s;

					contact_tangents[1].x = collision->contact_normal.y * contact_tangents[0].z - collision->contact_normal.z * contact_tangents[0].y;
					contact_tangents[1].y = -collision->contact_normal.x * contact_tangents[0].z;
					contact_tangents[1].z = collision->contact_normal.x * contact_tangents[0].y;
				}

				ztMat3 contact_to_world;
				contact_to_world[ztMat3_Col0Row0] = collision->contact_normal.x;
				contact_to_world[ztMat3_Col0Row1] = contact_tangents[0].x;
				contact_to_world[ztMat3_Col0Row2] = contact_tangents[1].x;
				contact_to_world[ztMat3_Col1Row0] = collision->contact_normal.y;
				contact_to_world[ztMat3_Col1Row1] = contact_tangents[0].y;
				contact_to_world[ztMat3_Col1Row2] = contact_tangents[1].y;
				contact_to_world[ztMat3_Col2Row0] = collision->contact_normal.z;
				contact_to_world[ztMat3_Col2Row1] = contact_tangents[0].z;
				contact_to_world[ztMat3_Col2Row2] = contact_tangents[1].z;
				contact_to_world = contact_to_world.getTranspose();
				ztMat3 contact_to_world_transpose = contact_to_world.getTranspose();

				ztVec3 local_velocity[2];
				ztVec3 relative_contact_pos[2];
				ztMat3 inverse_inertia_tensor[2];

				r32 velocity_from_accel = 0;

				{
					zt_fiz(2) {
						ztRigidBody *rigid_body = collision->rigid_bodies[i];
						if (rigid_body == nullptr) {
							local_velocity[i] = ztVec3::zero;
							relative_contact_pos[i] = ztVec3::zero;
							inverse_inertia_tensor[i] = ztMat3::zero;
							continue;
						}

						zt_rigidBody_transformInertiaTensor(&rigid_body->inverse_inertia_tensor_world, &rigid_body->inverse_inertia_tensor, &rigid_body->model->calculated_mat);

						inverse_inertia_tensor[i] = rigid_body->inverse_inertia_tensor_world;
						relative_contact_pos[i] = collision->contact_point - rigid_body->model->calculated_mat.getMultiply(ztVec3::zero);

						ztQuat rotation = ztQuat::makeFromMat4(rigid_body->model->calculated_mat);
						ztVec3 euler = zt_degreesToRadians(rotation.euler());

						ztVec3 velocity = euler.cross(relative_contact_pos[i]);
						velocity += rigid_body->velocity;

						local_velocity[i] = contact_to_world_transpose.getMultiply(velocity);
						ztVec3 accel_velocity = contact_to_world_transpose.getMultiply(rigid_body->prev_acceleration * dt);
						accel_velocity.x = 0;
						local_velocity[i] += accel_velocity;

						velocity_from_accel += (rigid_body->prev_acceleration * dt).dot(collision->contact_normal);
					}
				}

				ztVec3 contact_velocity = local_velocity[0] - local_velocity[1];
				ztVec3 impulse;

				r32 this_restitution = collision->restitution;
				if (zt_abs(contact_velocity.x) < .25f) {
					this_restitution = 0.f;
				}
				r32 desired_delta_velocity = -contact_velocity.x - this_restitution * (contact_velocity.x - velocity_from_accel);

				r32 friction = .0f;//.9f;

				if (friction == .0f) {
					ztVec3 delta_vel_world = relative_contact_pos[0].cross(collision->contact_normal);
					delta_vel_world = inverse_inertia_tensor[0].getMultiply(delta_vel_world);
					delta_vel_world = delta_vel_world.cross(relative_contact_pos[0]);

					r32 delta_velocity = delta_vel_world.dot(collision->contact_normal);
					delta_velocity += collision->rigid_bodies[0]->inverse_mass;

					if (collision->rigid_bodies[1]) {
						delta_vel_world = relative_contact_pos[1].cross(collision->contact_normal);
						delta_vel_world = inverse_inertia_tensor[1].getMultiply(delta_vel_world);
						delta_vel_world = delta_vel_world.cross(relative_contact_pos[1]);

						delta_velocity += delta_vel_world.dot(collision->contact_normal);
						delta_velocity += collision->rigid_bodies[1]->inverse_mass;
					}

					ztVec3 impulse_contact = zt_vec3(desired_delta_velocity / delta_velocity, 0, 0);
					impulse = contact_to_world.getMultiply(impulse_contact);
				}
				else {
					// this needs work:
					ztMat3 impulse_to_torque;
					zt_rigidBody_setSkewSymmetric(&impulse_to_torque, &relative_contact_pos[0]);

					ztMat3 delta_vel_world = impulse_to_torque;
					delta_vel_world = inverse_inertia_tensor[0].getMultiply(delta_vel_world);
					delta_vel_world *= impulse_to_torque;
					zt_fize(delta_vel_world.values) delta_vel_world.values[i] *= -1.f;

					r32 inverse_mass = collision->rigid_bodies[0]->inverse_mass;

					if (collision->rigid_bodies[1]) {
						zt_rigidBody_setSkewSymmetric(&impulse_to_torque, &relative_contact_pos[1]);

						ztMat3 delta_vel_world2 = impulse_to_torque;
						delta_vel_world2 = inverse_inertia_tensor[1].getMultiply(delta_vel_world2);
						delta_vel_world2 *= impulse_to_torque;
						zt_fize(delta_vel_world2.values) delta_vel_world2.values[i] *= -1.f;

						zt_fize(delta_vel_world.values) delta_vel_world.values[i] += delta_vel_world2.values[i];

						inverse_mass += collision->rigid_bodies[1]->inverse_mass;
					}

					ztMat3 delta_velocity = contact_to_world_transpose;
					delta_velocity = delta_velocity * delta_vel_world;
					delta_velocity = delta_velocity * contact_to_world;

					delta_velocity.values[0] += inverse_mass;
					delta_velocity.values[4] += inverse_mass;
					delta_velocity.values[8] += inverse_mass;

					ztMat3 impulse_matrix = delta_velocity.getInverse();

					ztVec3 vel_kill = zt_vec3(desired_delta_velocity, -contact_velocity.y, -contact_velocity.z);

					ztVec3 impulse_contact = impulse_matrix.getMultiply(vel_kill);

					r32 planar_impulse = zt_sqrt(impulse_contact.y * impulse_contact.y + impulse_contact.z * impulse_contact.z);
					if (planar_impulse > impulse_contact.x * friction) {
						impulse_contact.y /= planar_impulse;
						impulse_contact.z /= planar_impulse;

						impulse_contact.x = delta_velocity.values[0] + delta_velocity.values[1] * friction * impulse_contact.y + delta_velocity.values[2] * friction * impulse_contact.z;
						impulse_contact.x = desired_delta_velocity / impulse_contact.x;
						impulse_contact.y *= friction * impulse_contact.x;
						impulse_contact.z *= friction * impulse_contact.x;
					}
					impulse = contact_to_world.getMultiply(impulse_contact);
				}

				r32 total_inertia = 0;
				r32 linear_inertia[2];
				r32 angular_inertia[2];

				zt_fiz(2) {
					if (collision->rigid_bodies[i] == nullptr) {
						continue;
					}

					ztVec3 angular_inertia_world = relative_contact_pos[i].cross(collision->contact_normal);
					angular_inertia_world = inverse_inertia_tensor[i].getMultiply(angular_inertia_world);
					angular_inertia_world = angular_inertia_world.cross(relative_contact_pos[i]);

					angular_inertia[i] = angular_inertia_world.dot(collision->contact_normal);

					linear_inertia[i] = collision->rigid_bodies[i]->inverse_mass;// * 1.1f;

					total_inertia += linear_inertia[i] + angular_inertia[i];
				}

				ztVec3 angular_change[2];
				ztVec3 linear_change[2];

				zt_fiz(2) {
					if (collision->rigid_bodies[i] == nullptr) {
						continue;
					}

					r32 sign = i == 0 ? 1.f : -1.f;

					r32 angular_move = sign * collision->penetration * (angular_inertia[i] / total_inertia);
					r32 linear_move = sign * collision->penetration * (linear_inertia[i] / total_inertia);

					ztVec3 projection = relative_contact_pos[i] + collision->contact_normal * -relative_contact_pos[i].dot(collision->contact_normal);

					r32 max_magnitude = .2f * projection.magnitude();

					if (angular_move < -max_magnitude) {
						r32 total_move = angular_move + linear_move;
						angular_move = -max_magnitude;
						linear_move = total_move - angular_move;
					}
					else if (angular_move > max_magnitude) {
						r32 total_move = angular_move + linear_move;
						angular_move = max_magnitude;
						linear_move = total_move - angular_move;
					}

					if (angular_move == 0) {
						angular_change[i] = ztVec3::zero;
					}
					else {
						ztVec3 target_angular_direction = relative_contact_pos[i].cross(collision->contact_normal);
						angular_change[i] = inverse_inertia_tensor[i].getMultiply(target_angular_direction) * (angular_move * (1.f / angular_inertia[i]));
					}

					linear_change[i] = collision->contact_normal * linear_move;

					collision->rigid_bodies[i]->model->transform.position += collision->contact_normal * linear_move;
					collision->rigid_bodies[i]->model->transform.rotation = ztQuat::makeFromEuler(zt_radiansToDegrees(angular_change[i])) * collision->rigid_bodies[i]->model->transform.rotation;
					
					ztVec3 impulse_torque = relative_contact_pos[i].cross(impulse);
					
					ztVec3 velocity_change = impulse * collision->rigid_bodies[i]->inverse_mass * (i == 0 ? 1.f : -1.f);
					ztVec3 rotation_change = inverse_inertia_tensor[i].getMultiply(impulse_torque);

					ztVec3 prev_linear_velocity = collision->rigid_bodies[i]->velocity;
					collision->rigid_bodies[i]->velocity += velocity_change;
					ztVec3 prev_angular_velocity = collision->rigid_bodies[i]->angular_velocity;
					collision->rigid_bodies[i]->angular_velocity += rotation_change;

					r32 linear_velocity_len = velocity_change.length();
					if(linear_velocity_len < .5f) {
						zt_fjze(prev_linear_velocity.values) {
							if (prev_linear_velocity.values[j] < 0 && collision->rigid_bodies[i]->velocity.values[j] > 0 || prev_linear_velocity.values[j] > 0 && collision->rigid_bodies[i]->velocity.values[j] < 0) {
								// reversed direction, we need to just stop moving
								collision->rigid_bodies[i]->velocity.values[j] = 0;
								break;
							}
						}
					}

					r32 angular_velocity_len = rotation_change.length();//collision->rigid_bodies[i]->angular_velocity.length();
					if (angular_velocity_len < 5) {
						zt_fjze(prev_angular_velocity.values) {
							if (prev_angular_velocity.values[j] < 0 && collision->rigid_bodies[i]->angular_velocity.values[j] > 0 || prev_angular_velocity.values[j] > 0 && collision->rigid_bodies[i]->angular_velocity.values[j] < 0) {
								// reversed direction, we need to just stop rotating
								collision->rigid_bodies[i]->angular_velocity.values[j] = 0;
								break;
							}
						}
					}
					
					zt_bitRemove(collision->rigid_bodies[i]->flags, ztRigidBodyFlags_Sleeping);

					r32 length = rotation_change.length();
					rotation_change = zt_radiansToDegrees(rotation_change);
				}
			}
		}
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

bool zt_staticBodyMake(ztStaticBody *static_body, i32 max_triangles_count)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyMake");
	static_body->triangles = zt_mallocStructArray(ztTriangle, max_triangles_count);

	if (static_body->triangles == nullptr) {
		return false;
	}

	static_body->triangles_count = 0;
	static_body->triangles_size = max_triangles_count;

	static_body->min = ztVec3::max;
	static_body->max = ztVec3::min;

	zt_memSet(&static_body->octree, zt_sizeof(ztOcTree), 0);

	return true;
}

// ================================================================================================================================================================================================

void zt_staticBodyFree(ztStaticBody *static_body)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyFree");
	if (static_body == nullptr) {
		return;
	}

	if (static_body->triangles) {
		zt_free(static_body->triangles);
		static_body->triangles = nullptr;
		static_body->triangles_count = static_body->triangles_size = 0;
	}

	zt_ocTreeFree(&static_body->octree);
}

// ================================================================================================================================================================================================

bool zt_staticBodyAddTriangles(ztStaticBody *static_body, ztVec3 *verts, i32 verts_count)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyAddTriangles");
	zt_returnValOnNull(static_body, false);
	zt_returnValOnNull(verts, false);
	zt_assertReturnValOnFail(verts_count > 0, false);
	zt_assertReturnValOnFail(verts_count % 3 == 0, false);
	zt_assertReturnValOnFail(static_body->triangles_size - static_body->triangles_count >= verts_count / 3, false);

	for (int i = 0; i < verts_count; i += 3) {
		ztTriangle *triangle = &static_body->triangles[static_body->triangles_count++];

		zt_fjz(3) {
			triangle->points[j] = verts[i + j];

			zt_fkz(3) {
				static_body->min.values[k] = zt_min(static_body->min.values[k], triangle->points[j].values[k]);
				static_body->max.values[k] = zt_max(static_body->max.values[k], triangle->points[j].values[k]);
			}
		}

		zt_triangleCalculateNormal(triangle->points[0], triangle->points[1], triangle->points[2], &triangle->normal);
	}

	return true;
}

// ================================================================================================================================================================================================

void zt_staticBodyGenerateOcTree(ztStaticBody *static_body, i32 max_objects_per_node, i32 max_node_levels)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyGenerateOcTree");
	zt_ocTreeFree(&static_body->octree);

	ztOcTreeItemContainedTestTriangles data;
	data.triangles = static_body->triangles;
	data.triangles_count = static_body->triangles_count;

	zt_ocTreeMake(&static_body->octree, max_objects_per_node, max_node_levels, (static_body->min + static_body->max) * .5f, (static_body->max - static_body->min) + ztVec3::one, zt_ocTreeItemContainedTestTriangles, &data);
}

// ================================================================================================================================================================================================

#define ZT_STATIC_BODY_FILE_GUID        zt_guidMake(0x209cfa2d, 0xeeb84124, 0x97d35b8b, 0x182e1081)
#define ZT_STATIC_BODY_FILE_VERSION     10001

#define _serialCheck(code) if(!(code)) { zt_logCritical("ztStaticBody serialization failed."); return false; }

// ================================================================================================================================================================================================

bool zt_staticBodySave(ztSerial *serial, ztStaticBody *static_body)
{
	ZT_PROFILE_PHYSICS("zt_staticBodySave");
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWrite(serial, ZT_STATIC_BODY_FILE_GUID));
		_serialCheck(zt_serialWrite(serial, ZT_STATIC_BODY_FILE_VERSION));

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, static_body->triangles_size));
			_serialCheck(zt_serialWrite(serial, static_body->triangles_count));

			zt_fiz(static_body->triangles_count) {
				_serialCheck(zt_serialWrite(serial, static_body->triangles[i].points[0]));
				_serialCheck(zt_serialWrite(serial, static_body->triangles[i].points[1]));
				_serialCheck(zt_serialWrite(serial, static_body->triangles[i].points[2]));
				_serialCheck(zt_serialWrite(serial, static_body->triangles[i].normal));
			}

			_serialCheck(zt_serialWrite(serial, static_body->min));
			_serialCheck(zt_serialWrite(serial, static_body->max));

			_serialCheck(zt_serialGroupPush(serial));
			{
				_serialCheck(zt_ocTreeSave(&static_body->octree, serial));
			}
			_serialCheck(zt_serialGroupPop(serial));
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_staticBodyLoad(ztSerial *serial, ztStaticBody *static_body)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyLoad");
	_serialCheck(zt_serialGroupPush(serial));
	{
		ztGuid guid;
		_serialCheck(zt_serialRead(serial, &guid));
		if (guid != ZT_STATIC_BODY_FILE_GUID) {
			zt_logCritical("ztStaticBody guid mismatch");
			return false;
		}

		i32 version = 0;
		_serialCheck(zt_serialRead(serial, &version));
		if (version > ZT_STATIC_BODY_FILE_VERSION) {
			zt_logCritical("ztStaticBody version newer than supported");
			return false;
		}

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialRead(serial, &static_body->triangles_size));

			zt_staticBodyMake(static_body, static_body->triangles_size);
			
			_serialCheck(zt_serialRead(serial, &static_body->triangles_count));

			zt_fiz(static_body->triangles_count) {
				_serialCheck(zt_serialRead(serial, &static_body->triangles[i].points[0]));
				_serialCheck(zt_serialRead(serial, &static_body->triangles[i].points[1]));
				_serialCheck(zt_serialRead(serial, &static_body->triangles[i].points[2]));
				_serialCheck(zt_serialRead(serial, &static_body->triangles[i].normal));
			}

			_serialCheck(zt_serialRead(serial, &static_body->min));
			_serialCheck(zt_serialRead(serial, &static_body->max));

			_serialCheck(zt_serialGroupPush(serial));
			{
				_serialCheck(zt_ocTreeLoad(&static_body->octree, serial));
			}
			_serialCheck(zt_serialGroupPop(serial));
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

#undef _serialCheck

// ================================================================================================================================================================================================

i32 zt_staticBodyHasCollisionsAABB(ztStaticBody *static_body, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, ztVec3 *contact_points, ztVec3 *contact_normals, i32 *contact_triangles, i32 contact_count)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyHasCollisionsAABB");
	if (static_body->triangles_count == 0) {
		return 0;
	}

	ztOcTree::Node *nodes[128];
	i32 nodes_found = zt_ocTreeFindNodesThatIntersect(&static_body->octree, nodes, zt_elementsOf(nodes), aabb_center, aabb_extents);

	i32 contact_idx = 0;

	zt_fvz(nidx, zt_min(nodes_found, zt_elementsOf(nodes))) {
		ztOcTree::Node *node = nodes[nidx];

		zt_fvz(tridx, node->objects_count) {
			bool abort = false;
			zt_fiz(zt_min(contact_idx, contact_count)) {
				if (contact_triangles[i] == node->objects[tridx]) {
					abort = true;
					break;
				}
			}
			if (!abort) {
				ztTriangle *triangle = &static_body->triangles[node->objects[tridx]];
				ztVec3 intersect_point;
				if (zt_collisionTriangleInAABB(triangle->points[0], triangle->points[1], triangle->points[2], aabb_center, aabb_extents, &intersect_point)) {
					i32 idx = contact_idx++;
					if (idx < contact_count) {
						contact_points[idx] = intersect_point;
						contact_normals[idx] = triangle->normal;
						contact_triangles[idx] = node->objects[tridx];
					}
				}
			}
		}
	}

	return contact_idx;
}

// ================================================================================================================================================================================================

i32 zt_staticBodyHasCollisionsOBB(ztStaticBody *static_body, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat &obb_rot, ztVec3 *contact_points, ztVec3 *contact_normals, i32 *contact_triangles, i32 contact_count)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyHasCollisionsOBB");

	if (static_body->triangles_count == 0) {
		return 0;
	}

	r32 max_ext = obb_extents.length();
	ztVec3 aabb_center  = obb_center;
	ztVec3 aabb_extents = zt_vec3(max_ext, max_ext, max_ext);

	ztOcTree::Node *nodes[256];
	i32 nodes_found = zt_ocTreeFindNodesThatIntersect(&static_body->octree, nodes, zt_elementsOf(nodes), aabb_center, aabb_extents);

	if (nodes_found > zt_elementsOf(nodes)) {
		zt_assert(false);
		nodes_found = zt_elementsOf(nodes);
	}

	i32 contact_idx = 0;

	ztMat4 mat = zt_transformToMat4(obb_center, obb_rot).getInverse();

	zt_fvz(nidx, nodes_found) {
		ztOcTree::Node *node = nodes[nidx];

		//zt_debugDisplayCube(node->size, node->center, ztColor_Cyan);

		zt_fvz(tridx, node->objects_count) {
			bool abort = false;
			zt_fiz(zt_min(contact_idx, contact_count)) {
				if (contact_triangles[i] == node->objects[tridx]) {
					abort = true;
					break;
				}
			}

			if (!abort) {
				ztTriangle *triangle = &static_body->triangles[node->objects[tridx]];
				//zt_debugDisplayLine(triangle->points[0], triangle->points[1], ztColor_Red);
				//zt_debugDisplayLine(triangle->points[0], triangle->points[2], ztColor_Red);
				//zt_debugDisplayLine(triangle->points[1], triangle->points[2], ztColor_Red);

				ztVec3 center = (triangle->points[0] + triangle->points[1] + triangle->points[2]) * .33333f;
				ztVec3 direction = center - aabb_center;
				direction.normalize();

				if (direction.dot(triangle->normal) >= 0.f) {
					continue;
				}

				if (zt_collisionTriangleInAABB(triangle->points[0], triangle->points[1], triangle->points[2], aabb_center, aabb_extents)) {
					ztVec3 p0 = mat.getMultiply(triangle->points[0]);
					ztVec3 p1 = mat.getMultiply(triangle->points[1]);
					ztVec3 p2 = mat.getMultiply(triangle->points[2]);

					ztVec3 intersect_point;
					if (zt_collisionTriangleInAABB(p0, p1, p2, ztVec3::zero, obb_extents, &intersect_point)) {
						i32 idx = contact_idx++;
						if (idx < contact_count) {
							intersect_point = zt_closestPointTrianglePoint(p0, p1, p2, intersect_point);
							contact_points[idx] = mat.getInverse().getMultiply(intersect_point);
							contact_normals[idx] = triangle->normal;
							contact_triangles[idx] = node->objects[tridx];
						}
					}
				}
			}
		}
	}

	return contact_idx;
}

// ================================================================================================================================================================================================

i32 zt_staticBodyHasCollisionsSphere(ztStaticBody *static_body, const ztVec3 &sphere_center, r32 sphere_radius, ztVec3 *contact_points, ztVec3 *contact_normals, i32 *contact_triangles, i32 contact_count)
{
	ZT_PROFILE_PHYSICS("zt_staticBodyHasCollisionsSphere");
	if (static_body->triangles_count == 0) {
		return 0;
	}

	ztVec3 aabb_center = sphere_center;
	ztVec3 aabb_extents = zt_vec3(sphere_radius, sphere_radius, sphere_radius);

	ztOcTree::Node *nodes[128];
	i32 nodes_found = zt_ocTreeFindNodesThatIntersect(&static_body->octree, nodes, zt_elementsOf(nodes), aabb_center, aabb_extents);

	i32 contact_idx = 0;

	zt_fvz(nidx, nodes_found) {
		ztOcTree::Node *node = nodes[nidx];

		zt_fvz(tridx, node->objects_count) {
			bool abort = false;
			zt_fiz(zt_min(contact_idx, contact_count)) {
				if (contact_triangles[i] == node->objects[tridx]) {
					abort = true;
					break;
				}
			}

			if (!abort) {
				ztTriangle *triangle = &static_body->triangles[node->objects[tridx]];
				if (zt_collisionTriangleInAABB(triangle->points[0], triangle->points[1], triangle->points[2], aabb_center, aabb_extents)) {

					ztVec3 intersect_point;
					if (zt_collisionTriangleInSphere(triangle->points[0], triangle->points[1], triangle->points[2], sphere_center, sphere_radius, &intersect_point)) {
						i32 idx = contact_idx++;
						if (idx < contact_count) {
							contact_points[idx] = intersect_point;
							contact_normals[idx] = triangle->normal;
							contact_triangles[idx] = node->objects[tridx];
						}
					}
				}
			}
		}
	}

	return contact_idx;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_movingBodyMake(ztMovingBody *moving_body, ztModel *model, r32 restitution, ztCollisionGeometry cg_bounding, ztCollisionGeometry *details, int details_count)
{
	ZT_PROFILE_PHYSICS("zt_movingBodyMake");
	moving_body->model            = model;
	moving_body->transform        = nullptr;
	moving_body->transform_prev   = model == nullptr ? zt_transformMake() : model->transform;
	moving_body->restitution      = restitution;
	moving_body->flags            = ztMovingBodyFlags_NeedsMatrixCalc;
	moving_body->cg_bounding      = cg_bounding;
	moving_body->cg_details_count = details_count;

	zt_fiz(details_count) {
		moving_body->cg_details[i] = details[i];
	}

	moving_body->collisions       = nullptr;
}

// ================================================================================================================================================================================================

void zt_movingBodyMake(ztMovingBody *moving_body, ztModel *model, r32 restitution, ztCollisionGeometry cg_bounding, ztCollisionGeometry detail)
{
	zt_movingBodyMake(moving_body, model, restitution, cg_bounding, &detail, 1);
}

// ================================================================================================================================================================================================

void zt_movingBodyFree(ztMovingBody *moving_body)
{
	// nothing to do currently
}

// ================================================================================================================================================================================================

#define ZT_MOVING_BODY_FILE_GUID          zt_guidMake(0x07791b5f, 0x5c894d8b, 0x81c2515b, 0xf24f2f42)
#define ZT_MOVING_BODY_FILE_VERSION       10001

#define _serialCheck(code) if(!(code)) { zt_logCritical("ztMovingBody serialization failed."); return false; }

// ================================================================================================================================================================================================

bool zt_movingBodySave(ztSerial *serial, ztMovingBody *moving_body)
{
	ZT_PROFILE_GAME("zt_movingBodySave");
	_serialCheck(zt_serialGroupPush(serial));
	{
		_serialCheck(zt_serialWrite(serial, ZT_MOVING_BODY_FILE_GUID));
		_serialCheck(zt_serialWrite(serial, ZT_MOVING_BODY_FILE_VERSION));

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, moving_body->transform_prev.position));
			_serialCheck(zt_serialWrite(serial, moving_body->transform_prev.rotation));
			_serialCheck(zt_serialWrite(serial, moving_body->transform_prev.scale));
			_serialCheck(zt_serialWrite(serial, moving_body->restitution));
			_serialCheck(zt_serialWrite(serial, moving_body->flags));
			_serialCheck(zt_serialWrite(serial, moving_body->collision_layer));
			_serialCheck(zt_serialWrite(serial, moving_body->collides_with_layers));

			_serialCheck(zt_collisionGeometrySave(serial, &moving_body->cg_bounding));

			_serialCheck(zt_serialWrite(serial, moving_body->cg_details_count));
			zt_fiz(moving_body->cg_details_count) {
				_serialCheck(zt_collisionGeometrySave(serial, &moving_body->cg_details[i]));
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;
}

// ================================================================================================================================================================================================

bool zt_movingBodyLoad(ztSerial *serial, ztMovingBody *moving_body)
{
	ZT_PROFILE_GAME("zt_movingBodyLoad");
	_serialCheck(zt_serialGroupPush(serial));
	{
		ztGuid guid;
		_serialCheck(zt_serialRead(serial, &guid));
		if (guid != ZT_MOVING_BODY_FILE_GUID) {
			zt_logCritical("ztMovingBody guid mismatch");
			return false;
		}

		i32 version = 0;
		_serialCheck(zt_serialRead(serial, &version));
		if (version > ZT_MOVING_BODY_FILE_VERSION) {
			zt_logCritical("ztMovingBody version newer than supported");
			return false;
		}

		zt_memSet(moving_body, zt_sizeof(ztMovingBody), 0);

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialRead(serial, &moving_body->transform_prev.position));
			_serialCheck(zt_serialRead(serial, &moving_body->transform_prev.rotation));
			_serialCheck(zt_serialRead(serial, &moving_body->transform_prev.scale));
			_serialCheck(zt_serialRead(serial, &moving_body->restitution));
			_serialCheck(zt_serialRead(serial, &moving_body->flags));
			_serialCheck(zt_serialRead(serial, &moving_body->collision_layer));
			_serialCheck(zt_serialRead(serial, &moving_body->collides_with_layers));

			_serialCheck(zt_collisionGeometryLoad(serial, &moving_body->cg_bounding));

			_serialCheck(zt_serialRead(serial, &moving_body->cg_details_count));
			zt_fiz(moving_body->cg_details_count) {
				_serialCheck(zt_collisionGeometryLoad(serial, &moving_body->cg_details[i]));
			}
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));
	return true;}

// ================================================================================================================================================================================================

#undef _serialCheck

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztForceAnchor zt_forceAnchor(ztRigidBody *rigid_body, const ztVec3 &connection_point)
{
	ZT_PROFILE_PHYSICS("zt_forceAnchor");
	zt_assert(rigid_body != nullptr);
	ztForceAnchor anchor;
	anchor.type = ztForceAnchorType_RigidBody;
	anchor.rigid_body = rigid_body;
	anchor.connection_point = connection_point;
	return anchor;
}

// ================================================================================================================================================================================================

ztForceAnchor zt_forceAnchor(ztTransform *transform)
{
	ZT_PROFILE_PHYSICS("zt_forceAnchor");
	zt_assert(transform != nullptr);
	ztForceAnchor anchor;
	anchor.type = ztForceAnchorType_Transform;
	anchor.transform = transform;
	return anchor;
}

// ================================================================================================================================================================================================

ztForceAnchor zt_forceAnchor(ztVec3 *vec3_ptr)
{
	ZT_PROFILE_PHYSICS("zt_forceAnchor");
	zt_assert(vec3_ptr != nullptr);
	ztForceAnchor anchor;
	anchor.type = ztForceAnchorType_Vec3Ptr;
	anchor.vec3_ptr = vec3_ptr;
	return anchor;
}

// ================================================================================================================================================================================================

ztForceAnchor zt_forceAnchor(ztVec3 vec3)
{
	ZT_PROFILE_PHYSICS("zt_forceAnchor");
	ztForceAnchor anchor;
	anchor.type = ztForceAnchorType_Vec3;
	anchor.vec3 = vec3;
	return anchor;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztForce zt_forceMakeSpring(ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 rest_length)
{
	ZT_PROFILE_PHYSICS("zt_forceMakeSpring");
	zt_assert(rigid_body != nullptr);

	ztForce force;
	force.type                   = ztForceType_Spring;
	force.rigid_body             = rigid_body;
	force.connection_point       = connection_point;
	force.anchor                 = anchor;
	force.spring.spring_constant = spring_constant;
	force.spring.rest_length     = rest_length;

	return force;
}

// ================================================================================================================================================================================================

ztForce zt_forceMakeStiffSpring(ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 damping)
{
	ZT_PROFILE_PHYSICS("zt_forceMakeStiffSpring");
	zt_assert(rigid_body != nullptr);

	ztForce force;
	force.type                         = ztForceType_StiffSpring;
	force.rigid_body                   = rigid_body;
	force.connection_point       = connection_point;
	force.anchor                       = anchor;
	force.stiff_spring.spring_constant = spring_constant;
	force.stiff_spring.damping         = damping;

	return force;
}

// ================================================================================================================================================================================================

ztForce zt_forceMakeBungee(ztRigidBody *rigid_body, const ztVec3 &connection_point, ztForceAnchor anchor, r32 spring_constant, r32 rest_length)
{
	ZT_PROFILE_PHYSICS("zt_forceMakeBungee");
	zt_assert(rigid_body != nullptr);

	ztForce force;
	force.type                   = ztForceType_Bungee;
	force.rigid_body             = rigid_body;
	force.connection_point       = connection_point;
	force.anchor                 = anchor;
	force.spring.spring_constant = spring_constant;
	force.spring.rest_length     = rest_length;

	return force;
}

// ================================================================================================================================================================================================

ztForce zt_forceMakeBuoyancy(ztRigidBody *rigid_body, const ztVec3 &connection_point, r32 max_depth, r32 volume, r32 water_height, r32 liquid_density)
{
	ZT_PROFILE_PHYSICS("zt_forceMakeBuoyancy");
	zt_assert(rigid_body != nullptr);

	ztForce force;
	force.type                    = ztForceType_Buoyancy;
	force.rigid_body              = rigid_body;
	force.connection_point        = connection_point;
	force.buoyancy.max_depth      = max_depth;
	force.buoyancy.volume         = volume;
	force.buoyancy.water_height   = water_height;
	force.buoyancy.liquid_density = liquid_density;

	return force;
}

// ================================================================================================================================================================================================

void zt_forcesUpdate(ztForce *forces, int forces_count, r32 dt)
{
	ZT_PROFILE_PHYSICS("zt_forcesUpdate");
	ztVec3 force_to_apply;

	zt_fiz(forces_count) {
		ztForce *force = &forces[i];

		ztVec3 point_body = force->rigid_body->model->calculated_mat * force->connection_point;

#		define getAnchor(force) (force->anchor.type == ztForceAnchorType_RigidBody ? force->anchor.rigid_body->model->calculated_mat * force->anchor.connection_point : \
								(force->anchor.type == ztForceAnchorType_Transform ? force->anchor.transform->position : \
								(force->anchor.type == ztForceAnchorType_Vec3Ptr ? *force->anchor.vec3_ptr : force->anchor.vec3)))

		switch (force->type)
		{
			case ztForceType_Spring: {
				force_to_apply = point_body - getAnchor(force);

				r32 magnitude = force_to_apply.length();
				magnitude = (magnitude - force->spring.rest_length) * force->spring.spring_constant;

				force_to_apply.normalize();
				force_to_apply *= -magnitude;
			} break;

			// ------------------------------------------------------------------------------------

			case ztForceType_StiffSpring: {
				ztVec3 position = point_body;
				ztVec3 anchor = getAnchor(force);
				position -= anchor;

				r32 gamma = .5f * zt_sqrt(4 * force->stiff_spring.spring_constant - force->stiff_spring.damping * force->stiff_spring.damping);
				if (gamma != 0.f) {
					ztVec3 c = position * (force->stiff_spring.damping / (2.f * gamma)) + force->rigid_body->velocity * (1.f / gamma);
					ztVec3 target = position * zt_cos(gamma * dt) + c * zt_sin(gamma * dt);
					target *= zt_exp(-.5f * dt * force->stiff_spring.damping);

					ztVec3 accel = (target - position) * (1.f / dt * dt) - force->rigid_body->velocity * dt;
					force_to_apply = accel * (1.f / force->rigid_body->inverse_mass * (1.f / dt));
				}
			} break;

			// ------------------------------------------------------------------------------------

			case ztForceType_Bungee: {
				force_to_apply = point_body - getAnchor(force);

				r32 magnitude = force_to_apply.length();
				if (magnitude > force->spring.rest_length) {
					magnitude = (magnitude - force->spring.rest_length) * force->spring.spring_constant;

					force_to_apply.normalize();
					force_to_apply *= -magnitude;
				}
			} break;

			// ------------------------------------------------------------------------------------

			case ztForceType_Buoyancy: {
				r32 depth = point_body.y;
				if (depth < force->buoyancy.water_height + force->buoyancy.max_depth) {
					if (depth < force->buoyancy.water_height - force->buoyancy.max_depth) {
						force_to_apply.y = force->buoyancy.liquid_density * force->buoyancy.volume;
					}
					else {
						force_to_apply.y = force->buoyancy.liquid_density * force->buoyancy.volume * (depth - force->buoyancy.max_depth - force->buoyancy.water_height) / 2.f * force->buoyancy.max_depth;
					}
				}
			} break;

			// ------------------------------------------------------------------------------------

			default: {
				zt_assert(false);
			}
		}

		force->rigid_body->force_accum += force_to_apply;
		force->rigid_body->torque_accum += point_body.cross(force_to_apply);

#		undef getAnchor
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztConnector zt_connectorMakeCable(r32 max_length, r32 restitution)
{
	ZT_PROFILE_PHYSICS("zt_connectorMakeCable");
	ztConnector connector;
	connector.type = ztConnectorType_Cable;
	connector.cable.max_length = max_length;
	connector.cable.restitution = restitution;
	return connector;
}

// ================================================================================================================================================================================================

ztConnector zt_connectorMakeRod(r32 length)
{
	ZT_PROFILE_PHYSICS("zt_connectorMakeRod");
	ztConnector connector;
	connector.type = ztConnectorType_Rod;
	connector.rod.length = length;
	return connector;
}

// ================================================================================================================================================================================================

int zt_connectorCalculateCollisions(ztConnector *connectors, int connectors_count, ztRigidBodyCollision *collisions, int collisions_size)
{
	ZT_PROFILE_PHYSICS("zt_connectorCalculateCollisions");
	zt_assert(collisions != nullptr && collisions_size > 0);

	int collisions_idx = 0;

	zt_fiz(connectors_count) {
		ztConnector *connector = &connectors[i];

		ztVec3 relative_pos = connector->rigid_bodies[0]->model->transform.position - connector->rigid_bodies[1]->model->transform.position;
		r32 length = relative_pos.length();

		switch(connector->type)
		{
			case ztConnectorType_Cable: {
				if (length > connector->cable.max_length) {
					ztRigidBodyCollision *collision = &collisions[collisions_idx++];
					collision->rigid_bodies[0] = connector->rigid_bodies[0];
					collision->rigid_bodies[1] = connector->rigid_bodies[1];

					collision->contact_normal = connector->rigid_bodies[1]->model->transform.position - connector->rigid_bodies[1]->model->transform.position;
					collision->contact_normal.normalize();
					collision->penetration = length - connector->cable.max_length;
					collision->restitution = connector->cable.restitution;

					if (collisions_idx >= collisions_size) return collisions_idx;
				}
			} break;

			case ztConnectorType_Rod: {
				if (!zt_real32Eq(length, connector->rod.length)) {
					ztRigidBodyCollision *collision = &collisions[collisions_idx++];
					collision->rigid_bodies[0] = connector->rigid_bodies[0];
					collision->rigid_bodies[1] = connector->rigid_bodies[1];

					collision->contact_normal = connector->rigid_bodies[1]->model->transform.position - connector->rigid_bodies[1]->model->transform.position;
					collision->contact_normal.normalize();

					if (length < connector->rod.length) {
						collision->contact_normal *= -1;
						collision->penetration = connector->rod.length - length;
					}
					else {
						collision->penetration = length - connector->rod.length;
					}

					collision->restitution = 0;

					if (collisions_idx >= collisions_size) return collisions_idx;
				}
			} break;
		}
	}

	return collisions_idx;
}

// ================================================================================================================================================================================================

int zt_collisionBrute(ztRigidBody **rigid_bodies, int rigid_bodies_count, ztRigidBodyCollision *collisions, int collisions_size)
{
	ZT_PROFILE_PHYSICS("zt_collisionBrute");
	int col_idx = 0;
	ztVec3 contact_normal = ztVec3::min;
	ztVec3 contact_point = ztVec3::min;

	r32 dummy_penetration;
	ztVec3 dummy_contact_normal;
	ztVec3 dummy_contact_point;

	zt_fiz(rigid_bodies_count - 1) {
		for(int j = i + 1; j < rigid_bodies_count; ++j) {

			if (!(rigid_bodies[i]->collides_with_layers & zt_bit(rigid_bodies[j]->collision_layer)) && !(rigid_bodies[j]->collides_with_layers & zt_bit(rigid_bodies[i]->collision_layer))) {
				continue;
			}
			bool body_one_needs_test = rigid_bodies[i]->inverse_mass != 0 && !zt_bitIsSet(rigid_bodies[i]->flags, ztRigidBodyFlags_Sleeping) && !zt_bitIsSet(rigid_bodies[i]->flags, ztRigidBodyFlags_Static);
			bool body_two_needs_test = rigid_bodies[j]->inverse_mass != 0 && !zt_bitIsSet(rigid_bodies[j]->flags, ztRigidBodyFlags_Sleeping) && !zt_bitIsSet(rigid_bodies[j]->flags, ztRigidBodyFlags_Static);

			if(!body_one_needs_test && !body_two_needs_test) {
				continue;
			}

			if (zt_collisionGeometryIntersecting(&rigid_bodies[i]->cg_bounding, &rigid_bodies[i]->model->transform, nullptr, &rigid_bodies[j]->cg_bounding, &rigid_bodies[j]->model->transform, nullptr, &dummy_penetration, &dummy_contact_normal, &dummy_contact_point)) {
				// bounding volumes are colliding, now check actual collision geometry

				// TODO: if no details exist, treat bounding as detail
				zt_fxz(rigid_bodies[i]->cg_details_count) {
					zt_fyz(rigid_bodies[j]->cg_details_count) {
						r32 penetration = 0;
						if (zt_collisionGeometryIntersecting(&rigid_bodies[i]->cg_details[x], &rigid_bodies[i]->model->transform, nullptr, &rigid_bodies[j]->cg_details[y], &rigid_bodies[j]->model->transform, nullptr, &penetration, &contact_normal, &contact_point)) {
							rigid_bodies[i]->flags |= ztRigidBodyFlags_HadCollision;
							rigid_bodies[j]->flags |= ztRigidBodyFlags_HadCollision;

							if (col_idx < collisions_size) {
								collisions[col_idx].rigid_bodies[0] = rigid_bodies[i];
								collisions[col_idx].rigid_bodies[1] = rigid_bodies[j];
								collisions[col_idx].restitution     = .1f;
								collisions[col_idx].penetration     = penetration;
								collisions[col_idx].contact_normal  = contact_normal == ztVec3::min ? rigid_bodies[i]->model->transform.position - rigid_bodies[j]->model->transform.position : contact_normal;
								collisions[col_idx].contact_normal.normalize();
								collisions[col_idx].contact_point   = contact_point;
								col_idx += 1;

								contact_normal = ztVec3::min;
								contact_point = ztVec3::min;
							}
							else return col_idx;
							goto exit_detail_loop;
						}
					}
				}

			exit_detail_loop:
				;
			}
		}
	}

	return col_idx;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztPhysics *zt_physicsMake(ztMemoryArena *arena, int max_rigid_bodies, int max_static_bodies, int max_moving_bodies, int max_forces, int max_connectors)
{
	ZT_PROFILE_PHYSICS("zt_physicsMake");
	ztPhysics *physics = zt_mallocStructArena(ztPhysics, arena);

	physics->arena = arena;

	physics->rigid_bodies_count = 0;
	physics->rigid_bodies_size  = max_rigid_bodies;
	physics->rigid_bodies       = zt_mallocStructArrayArena(ztRigidBody*, physics->rigid_bodies_size, arena);

	physics->static_bodies_count = 0;
	physics->static_bodies_size  = max_static_bodies;
	physics->static_bodies       = zt_mallocStructArrayArena(ztStaticBody*, physics->static_bodies_size, arena);

	physics->moving_bodies_count = 0;
	physics->moving_bodies_size  = max_moving_bodies;
	physics->moving_bodies       = zt_mallocStructArrayArena(ztMovingBody*, physics->moving_bodies_size, arena);

	physics->forces_count       = 0;
	physics->forces_size        = max_forces;
	physics->forces             = zt_mallocStructArrayArena(ztForce*, physics->forces_size, arena);

	physics->connectors_count   = 0;
	physics->connectors_size    = max_connectors;
	physics->connectors         = zt_mallocStructArrayArena(ztConnector*, physics->connectors_size, arena);

	physics->collisions_size    = 1024;
	physics->collisions         = zt_mallocStructArrayArena(ztRigidBodyCollision, physics->collisions_size, arena);

	physics->moving_body_collisions_count = 0;
	physics->moving_body_collisions_size  = 1024;
	physics->moving_body_collisions       = zt_mallocStructArrayArena(ztMovingBodyCollision, physics->moving_body_collisions_size, arena);

	if (physics->rigid_bodies == nullptr || physics->forces == nullptr || physics->connectors == nullptr || physics->collisions == nullptr || physics->moving_body_collisions == nullptr) {
		zt_physicsFree(physics);
		return nullptr;
	}

	physics->extents_min = ztVec3::min;
	physics->extents_max = ztVec3::max;
	physics->extents_restitution = .5f;

	return physics;
}

// ================================================================================================================================================================================================

void zt_physicsFree(ztPhysics *physics)
{
	ZT_PROFILE_PHYSICS("zt_physicsFree");
	if (physics == nullptr) {
		return;
	}

	if (physics->rigid_bodies          ) zt_freeArena(physics->rigid_bodies, physics->arena);
	if (physics->static_bodies         ) zt_freeArena(physics->static_bodies, physics->arena);
	if (physics->moving_bodies         ) zt_freeArena(physics->moving_bodies, physics->arena);
	if (physics->forces                ) zt_freeArena(physics->forces, physics->arena);
	if (physics->connectors            ) zt_freeArena(physics->connectors, physics->arena);
	if (physics->collisions            ) zt_freeArena(physics->collisions, physics->arena);
	if (physics->moving_body_collisions) zt_freeArena(physics->moving_body_collisions, physics->arena);

	zt_freeArena(physics, physics->arena);
}

// ================================================================================================================================================================================================

int zt_physicsAddRigidBody(ztPhysics *physics, ztRigidBody *rigid_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsAddRigidBody");
	zt_returnValOnNull(physics, -1);
	zt_returnValOnNull(rigid_body, -1);

	zt_assertReturnValOnFail(physics->rigid_bodies_count < physics->rigid_bodies_size, -1);

	physics->rigid_bodies[physics->rigid_bodies_count] = rigid_body;

	rigid_body->motion = ztReal32Min;

	ztVec3 size = zt_vec3(.5f, .5f, .5f);

	zt_rigidBody_makeBlockInertiaTensor(&rigid_body->inverse_inertia_tensor, size, 1.f / zt_max(1.f, rigid_body->inverse_mass));
	zt_rigidBody_transformInertiaTensor(&rigid_body->inverse_inertia_tensor_world, &rigid_body->inverse_inertia_tensor, &rigid_body->model->calculated_mat);

	return physics->rigid_bodies_count++;
}

// ================================================================================================================================================================================================

int zt_physicsAddStaticBody(ztPhysics *physics, ztStaticBody *static_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsAddStaticBody");
	zt_returnValOnNull(physics, -1);
	zt_returnValOnNull(static_body, -1);

	zt_assertReturnValOnFail(physics->static_bodies_count < physics->static_bodies_size, -1);

	physics->static_bodies[physics->static_bodies_count] = static_body;

	return physics->static_bodies_count++;
}

// ================================================================================================================================================================================================

int zt_physicsAddMovingBody(ztPhysics *physics, ztMovingBody *moving_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsAddMovingBody");
	zt_returnValOnNull(physics, -1);
	zt_returnValOnNull(moving_body, -1);

	zt_assertReturnValOnFail(physics->moving_bodies_count < physics->moving_bodies_size, -1);

	physics->moving_bodies[physics->moving_bodies_count] = moving_body;

	moving_body->flags |= ztMovingBodyFlags_NeedsMatrixCalc;

	return physics->moving_bodies_count++;
}

// ================================================================================================================================================================================================

int zt_physicsAddForce(ztPhysics *physics, ztForce *force)
{
	ZT_PROFILE_PHYSICS("zt_physicsAddForce");
	zt_returnValOnNull(physics, -1);
	zt_returnValOnNull(force, -1);

	zt_assertReturnValOnFail(physics->forces_count < physics->forces_size, -1);
	physics->forces[physics->forces_count] = force;
	return physics->forces_count++;
}

// ================================================================================================================================================================================================

int zt_physicsAddConnector(ztPhysics *physics, ztConnector *connector)
{
	ZT_PROFILE_PHYSICS("zt_physicsAddConnector");
	zt_returnValOnNull(physics, -1);
	zt_returnValOnNull(connector, -1);

	zt_assertReturnValOnFail(physics->connectors_count < physics->connectors_size, -1);
	physics->connectors[physics->connectors_count] = connector;
	return physics->connectors_count++;
}

// ================================================================================================================================================================================================

bool zt_physicsRemoveRigidBody(ztPhysics *physics, ztRigidBody *rigid_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsRemoveRigidBody");
	zt_returnValOnNull(physics, false);
	zt_returnValOnNull(rigid_body, false);

	zt_fiz(physics->rigid_bodies_count) {
		if (physics->rigid_bodies[i] == rigid_body) {
			for (int j = i; j < physics->rigid_bodies_count - 1; ++j) {
				physics->rigid_bodies[j] = physics->rigid_bodies[j + 1];
			}
			physics->rigid_bodies_count -= 1;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_physicsRemoveStaticBody(ztPhysics *physics, ztStaticBody *static_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsRemoveStaticBody");
	zt_returnValOnNull(physics, false);
	zt_returnValOnNull(static_body, false);

	zt_fiz(physics->static_bodies_count) {
		if (physics->static_bodies[i] == static_body) {
			for (int j = i; j < physics->static_bodies_count - 1; ++j) {
				physics->static_bodies[j] = physics->static_bodies[j + 1];
			}
			physics->static_bodies_count -= 1;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_physicsRemoveMovingBody(ztPhysics *physics, ztMovingBody *moving_body)
{
	ZT_PROFILE_PHYSICS("zt_physicsRemoveMovingBody");
	zt_returnValOnNull(physics, false);
	zt_returnValOnNull(moving_body, false);

	zt_fiz(physics->moving_bodies_count) {
		if (physics->moving_bodies[i] == moving_body) {
			for (int j = i; j < physics->moving_bodies_count - 1; ++j) {
				physics->moving_bodies[j] = physics->moving_bodies[j + 1];
			}
			physics->moving_bodies_count -= 1;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_physicsRemoveForce(ztPhysics *physics, ztForce *force)
{
	ZT_PROFILE_PHYSICS("zt_physicsRemoveForce");
	zt_returnValOnNull(physics, false);
	zt_returnValOnNull(force, false);

	zt_fiz(physics->forces_count) {
		if (physics->forces[i] == force) {
			for (int j = i; j < physics->forces_count - 1; ++j) {
				physics->forces[j] = physics->forces[j + 1];
			}
			physics->forces_count -= 1;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_physicsRemoveConnector(ztPhysics *physics, ztConnector *connector)
{
	ZT_PROFILE_PHYSICS("zt_physicsRemoveConnector");
	zt_returnValOnNull(physics, false);
	zt_returnValOnNull(connector, false);


	zt_fiz(physics->connectors_count) {
		if (physics->connectors[i] == connector) {
			for (int j = i; j < physics->connectors_count - 1; ++j) {
				physics->connectors[j] = physics->connectors[j + 1];
			}
			physics->connectors_count -= 1;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

void zt_physicsUpdate(ztPhysics *physics, r32 dt)
{
	ZT_PROFILE_PHYSICS("zt_physicsUpdate");

	zt_debugDisplayRemoveGuidItems(ZT_COLLISION_DEBUG_GUID);

	zt_rigidBodiesUpdatePreCollision(physics->rigid_bodies, physics->rigid_bodies_count, dt);

	int collisions_iterations = 0;

#	define zt_checkCollisionsCount \
		{ \
			if (collisions_count >= physics->collisions_size) { \
				zt_arrayResizeArenaNoCopy(physics->collisions, ztRigidBodyCollision, physics->collisions_size * 2, physics->arena); \
				if (physics->collisions == nullptr) { \
					zt_logCritical("unable to resize physics collision cache"); \
					physics->collisions = zt_mallocStructArrayArena(ztRigidBodyCollision, physics->collisions_size, physics->arena); \
					break; \
				} \
				else { \
					zt_logDebug("physics resized collision cache from %d to %d", physics->collisions_size, physics->collisions_size * 2); \
					physics->collisions_size *= 2; \
				} \
			} \
		}

	while (collisions_iterations++ < 1) {//32) {
		int collisions_count = 0;

		if (physics->extents_min != ztVec3::min) {
			zt_fjz(3) {
				if (physics->extents_min.values[j] == ztReal32Min) {
					continue;
				}

				zt_fiz(physics->rigid_bodies_count) {
					if (physics->rigid_bodies[i]->model->transform.position.values[j] < physics->extents_min.values[j]) {
						zt_checkCollisionsCount;
						ztRigidBodyCollision * collision = &physics->collisions[collisions_count++];

						collision->rigid_bodies[0] = physics->rigid_bodies[i];
						collision->rigid_bodies[1] = nullptr;
						collision->contact_normal = zt_vec3(j == 0 ? 1.f : 0.f, j == 1 ? 1.f : 0.f, j == 2 ? 1.f : 0.f);
						collision->penetration = physics->rigid_bodies[i]->model->transform.position.values[j] - physics->extents_min.values[j];
						collision->restitution = physics->extents_restitution;
					}
				}
			}
		}

		if (physics->extents_max != ztVec3::max) {
			zt_fjz(3) {
				if (physics->extents_max.values[j] == ztReal32Max) {
					continue;
				}

				zt_fiz(physics->rigid_bodies_count) {
					if (physics->rigid_bodies[i]->model->transform.position.values[j] > physics->extents_max.values[j]) {
						zt_checkCollisionsCount;
						ztRigidBodyCollision * collision = &physics->collisions[collisions_count++];

						collision->rigid_bodies[0] = physics->rigid_bodies[i];
						collision->rigid_bodies[1] = nullptr;
						collision->contact_normal = zt_vec3(j == 0 ? -1.f : 0.f, j == 1 ? -1.f : 0.f, j == 2 ? -1.f : 0.f);
						collision->penetration = physics->extents_max.values[j] - physics->rigid_bodies[i]->model->transform.position.values[j];
						collision->restitution = physics->extents_restitution;
					}
				}
			}
		}

		collisions_count += zt_collisionBrute(physics->rigid_bodies, physics->rigid_bodies_count, physics->collisions + collisions_count, physics->collisions_size - collisions_count);

		// todo: rigid body with static bodies
		// todo: rigid body with moving bodies

#	undef zt_checkCollisionsCount

		if (collisions_count > 0) {
			zt_rigidBodyCollisionsResolve(physics->collisions, collisions_count, dt, zt_convertToi32Floor(collisions_count * 1.25f));
		}

		zt_rigidBodiesUpdatePostCollision(physics->rigid_bodies, physics->rigid_bodies_count, dt);

		if (collisions_count == 0) break;
	}

	physics->moving_body_collisions_count = 0;

	zt_fvz(midx, physics->moving_bodies_count) {
		ztMovingBody *moving_body = physics->moving_bodies[midx];

		if (zt_bitIsSet(moving_body->flags, ztMovingBodyFlags_NeedsMatrixCalc)) {
			zt_bitRemove(moving_body->flags, ztMovingBodyFlags_NeedsMatrixCalc);
			if (moving_body->model) {
				moving_body->transform = &moving_body->model->transform;
			}
			moving_body->transform_prev = *moving_body->transform;
		}

		if (moving_body->transform->position != moving_body->transform_prev.position) {
			moving_body->flags |= ztMovingBodyFlags_NeedsCollisionCheck;
		}
		else {
			zt_bitRemove(moving_body->flags, ztMovingBodyFlags_NeedsCollisionCheck);
		}

		moving_body->collisions = nullptr;
	}

	struct local
	{
		static void getMovingBodyAABB(ztMovingBody *moving_body, ztVec3 *aabb_center, ztVec3 *aabb_extents)
		{
			ztVec3 min = ztVec3::max;
			ztVec3 max = ztVec3::min;

			zt_fize(min.values) min.values[i] = zt_min(moving_body->transform->position.values[i], moving_body->transform_prev.position.values[i]);
			zt_fize(max.values) max.values[i] = zt_max(moving_body->transform->position.values[i], moving_body->transform_prev.position.values[i]);

			switch (moving_body->cg_bounding.type)
			{
				case ztCollisionGeometryType_AxisAlignedBox: {
					min -= moving_body->cg_bounding.aabb_extents * .5f * moving_body->transform->scale;
					max += moving_body->cg_bounding.aabb_extents * .5f * moving_body->transform->scale;
				}; break;

				case ztCollisionGeometryType_OrientedBox: {
					min -= moving_body->cg_bounding.obb_extents * .5f * moving_body->transform->scale;
					max += moving_body->cg_bounding.obb_extents * .5f * moving_body->transform->scale;
				}; break;

				case ztCollisionGeometryType_Sphere: {
					min -= ztVec3::one * moving_body->cg_bounding.sphere_radius * .5f * moving_body->transform->scale.x;
					max += ztVec3::one * moving_body->cg_bounding.sphere_radius * .5f * moving_body->transform->scale.x;
				}; break;

				case ztCollisionGeometryType_Capsule: {
				}; break;

				case ztCollisionGeometryType_Triangles: {
				}; break;
			}

			*aabb_center = (min + max) * .5f;
			*aabb_extents = (max - min);
		}
	};

	static const r32 iteration_amt = zt_inchesToUnits(1.f);

	// do moving vs moving before moving vs static
	// it's more important that objects do not pass through static environment than avoiding penetration with other moving objects
	collisions_iterations = 0;
	while (collisions_iterations++ < 1) {
		int collisions_count = 0;

		zt_fvz(midx_1, physics->moving_bodies_count) {
			ztMovingBody *moving_body_1 = physics->moving_bodies[midx_1];

			if (zt_bitIsSet(moving_body_1->flags, ztMovingBodyFlags_NeedsCollisionCheck)) {
				ztVec3 velocity_1 = moving_body_1->transform->position - moving_body_1->transform_prev.position;
				r32 velocity_len_1 = velocity_1.length();

				ztVec3 aabb_center_1, aabb_extents_1;
				local::getMovingBodyAABB(moving_body_1, &aabb_center_1, &aabb_extents_1);

				ztTransform transform_1 = moving_body_1->transform_prev;

				for (int midx_2 = midx_1 + 1; midx_2 < physics->moving_bodies_count; ++midx_2) {
					ztMovingBody *moving_body_2 = physics->moving_bodies[midx_2];

					ztVec3 aabb_center_2, aabb_extents_2;
					local::getMovingBodyAABB(moving_body_2, &aabb_center_2, &aabb_extents_2);

					if (zt_collisionAABBInAABB(aabb_center_1, aabb_extents_1, aabb_center_2, aabb_extents_2)) {
						ztVec3 velocity_2 = moving_body_2->transform->position - moving_body_2->transform_prev.position;
						r32 velocity_len_2 = velocity_2.length();

						int iterations = zt_max(1, zt_convertToi32Ceil(zt_max(velocity_len_1, velocity_len_2) / iteration_amt));

						ztVec3 velocity_per_1 = velocity_1 * (1.f / iterations);
						ztVec3 velocity_per_2 = velocity_2 * (1.f / iterations);
						r32 percent_of_move_1 = velocity_len_2 / (velocity_len_1 + velocity_len_2);
						r32 percent_of_move_2 = velocity_len_1 / (velocity_len_1 + velocity_len_2);

						ztTransform transform_2 = zt_transformMake(moving_body_2->transform_prev.position, moving_body_2->transform_prev.rotation, moving_body_2->transform_prev.scale);

						ztVec3 contact_normals[32];
						ztVec3 contact_points[32];
						r32    contact_distances[32];

						zt_fiz(iterations) {
							transform_1.position += velocity_per_1;
							transform_2.position += velocity_per_2;

							i32 contacts = 0;

							zt_fjz(moving_body_1->cg_details_count) {
								ztCollisionGeometry *cg_1 = &moving_body_1->cg_details[j];

								zt_fkz(moving_body_2->cg_details_count) {
									ztCollisionGeometry *cg_2 = &moving_body_2->cg_details[k];

									r32 penetration = 0;
									ztVec3 contact_normal, contact_point;
									if (zt_collisionGeometryIntersecting(cg_1, &transform_1, nullptr, cg_2, &transform_2, nullptr, &penetration, &contact_normal, &contact_point)) {
										contact_normals[contacts] = contact_normal;
										contact_points[contacts] = contact_point;
										contact_distances[contacts++] = penetration;
									}
								}
							}

							if (contacts > 0) {
								collisions_count += 1;

								while (true) {
									r32 largest_val = ztReal32Min;
									int largest_idx = -1;
									zt_fiz(contacts) {
										if (contact_distances[i] > largest_val) {
											largest_val = contact_distances[i];
											largest_idx = i;
										}
									}

									if (largest_idx == -1) {
										break;
									}

									int idx = largest_idx;

									if(zt_bitIsSet(moving_body_1->flags, ztMovingBodyFlags_TrackCollisions) && moving_body_1->collisions == nullptr) {
										if (physics->moving_body_collisions_count < physics->moving_body_collisions_size) {
											ztMovingBodyCollision *collision = &physics->moving_body_collisions[physics->moving_body_collisions_count++];
											collision->moving_bodies[0] = moving_body_1;
											collision->moving_bodies[1] = moving_body_2;
											collision->penetration = contact_distances[idx];
											collision->contact_point = contact_points[idx];
											collision->contact_normal = contact_normals[idx];
											collision->next = nullptr;
											zt_singleLinkAddToEnd(moving_body_1->collisions, collision);
										}
									}
									if(zt_bitIsSet(moving_body_2->flags, ztMovingBodyFlags_TrackCollisions) && moving_body_2->collisions == nullptr) {
										if (physics->moving_body_collisions_count < physics->moving_body_collisions_size) {
											ztMovingBodyCollision *collision = &physics->moving_body_collisions[physics->moving_body_collisions_count++];
											collision->moving_bodies[0] = moving_body_2;
											collision->moving_bodies[1] = moving_body_1;
											collision->penetration = contact_distances[idx];
											collision->contact_point = contact_points[idx];
											collision->contact_normal = contact_normals[idx] * -1;
											collision->next = nullptr;
											zt_singleLinkAddToEnd(moving_body_2->collisions, collision);
										}
									}

									if (zt_bitIsSet(moving_body_1->flags, ztMovingBodyFlags_AllowPenetration) || zt_bitIsSet(moving_body_2->flags, ztMovingBodyFlags_AllowPenetration)) {
										break;
									}

									struct Geometries
									{
										static bool colliding(ztMovingBody *moving_body_1, ztTransform *transform_1, ztMovingBody *moving_body_2, ztTransform *transform_2)
										{
											zt_fjz(moving_body_1->cg_details_count) {
												ztCollisionGeometry *cg_1 = &moving_body_1->cg_details[j];
												zt_fkz(moving_body_2->cg_details_count) {
													ztCollisionGeometry *cg_2 = &moving_body_2->cg_details[k];

													r32 penetration;
													ztVec3 contact_normal, contact_point;
													if (zt_collisionGeometryIntersecting(cg_1, transform_1, nullptr, cg_2, transform_2, nullptr, &penetration, &contact_normal, &contact_point)) {
														return true;
													}
												}
											}

											return false;
										}
									};

									if (Geometries::colliding(moving_body_1, &transform_1, moving_body_2, &transform_2)) {
										bool backward = true;
										r32 dist = iteration_amt;
										int splits = 0;
										zt_fvz(splits, 32) {
											dist *= .5f;

											ztVec3 to_move = contact_normals[idx] * dist * (backward ? 1.f : -1.f);
											transform_1.position += percent_of_move_1 * to_move;
											transform_2.position -= percent_of_move_2 * to_move;

											backward = Geometries::colliding(moving_body_1, &transform_1, moving_body_2, &transform_2);

											if (splits >= 8 && !backward) break;
										}

										velocity_per_1 *= ztVec3::one - zt_vec3(zt_abs(contact_normals[idx].x), zt_abs(contact_normals[idx].y), zt_abs(contact_normals[idx].z));
										velocity_per_2 *= ztVec3::one - zt_vec3(zt_abs(contact_normals[idx].x), zt_abs(contact_normals[idx].y), zt_abs(contact_normals[idx].z));
									}

									contact_distances[idx] = ztReal32Min;
								}
							}
						}
						moving_body_1->transform_prev.position = moving_body_1->transform->position;
						moving_body_2->transform_prev.position = moving_body_2->transform->position;

						moving_body_1->transform->position = transform_1.position;
						moving_body_2->transform->position = transform_2.position;
					}
				}
			}
		}
	}


	int dbg_static_body_aabb_tests = 0;
	int dbg_cg_details_tests = 0;
	int dbg_total_contacts = 0;
	int dbg_triangle_colliding_tests = 0;

	collisions_iterations = 0;
	while (collisions_iterations++ < 1) {
		int collisions_count = 0;

		zt_fvz(midx, physics->moving_bodies_count) {
			ztMovingBody *moving_body = physics->moving_bodies[midx];

			if (zt_bitIsSet(moving_body->flags, ztMovingBodyFlags_NeedsCollisionCheck)) {
				ztVec3 velocity = moving_body->transform->position - moving_body->transform_prev.position;

				ztVec3 contact_points[32];
				ztVec3 contact_normals[32];
				i32    contact_triangles[32];
				r32    contact_distances[32];

				r32 velocity_len = velocity.length();

				ztVec3 center, extents;
				local::getMovingBodyAABB(moving_body, &center, &extents);

				zt_fvz(sidx, physics->static_bodies_count) {
					ztStaticBody *static_body = physics->static_bodies[sidx];

					dbg_static_body_aabb_tests += 1;
					if (zt_staticBodyHasCollisionsAABB(static_body, center, extents)) {
						int iterations = zt_max(12, zt_convertToi32Ceil(velocity_len / iteration_amt));
						//int iterations = zt_max(1, zt_min(12, zt_convertToi32Ceil(velocity_len / iteration_amt)));

						ztVec3 velocity_per = velocity * (1.f / iterations);
						ztVec3 current_pos = moving_body->transform_prev.position;

						zt_fiz(iterations) {
							current_pos += velocity_per;

							i32 contacts = 0;

							zt_fjz(moving_body->cg_details_count) {
								dbg_cg_details_tests += 1;
								ztCollisionGeometry *cg = &moving_body->cg_details[j];
								switch(cg->type)
								{
									case ztCollisionGeometryType_AxisAlignedBox: {
										contacts += zt_staticBodyHasCollisionsAABB(static_body, current_pos + cg->aabb_center * moving_body->transform->scale, cg->aabb_extents * moving_body->transform->scale, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_normals) - contacts);
									}; break;

									case ztCollisionGeometryType_OrientedBox: {
										ztQuat rot = moving_body->transform->rotation * cg->obb_rotation;
										contacts += zt_staticBodyHasCollisionsOBB(static_body, current_pos + cg->obb_center * moving_body->transform->scale, cg->obb_extents * moving_body->transform->scale, rot, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_normals) - contacts);
									}; break;

									case ztCollisionGeometryType_Sphere: {
										contacts += zt_staticBodyHasCollisionsSphere(static_body, current_pos + cg->sphere_center * moving_body->transform->scale, cg->sphere_radius * moving_body->transform->scale.x, contact_points + contacts, contact_normals + contacts, contact_triangles + contacts, zt_elementsOf(contact_normals) - contacts);
									}; break;

									case ztCollisionGeometryType_Capsule: {
									}; break;

									case ztCollisionGeometryType_Triangles: {
									}; break;
								}
							}

							dbg_total_contacts += contacts;

							if (contacts > 0) {
								collisions_count += 1;
								zt_fiz(contacts) {
									contact_distances[i] = contact_points[i].distance(current_pos);

									ztTriangle *tri = &static_body->triangles[contact_triangles[i]];
									ztVec3 center = (tri->points[0] + tri->points[1] + tri->points[2]) * .3333f;

									r32 dot = velocity.dot(contact_normals[i]);
									if (dot > 0.f) {
										contact_distances[i] = ztReal32Max;
									}
								}

								int movement_iterations = 0;
								while (++movement_iterations) {
									r32 largest_val = ztReal32Max;
									int largest_idx = -1;
									zt_fiz(contacts) {
										if (contact_distances[i] < largest_val) {
											largest_val = contact_distances[i];
											largest_idx = i;
										}
									}

									if (largest_idx == -1) {
										break;
									}

									int idx = largest_idx;

									if (zt_bitIsSet(moving_body->flags, ztMovingBodyFlags_TrackCollisions) && movement_iterations == 1) {
										if (physics->moving_body_collisions_count < physics->moving_body_collisions_size) {
											ztMovingBodyCollision *collision = &physics->moving_body_collisions[physics->moving_body_collisions_count++];
											collision->moving_bodies[0] = moving_body;
											collision->moving_bodies[1] = nullptr;
											collision->penetration = contact_distances[idx];
											collision->contact_point = contact_points[idx];
											collision->contact_normal = contact_normals[idx];
											collision->next = nullptr;
											zt_singleLinkAddToEnd(moving_body->collisions, collision);
										}
									}

									if (zt_bitIsSet(moving_body->flags, ztMovingBodyFlags_AllowPenetration)) {
										break;
									}

									ztTriangle *tri = &static_body->triangles[contact_triangles[idx]];


									struct Triangle
									{
										static bool colliding(ztTriangle *tri, ztMovingBody *moving_body, const ztVec3 &current_pos)
										{
											bool collision = false;

											zt_fjz(moving_body->cg_details_count) {
												ztCollisionGeometry *cg = &moving_body->cg_details[j];
												switch(cg->type)
												{
													case ztCollisionGeometryType_AxisAlignedBox: {
														collision = collision || zt_collisionTriangleInAABB(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->aabb_center * moving_body->transform->scale, cg->aabb_extents * moving_body->transform->scale);
													}; break;

													case ztCollisionGeometryType_OrientedBox: {
														ztQuat rot = moving_body->transform->rotation * cg->obb_rotation;
														collision = collision || zt_collisionTriangleInOBB(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->obb_center * moving_body->transform->scale, cg->obb_extents * moving_body->transform->scale, rot);
													}; break;

													case ztCollisionGeometryType_Sphere: {
														collision = collision || zt_collisionTriangleInSphere(tri->points[0], tri->points[1], tri->points[2], current_pos + cg->sphere_center * moving_body->transform->scale, cg->sphere_radius * moving_body->transform->scale.x);
													}; break;

													case ztCollisionGeometryType_Capsule: {
													}; break;

													case ztCollisionGeometryType_Triangles: {
													}; break;
												}
											}

											return collision;
										}
									};

									dbg_triangle_colliding_tests += 1;
									if (Triangle::colliding(tri, moving_body, current_pos)) {
										bool backward = true;
										r32 dist = iteration_amt;
										zt_fvz(splits, 32) {
											dist *= .5f;

											ztVec3 to_move = contact_normals[idx] * dist * (backward ? 1.f : -1.f);
											current_pos += to_move;

											dbg_triangle_colliding_tests += 1;
											backward = Triangle::colliding(tri, moving_body, current_pos);

											if (splits >= 8 && !backward) break;
										}

										velocity_per *= ztVec3::one - zt_vec3(zt_abs(contact_normals[idx].x), zt_abs(contact_normals[idx].y), zt_abs(contact_normals[idx].z));
									}

									contact_distances[idx] = ztReal32Max;
								}
							}
						}
						moving_body->transform->position = current_pos;
					}
				}

			}
			moving_body->transform_prev.position = moving_body->transform->position;
		}
	}

	//zt_strMakePrintf(debug_info, 512, "dbg_static_body_aabb_tests: %d\ndbg_cg_details_tests: %d\ndbg_total_contacts: %d\ndbg_triangle_colliding_tests: %d", dbg_static_body_aabb_tests, dbg_cg_details_tests, dbg_total_contacts, dbg_triangle_colliding_tests);
	//zt_debugDisplayGuiText(debug_info, zt_vec2(-5, -5), ztColor_White);
}

// ================================================================================================================================================================================================

void zt_physicsRenderDebug(ztPhysics *physics, ztDrawList *draw_list)
{
	zt_drawListPushShader(draw_list, zt_shaderGetDefault(ztShaderDefault_Unlit));
	zt_drawListPushTexture(draw_list, ztTextureDefault);

	zt_drawListPushColor(draw_list, ztColor_Yellow);
	zt_fiz(physics->rigid_bodies_count) {
		zt_rigidBodyRenderDebug(physics->rigid_bodies[i], draw_list);
	}
	zt_drawListPopColor(draw_list);

	zt_drawListPopTexture(draw_list);
	zt_drawListPopShader(draw_list);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

bool zt_collisionPointInRect(const ztVec2 &point, const ztVec2 &rect_pos, const ztVec2 &rect_size)
{
	return zt_collisionPointInRect(point.x, point.y, rect_pos.x, rect_pos.y, rect_size.x, rect_size.y);
}

// ================================================================================================================================================================================================

bool zt_collisionPointInRect(r32 p_x, r32 p_y, r32 rect_x, r32 rect_y, r32 rect_w, r32 rect_h)
{
	return zt_collisionPointInRectLL(p_x, p_y, rect_x - rect_w / 2.f, rect_y - rect_h / 2.f, rect_w, rect_h);
}

// ================================================================================================================================================================================================

bool zt_collisionPointInRectLL(const ztVec2 &point, const ztVec2 &rect_pos, const ztVec2 &rect_size)
{
	return zt_collisionPointInRectLL(point.x, point.y, rect_pos.x, rect_pos.y, rect_size.x, rect_size.y);
}

// ================================================================================================================================================================================================

bool zt_collisionPointInRectLL(r32 p_x, r32 p_y, r32 rect_x, r32 rect_y, r32 rect_w, r32 rect_h)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInRectLL");
	return !(p_x < rect_x || p_y < rect_y || p_x > rect_x + rect_w || p_y > rect_y + rect_h);
}

// ================================================================================================================================================================================================

bool zt_collisionPointInCircle(const ztVec2 &point, const ztVec2 &circle_pos, r32 radius)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInCircle");
	return zt_abs(point.distance(circle_pos)) <= radius;
}

// ================================================================================================================================================================================================

bool zt_collisionPointInSphere(const ztVec3 &point, const ztVec3 &sphere_pos, r32 radius)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInSphere");
	return zt_abs(point.distance(sphere_pos)) <= radius;
}

// ================================================================================================================================================================================================

bool zt_collisionPointInTriangle(const ztVec3 &point, const ztVec3 &t0, const ztVec3 &t1, const ztVec3 &t2)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInTriangle");
	ztVec3 a = t0 - point;
	ztVec3 b = t1 - point;
	ztVec3 c = t2 - point;

	ztVec3 u = b.cross(c);
	ztVec3 v = c.cross(a);

	if (u.dot(v) < 0.f) {
		return false;
	}

	ztVec3 w = a.cross(b);

	if (u.dot(w) < 0.f) {
		return false;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInPlane(const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &plane_coord, const ztVec3 &plane_normal, ztVec3 *intersection_point, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineInPlane");
	ztVec3 line_dir = (line_end - line_beg);

	r32 dot = plane_normal.dot(plane_coord);
	if (plane_normal.dot(line_dir) == 0) {
		// line is parallel
		return false;
	}

	r32 x = (dot - plane_normal.dot(line_beg)) / plane_normal.dot(line_dir);
	if (x < 0 - ztReal32Epsilon || x > 1 + ztReal32Epsilon) {
		return false;
	}

	if (intersection_point) {
		*intersection_point = line_beg + (line_dir * zt_vec3(x, x, x));
	}
	if (intersection_time) {
		*intersection_time = x;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInPlane(const ztVec3 &line_beg, const ztVec3 &line_end, const ztPlane& plane, ztVec3 *intersection_point, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineInPlane");
	ztVec3 line_dir = (line_end - line_beg);

	r32 dot = plane.normal.dot(line_dir);
	if (dot == 0) {
		return false;
	}

	r32 t = (plane.distance - plane.normal.dot(line_beg)) / dot;

	if (t >= 0.f && t <= 1.f) {
		if (intersection_point) {
			*intersection_point = line_beg + (line_dir * t);
		}
		if (intersection_time) {
			*intersection_time = t;
		}
		return true;
	}

	return false;

	//r32 dot = plane.distance;
	//if (plane.normal.dot(line_dir) == 0) {
	//	// line is parallel
	//	return false;
	//}

	//r32 x = (dot - plane.normal.dot(line_beg)) / plane.normal.dot(line_dir);
	//if (x < 0 - ztReal32Epsilon || x > 1 + ztReal32Epsilon) {
	//	return false;
	//}

	//if (intersection_point) {
	//	*intersection_point = line_beg + (line_dir * zt_vec3(x, x, x));
	//}
	//return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInTriangle(const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &p1, const ztVec2 &p2, const ztVec2 &p3, ztVec2 *intersection_point, r32 *intersection_time)
{
	ztVec3 local_intersection_point;

	bool result = zt_collisionLineInTriangle(zt_vec3(line_beg, 0), zt_vec3(line_end, 0), zt_vec3(p1, 0), zt_vec3(p2, 0), zt_vec3(p3, 0), &local_intersection_point, intersection_time);

	if (result && intersection_point) *intersection_point = local_intersection_point.xy;
	return result;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInTriangle(const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, ztVec3 *intersection_point, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineInTriangle");
	ztVec3 ab = p2 - p1;
	ztVec3 ac = p3 - p1;
	ztVec3 qp = line_beg - line_end;

	ztVec3 n = ab.cross(ac);

	r32 d = qp.dot(n);
	if (d <= 0.f) {
		return false;
	}

	ztVec3 ap = line_beg - p1;
	r32 time = ap.dot(n);
	if (time < 0.f) {
		return false;
	}
	if (time > d) {
		return false;
	}

	ztVec3 ip;
	ztVec3 e = qp.cross(ap);
	ip.y = ac.dot(e);
	if (ip.y < 0.0f || ip.y > d) {
		return false;
	}

	ip.z = -ab.dot(e);
	if (ip.z < 0.f || ip.y + ip.z > d) {
		return false;
	}

	if (intersection_point || intersection_time) {
		r32 ood = 1.f / d;
		time *= ood;
		ip.y *= ood;
		ip.z *= ood;
		ip.x = 1.f - ip.y - ip.z;

		if (intersection_point) *intersection_point = (ip.x * p1) + (ip.y * p2) + (ip.z * p3);
		if (intersection_time) *intersection_time = time;
	}

	return 1;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInCircle(const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &circle_pos, r32 radius)
{
	ztVec3 point = zt_closestPointLineSegmentPoint(zt_vec3(line_beg, 0), zt_vec3(line_end, 0), zt_vec3(circle_pos, 0));
	return point.xy.distance(circle_pos) <= radius;
}

// ================================================================================================================================================================================================

bool zt_collisionLineWithLine(const ztVec2 &line1_beg, const ztVec2 &line1_end, const ztVec2 &line2_beg, const ztVec2 &line2_end, ztVec2 *intersection_point, r32 *intersection_time)
{
	ztVec2 s1 = line1_end - line1_beg;
	ztVec2 s2 = line2_end - line2_beg;

	r32 den = -s2.x * s1.y + s1.x * s2.y;

	r32 s = den == 0 ? -1 : (-s1.y * (line1_beg.x - line2_beg.x) + s1.x * (line1_beg.y - line2_beg.y)) / den;
	r32 t = den == 0 ? -1 : ( s2.x * (line1_beg.y - line2_beg.y) - s2.y * (line1_beg.x - line2_beg.x)) / den;

	if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
		if (intersection_point) *intersection_point = line1_beg + (t * s1);
		if (intersection_time) *intersection_time = t;
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionPointInAABB(const ztVec2 &point, const ztVec2 &aabb_center, const ztVec2 &aabb_extents)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInAABB");
	return point.x >= aabb_center.x - aabb_extents.x / 2.f && point.x <= aabb_center.x + aabb_extents.x / 2.f &&
	       point.y >= aabb_center.y - aabb_extents.y / 2.f && point.y <= aabb_center.y + aabb_extents.y / 2.f;
}

// ================================================================================================================================================================================================

bool zt_collisionPointInAABB(const ztVec3 &point, const ztVec3 &aabb_center, const ztVec3 &aabb_extents)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInAABB");
	return point.x >= aabb_center.x - aabb_extents.x / 2.f && point.x <= aabb_center.x + aabb_extents.x / 2.f &&
		point.y >= aabb_center.y - aabb_extents.y / 2.f && point.y <= aabb_center.y + aabb_extents.y / 2.f &&
		point.z >= aabb_center.z - aabb_extents.z / 2.f && point.z <= aabb_center.z + aabb_extents.z / 2.f;
}

// ================================================================================================================================================================================================

bool zt_collisionRayInAABB(const ztVec3 &point, const ztVec3 &direction, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionRayInAABB");
	r32 tmin = 0;
	r32 tmax = ztReal32Max;

	ztVec3 aabb_min = zt_vec3(aabb_center.x - (aabb_extents.x / 2.f), aabb_center.y - (aabb_extents.y / 2.f), aabb_center.z - (aabb_extents.z / 2.f));
	ztVec3 aabb_max = zt_vec3(aabb_center.x + (aabb_extents.x / 2.f), aabb_center.y + (aabb_extents.y / 2.f), aabb_center.z + (aabb_extents.z / 2.f));

	zt_fiz(3) {
		if (zt_real32Eq(direction.values[i], 0)) {
			// parallel in this axis
			if (point.values[i] < aabb_min.values[i] || point.values[i] > aabb_max.values[i]) {
				return false;
			}
		}
		else {
			r32 t1, t2;
			if (direction.values[i] >= 0) {
				t1 = (aabb_min.values[i] - point.values[i]) / direction.values[i];
				t2 = (aabb_max.values[i] - point.values[i]) / direction.values[i];
			}
			else {
				t1 = (aabb_max.values[i] - point.values[i]) / direction.values[i];
				t2 = (aabb_min.values[i] - point.values[i]) / direction.values[i];
			}

			if (tmin > t2 || t1 > tmax) { return false; }

			if (t1 > tmin) tmin = t1;
			if (t2 < tmax) tmax = t2;

			if (tmin > tmax) {
				return false;
			}
		}
	}

	if (intersection_time) *intersection_time = tmin;

	if (intersection_point) {
		*intersection_point = point + direction * tmin;
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionRayInSphere(const ztVec3 &point, const ztVec3 &direction, const ztVec3 &sphere_center, r32 sphere_radius, r32 *intersection_time, ztVec3 *intersection_point)
{
	ztVec3 m = point - sphere_center;
	r32 b = m.dot(direction);
	r32 c = m.dot(m);

	if (c > 0.f && b > 0.f) {
		return false;
	}

	r32 discr = b * b - c;
	if (discr < 0.f) {
		return false;
	}

	r32 time = -b - zt_sqrt(discr);

	if (time < 0.f) {
		time = 0;
	}

	if (intersection_time) *intersection_time = time;
	if (intersection_point) *intersection_point = point + direction * time;

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineSegmentInAABB(const ztVec2 &line_0, const ztVec2 &line_1, const ztVec2 &aabb_center, const ztVec2 &aabb_extents, r32 *intersection_time, ztVec2 intersection_points[2])
{
	ZT_PROFILE_PHYSICS("zt_collisionLineSegmentInAABB");
	r32 tmin = 0;
	r32 tmax = ztReal32Max;

	ztVec2 direction = line_1 - line_0;
	//direction.normalize();

	ztVec2 aabb_min = zt_vec2(aabb_center.x - (aabb_extents.x / 2.f), aabb_center.y - (aabb_extents.y / 2.f));
	ztVec2 aabb_max = zt_vec2(aabb_center.x + (aabb_extents.x / 2.f), aabb_center.y + (aabb_extents.y / 2.f));

	zt_fiz(2) {
		if (zt_real32Eq(direction.values[i], 0)) {
			// parallel in this axis
			if (line_0.values[i] < aabb_min.values[i] || line_0.values[i] > aabb_max.values[i]) {
				return false;
			}
		}
		else {
			r32 t1, t2;
			if (direction.values[i] >= 0) {
				t1 = (aabb_min.values[i] - line_0.values[i]) / direction.values[i];
				t2 = (aabb_max.values[i] - line_0.values[i]) / direction.values[i];
			}
			else {
				t1 = (aabb_max.values[i] - line_0.values[i]) / direction.values[i];
				t2 = (aabb_min.values[i] - line_0.values[i]) / direction.values[i];
			}

			if (tmin > t2 || t1 > tmax) { return false; }

			if (t1 > tmin) tmin = t1;
			if (t2 < tmax) tmax = t2;

			if (tmin > tmax) {
				return false;
			}
		}
	}

	if (intersection_time) *intersection_time = tmin;

	if (tmin < 0 || tmin > 1) {
		return false;
	}

	if (intersection_points) {
		intersection_points[0] = line_0 + direction * tmin;
		intersection_points[1] = line_0 + direction * zt_min(1, tmax);
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineSegmentInAABB(const ztVec3 &line_0, const ztVec3 &line_1, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time, ztVec3 intersection_points[2], i32 *intersection_axis)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineSegmentInAABB");
	r32 tmin = 0;
	r32 tmax = ztReal32Max;

	ztVec3 direction = line_1 - line_0;
	//direction.normalize();

	ztVec3 aabb_min = zt_vec3(aabb_center.x - (aabb_extents.x / 2.f), aabb_center.y - (aabb_extents.y / 2.f), aabb_center.z - (aabb_extents.z / 2.f));
	ztVec3 aabb_max = zt_vec3(aabb_center.x + (aabb_extents.x / 2.f), aabb_center.y + (aabb_extents.y / 2.f), aabb_center.z + (aabb_extents.z / 2.f));

	zt_fiz(3) {
		if (zt_real32Eq(direction.values[i], 0)) {
			// parallel in this axis
			if (line_0.values[i] < aabb_min.values[i] || line_0.values[i] > aabb_max.values[i]) {
				return false;
			}
		}
		else {
			r32 t1, t2;
			if (direction.values[i] >= 0) {
				t1 = (aabb_min.values[i] - line_0.values[i]) / direction.values[i];
				t2 = (aabb_max.values[i] - line_0.values[i]) / direction.values[i];
			}
			else {
				t1 = (aabb_max.values[i] - line_0.values[i]) / direction.values[i];
				t2 = (aabb_min.values[i] - line_0.values[i]) / direction.values[i];
			}

			if (tmin > t2 || t1 > tmax) { return false; }

			bool intersects = false;
			if (t1 > tmin) { intersects = true; tmin = t1; }
			if (t2 < tmax) { intersects = true; tmax = t2; }

			if (intersects && intersection_axis) {
				if(zt_real32Eq(tmin, 0) && zt_real32Eq(tmax, 1)) {
					*intersection_axis = -1; // the line is entirely inside the aabb
				}
				else {
					*intersection_axis = i * 2;
					if (direction.values[i] > 0) {
						*intersection_axis += 1;
					}
				}
			}

			if (tmin > tmax) {
				return false;
			}
		}
	}

	if (intersection_time) *intersection_time = tmin;

	if (tmin < 0 || tmin > 1) {
		return false;
	}

	if (intersection_points) {
		intersection_points[0] = line_0 + direction * tmin;
		intersection_points[1] = line_0 + direction * zt_min(1, tmax);
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInAABB(const ztVec2 &aabb_center_1, const ztVec2 &aabb_extents_1, const ztVec2 &aabb_center_2, const ztVec2 &aabb_extents_2)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInAABB");
	if (aabb_center_1.x + (aabb_extents_1.x / 2.f) < aabb_center_2.x - (aabb_extents_2.x / 2.f) || aabb_center_1.x - (aabb_extents_1.x / 2.f) > aabb_center_2.x + (aabb_extents_2.x / 2.f)) return false;
	if (aabb_center_1.y + (aabb_extents_1.y / 2.f) < aabb_center_2.y - (aabb_extents_2.y / 2.f) || aabb_center_1.y - (aabb_extents_1.y / 2.f) > aabb_center_2.y + (aabb_extents_2.y / 2.f)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInAABB(const ztVec2 &aabb_center_1, const ztVec2 &aabb_extents_1, const ztVec2 &aabb_center_2, const ztVec2 &aabb_extents_2, ztVec2 *collision_normal, r32 *collision_depth, int *collision_face)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInAABB");

	static ztVec2 faces[4] = {
		zt_vec2(-1, 0),
		zt_vec2(1, 0),
		zt_vec2(0, -1),
		zt_vec2(0, 1),
	};

	ztVec2 aabb_min_1 = zt_vec2(aabb_center_1.x - (aabb_extents_1.x / 2.f), aabb_center_1.y - (aabb_extents_1.y / 2.f));
	ztVec2 aabb_max_1 = zt_vec2(aabb_center_1.x + (aabb_extents_1.x / 2.f), aabb_center_1.y + (aabb_extents_1.y / 2.f));

	ztVec2 aabb_min_2 = zt_vec2(aabb_center_2.x - (aabb_extents_2.x / 2.f), aabb_center_2.y - (aabb_extents_2.y / 2.f));
	ztVec2 aabb_max_2 = zt_vec2(aabb_center_2.x + (aabb_extents_2.x / 2.f), aabb_center_2.y + (aabb_extents_2.y / 2.f));

	r32 distances[4] = {
		(aabb_max_2.x - aabb_min_1.x),
		(aabb_max_1.x - aabb_min_2.x),
		(aabb_max_2.y - aabb_min_1.y),
		(aabb_max_1.y - aabb_min_2.y),
	};

	r32 collision_depth_local = ztReal32Max;

	zt_fiz(4) {
		if (distances[i] < 0.0f) {
			return false;
		}

		if ((i == 0) || (distances[i] < collision_depth_local)) {
			if (collision_face) *collision_face = i;
			if (collision_normal) *collision_normal = faces[i];
			if (collision_depth) *collision_depth = distances[i];
			collision_depth_local = distances[i];
		}
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInAABB(const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInAABB");
	if (aabb_center_1.x + (aabb_extents_1.x / 2.f) < aabb_center_2.x - (aabb_extents_2.x / 2.f) || aabb_center_1.x - (aabb_extents_1.x / 2.f) > aabb_center_2.x + (aabb_extents_2.x / 2.f)) return false;
	if (aabb_center_1.y + (aabb_extents_1.y / 2.f) < aabb_center_2.y - (aabb_extents_2.y / 2.f) || aabb_center_1.y - (aabb_extents_1.y / 2.f) > aabb_center_2.y + (aabb_extents_2.y / 2.f)) return false;
	if (aabb_center_1.z + (aabb_extents_1.z / 2.f) < aabb_center_2.z - (aabb_extents_2.z / 2.f) || aabb_center_1.z - (aabb_extents_1.z / 2.f) > aabb_center_2.z + (aabb_extents_2.z / 2.f)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInAABB(const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2, ztVec3 *collision_normal, r32 *collision_depth, int *collision_face)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInAABB");

	static ztVec3 faces[6] = {
		zt_vec3(-1,  0,  0),
		zt_vec3( 1,  0,  0),
		zt_vec3( 0, -1,  0),
		zt_vec3( 0,  1,  0),
		zt_vec3( 0,  0, -1),
		zt_vec3( 0,  0,  1),
	};

	ztVec3 aabb_min_1 = zt_vec3(aabb_center_1.x - (aabb_extents_1.x / 2.f), aabb_center_1.y - (aabb_extents_1.y / 2.f), aabb_center_1.z - (aabb_extents_1.z / 2.f));
	ztVec3 aabb_max_1 = zt_vec3(aabb_center_1.x + (aabb_extents_1.x / 2.f), aabb_center_1.y + (aabb_extents_1.y / 2.f), aabb_center_1.z + (aabb_extents_1.z / 2.f));
	
	ztVec3 aabb_min_2 = zt_vec3(aabb_center_2.x - (aabb_extents_2.x / 2.f), aabb_center_2.y - (aabb_extents_2.y / 2.f), aabb_center_2.z - (aabb_extents_2.z / 2.f));
	ztVec3 aabb_max_2 = zt_vec3(aabb_center_2.x + (aabb_extents_2.x / 2.f), aabb_center_2.y + (aabb_extents_2.y / 2.f), aabb_center_2.z + (aabb_extents_2.z / 2.f));
	
	r32 distances[6] = {
		(aabb_max_2.x - aabb_min_1.x),
		(aabb_max_1.x - aabb_min_2.x),
		(aabb_max_2.y - aabb_min_1.y),
		(aabb_max_1.y - aabb_min_2.y),
		(aabb_max_2.z - aabb_min_1.z),
		(aabb_max_1.z - aabb_min_2.z)
	};

	r32 collision_depth_local = ztReal32Max;

	zt_fiz(6) {
		if (distances[i] < 0.0f) {
			return false;
		}

		if ((i == 0) || (distances[i] < collision_depth_local)) {
			if (collision_face) *collision_face = i;
			if (collision_normal) *collision_normal = faces[i];
			if (collision_depth) *collision_depth = distances[i];
			collision_depth_local = distances[i];
		}
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionMovingAABBInAABB(const ztVec3 &aabb_center_1, const ztVec3 &aabb_extents_1, const ztVec3 &aabb_velocity_1, const ztVec3 &aabb_center_2, const ztVec3 &aabb_extents_2, const ztVec3 &aabb_velocity_2, r32 *time_first, r32 *time_last)
{
	ZT_PROFILE_PHYSICS("zt_collisionMovingAABBInAABB");
	*time_first = 0;
	*time_last = 1;

	if (zt_collisionAABBInAABB(aabb_center_1, aabb_extents_1, aabb_center_2, aabb_extents_2)) {
		*time_first = *time_last = 0;
		return true;
	}

	ztVec3 velocity = aabb_velocity_2 - aabb_velocity_1;

	if (zt_real32Eq(velocity.x, 0) && zt_real32Eq(velocity.y, 0) && zt_real32Eq(velocity.z, 0)) {
		return false;
	}

	ztVec3 aabb_min_1 = zt_vec3(aabb_center_1.x - (aabb_extents_1.x / 2.f), aabb_center_1.y - (aabb_extents_1.y / 2.f), aabb_center_1.z - (aabb_extents_1.z / 2.f));
	ztVec3 aabb_max_1 = zt_vec3(aabb_center_1.x + (aabb_extents_1.x / 2.f), aabb_center_1.y + (aabb_extents_1.y / 2.f), aabb_center_1.z + (aabb_extents_1.z / 2.f));
	
	ztVec3 aabb_min_2 = zt_vec3(aabb_center_2.x - (aabb_extents_2.x / 2.f), aabb_center_2.y - (aabb_extents_2.y / 2.f), aabb_center_2.z - (aabb_extents_2.z / 2.f));
	ztVec3 aabb_max_2 = zt_vec3(aabb_center_2.x + (aabb_extents_2.x / 2.f), aabb_center_2.y + (aabb_extents_2.y / 2.f), aabb_center_2.z + (aabb_extents_2.z / 2.f));

	zt_fiz(3) {
		if (velocity.values[i] < 0.f) {
			if (aabb_max_2.values[i] < aabb_min_1.values[i]) return false;
			if (aabb_max_1.values[i] < aabb_min_2.values[i]) *time_first = zt_max((aabb_max_1.values[i] - aabb_min_2.values[i]) / velocity.values[i], *time_first);
			if (aabb_max_2.values[i] > aabb_min_1.values[i]) *time_last = zt_min((aabb_min_1.values[i] - aabb_max_2.values[i]) / velocity.values[i], *time_last);
		}
		else if (velocity.values[i] > 0) {
			if (aabb_min_2.values[i] > aabb_max_1.values[i]) return false;
			if (aabb_max_2.values[i] < aabb_min_1.values[i]) *time_first = zt_max((aabb_min_1.values[i] - aabb_max_2.values[i]) / velocity.values[i], *time_first);
			if (aabb_max_1.values[i] > aabb_min_2.values[i]) *time_last = zt_min((aabb_max_1.values[i] - aabb_min_2.values[i]) / velocity.values[i], *time_last);
		}
		else {
			if (aabb_max_2.values[i] < aabb_min_1.values[i]) return false;
			if (aabb_min_2.values[i] > aabb_max_1.values[i]) return false;
		}

		if (*time_first > *time_last) {
			return false;
		}
	}

	return zt_between(*time_first, 0, 1) && zt_between(*time_last, 0, 1);
}

// ================================================================================================================================================================================================

ztInternal ztVec3 _zt_collisionOBBOBB_mult(const ztMat4 &mat, const ztVec3 &v)
{
	ztMat3 mat3 = zt_mat3(mat);
	mat3.transpose();

	ztVec3 pos = mat.cols[3].xyz;

	return mat3.getMultiply(v - pos);
}

// ================================================================================================================================================================================================

ztInternal ztVec3 _zt_collisionOBBOBB_mult(const ztMat3 &mat, const ztVec3 &v)
{
	ztMat3 mat3 = mat;
	mat3.transpose();

	return mat3.getMultiply(v);
}

// ================================================================================================================================================================================================

ztInternal void _zt_collisionOBBOBB_incidentFace(ztMat4 &itx, const ztVec3 &e, const ztVec3 &norm, ztVec3 *clip_vert)
{
	ztVec3 normal = _zt_collisionOBBOBB_mult(zt_mat3(itx), norm) * -1.f;
	ztVec3 normal_abs = zt_vec3(zt_abs(normal.x), zt_abs(normal.y), zt_abs(normal.z));

	if (normal_abs.x > normal_abs.y && normal_abs.x > normal_abs.z) {
		if (normal.x > 0.f) {
			clip_vert[0] = zt_vec3(e.x,  e.y, -e.z);
			clip_vert[1] = zt_vec3(e.x,  e.y,  e.z);
			clip_vert[2] = zt_vec3(e.x, -e.y, -e.z);
			clip_vert[3] = zt_vec3(e.x, -e.y, -e.z);
		}
		else {
			clip_vert[0] = zt_vec3(-e.x, -e.y,  e.z);
			clip_vert[1] = zt_vec3(-e.x,  e.y,  e.z);
			clip_vert[2] = zt_vec3(-e.x,  e.y, -e.z);
			clip_vert[3] = zt_vec3(-e.x, -e.y, -e.z);
		}
	}
	else if (normal_abs.y > normal_abs.x && normal_abs.y > normal_abs.z) {
		if (normal.y > 0.f) {
			clip_vert[0] = zt_vec3(-e.x,  e.y,  e.z);
			clip_vert[1] = zt_vec3( e.x,  e.y,  e.z);
			clip_vert[2] = zt_vec3( e.x,  e.y, -e.z);
			clip_vert[3] = zt_vec3(-e.x,  e.y, -e.z);
		}
		else {
			clip_vert[0] = zt_vec3( e.x, -e.y,  e.z);
			clip_vert[1] = zt_vec3(-e.x, -e.y,  e.z);
			clip_vert[2] = zt_vec3(-e.x, -e.y, -e.z);
			clip_vert[3] = zt_vec3( e.x, -e.y, -e.z);
		}
	}
	else {
		if (normal.z > 0.f) {
			clip_vert[0] = zt_vec3(-e.x,  e.y,  e.z);
			clip_vert[1] = zt_vec3(-e.x, -e.y,  e.z);
			clip_vert[2] = zt_vec3( e.x, -e.y,  e.z);
			clip_vert[3] = zt_vec3( e.x,  e.y,  e.z);
		}
		else {
			clip_vert[0] = zt_vec3( e.x, -e.y, -e.z);
			clip_vert[1] = zt_vec3(-e.x, -e.y, -e.z);
			clip_vert[2] = zt_vec3(-e.x,  e.y, -e.z);
			clip_vert[3] = zt_vec3( e.x,  e.y, -e.z);
		}
	}

	zt_fiz(4) {
		clip_vert[i] = itx.getMultiply(clip_vert[i]);
	}
}

// ================================================================================================================================================================================================

static i32 _zt_collisionOBBOBB_ortho(r32 sign, r32 e, i32 axis, ztVec3 *in, i32 in_count, ztVec3 *out)
{
	i32 out_count = 0;
	ztVec3 a = in[in_count - 1];

	zt_fiz(in_count) {
		ztVec3 b = in[i];

		r32 da = sign * a.values[axis] - e;
		r32 db = sign * b.values[axis] - e;

		ztVec3 cv;

		if ((da < .0f && db < .0f) || (zt_between(da, -.005f, .005) || zt_between(db, -.005f, .005f))) {
			out[out_count++] = b;
		}
		else if (da < .0f && db >= 0.f) {
			cv = a + (b - a) * (da / (da - db));
			out[out_count++] = cv;
		}
		else if (da >= 0.f && db < .0f) {
			cv = a + (b - a) * (da / (da - db));
			out[out_count++] = cv;
			out[out_count++] = b;
		}

		a = b;
	}

	return out_count;
}

// ================================================================================================================================================================================================

ztInternal i32 _zt_collisionOBBOBB_clip(const ztVec3& r_vec, const ztVec3& e, const ztMat3& basis, ztVec3 *incident, ztVec3 *out_verts, r32 *out_depths)
{
	i32 in_count = 4;
	i32 out_count = 0;
	ztVec3 in[8];
	ztVec3 out[8];

	zt_fiz(4) {
		in[i] = _zt_collisionOBBOBB_mult(basis, incident[i] - r_vec);
	}

	out_count = _zt_collisionOBBOBB_ortho(1.f, e.x, 0, in, in_count, out);
	if (out_count == 0) return 0;

	in_count = _zt_collisionOBBOBB_ortho(1.f, e.y, 1, out, out_count, in);
	if (in_count == 0) return 0;

	out_count = _zt_collisionOBBOBB_ortho(-1.f, e.x, 0, in, in_count, out);
	if (out_count == 0) return 0;

	in_count = _zt_collisionOBBOBB_ortho(-1.f, e.y, 1, out, out_count, in);

	out_count = 0;
	zt_fiz(in_count) {
		r32 d = in[i].z - e.z;
		if (d <= 0.f) {
			out_verts[out_count] = in[i];
			out_verts[out_count] = basis.getMultiply(in[i]) + r_vec;
			out_depths[out_count++] = d;
		}
	}

	return out_count;
}

// ================================================================================================================================================================================================

ztInternal void _zt_collisionOBBOBB_referenceEdgesAndBasis(ztVec3& e_r, ztMat4 &mat, ztVec3 &norm, i32 axis, ztMat3 *basis, ztVec3 *e)
{
	ztVec3 normal = _zt_collisionOBBOBB_mult(zt_mat3(mat), norm).getNormal();

	if (axis >= 3) {
		axis -= 3;
	}

	switch(axis)
	{
		case 0: {
			if (normal.x > 0.f) {
				*e = zt_vec3(e_r.y, e_r.z, e_r.x);
				basis->cols[0] = mat.cols[1].xyz;
				basis->cols[1] = mat.cols[2].xyz;
				basis->cols[2] = mat.cols[0].xyz;
			}
			else {
				*e = zt_vec3(e_r.z, e_r.y, e_r.x);
				basis->cols[0] = mat.cols[2].xyz;
				basis->cols[1] = mat.cols[1].xyz;
				basis->cols[2] = mat.cols[0].xyz * -1.f;
			}
		} break;

		case 1: {
			if (normal.y > 0.f) {
				*e = zt_vec3(e_r.z, e_r.x, e_r.y);
				basis->cols[0] = mat.cols[2].xyz;
				basis->cols[1] = mat.cols[0].xyz;
				basis->cols[2] = mat.cols[1].xyz;
			}
			else {
				*e = zt_vec3(e_r.z, e_r.x, e_r.y);
				basis->cols[0] = mat.cols[2].xyz;
				basis->cols[1] = mat.cols[0].xyz * -1.f;
				basis->cols[2] = mat.cols[1].xyz * -1.f;
			}
		} break;

		case 2: {
			if (normal.z > 0.f) {
				*e = zt_vec3(e_r.y, e_r.x, e_r.z);
				basis->cols[0] = mat.cols[1].xyz;
				basis->cols[1] = mat.cols[0].xyz * -1.f;
				basis->cols[2] = mat.cols[2].xyz;
			}
			else {
				*e = zt_vec3(e_r.y, e_r.x, e_r.z);
				basis->cols[0] = mat.cols[1].xyz * -1.f;
				basis->cols[1] = mat.cols[0].xyz * -1.f;
				basis->cols[2] = mat.cols[2].xyz * -1.f;
			}
		} break;
	}
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInPlane(const ztVec3 &aabb_center, const ztVec3 &aabb_extents, const ztPlane& plane, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInPlane");

	ztVec3 half_ext = zt_vec3(aabb_extents.x / 2, aabb_extents.y / 2, aabb_extents.z / 2);

	r32 int_rad = half_ext.x * zt_abs(plane.normal.x) + half_ext.y * zt_abs(plane.normal.y) + half_ext.z * zt_abs(plane.normal.z);
	r32 dist = plane.normal.dot(aabb_center) - plane.distance;

	if (zt_abs(dist) <= int_rad) {

		if (intersection_point) {
			ztVec3 verts[8] = {
				zt_vec3(-half_ext.x,  half_ext.y, -half_ext.z),
				zt_vec3(-half_ext.x,  half_ext.y,  half_ext.z),
				zt_vec3( half_ext.x,  half_ext.y,  half_ext.z),
				zt_vec3( half_ext.x,  half_ext.y, -half_ext.z),
				zt_vec3(-half_ext.x, -half_ext.y, -half_ext.z),
				zt_vec3(-half_ext.x, -half_ext.y,  half_ext.z),
				zt_vec3( half_ext.x, -half_ext.y,  half_ext.z),
				zt_vec3( half_ext.x, -half_ext.y, -half_ext.z),
			};

			ztVec2i lines[12] = {
				zt_vec2i(0, 1),
				zt_vec2i(1, 2),
				zt_vec2i(2, 3),
				zt_vec2i(3, 0),

				zt_vec2i(4, 5),
				zt_vec2i(5, 6),
				zt_vec2i(6, 7),
				zt_vec2i(7, 4),

				zt_vec2i(0, 4),
				zt_vec2i(1, 5),
				zt_vec2i(2, 6),
				zt_vec2i(3, 7),
			};

			r32 penetrations[12];
			ztVec3 points[12];

			r32 smallest_penetration = ztReal32Max;

			// test each line, keeping track of smallest penetration... average matching smallest penetrations to get contact point...

			zt_fize(lines) {
				ztVec3 line_beg = verts[lines[i].x];
				ztVec3 line_end = verts[lines[i].y];
				ztVec3 line_dir = (line_end - line_beg);

				r32 dot = plane.normal.dot(line_dir);
				if (dot == 0) {
					penetrations[i] = ztReal32Min;
					continue;
				}

				bool reverse = dot < 0;

				r32 t = (plane.distance - plane.normal.dot(line_beg)) / dot;

				if (t >= 0.f && t <= 1.f) {
					points[i] = line_beg + (line_dir * t);
					if (reverse) t = 1 - 1;
					penetrations[i] = (line_dir * (1 - t)).length();

					if (penetrations[i] < smallest_penetration) {
						smallest_penetration = penetrations[i];
					}
				}
				else {
					penetrations[i] = ztReal32Min;
				}
			}

			int intersections = 0;
			ztVec3 contact_point = ztVec3::zero;

			zt_fize(lines) {
				//if(zt_real32Close(penetrations[i], smallest_penetration)) {
				if (penetrations[i] != ztReal32Min) {
					intersections += 1;
					contact_point += points[i];
				}
			}

			if (intersections > 0) {
				*intersection_point = contact_point * (1.f / intersections);
			}
			//*intersection_point = aabb_center + (plane.normal * -dist);
		}
		return true;
	}
	
	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionTriangleInAABB(const ztVec2 &p1, const ztVec2 &p2, const ztVec2 &p3, const ztVec2 &aabb_center, const ztVec2& aabb_size, ztVec3 *intersection_point)
{
	return zt_collisionTriangleInAABB(zt_vec3(p1, 0), zt_vec3(p2, 0), zt_vec3(p3, 0), zt_vec3(aabb_center, 0), zt_vec3(aabb_size, 1), intersection_point);
}

// ================================================================================================================================================================================================

bool zt_collisionTriangleInAABB(const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &aabb_center, const ztVec3& aabb_size, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionTriangleInAABB");

	ztVec3 t0 = p1 - aabb_center;
	ztVec3 t1 = p2 - aabb_center;
	ztVec3 t2 = p3 - aabb_center;

	ztVec3 f0 = t1 - t0;
	ztVec3 f1 = t2 - t1;
	ztVec3 f2 = t0 - t2;

	ztVec3 ext = aabb_size * .5;

	ztVec3 a00 = zt_vec3(0, -f0.z, f0.y);
	ztVec3 p = zt_vec3(t0.dot(a00), t1.dot(a00), t2.dot(a00));
	r32 r = ext.y * zt_abs(f0.z) + ext.z * zt_abs(f0.y);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a01 = zt_vec3(0, -f1.z, f1.y);
	p = zt_vec3(t0.dot(a01), t1.dot(a01), t2.dot(a01));
	r = ext.y * zt_abs(f1.z) + ext.z * zt_abs(f1.y);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a02 = zt_vec3(0, -f2.z, f2.y);
	p = zt_vec3(t0.dot(a02), t1.dot(a02), t2.dot(a02));
	r = ext.y * zt_abs(f2.z) + ext.z * zt_abs(f2.y);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a10 = zt_vec3(f0.z, 0, -f0.x);
	p = zt_vec3(t0.dot(a10), t1.dot(a10), t2.dot(a10));
	r = ext.x * zt_abs(f0.z) + ext.z * zt_abs(f0.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a11 = zt_vec3(f1.z, 0, -f1.x);
	p = zt_vec3(t0.dot(a11), t1.dot(a11), t2.dot(a11));
	r = ext.x * zt_abs(f1.z) + ext.z * zt_abs(f1.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a12 = zt_vec3(f2.z, 0, -f2.x);
	p = zt_vec3(t0.dot(a12), t1.dot(a12), t2.dot(a12));
	r = ext.x * zt_abs(f2.z) + ext.z * zt_abs(f2.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a20 = zt_vec3(-f0.y, f0.x, 0);
	p = zt_vec3(t0.dot(a20), t1.dot(a20), t2.dot(a20));
	r = ext.x * zt_abs(f0.y) + ext.y * zt_abs(f0.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a21 = zt_vec3(-f1.y, f1.x, 0);
	p = zt_vec3(t0.dot(a21), t1.dot(a21), t2.dot(a21));
	r = ext.x * zt_abs(f1.y) + ext.y * zt_abs(f1.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}

	ztVec3 a22 = zt_vec3(-f2.y, f2.x, 0);
	p = zt_vec3(t0.dot(a22), t1.dot(a22), t2.dot(a22));
	r = ext.x * zt_abs(f2.y) + ext.y * zt_abs(f2.x);
	if (zt_max(-zt_max(p.x, zt_max(p.y, p.z)), zt_min(p.x, zt_min(p.y, p.z))) > r) {
		return false;
	}


	if (zt_max(t0.x, zt_max(t1.x, t2.x)) < -ext.x || zt_min(t0.x, zt_min(t1.x, t2.x)) > ext.x) {
		return false;
	}
	if (zt_max(t0.y, zt_max(t1.y, t2.y)) < -ext.y || zt_min(t0.y, zt_min(t1.y, t2.y)) > ext.y) {
		return false;
	}
	if (zt_max(t0.z, zt_max(t1.z, t2.z)) < -ext.z || zt_min(t0.z, zt_min(t1.z, t2.z)) > ext.z) {
		return false;
	}

	ztPlane plane = zt_planeMake(p1, p2, p3);

	return zt_collisionAABBInPlane(aabb_center, aabb_size, plane, intersection_point);
}

// ================================================================================================================================================================================================

bool zt_collisionTriangleInOBB(const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &obb_center, const ztVec3& obb_size, const ztQuat &obb_rot, ztVec3 *intersection_point)
{
	ztMat4 transform = zt_transformToMat4(obb_center, obb_rot).getInverse();

	ztVec3 rp1 = transform.getMultiply(p1);
	ztVec3 rp2 = transform.getMultiply(p2);
	ztVec3 rp3 = transform.getMultiply(p3);

	if (zt_collisionTriangleInAABB(rp1, rp2, rp3, ztVec3::zero, obb_size, intersection_point)) {
		if (intersection_point) {
			*intersection_point = transform.getInverse().getMultiply(*intersection_point);
		}
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionTriangleInSphere(const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3 &sphere_center, r32 sphere_radius, ztVec3 *intersection_point)
{
	ztVec3 closest_pt = zt_closestPointTrianglePoint(p1, p2, p3, sphere_center);
	ztVec3 diff = closest_pt - sphere_center;

	if (diff.dot(diff) <= sphere_radius * sphere_radius) {
		if (intersection_point) {
			*intersection_point = closest_pt;
		}
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionOBBInOBB(const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2)
{
	ZT_PROFILE_PHYSICS("zt_collisionOBBInOBB");
	ztVec3 obb_axis_1[3] = {
		obb_rot_1.rotatePosition(1, 0, 0),
		obb_rot_1.rotatePosition(0, 1, 0),
		obb_rot_1.rotatePosition(0, 0, 1),
	};

	ztVec3 obb_axis_2[3] = {
		obb_rot_2.rotatePosition(1, 0, 0),
		obb_rot_2.rotatePosition(0, 1, 0),
		obb_rot_2.rotatePosition(0, 0, 1),
	};

	return zt_collisionOBBInOBB(obb_center_1, obb_extents_1, obb_rot_1, obb_axis_1, obb_center_2, obb_extents_2, obb_rot_2, obb_axis_2);
}

// ================================================================================================================================================================================================

bool zt_collisionOBBInOBB(const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 obb_axis_1[3], const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, const ztVec3 obb_axis_2[3])
{
	ZT_PROFILE_PHYSICS("zt_collisionOBBInOBB");
	r32 mat_r[3][3], mat_abs_r[3][3], ra, rb, sp;

	zt_fiz(3) {
		zt_fjz(3) {
			mat_r[i][j] = obb_axis_1[i].dot(obb_axis_2[j]);
			mat_abs_r[i][j] = zt_abs(mat_r[i][j]) + ztReal32Epsilon;
		}
	}

	ztVec3 t = obb_center_2 - obb_center_1;
	t = zt_vec3(t.dot(obb_axis_1[0]), t.dot(obb_axis_1[1]), t.dot(obb_axis_1[2]));

	ztVec3 a_ext = obb_extents_1 * .5f;
	ztVec3 b_ext = obb_extents_2 * .5f;

	struct local
	{
		static bool test(r32 sp, r32 ra, r32 rb)
		{
			if (sp > ra + rb) return false;
			return true;
		}
	};

	// axis 0 - x, 1 - y, 2 - z

	// axis A0, A1, A2 (0-2)
	zt_fiz(3) {
		ra = a_ext.values[i];
		rb = b_ext.values[0] * mat_abs_r[i][0] + b_ext.values[1] * mat_abs_r[i][1] + b_ext.values[2] * mat_abs_r[i][2];
		sp = zt_abs(t.values[i]);
		if (!local::test(sp, ra, rb)) return false;
	}

	// axis B0, B1, B2 (3-5)
	zt_fiz(3) {
		ra = a_ext.values[0] * mat_abs_r[0][i] + a_ext.values[1] * mat_abs_r[1][i] + a_ext.values[2] * mat_abs_r[2][i];
		rb = b_ext.values[i];
		sp = zt_abs(t.values[0] * mat_r[0][i] + t.values[1] *  mat_r[1][i] + t.values[2] * mat_r[2][i]);
		if (!local::test(sp, ra, rb)) return false;
	}

	// axis A0 x B0 (6)
	ra = a_ext.values[1] * mat_abs_r[2][0] + a_ext.values[2] * mat_abs_r[1][0];
	rb = b_ext.values[1] * mat_abs_r[0][2] + b_ext.values[2] * mat_abs_r[0][1];
	sp = zt_abs(t.values[2] * mat_r[1][0] - t.values[1] * mat_r[2][0]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A0 x B1 (7)
	ra = a_ext.values[1] * mat_abs_r[2][1] + a_ext.values[2] * mat_abs_r[1][1];
	rb = b_ext.values[0] * mat_abs_r[0][2] + b_ext.values[2] * mat_abs_r[0][0];
	sp = zt_abs(t.values[2] * mat_r[1][1] - t.values[1] * mat_r[2][1]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A0 x B2 (8)
	ra = a_ext.values[1] * mat_abs_r[2][2] + a_ext.values[2] * mat_abs_r[1][2];
	rb = b_ext.values[0] * mat_abs_r[0][1] + b_ext.values[1] * mat_abs_r[0][0];
	sp = zt_abs(t.values[2] * mat_r[1][2] - t.values[1] * mat_r[2][2]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A1 x B0 (9)
	ra = a_ext.values[0] * mat_abs_r[2][0] + a_ext.values[2] * mat_abs_r[0][0];
	rb = b_ext.values[1] * mat_abs_r[1][2] + b_ext.values[2] * mat_abs_r[1][1];
	sp = zt_abs(t.values[0] * mat_r[2][0] - t.values[2] * mat_r[0][0]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A1 x B1 (10)
	ra = a_ext.values[0] * mat_abs_r[2][1] + a_ext.values[2] * mat_abs_r[0][1];
	rb = b_ext.values[0] * mat_abs_r[1][2] + b_ext.values[2] * mat_abs_r[1][0];
	sp = zt_abs(t.values[0] * mat_r[2][1] - t.values[2] * mat_r[0][1]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A1 x B2 (11)
	ra = a_ext.values[0] * mat_abs_r[2][2] + a_ext.values[2] * mat_abs_r[0][2];
	rb = b_ext.values[0] * mat_abs_r[1][1] + b_ext.values[1] * mat_abs_r[1][0];
	sp = zt_abs(t.values[0] * mat_r[2][2] - t.values[2] * mat_r[0][2]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A2 x B0 (12)
	ra = a_ext.values[0] * mat_abs_r[1][0] + a_ext.values[1] * mat_abs_r[0][0];
	rb = b_ext.values[1] * mat_abs_r[2][2] + b_ext.values[2] * mat_abs_r[2][1];
	sp = zt_abs(t.values[1] * mat_r[0][0] - t.values[0] * mat_r[1][0]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A2 x B1 (13)
	ra = a_ext.values[0] * mat_abs_r[1][1] + a_ext.values[1] * mat_abs_r[0][1];
	rb = b_ext.values[0] * mat_abs_r[2][2] + b_ext.values[2] * mat_abs_r[2][0];
	sp = zt_abs(t.values[1] * mat_r[0][1] - t.values[0] * mat_r[1][1]);
	if (!local::test(sp, ra, rb)) return false;

	// axis A2 x B2 (14)
	ra = a_ext.values[0] * mat_abs_r[1][2] + a_ext.values[1] * mat_abs_r[0][2];
	rb = b_ext.values[0] * mat_abs_r[2][1] + b_ext.values[1] * mat_abs_r[2][0];
	sp = zt_abs(t.values[1] * mat_r[0][2] - t.values[0] * mat_r[1][2]);
	if (!local::test(sp, ra, rb)) return false;

	return true;
}

// ================================================================================================================================================================================================

int zt_collisionOBBInOBBGetContactPoints(const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, ztVec3 *contact_normal, ztVec3 *contacts, r32 *penetrations, int contacts_size)
{
	ZT_PROFILE_PHYSICS("zt_collisionOBBInOBB");
	ztVec3 obb_axis_1[3] = {
		obb_rot_1.rotatePosition(1, 0, 0),
		obb_rot_1.rotatePosition(0, 1, 0),
		obb_rot_1.rotatePosition(0, 0, 1),
	};

	ztVec3 obb_axis_2[3] = {
		obb_rot_2.rotatePosition(1, 0, 0),
		obb_rot_2.rotatePosition(0, 1, 0),
		obb_rot_2.rotatePosition(0, 0, 1),
	};

	return zt_collisionOBBInOBBGetContactPoints(obb_center_1, obb_extents_1, obb_rot_1, obb_axis_1, obb_center_2, obb_extents_2, obb_rot_2, obb_axis_2, contact_normal, contacts, penetrations, contacts_size);
}

// ================================================================================================================================================================================================

int zt_collisionOBBInOBBGetContactPoints(const ztVec3 &obb_center_1, const ztVec3 &obb_extents_1, const ztQuat& obb_rot_1, const ztVec3 obb_axis_1[3], const ztVec3 &obb_center_2, const ztVec3 &obb_extents_2, const ztQuat& obb_rot_2, const ztVec3 obb_axis_2[3], ztVec3 *contact_normal, ztVec3 *contacts, r32 *penetrations, int contacts_size)
{
	ZT_PROFILE_PHYSICS("zt_collisionOBBInOBBGetContactPoints");
	r32 mat_r[3][3], mat_abs_r[3][3], ra, rb, sp;

	zt_fiz(3) {
		zt_fjz(3) {
			mat_r[i][j] = obb_axis_1[i].dot(obb_axis_2[j]);
			mat_abs_r[i][j] = zt_abs(mat_r[i][j]) + ztReal32Epsilon;
		}
	}

	ztVec3 center = obb_center_2 - obb_center_1;
	ztVec3 t = center;
	t = zt_vec3(t.dot(obb_axis_1[0]), t.dot(obb_axis_1[1]), t.dot(obb_axis_1[2]));

	ztVec3 a_ext = obb_extents_1 * .5f;
	ztVec3 b_ext = obb_extents_2 * .5f;

	int axis_idx = 0;
	r32 max_span = 0.f;
	i32 max_axis = 0;

	int contacts_idx = 0;

	struct local
	{
		static bool testFace(i32 *max_axis, i32 axis, r32 sp, r32 *max_sp, r32 ra, r32 rb, const ztVec3 &normal, ztVec3 *axis_normal)
		{
			if (sp > ra + rb) return false;
			sp -= (ra + rb);

			if (sp > *max_sp) {
				*max_sp = sp;
				*max_axis = axis;
				*axis_normal = normal;
			}

			return true;
		}

		static bool testEdge(i32 *max_axis, i32 axis, r32 sp, r32 *max_sp, r32 ra, r32 rb, const ztVec3 &normal, ztVec3 *axis_normal)
		{
			if (sp > ra + rb) return false;
			sp -= (ra + rb);

			r32 len = 1.f / normal.length();
			sp *= len;

			if (sp > *max_sp) {
				*max_sp = sp;
				*max_axis = axis;
				*axis_normal = normal;
			}

			return true;
		}

		static void supportEdge(const ztMat4 &mat, const ztVec3 &e, const ztVec3& norm, ztVec3 *p_out, ztVec3 *q_out)
		{
			ztVec3 normal = _zt_collisionOBBOBB_mult(mat, norm).getNormal();
			ztVec3 normal_abs = zt_vec3(zt_abs(normal.x), zt_abs(normal.y), zt_abs(normal.z));

			ztVec3 p, q;

			if (normal_abs.x > normal_abs.y) {
				if (normal_abs.y > normal_abs.z) {
					p = zt_vec3(e.x, e.y, e.z);
					q = zt_vec3(e.x, e.y, -e.z);
				}
				else {
					p = zt_vec3(e.x, e.y, e.z);
					q = zt_vec3(e.x, -e.y, e.z);
				}
			}
			else {
				if (normal_abs.x > normal_abs.z) {
					p = zt_vec3(e.x, e.y, e.z);
					q = zt_vec3(e.x, e.y, -e.z);
				}
				else {
					p = zt_vec3(e.x, e.y, e.z);
					q = zt_vec3(-e.x, e.y, e.z);
				}
			}

			r32 sign_x = normal.x >= 0 ? 1.f : -1.f;
			r32 sign_y = normal.y >= 0 ? 1.f : -1.f;
			r32 sign_z = normal.z >= 0 ? 1.f : -1.f;

			p.x *= sign_x;
			p.y *= sign_y;
			p.z *= sign_z;
			q.x *= sign_x;
			q.y *= sign_y;
			q.z *= sign_z;

			*p_out = mat.getMultiply(p);
			*q_out = mat.getMultiply(q);
		}

		static void edgeContact(ztVec3 *contact_a, ztVec3 *contact_b, const ztVec3 &pa, const ztVec3 &qa, const ztVec3 &pb, const ztVec3 &qb)
		{
			ztVec3 da = qa - pa;
			ztVec3 db = qb - pb;
			ztVec3 r = pa - pb;
			r32 a = da.dot(da);
			r32 e = db.dot(db);
			r32 f = db.dot(r);
			r32 c = db.dot(r);

			r32 b = da.dot(db);
			r32 denom = a * e - b * b;

			r32 ta = (b * f - c * e) / denom;
			r32 tb = (b * ta + f) / e;

			*contact_a = pa + da * ta;
			*contact_b = pb + db * tb;
		}
	};

	// axis 0 - x, 1 - y, 2 - z

	i32 a_axis = -1, b_axis = -1, e_axis = -1;
	r32 a_span = ztReal32Min, b_span = ztReal32Min, e_span = ztReal32Min;
	ztVec3 a_norm = ztVec3::zero, b_norm = ztVec3::zero, e_norm = ztVec3::zero;

	// axis A0, A1, A2 (0-2)
	zt_fiz(3) {
		ra = a_ext.values[i];
		rb = b_ext.values[0] * mat_abs_r[i][0] + b_ext.values[1] * mat_abs_r[i][1] + b_ext.values[2] * mat_abs_r[i][2];
		sp = zt_abs(t.values[i]);
		if (!local::testFace(&a_axis, axis_idx++, sp, &a_span, ra, rb, obb_axis_1[i], &a_norm)) return false;
	}

	// axis B0, B1, B2 (3-5)
	zt_fiz(3) {
		ra = a_ext.values[0] * mat_abs_r[0][i] + a_ext.values[1] * mat_abs_r[1][i] + a_ext.values[2] * mat_abs_r[2][i];
		rb = b_ext.values[i];
		sp = zt_abs(t.values[0] * mat_r[0][i] + t.values[1] *  mat_r[1][i] + t.values[2] * mat_r[2][i]);
		if (!local::testFace(&b_axis, axis_idx++, sp, &b_span, ra, rb, obb_axis_2[i], &b_norm)) return false;
	}

	// axis A0 x B0 (6)
	ra = a_ext.values[1] * mat_abs_r[2][0] + a_ext.values[2] * mat_abs_r[1][0];
	rb = b_ext.values[1] * mat_abs_r[0][2] + b_ext.values[2] * mat_abs_r[0][1];
	sp = zt_abs(t.values[2] * mat_r[1][0] - t.values[1] * mat_r[2][0]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(0.f, -mat_r[2][0], mat_r[1][0]), &e_norm)) return false;

	// axis A0 x B1 (7)
	ra = a_ext.values[1] * mat_abs_r[2][1] + a_ext.values[2] * mat_abs_r[1][1];
	rb = b_ext.values[0] * mat_abs_r[0][2] + b_ext.values[2] * mat_abs_r[0][0];
	sp = zt_abs(t.values[2] * mat_r[1][1] - t.values[1] * mat_r[2][1]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(0.f, -mat_r[2][1], mat_r[1][1]), &e_norm)) return false;

	// axis A0 x B2 (8)
	ra = a_ext.values[1] * mat_abs_r[2][2] + a_ext.values[2] * mat_abs_r[1][2];
	rb = b_ext.values[0] * mat_abs_r[0][1] + b_ext.values[1] * mat_abs_r[0][0];
	sp = zt_abs(t.values[2] * mat_r[1][2] - t.values[1] * mat_r[2][2]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(0.f, -mat_r[2][2], mat_r[1][2]), &e_norm)) return false;

	// axis A1 x B0 (9)
	ra = a_ext.values[0] * mat_abs_r[2][0] + a_ext.values[2] * mat_abs_r[0][0];
	rb = b_ext.values[1] * mat_abs_r[1][2] + b_ext.values[2] * mat_abs_r[1][1];
	sp = zt_abs(t.values[0] * mat_r[2][0] - t.values[2] * mat_r[0][0]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(mat_r[2][0], 0.f, -mat_r[0][0]), &e_norm)) return false;

	// axis A1 x B1 (10)
	ra = a_ext.values[0] * mat_abs_r[2][1] + a_ext.values[2] * mat_abs_r[0][1];
	rb = b_ext.values[0] * mat_abs_r[1][2] + b_ext.values[2] * mat_abs_r[1][0];
	sp = zt_abs(t.values[0] * mat_r[2][1] - t.values[2] * mat_r[0][1]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(mat_r[2][1], 0.f, -mat_r[0][1]), &e_norm)) return false;

	// axis A1 x B2 (11)
	ra = a_ext.values[0] * mat_abs_r[2][2] + a_ext.values[2] * mat_abs_r[0][2];
	rb = b_ext.values[0] * mat_abs_r[1][1] + b_ext.values[1] * mat_abs_r[1][0];
	sp = zt_abs(t.values[0] * mat_r[2][2] - t.values[2] * mat_r[0][2]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(mat_r[2][2], 0.f, -mat_r[0][2]), &e_norm)) return false;

	// axis A2 x B0 (12)
	ra = a_ext.values[0] * mat_abs_r[1][0] + a_ext.values[1] * mat_abs_r[0][0];
	rb = b_ext.values[1] * mat_abs_r[2][2] + b_ext.values[2] * mat_abs_r[2][1];
	sp = zt_abs(t.values[1] * mat_r[0][0] - t.values[0] * mat_r[1][0]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(-mat_r[1][0], mat_r[0][0], 0.f), &e_norm)) return false;

	// axis A2 x B1 (13)
	ra = a_ext.values[0] * mat_abs_r[1][1] + a_ext.values[1] * mat_abs_r[0][1];
	rb = b_ext.values[0] * mat_abs_r[2][2] + b_ext.values[2] * mat_abs_r[2][0];
	sp = zt_abs(t.values[1] * mat_r[0][1] - t.values[0] * mat_r[1][1]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(-mat_r[1][1], mat_r[0][1], 0.f), &e_norm)) return false;

	// axis A2 x B2 (14)
	ra = a_ext.values[0] * mat_abs_r[1][2] + a_ext.values[1] * mat_abs_r[0][2];
	rb = b_ext.values[0] * mat_abs_r[2][1] + b_ext.values[1] * mat_abs_r[2][0];
	sp = zt_abs(t.values[1] * mat_r[0][2] - t.values[0] * mat_r[1][2]);
	if (!local::testEdge(&e_axis, axis_idx++, sp, &e_span, ra, rb, zt_vec3(-mat_r[1][2], mat_r[0][2], 0.f), &e_norm)) return false;


	const r32 fudge_pct = 0.95f;
	const r32 fudge_amt = 0.01f;

	i32    final_axis;
	r32    final_span;
	ztVec3 final_norm;

	r32 face_span = zt_max(a_span, b_span);
	if (fudge_pct * e_span > face_span + fudge_amt) {
		final_axis = e_axis;
		final_span = e_span;
		final_norm = e_norm;
	}
	else if (fudge_pct * b_span > a_span + fudge_amt) {
		final_axis = b_axis;
		final_span = b_span;
		final_norm = b_norm;
	}
	else {
		final_axis = a_axis;
		final_span = a_span;
		final_norm = a_norm;
	}

	if (final_norm.dot(center) < 0.f) {
		final_norm *= -1;
	}

	final_norm.normalize();

	if (final_axis < 6) {
		ztTransform r_tra, i_tra;
		ztMat4      r_mat, i_mat;
		ztVec3      r_vec, i_vec;

		bool flip;

		if (final_axis < 3) {
			r_tra.position = obb_center_1;
			r_tra.rotation = obb_rot_1;
			r_tra.scale    = ztVec3::one;
			r_mat          = zt_transformToMat4(&r_tra);
			r_vec          = a_ext;

			i_tra.position = obb_center_2;
			i_tra.rotation = obb_rot_2;
			i_tra.scale    = ztVec3::one;
			i_mat          = zt_transformToMat4(&i_tra);
			i_vec          = b_ext;
			
			flip = false;
		}
		else {
			r_tra.position = obb_center_2;
			r_tra.rotation = obb_rot_2;
			r_tra.scale    = ztVec3::one;
			r_mat          = zt_transformToMat4(&r_tra);
			r_vec          = b_ext;

			i_tra.position = obb_center_1;
			i_tra.rotation = obb_rot_1;
			i_tra.scale    = ztVec3::one;
			i_mat          = zt_transformToMat4(&i_tra);
			i_vec          = a_ext;

			final_norm *= -1.f;

			flip = true;
		}

		ztVec3 incident[4];
		_zt_collisionOBBOBB_incidentFace(i_mat, i_vec, final_norm, incident);

		ztMat3 basis;
		ztVec3 e;

		_zt_collisionOBBOBB_referenceEdgesAndBasis(r_vec, r_mat, final_norm, final_axis, &basis, &e);

		final_norm.normalize();

		ztVec3 out[8];
		r32 depths[8];
		i32 out_count = _zt_collisionOBBOBB_clip(r_tra.position, e, basis, incident, out, depths);
		if (out_count > 0) {
			if (contact_normal) *contact_normal = flip ? final_norm * -1 : final_norm;

			zt_fiz(out_count) {
				int idx = contacts_idx++;
				if (idx < contacts_size) {
					contacts[idx] = out[i];
					penetrations[idx] = depths[i];
				}
			}
		}
	}
	else {
		ztTransform r_tra, i_tra;
		ztMat4      r_mat, i_mat;

		r_tra.position = obb_center_1;
		r_tra.rotation = obb_rot_1;
		r_tra.scale    = ztVec3::one;
		r_mat          = zt_transformToMat4(&r_tra);

		i_tra.position = obb_center_2;
		i_tra.rotation = obb_rot_2;
		i_tra.scale    = ztVec3::one;
		i_mat          = zt_transformToMat4(&i_tra);

		obb_rot_1.rotatePosition(&final_norm);
		final_norm.normalize();

		if (final_norm.dot(center) < 0.f) {
			final_norm *= -1.f;
		}

		ztVec3 pa, qa;
		ztVec3 pb, qb;
		local::supportEdge(r_mat, a_ext, final_norm, &pa, &qa);
		local::supportEdge(i_mat, b_ext, final_norm * -1.f, &pb, &qb);

		ztVec3 ca, cb;
		local::edgeContact(&ca, &cb, pa, qa, pb, qb);

		if (contact_normal) *contact_normal = final_norm;

		int idx = contacts_idx++;
		if (idx < contacts_size) {
			contacts[idx] = (ca + cb) * .5f;
			penetrations[idx] = final_span;
		}
	}

	return contacts_idx;
}

// ================================================================================================================================================================================================

bool zt_collisionLineSegmentInOBB(const ztVec3 &line_0, const ztVec3 &line_1, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat& obb_rot, r32 *intersection_time, ztVec3 intersections[2], i32 *intersection_axis)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineSegmentInOBB");
	ztQuat to_local = obb_rot.getInverse();
	if (zt_collisionLineSegmentInAABB(to_local.rotatePosition(line_0 - obb_center), to_local.rotatePosition(line_1 - obb_center), ztVec3::zero, obb_extents, intersection_time, intersections, intersection_axis)) {
		if (intersections) {
			intersections[0] = obb_rot.rotatePosition(intersections[0]) + obb_center;
			intersections[1] = obb_rot.rotatePosition(intersections[1]) + obb_center;
		}
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionPointInFrustum(const ztFrustum& frustum, const ztVec3 &point, bool check_near_far)
{
	ZT_PROFILE_PHYSICS("zt_collisionPointInFrustum");

	zt_fiz(zt_elementsOf(frustum.planes) - (check_near_far ? 0 : 2)) {
		r32 dot = point.dot(frustum.planes[i].normal);
		if (dot - frustum.planes[i].distance < 0 -0.0001f) {
			return false;
		}
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInFrustum(const ztFrustum& frustum, const ztVec3 &line_beg, const ztVec3 &line_end, ztVec3 *intersection_pointer)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineInFrustum");

	ztVec3 intersection_point;
	zt_fize(frustum.planes) {
		if (zt_collisionLineInPlane(line_beg, line_end, frustum.planes[i], &intersection_point)) {
			if (zt_collisionPointInFrustum(frustum, intersection_point, false)) {
				if (intersection_pointer) {
					*intersection_pointer = intersection_point;
				}
				return true;
			}
		}
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionAABBInFrustum(const ztFrustum& frustum, const ztVec3 &aabb_center, const ztVec3 &aabb_extents)
{
	ZT_PROFILE_PHYSICS("zt_collisionAABBInFrustum");

	ztVec3 aabb[] = {
		zt_vec3(aabb_center.x - aabb_extents.x / 2, aabb_center.y - aabb_extents.y / 2, aabb_center.z - aabb_extents.z / 2),
		zt_vec3(aabb_center.x + aabb_extents.x / 2, aabb_center.y + aabb_extents.y / 2, aabb_center.z + aabb_extents.z / 2),
	};

#	define test_plane(plane) \
		if(zt_vec3(aabb[(plane).normal.x > 0 ? 1 : 0].x, aabb[(plane).normal.y > 0 ? 1 : 0].y, aabb[(plane).normal.z > 0 ? 1 : 0].z).dot((plane.normal)) + (plane).distance <= 0) return false;

	test_plane(frustum.plane_near);
	test_plane(frustum.plane_left);
	test_plane(frustum.plane_right);
	test_plane(frustum.plane_top);
	test_plane(frustum.plane_bottom);
	test_plane(frustum.plane_far);

#	undef test_plane
	return true;
}

// ================================================================================================================================================================================================

bool zt_collisionSphereInFrustum(const ztFrustum& frustum, const ztVec3 &sphere_center, r32 sphere_radius)
{
	r32 dist_1 = zt_min(zt_planeDistanceFromPoint(&frustum.plane_near, sphere_center), zt_planeDistanceFromPoint(&frustum.plane_far, sphere_center));
	r32 dist_2 = zt_min(zt_planeDistanceFromPoint(&frustum.plane_left, sphere_center), zt_planeDistanceFromPoint(&frustum.plane_right, sphere_center));
	r32 dist_3 = zt_min(zt_planeDistanceFromPoint(&frustum.plane_top,  sphere_center), zt_planeDistanceFromPoint(&frustum.plane_bottom, sphere_center));

	r32 dist = zt_min(zt_min(dist_1, dist_2), dist_3);

	return (dist + sphere_radius) > 0;
}

// ================================================================================================================================================================================================

bool zt_collisionLineInGrid(int x1, int y1, int x2, int y2, byte* array2d, int cols, int rows)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineInGrid");

	x1 = zt_clamp(x1, 0, cols - 1);
	y1 = zt_clamp(y1, 0, rows - 1);
	x2 = zt_clamp(x2, 0, cols - 1);
	y2 = zt_clamp(y2, 0, rows - 1);

	if (x1 == x2) {
		for (int y = zt_min(y1, y2) + 1; y < zt_max(y1, y2); ++y) {
			if (array2d[y * cols + x1] != 0) return true;
		}
		return false;
	}
	else if (y1 == y2) {
		for (int x = zt_min(x1, x2) + 1; x < zt_max(x1, x2); ++x) {
			if (array2d[y1 * cols + x] != 0) return true;
		}
		return false;
	}

	// using Xiaolin Wu's AA line drawing algorithm

	r32 dx = (r32)x2 - (r32)x1;
	r32 dy = (r32)y2 - (r32)y1;

#	define lp_pixel(PX, PY) if( array2d[(PY) * cols + (PX)] != 0 && !((PX == x1 && PY == y1) || (PX == x2 && PY == y2))) return true;

	if (zt_abs(dx) > zt_abs(dy)) {
		if (x2 < x1) {
			zt_swap(x1, x2);
			zt_swap(y1, y2);
		}
		r32 gradient = dy / dx;
		r32 xend = (real32)x1;
		r32 yend = y1 + gradient * (xend - x1);
		int xpxl1 = (int)xend;

		r32 intery = yend + gradient;

		xend = (r32)x2;
		yend = y2 + gradient*(xend - x2);
		int xpxl2 = (int)xend;

		int x;
		for (x = xpxl1 + 1; x <= xpxl2 - 1; ++x) {
			lp_pixel(x, (int)(intery));
			lp_pixel(x, (int)(intery)+1);
			intery += gradient;
		}
	}
	else {
		if (y2 < y1) {
			zt_swap(x1, x2);
			zt_swap(y1, y2);
		}
		r32 gradient = dx / dy;
		r32 yend = (r32)y1;
		r32 xend = x1 + gradient * (yend - y1);
		int ypxl1 = (int)yend;
		r32 interx = xend + gradient;

		yend = (r32)y2;
		xend = x2 + gradient*(yend - y2);
		int ypxl2 = (int)yend;

		int y;
		for (y = ypxl1 + 1; y <= ypxl2 - 1; ++y) {
			lp_pixel((int)(interx), y);
			lp_pixel((int)(interx)+1, y);
			interx += gradient;
		}
	}

#undef lp_pixel
	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionMovingSphereInPlane(const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &sphere_velocity, const ztPlane& plane, r32 *intersection_time, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionMovingSphereInPlane");

	r32 dist = plane.normal.dot(sphere_pos) - plane.distance;
	if (zt_abs(dist) <= sphere_radius && !zt_real32Close(sphere_radius - zt_abs(dist), 0.0f)) {
		// sphere already intersecting before movement
		if (intersection_time) *intersection_time = 0.0f;
		if (intersection_point) *intersection_point = sphere_pos;
		return true;
	}
	else {
		r32 denom = plane.normal.dot(sphere_velocity);
		if (denom * dist >= 0.0f) {
			// sphere moving parallel to or away
			return false;
		}
		else {
			// sphere moving towards the plane
			r32 r = dist > 0.0f ? sphere_radius : -sphere_radius;
			r32 t = (r - dist) / denom;
			if (intersection_time) *intersection_time = t;
			if (intersection_point) *intersection_point = (sphere_pos + (sphere_velocity * t)) + ((plane.normal * r) * -1);
			return t > 0.0001f && t < 1.0001f;
		}
	}
}

// ================================================================================================================================================================================================

bool zt_collisionMovingSphereInMovingSphere(const ztVec3 &sphere1_pos, r32 sphere1_radius, const ztVec3 &sphere1_velocity, const ztVec3 &sphere2_pos, r32 sphere2_radius, const ztVec3 &sphere2_velocity, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionMovingSphereInMovingSphere");

	ztVec3 diff = sphere2_pos - sphere1_pos;
	ztVec3 rel = sphere2_velocity - sphere1_velocity;
	r32 rad = sphere2_radius + sphere1_radius;
	r32 c = diff.dot(diff) - (rad * rad);
	if (c < 0.0f) {
		if (intersection_time) *intersection_time = 0.0f; // already intersecting before movement
		return true;
	}
	r32 a = rel.dot(rel);
	if (zt_real32Eq(a, 0)) return false; // not moving relative each other
	r32 b = rel.dot(diff);
	if (b >= 0.0f) return false; // not moving towards each other
	r32 d = (b * b) - (a * c);
	if (d < 0.0f) return false; //spheres do not intersect

	r32 t = (-b - zt_sqrt(d)) / a;
	if (t >= 0 && t <= 1) {
		if (intersection_time) *intersection_time = t;
		return true;
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionMovingSphereInAABB(const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &sphere_velocity, const ztVec3 &aabb_center, const ztVec3 &aabb_extents, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionMovingSphereInAABB");

	ztVec3 intersection_points[2] = { ztVec3::min, ztVec3::min };
	if (zt_collisionLineSegmentInAABB(sphere_pos, sphere_pos + sphere_velocity, aabb_center, aabb_extents + zt_vec3(sphere_radius * 2, sphere_radius * 2, sphere_radius * 2), intersection_time, intersection_points)) {
		if (intersection_time) *intersection_time = sphere_pos.distance(intersection_points[0]) / sphere_pos.distance(sphere_pos + sphere_velocity);
		return true;
	}

	// we now need to check for corners (voronoi regions)

	struct local
	{
		static ztVec3 corner(const ztVec3 &aabb_center, const ztVec3 &aabb_extents, int n)
		{
			ztVec3 result;
			result.x = aabb_center.x + aabb_extents.x / (2 * ((n & 1) ? 1 : -1));
			result.y = aabb_center.y + aabb_extents.y / (2 * ((n & 1) ? 1 : -1));
			result.z = aabb_center.z + aabb_extents.z / (2 * ((n & 1) ? 1 : -1));
			return result;
		}
	};

	int u = 0, v = 0;
	if (intersection_points[0].x > (aabb_center.x + aabb_extents.x / 2)) v |= (1<<0);
	if (intersection_points[0].x < (aabb_center.x - aabb_extents.x / 2)) u |= (1<<0);
	if (intersection_points[0].y < (aabb_center.y - aabb_extents.y / 2)) u |= (1<<1);
	if (intersection_points[0].y > (aabb_center.y + aabb_extents.y / 2)) v |= (1<<1);
	if (intersection_points[0].z < (aabb_center.z - aabb_extents.z / 2)) u |= (1<<2);
	if (intersection_points[0].z > (aabb_center.z + aabb_extents.z / 2)) v |= (1<<2);

	int m = u + v;
	if (m == 7) { // in a vertex region
		r32 min = ztReal32Max;
		r32 intersection_time_lcl;
		if (zt_collisionLineSegmentCapsule(sphere_pos, sphere_pos + sphere_velocity, local::corner(aabb_center, aabb_extents, v), local::corner(aabb_center, aabb_extents, v ^ 1), sphere_radius, &intersection_time_lcl)) min = zt_min(intersection_time_lcl, min);
		if (zt_collisionLineSegmentCapsule(sphere_pos, sphere_pos + sphere_velocity, local::corner(aabb_center, aabb_extents, v), local::corner(aabb_center, aabb_extents, v ^ 2), sphere_radius, &intersection_time_lcl)) min = zt_min(intersection_time_lcl, min);
		if (zt_collisionLineSegmentCapsule(sphere_pos, sphere_pos + sphere_velocity, local::corner(aabb_center, aabb_extents, v), local::corner(aabb_center, aabb_extents, v ^ 4), sphere_radius, &intersection_time_lcl)) min = zt_min(intersection_time_lcl, min);

		if (min == ztReal32Max) {
			return false; // No intersection
		}

		if (intersection_time) *intersection_time  = min;

		return min > 0 && min < 1.0001f;
	}

	if ((m & (m - 1)) == 0) { // in face region
		return true; // zt_collisionLineSegmentInAABB already populated  intersection_time
	}

	// in an edge region. intersect against the capsule at the edge
	return zt_collisionLineSegmentCapsule(sphere_pos, sphere_pos + sphere_velocity, local::corner(aabb_center, aabb_extents, u ^ 7), local::corner(aabb_center, aabb_extents, v), sphere_radius, intersection_time);
}

// ================================================================================================================================================================================================

r32 zt_collisionSquareDistPointToSegment(const ztVec3 &point, const ztVec3 &seg_beg, const ztVec3 &seg_end)
{
	ZT_PROFILE_PHYSICS("zt_collisionSquareDistPointToSegment");

	ztVec3 seg_dif = seg_end - seg_beg;
	ztVec3 pnt_beg = point - seg_beg;
	ztVec3 pnt_end = point - seg_end;

	r32 e = pnt_beg.dot(seg_dif);

	if (e <= 0.0f) return pnt_beg.dot(pnt_beg);
	r32 f = seg_dif.dot(seg_dif);
	if (e >= f) return pnt_end.dot(pnt_end);

	return pnt_beg.dot(pnt_beg) - e * e / f;
}

// ================================================================================================================================================================================================

r32 zt_collisionSquareDistPointToAABB(const ztVec3 &point, const ztVec3 &aabb_center, const ztVec3 &aabb_extents)
{
	r32 sq_dist = 0.f;
	ztVec3 half = aabb_extents * .5f;
	ztVec3 min = aabb_center - half;
	ztVec3 max = aabb_center + half;

	zt_fize(point.values) {
		if (point.values[i] < min.values[i]) {
			sq_dist += (min.values[i] - point.values[i]) * (min.values[i] - point.values[i]);
		}
		if (point.values[i] > max.values[i]) {
			sq_dist += (point.values[i] - max.values[i]) * (point.values[i] - max.values[i]);
		}
	}

	return sq_dist;
}

// ================================================================================================================================================================================================

bool zt_collisionSphereCapsule(const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &capsule_beg, ztVec3 &capsule_end, r32 capsule_radius)
{
	ZT_PROFILE_PHYSICS("zt_collisionSphereCapsule");

	r32 dist_sq = zt_collisionSquareDistPointToSegment(sphere_pos, capsule_beg, capsule_end);
	r32 radius = sphere_radius + capsule_radius;
	return dist_sq < radius * radius;
}

// ================================================================================================================================================================================================

bool zt_collisionSpherePlane(const ztVec3 &sphere_pos, r32 sphere_radius, const ztPlane& plane)
{
	ZT_PROFILE_PHYSICS("zt_collisionSpherePlane");
	r32 dist = sphere_pos.dot(plane.normal) - plane.distance;
	return zt_abs(dist) <= sphere_radius;
}

// ================================================================================================================================================================================================

bool zt_collisionSphereSphere(const ztVec3 &sphere1_pos, r32 sphere1_radius, const ztVec3 &sphere2_pos, r32 sphere2_radius)
{
	ZT_PROFILE_PHYSICS("zt_collisionSphereSphere");
	ztVec3 diff = sphere2_pos - sphere1_pos;
	r32 rad = sphere2_radius + sphere1_radius;
	r32 c = diff.dot(diff) - (rad * rad);
	return (c < 0.0f);
}

// ================================================================================================================================================================================================

bool zt_collisionSphereInAABB(const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &aabb_center, const ztVec3 &aabb_extents)
{
	ZT_PROFILE_PHYSICS("zt_collisionSphereInAABB");
	r32 sq_dist = zt_collisionSquareDistPointToAABB(sphere_pos, aabb_center, aabb_extents);
	return sq_dist <= sphere_radius * sphere_radius;
}

// ================================================================================================================================================================================================

bool zt_collisionSphereInOBB(const ztVec3 &sphere_pos, r32 sphere_radius, const ztVec3 &obb_center, const ztVec3 &obb_extents, const ztQuat& obb_rot)
{
	ZT_PROFILE_PHYSICS("zt_collisionSphereInOBB");
	ztVec3 p = zt_closestPointOBBPoint(obb_center, obb_extents, obb_rot, sphere_pos);

	ztVec3 v = p - sphere_pos;

	if (v.dot(v) <= sphere_radius * sphere_radius) {
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionRaySphere(const ztVec3 &ray_pos, const ztVec3 &ray_dir, const ztVec3 &sphere_pos, r32 sphere_radius, r32 *intersection_time, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionRaySphere");

	ztVec3 m = ray_pos - sphere_pos;
	r32 b = m.dot(ray_dir);
	r32 c = m.dot(m) - sphere_radius * sphere_radius;

	if (c > 0.0f && b > 0.0f) {
		return false;
	}

	r32 discr = b * b - c;
	if (discr < 0.0f) {
		return false;
	}

	r32 intersection_time_lcl = -b - zt_sqrt(discr);

	if (intersection_time_lcl < 0.0f) {
		intersection_time_lcl = 0.0f;
	}

	if (intersection_time) *intersection_time = intersection_time_lcl;
	if (intersection_point) *intersection_point = ray_pos + ray_dir * intersection_time_lcl;

	return true;
}


// ================================================================================================================================================================================================

bool zt_collisionCircleInAABB(const ztVec2 &circle_pos, r32 circle_radius, const ztVec2 &aabb_center, const ztVec2 &aabb_extents)
{
	ZT_PROFILE_PHYSICS("zt_collisionCircleInAABB");

	return zt_collisionSphereInAABB(zt_vec3(circle_pos, 0), circle_radius, zt_vec3(aabb_center, 0), zt_vec3(aabb_extents, 1));
}

// ================================================================================================================================================================================================

bool zt_collisionLineSegmentSphere(const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &sphere_pos, r32 sphere_radius, r32 *intersection_time, ztVec3 *intersection_point)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineSegmentSphere");

	ztVec3 dist = line_end - line_beg;
	ztVec3 dir = dist.getNormal();

	r32 intersection_time_lcl;
	ztVec3 intersection_point_lcl;

	if (zt_collisionRaySphere(line_beg, dir, sphere_pos, sphere_radius, &intersection_time_lcl, &intersection_point_lcl)) {
		intersection_time_lcl = intersection_time_lcl / dist.length();

		if (intersection_time) *intersection_time = intersection_time_lcl;
		if (intersection_point) *intersection_point = intersection_point_lcl;

		return (intersection_time_lcl <= 1);
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_collisionLineSegmentCapsule(const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &capsule_beg, const ztVec3 &capsule_end, r32 capsule_radius, r32 *intersection_time)
{
	ZT_PROFILE_PHYSICS("zt_collisionLineSegmentCapsule");

	ztVec3 d = capsule_end - capsule_beg;
	ztVec3 m = line_beg - capsule_beg;
	ztVec3 n = line_end - line_beg;
	r32 md = m.dot(d);
	r32 nd = n.dot(d);
	r32 dd = d.dot(d);

	if (md < 0.0f && md + nd < 0.0f) {
		return zt_collisionLineSegmentSphere(line_beg, line_end, capsule_beg, capsule_radius, intersection_time);
	}
	if (md > dd && md + nd > dd) {
		return zt_collisionLineSegmentSphere(line_beg, line_end, capsule_end, capsule_radius, intersection_time);
	}

	r32 nn = n.dot(n);
	r32 mn = m.dot(n);
	r32 a = dd * nn - nd * nd;
	r32 k = m.dot(m) - capsule_radius * capsule_radius;
	r32 c = dd * k - md * md;
	if (zt_abs(a) < ztReal32Epsilon) {
		if (c > 0.0f) {
			return false;
		}

		if (md < 0.0f){
			if (intersection_time) zt_collisionLineSegmentSphere(line_beg, line_end, capsule_beg, capsule_radius, intersection_time);
		}
		else if (md > dd){
			if (intersection_time) zt_collisionLineSegmentSphere(line_beg, line_end, capsule_end, capsule_radius, intersection_time);
		}
		else {
			if (intersection_time) *intersection_time = 0.0f;
		}
		return true;
	}

	r32 b = dd * mn - nd * md;
	r32 discr = b * b - a * c;
	if (discr < 0.0f) {
		return false;
	}

	r32 t = (-b - zt_sqrt(discr)) / a;
	if (t < 0.0f || t > 1.0f) {
		return false;
	}

	if (md + t * nd < 0.0f) {
		return zt_collisionLineSegmentSphere(line_beg, line_end, capsule_beg, capsule_radius, intersection_time);
	}
	else if (md + t * nd > dd) {
		return zt_collisionLineSegmentSphere(line_beg, line_end, capsule_end, capsule_radius, intersection_time);
	}
	if (intersection_time) *intersection_time = t;

	return true;
}

// ================================================================================================================================================================================================

ztVec2 zt_closestPointLineSegmentPoint(const ztVec2 &line_beg, const ztVec2 &line_end, const ztVec2 &point)
{
	ztVec2 diff = line_end - line_beg;

	r32 t = (point - line_beg).dot(diff) / diff.dot(diff);

	if (t < .0f) t = 0;
	if (t > 1.f) t = 1.f;

	return line_beg + diff * t;
}

// ================================================================================================================================================================================================

ztVec3 zt_closestPointLineSegmentPoint(const ztVec3 &line_beg, const ztVec3 &line_end, const ztVec3 &point)
{
	ztVec3 diff = line_end - line_beg;

	r32 t = (point - line_beg).dot(diff) / diff.dot(diff);

	if (t < .0f) t = 0;
	if (t > 1.f) t = 1.f;

	return line_beg + diff * t;
}

// ================================================================================================================================================================================================

ztVec3 zt_closestPointAABBPoint(const ztVec3 &aabb_center, const ztVec3 &aabb_size, const ztVec3& point)
{
	ztVec3 out;

	zt_fiz(3) {
		r32 v = point.values[i];
		     if (v < aabb_center.values[i] - aabb_size.values[i] * .5f) out.values[i] = aabb_center.values[i] - aabb_size.values[i] * .5f;
		else if (v > aabb_center.values[i] + aabb_size.values[i] * .5f) out.values[i] = aabb_center.values[i] + aabb_size.values[i] * .5f;
		else out.values[i] = v;
	}

	return out;
}

// ================================================================================================================================================================================================

ztVec3 zt_closestPointOBBPoint(const ztVec3 &obb_center, const ztVec3 &obb_size, const ztQuat &obb_rot, const ztVec3& point)
{
	ztQuat to_local = obb_rot.getInverse();

	ztVec3 p = to_local.rotatePosition(point - obb_center);

	ztVec3 cp = zt_closestPointAABBPoint(ztVec3::zero, obb_size, p);
	obb_rot.rotatePosition(&cp);

	return cp + obb_center;
}

// ================================================================================================================================================================================================

ztVec3 zt_closestPointTrianglePoint(const ztVec3 &p1, const ztVec3 &p2, const ztVec3 &p3, const ztVec3& point)
{
	ztVec3 p2_1 = p2 - p1;
	ztVec3 p3_1 = p3 - p1;
	ztVec3 p3_2 = p3 - p2;

	ztVec3 pmp1 = point - p1;
	ztVec3 pmp2 = point - p2;
	ztVec3 pmp3 = point - p3;

	r32 snom = pmp1.dot(p2_1);
	r32 sdenom = pmp2.dot(p1 - p2);

	r32 tnom = pmp1.dot(p3_1);
	r32 tdenom = pmp3.dot(p1 - p3);

	if (snom <= 0.f && tnom <= 0.f) {
		return p1;
	}

	r32 unom = pmp2.dot(p3_2);
	r32 udenom = pmp3.dot(p1 - p3);

	if (sdenom <= 0.f && unom <= 0.f) return p2;
	if (tdenom <= 0.f && udenom <= 0.f) return p3;

	ztVec3 n = p2_1.cross(p3_1);

	r32 vc = n.dot( (p1 - point).cross(p2 - point));
	if (vc <= 0.f && snom >= 0.f && sdenom >= 0.f) {
		return p1 + snom / (snom + sdenom) * p2_1;
	}

	r32 va = n.dot( (p2 - point).cross(p3 - point) );
	if (va <= 0.f && unom >= 0.f && udenom >= 0.f) {
		return p2 + unom / (unom + udenom) * p3_2;
	}

	r32 vb = n.dot( (p3 - point).cross(p1 - point) );
	if (vb <= 0.f && tnom >= 0.f && tdenom >= 0.f) {
		return p1 + tnom / (tnom + tdenom) * p3_1;
	}

	r32 u = va / (va + vb + vc);
	r32 v = vb / (va + vb + vc);
	r32 w = 1.f - u - v;
	return u * p1 + v * p2 + w * p3;
}

// ================================================================================================================================================================================================

void zt_collisionResizeAABBToFitAABB(ztVec3 *aabb_center, ztVec3 *aabb_size, ztVec3 fit_aabb_center, ztVec3 fit_aabb_size)
{
	ztVec3 min = *aabb_center - (*aabb_size * .5);
	ztVec3 max = *aabb_center + (*aabb_size * .5);

	ztVec3 fmin = fit_aabb_center - (fit_aabb_size * .5f);
	ztVec3 fmax = fit_aabb_center + (fit_aabb_size * .5f);

	min.x = zt_min(min.x, fmin.x);
	min.y = zt_min(min.y, fmin.y);
	min.z = zt_min(min.z, fmin.z);

	max.x = zt_max(max.x, fmax.x);
	max.y = zt_max(max.y, fmax.y);
	max.z = zt_max(max.z, fmax.z);

	*aabb_center = (min + max) * .5f;
	*aabb_size = (max - min);
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseLinear, ZT_FUNC_TWEEN_EASE(zt_tweenEaseLinear))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseLinear");
	return value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseBack, ZT_FUNC_TWEEN_EASE(zt_tweenEaseBack))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseBack");
	return (value * value) * (2.70158f * value - 1.70158f);
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseBounce, ZT_FUNC_TWEEN_EASE(zt_tweenEaseBounce))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseBounce");
	if (1 - value < 1 / 2.75f) {
		value = 1 - 7.5625f * ((1 - value) * (1-value));
	}
	else if (1 - value < 2 / 2.75f) {
		value = 1 - (7.5625f * (1 - value - 1.5f / 2.75f) * (1 - value - 1.5f / 2.75f) + 0.75f);
	}
	else if (1 - value < 2.5 / 2.75) {
		value = 1 - (7.5625f * (1 - value - 2.25f / 2.75f) * (1 - value - 2.25f / 2.75f) + 0.9375f);
	}
	else {
		value = 1 - (7.5625f * (1 - value - 2.625f / 2.75f) * (1 - value - 2.625f / 2.75f) + 0.984375f);
	}

	return value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseCirc, ZT_FUNC_TWEEN_EASE(zt_tweenEaseCirc))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseCirc");
	return 1 - zt_sqrt(1 - (value * value));
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseCubic, ZT_FUNC_TWEEN_EASE(zt_tweenEaseCubic))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseCubic");
	return value * value * value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseElastic, ZT_FUNC_TWEEN_EASE(zt_tweenEaseElastic))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseElastic");
	if ( value == 0 || value == 1 ) return value;
	//return zt_sin(2.f * ztMathPi2 * value) * zt_pow(5, 2.f * (value - 1));
	return zt_pow(2.f, 12.f * (value - 1.f)) * zt_sin(value * (2.f * ztMathPi2) / .39f);
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseExpo, ZT_FUNC_TWEEN_EASE(zt_tweenEaseExpo))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseExpo");
	if ( value == 0 ) return 0;
	return zt_pow(2, 10 * (value - 1));
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseQuad, ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuad))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseQuad");
	return value * value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseQuart, ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuart))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseQuart");
	return value * value * value * value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseQuint, ZT_FUNC_TWEEN_EASE(zt_tweenEaseQuint))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseQuint");
	return value * value * value * value * value;
}

// ================================================================================================================================================================================================

ZT_FUNCTION_POINTER_REGISTER(zt_tweenEaseSine, ZT_FUNC_TWEEN_EASE(zt_tweenEaseSine))
{
	ZT_PROFILE_ANIMATION("zt_tweenEaseSine");
	return 1 - zt_cos(value * 3.14159f / 2);
}

// ================================================================================================================================================================================================

r32 zt_tweenValue(r32 val_beg, r32 val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out)
{
	return zt_tweenValue(val_beg, val_end, percent, ease_in, nullptr, ease_out, nullptr);
}

// ================================================================================================================================================================================================

r32 zt_tweenValue(r32 val_beg, r32 val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(r32)");
	if (ease_in && ease_out == nullptr) {
		percent = ease_in(percent, ease_in_user_data);
	}
	else if (ease_in == nullptr && ease_out) {
		percent = 1 - ease_out(1 - percent, ease_out_user_data);
	}
	else if (ease_in && ease_out) {
		if (percent < .5f) {
			percent = ease_in(2 * percent, ease_in_user_data) / 2.0f;
		}
		else if(percent > .5) {
			percent = .5f + .5f * (1 - ease_out(1 - (percent - .5f) * 2, ease_out_user_data));
		}
	}

	return zt_lerp(val_beg, val_end, percent);
}

// ================================================================================================================================================================================================

ztVec2 zt_tweenValue(const ztVec2 &val_beg, const ztVec2 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec2)");
	return zt_vec2(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_out));
}

// ================================================================================================================================================================================================

ztVec2 zt_tweenValue(const ztVec2 &val_beg, const ztVec2 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec2)");
	return zt_vec2(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data));
}

// ================================================================================================================================================================================================

ztVec3 zt_tweenValue(const ztVec3 &val_beg, const ztVec3 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec3)");
	return zt_vec3(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.z, val_end.z, percent, ease_in, ease_out));
}

// ================================================================================================================================================================================================

ztVec3 zt_tweenValue(const ztVec3 &val_beg, const ztVec3 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec3)");
	return zt_vec3(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.z, val_end.z, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data));
}

// ================================================================================================================================================================================================

ztVec4 zt_tweenValue(const ztVec4 &val_beg, const ztVec4 &val_end, r32 percent, ztTweenEase_Func *ease_in, ztTweenEase_Func *ease_out)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec4)");
	return zt_vec4(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.z, val_end.z, percent, ease_in, ease_out),
	               zt_tweenValue(val_beg.w, val_end.w, percent, ease_in, ease_out));
}

// ================================================================================================================================================================================================

ztVec4 zt_tweenValue(const ztVec4 &val_beg, const ztVec4 &val_end, r32 percent, ztTweenEase_Func *ease_in, void *ease_in_user_data, ztTweenEase_Func *ease_out, void *ease_out_user_data)
{
	ZT_PROFILE_ANIMATION("zt_tweenValue(ztVec4)");
	return zt_vec4(zt_tweenValue(val_beg.x, val_end.x, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.y, val_end.y, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.z, val_end.z, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data),
	               zt_tweenValue(val_beg.w, val_end.w, percent, ease_in, ease_in_user_data, ease_out, ease_out_user_data));
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void _zt_tweenItemMakeReal(ztTweenItem *tween_item, r32 beg_val, r32 end_val, r32 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func), ztAnimCurve *curve)
{
	ZT_PROFILE_ANIMATION("_zt_tweenItemMakeReal");
	zt_returnOnNull(tween_item);
	zt_returnOnNull(value);

	tween_item->type           = ztTweenItemType_Real;
	tween_item->real.value_beg = beg_val;
	tween_item->real.value_end = end_val;
	tween_item->real.value     = value;
	tween_item->flags          = flags;
	tween_item->length         = length;
	tween_item->time           = 0;
	tween_item->delay          = delay;
	tween_item->ease_in        = ease_in;
	tween_item->ease_out       = ease_out;
	tween_item->curve          = curve;

	if (delay == 0) {
		*value = beg_val;
	}
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, r32 beg_val, r32 end_val, r32 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func))
{
	_zt_tweenItemMakeReal(tween_item, beg_val, end_val, value, flags, length, delay, ease_in, ease_out, nullptr);
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, r32 beg_val, r32 end_val, r32 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve)
{
	_zt_tweenItemMakeReal(tween_item, beg_val, end_val, value, flags, length, delay, ZT_FUNCTION_POINTER_TO_VAR_NULL, ZT_FUNCTION_POINTER_TO_VAR_NULL, curve);
}

// ================================================================================================================================================================================================

void _zt_tweenItemMakeVec2(ztTweenItem *tween_item, ztVec2 beg_val, ztVec2 end_val, ztVec2 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func), ztAnimCurve *curve)
{
	ZT_PROFILE_ANIMATION("_zt_tweenItemMakeVec2");
	zt_returnOnNull(tween_item);
	zt_returnOnNull(value);

	tween_item->type           = ztTweenItemType_Vec2;
	tween_item->vec2.value_beg = beg_val;
	tween_item->vec2.value_end = end_val;
	tween_item->vec2.value     = value;
	tween_item->flags          = flags;
	tween_item->length         = length;
	tween_item->time           = 0;
	tween_item->delay          = delay;
	tween_item->ease_in        = ease_in;
	tween_item->ease_out       = ease_out;
	tween_item->curve          = curve;

	if (delay == 0) {
		*value = beg_val;
	}
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec2 beg_val, ztVec2 end_val, ztVec2 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func))
{
	_zt_tweenItemMakeVec2(tween_item, beg_val, end_val, value, flags, length, delay, ease_in, ease_out, nullptr);
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec2 beg_val, ztVec2 end_val, ztVec2 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve)
{
	_zt_tweenItemMakeVec2(tween_item, beg_val, end_val, value, flags, length, delay, ZT_FUNCTION_POINTER_TO_VAR_NULL, ZT_FUNCTION_POINTER_TO_VAR_NULL, curve);
}

// ================================================================================================================================================================================================

void _zt_tweenItemMakeVec3(ztTweenItem *tween_item, ztVec3 beg_val, ztVec3 end_val, ztVec3 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func), ztAnimCurve *curve)
{
	ZT_PROFILE_ANIMATION("_zt_tweenItemMakeVec3");
	zt_returnOnNull(tween_item);
	zt_returnOnNull(value);

	tween_item->type           = ztTweenItemType_Vec3;
	tween_item->vec3.value_beg = beg_val;
	tween_item->vec3.value_end = end_val;
	tween_item->vec3.value     = value;
	tween_item->flags          = flags;
	tween_item->length         = length;
	tween_item->time           = 0;
	tween_item->delay          = delay;
	tween_item->ease_in        = ease_in;
	tween_item->ease_out       = ease_out;
	tween_item->curve          = curve;

	if (delay == 0) {
		*value = beg_val;
	}
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec3 beg_val, ztVec3 end_val, ztVec3 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func))
{
	_zt_tweenItemMakeVec3(tween_item, beg_val, end_val, value, flags, length, delay, ease_in, ease_out, nullptr);
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec3 beg_val, ztVec3 end_val, ztVec3 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve)
{
	_zt_tweenItemMakeVec3(tween_item, beg_val, end_val, value, flags, length, delay, ZT_FUNCTION_POINTER_TO_VAR_NULL, ZT_FUNCTION_POINTER_TO_VAR_NULL, curve);
}

// ================================================================================================================================================================================================

void _zt_tweenItemMakeVec4(ztTweenItem *tween_item, ztVec4 beg_val, ztVec4 end_val, ztVec4 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func), ztAnimCurve *curve)
{
	ZT_PROFILE_ANIMATION("_zt_tweenItemMakeVec4");
	zt_returnOnNull(tween_item);
	zt_returnOnNull(value);

	tween_item->type           = ztTweenItemType_Vec4;
	tween_item->vec4.value_beg = beg_val;
	tween_item->vec4.value_end = end_val;
	tween_item->vec4.value     = value;
	tween_item->flags          = flags;
	tween_item->length         = length;
	tween_item->time           = 0;
	tween_item->delay          = delay;
	tween_item->ease_in        = ease_in;
	tween_item->ease_out       = ease_out;
	tween_item->curve          = curve;

	if (delay == 0) {
		*value = beg_val;
	}
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec4 beg_val, ztVec4 end_val, ztVec4 *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func))
{
	_zt_tweenItemMakeVec4(tween_item, beg_val, end_val, value, flags, length, delay, ease_in, ease_out, nullptr);
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztVec4 beg_val, ztVec4 end_val, ztVec4 *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve)
{
	_zt_tweenItemMakeVec4(tween_item, beg_val, end_val, value, flags, length, delay, ZT_FUNCTION_POINTER_TO_VAR_NULL, ZT_FUNCTION_POINTER_TO_VAR_NULL, curve);
}

// ================================================================================================================================================================================================

void _zt_tweenItemMakeQuat(ztTweenItem *tween_item, ztQuat beg_val, ztQuat end_val, ztQuat *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func), ztAnimCurve *curve)
{
	ZT_PROFILE_ANIMATION("_zt_tweenItemMakeQuat");
	zt_returnOnNull(tween_item);
	zt_returnOnNull(value);

	tween_item->type           = ztTweenItemType_Real;
	tween_item->quat.value_beg = beg_val;
	tween_item->quat.value_end = end_val;
	tween_item->quat.value     = value;
	tween_item->flags          = flags;
	tween_item->length         = length;
	tween_item->time           = 0;
	tween_item->delay          = delay;
	tween_item->ease_in        = ease_in;
	tween_item->ease_out       = ease_out;
	tween_item->curve          = curve;

	if (delay == 0) {
		*value = beg_val;
	}
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztQuat beg_val, ztQuat end_val, ztQuat *value, i32 flags, r32 length, r32 delay, ZT_FUNCTION_POINTER_VAR(ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_VAR(ease_out, ztTweenEase_Func))
{
	_zt_tweenItemMakeQuat(tween_item, beg_val, end_val, value, flags, length, delay, ease_in, ease_out, nullptr);
}

// ================================================================================================================================================================================================

void zt_tweenItemMake(ztTweenItem *tween_item, ztQuat beg_val, ztQuat end_val, ztQuat *value, i32 flags, r32 length, r32 delay, ztAnimCurve *curve)
{
	_zt_tweenItemMakeQuat(tween_item, beg_val, end_val, value, flags, length, delay, ZT_FUNCTION_POINTER_TO_VAR_NULL, ZT_FUNCTION_POINTER_TO_VAR_NULL, curve);
}

// ================================================================================================================================================================================================

r32 zt_tweenItemPercentComplete(ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemPercentComplete");
	zt_returnValOnNull(tween_item, 0);

	if (zt_bitIsSet(tween_item->flags, ztTweenItemFlags_Stopped)) {
		return 1;
	}

	if (tween_item->time < tween_item->delay) {
		return 0;
	}

	return (tween_item->time - tween_item->delay) / tween_item->length;
}

// ================================================================================================================================================================================================

bool zt_tweenItemIsComplete(ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemIsComplete");
	zt_returnValOnNull(tween_item, false);

	if (zt_bitIsSet(tween_item->flags, ztTweenItemFlags_Stopped)) {
		return true;
	}

	if (tween_item->time - tween_item->delay >= tween_item->length) {
		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

void zt_tweenItemStart(ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemStart");
	zt_returnOnNull(tween_item);

	tween_item->time = 0;
	zt_bitRemove(tween_item->flags, ztTweenItemFlags_Stopped);
	zt_bitRemove(tween_item->flags, ztTweenItemFlags_Paused);
}

// ================================================================================================================================================================================================

void zt_tweenItemPause(ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemPause");
	zt_returnOnNull(tween_item);

	tween_item->flags |= ztTweenItemFlags_Paused;
}

// ================================================================================================================================================================================================

void zt_tweenItemStop(ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemStop");
	zt_returnOnNull(tween_item);

	zt_bitRemove(tween_item->flags, ztTweenItemFlags_Paused);
	tween_item->flags |= ztTweenItemFlags_Stopped;
}

// ================================================================================================================================================================================================

void zt_tweenItemUpdate(ztTweenItem *tween_item, int tween_item_count, r32 dt)
{
	ZT_PROFILE_ANIMATION("zt_tweenItemUpdate");
	zt_returnOnNull(tween_item);

	zt_fiz(tween_item_count) {

		if (tween_item[i].type == ztTweenItemType_Invalid || zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_Paused) || zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_Stopped)) {
			continue;
		}

		if (zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_PingPongs) && zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_DirectionBack)) {
			tween_item[i].time -= dt;

			if (tween_item[i].time < 0) {
				zt_bitRemove(tween_item[i].flags, ztTweenItemFlags_DirectionBack);
				tween_item[i].time *= -1;
			}
		}
		else {
			tween_item[i].time += dt;

			if (tween_item[i].time - tween_item[i].delay >= tween_item[i].length) {
				if(zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_Loops)) {
					tween_item[i].time -= tween_item[i].length + tween_item[i].delay;
				}
				else if(zt_bitIsSet(tween_item[i].flags, ztTweenItemFlags_PingPongs)) {
					tween_item[i].time = tween_item[i].length - ((tween_item[i].time - tween_item[i].delay) - tween_item[i].length);
					tween_item[i].flags |= ztTweenItemFlags_DirectionBack;
				}
				else {
					tween_item[i].time = tween_item[i].length + tween_item[i].delay;
					tween_item[i].flags |= ztTweenItemFlags_Stopped;
				}
			}
		}

		r32 percent = zt_clamp(tween_item[i].time < tween_item[i].delay ? 0 : (tween_item[i].time - tween_item[i].delay) / tween_item[i].length, 0, 1);

		if (percent > 0 || tween_item[i].delay == 0) {
			switch (tween_item[i].type)
			{
				case ztTweenItemType_Real: {
					if (tween_item[i].curve) {
						*tween_item[i].real.value = zt_lerp(tween_item[i].real.value_beg, tween_item[i].real.value_end, zt_animCurveGetValue(tween_item[i].curve, percent));
					}
					else {
						*tween_item[i].real.value = zt_tweenValue(tween_item[i].real.value_beg, tween_item[i].real.value_end, percent, ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_out, ztTweenEase_Func));
					}
				} break;

				case ztTweenItemType_Vec2: {
					if (tween_item[i].curve) {
						*tween_item[i].vec2.value = ztVec2::lerp(tween_item[i].vec2.value_beg, tween_item[i].vec2.value_end, zt_animCurveGetValue(tween_item[i].curve, percent));
					}
					else {
						*tween_item[i].vec2.value = zt_tweenValue(tween_item[i].vec2.value_beg, tween_item[i].vec2.value_end, percent, ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_out, ztTweenEase_Func));
					}
				} break;

				case ztTweenItemType_Vec3: {
					if (tween_item[i].curve) {
						*tween_item[i].vec3.value = ztVec3::lerp(tween_item[i].vec3.value_beg, tween_item[i].vec3.value_end, zt_animCurveGetValue(tween_item[i].curve, percent));
					}
					else {
						*tween_item[i].vec3.value = zt_tweenValue(tween_item[i].vec3.value_beg, tween_item[i].vec3.value_end, percent, ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_out, ztTweenEase_Func));
					}
				} break;

				case ztTweenItemType_Vec4: {
					if (tween_item[i].curve) {
						*tween_item[i].vec4.value = ztVec4::lerp(tween_item[i].vec4.value_beg, tween_item[i].vec4.value_end, zt_animCurveGetValue(tween_item[i].curve, percent));
					}
					else {
						*tween_item[i].vec4.value = zt_tweenValue(tween_item[i].vec4.value_beg, tween_item[i].vec4.value_end, percent, ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_out, ztTweenEase_Func));
					}
				} break;

				case ztTweenItemType_Quat: {
					if (tween_item[i].curve) {
						*tween_item[i].quat.value = ztQuat::lerp(tween_item[i].quat.value_beg, tween_item[i].quat.value_end, zt_animCurveGetValue(tween_item[i].curve, percent));
					}
					else {
						tween_item[i].quat.value->xyzw = zt_tweenValue(tween_item[i].quat.value_beg.xyzw, tween_item[i].quat.value_end.xyzw, percent, ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_in, ztTweenEase_Func), ZT_FUNCTION_POINTER_ACCESS(tween_item[i].ease_out, ztTweenEase_Func));
					}
				} break;
			}
		}
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_tweenGroupMake(ztTweenGroup *tween_group, ztTweenItem *tween_items, int tween_items_count)
{
	ZT_PROFILE_ANIMATION("zt_tweenGroupMake");
	zt_returnOnNull(tween_group);
	zt_returnOnNull(tween_items);
	zt_assert(tween_items_count > 0 && tween_items_count < zt_elementsOf(tween_group->items));

	zt_fiz(tween_items_count) {
		zt_memCpy(&tween_group->items[i], zt_sizeof(ztTweenItem), &tween_items[i], zt_sizeof(ztTweenItem));
	}

	tween_group->items_count = tween_items_count;
}

// ================================================================================================================================================================================================

r32 zt_tweenGroupPercentComplete(ztTweenGroup *tween_group)
{
	ZT_PROFILE_ANIMATION("zt_tweenGroupPercentComplete");
	zt_returnValOnNull(tween_group, 0);

	r32 min_pct_complete = 1;

	zt_fiz(tween_group->items_count) {
		r32 pct_complete = zt_tweenItemPercentComplete(&tween_group->items[i]);
		if(pct_complete < min_pct_complete) {
			min_pct_complete = pct_complete;
		}
	}

	return min_pct_complete;
}

// ================================================================================================================================================================================================

bool zt_tweenGroupIsComplete(ztTweenGroup *tween_group)
{
	ZT_PROFILE_ANIMATION("zt_tweenGroupIsComplete");
	return zt_real32Eq(zt_tweenGroupPercentComplete(tween_group), 1.f);
}

// ================================================================================================================================================================================================

void zt_tweenGroupUpdate(ztTweenGroup *tween_group, int tween_group_count, r32 dt)
{
	ZT_PROFILE_ANIMATION("zt_tweenGroupUpdate");
	zt_returnOnNull(tween_group);

	zt_fiz(tween_group_count) {
		zt_tweenItemUpdate(tween_group[i].items, tween_group[i].items_count, dt);
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_tweenManagerMake(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerMake");
	zt_returnOnNull(tween_manager);
	zt_tweenManagerReset(tween_manager);
}

// ================================================================================================================================================================================================

void zt_tweenManagerReset(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerReset");
	zt_returnOnNull(tween_manager);
	zt_memSet(tween_manager, zt_sizeof(ztTweenManager), 0);
}

// ================================================================================================================================================================================================

ztTweenGroup *zt_tweenManagerGetTemporaryGroup(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerGetTemporaryGroup");
	zt_returnValOnNull(tween_manager, nullptr);

	zt_fize(tween_manager->groups) {
		if (!zt_bitIsSet(tween_manager->groups_flags[i], ztTweenManagerFlags_Claimed)) {
			tween_manager->groups_flags[i] |= ztTweenManagerFlags_Claimed | ztTweenManagerFlags_ReclaimOnceComplete;
			return &tween_manager->groups[i];
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

ztTweenGroup *zt_tweenManagerGetPermanentGroup(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerGetPermanentGroup");
	zt_returnValOnNull(tween_manager, nullptr);

	zt_fize(tween_manager->groups) {
		if (!zt_bitIsSet(tween_manager->groups_flags[i], ztTweenManagerFlags_Claimed)) {
			tween_manager->groups_flags[i] |= ztTweenManagerFlags_Claimed;
			return &tween_manager->groups[i];
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

void zt_tweenManagerReclaimGroup(ztTweenManager *tween_manager, ztTweenGroup *tween_group)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerReclaimGroup");
	zt_returnOnNull(tween_manager);
	zt_returnOnNull(tween_group);

	zt_fize(tween_manager->groups) {
		if (&tween_manager->groups[i] == tween_group) {
			zt_bitRemove(tween_manager->groups_flags[i], ztTweenManagerFlags_Claimed);
			return;
		}
	}

	zt_assert(false);
}

// ================================================================================================================================================================================================

ztTweenItem *zt_tweenManagerGetTemporaryItem(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerGetTemporaryItem");
	zt_returnValOnNull(tween_manager, nullptr);

	zt_fize(tween_manager->items) {
		if (!zt_bitIsSet(tween_manager->items_flags[i], ztTweenManagerFlags_Claimed)) {
			tween_manager->items_flags[i] |= ztTweenManagerFlags_Claimed |ztTweenManagerFlags_ReclaimOnceComplete;
			return &tween_manager->items[i];
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

ztTweenItem *zt_tweenManagerGetPermanentItem(ztTweenManager *tween_manager)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerGetPermanentItem");
	zt_returnValOnNull(tween_manager, nullptr);

	zt_fize(tween_manager->items) {
		if (!zt_bitIsSet(tween_manager->items_flags[i], ztTweenManagerFlags_Claimed)) {
			tween_manager->items_flags[i] |= ztTweenManagerFlags_Claimed;
			return &tween_manager->items[i];
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

void zt_tweenManagerReclaimItem(ztTweenManager *tween_manager, ztTweenItem *tween_item)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerReclaimItem");
	zt_returnOnNull(tween_manager);
	zt_returnOnNull(tween_item);

	zt_fize(tween_manager->items) {
		if (&tween_manager->items[i] == tween_item) {
			zt_bitRemove(tween_manager->groups_flags[i], ztTweenManagerFlags_Claimed);
			zt_bitRemove(tween_manager->groups_flags[i], ztTweenManagerFlags_ReclaimOnceComplete);
			return;
		}
	}

	zt_assert(false);
}

// ================================================================================================================================================================================================

void zt_tweenManagerUpdate(ztTweenManager *tween_manager, r32 dt)
{
	ZT_PROFILE_ANIMATION("zt_tweenManagerUpdate");
	zt_returnOnNull(tween_manager);

	zt_tweenGroupUpdate(tween_manager->groups, zt_elementsOf(tween_manager->groups), dt);
	zt_tweenItemUpdate(tween_manager->items, zt_elementsOf(tween_manager->items), dt);

	zt_fize(tween_manager->groups) {
		if (zt_bitIsSet(tween_manager->groups_flags[i], ztTweenManagerFlags_ReclaimOnceComplete)) {
			if (zt_tweenGroupIsComplete(&tween_manager->groups[i])) {
				tween_manager->groups_flags[i] = 0;
			}
		}
	}

	zt_fize(tween_manager->items) {
		if (zt_bitIsSet(tween_manager->items_flags[i], ztTweenManagerFlags_ReclaimOnceComplete)) {
			if (zt_tweenItemIsComplete(&tween_manager->items[i])) {
				tween_manager->items_flags[i] = 0;
			}
		}
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_variableCacheMake(ztVariableCache *cache, int max_variables)
{
	zt_returnOnNull(cache);
	cache->variables = zt_mallocStructArray(ztVariant, max_variables);
	cache->ids = zt_mallocStructArray(i32, max_variables);
	cache->frame_referenced = zt_mallocStructArray(i32, max_variables);
	cache->variables_count = max_variables;

	zt_fiz(max_variables) {
		cache->ids[i] = 0;
		cache->frame_referenced[i] = -1;
	}
}

// ================================================================================================================================================================================================

void zt_variableCacheFree(ztVariableCache *cache)
{
	if (cache == nullptr) {
		return;
	}

	zt_free(cache->variables);
	zt_free(cache->ids);
	zt_free(cache->frame_referenced);
	cache->variables_count = 0;
}

// ================================================================================================================================================================================================

ztInternal ztVariant *_zt_variableCacheFind(ztVariableCache *cache, i32 id)
{
	zt_fiz(cache->variables_count) {
		if (cache->ids[i] == id) {
			cache->frame_referenced[i] = zt_game->game_details.current_frame;
			return &cache->variables[i];
		}
	}

	return nullptr;
}

// ================================================================================================================================================================================================

ztInternal ztVariant *_zt_variableCacheNew(ztVariableCache *cache, i32 id)
{
	zt_fiz(cache->variables_count) {
		if (cache->ids[i] == 0) {
			cache->ids[i] = id;
			cache->frame_referenced[i] = zt_game->game_details.current_frame;
			return &cache->variables[i];
		}
	}

	zt_assert(false);
	return nullptr;
}

// ================================================================================================================================================================================================

ztInternal ztVariant *_zt_variableCacheFindOrNew(ztVariableCache *cache, i32 id, bool *is_new)
{
	zt_returnValOnNull(cache, nullptr);

	ztVariant *result = _zt_variableCacheFind(cache, id);
	if (result == nullptr) {
		result = _zt_variableCacheNew(cache, id);
		*is_new = true;
	}

	return result;
}

// ================================================================================================================================================================================================

#define _zt_variableCacheGetBody(FUNC) \
			if (frame_gap != ztVariableCacheFrameGapNone) { zt_variableCacheSetFrameGap(cache, id, frame_gap); } \
			ztVariant *result = _zt_variableCacheFind(cache, id); \
			if (result == nullptr) { \
				result = _zt_variableCacheNew(cache, id); \
				if (result == nullptr) { \
					return nullptr; \
				} \
				*result = FUNC(defval); \
			} \
			return result;

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVariant defval, i32 frame_gap)
{
	struct local {
		static ztVariant workaround(ztVariant variant) {
			return variant;
		}
	};

	_zt_variableCacheGetBody(local::workaround);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, r32 defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_r32);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, i32 defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_i32);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec2 defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_vec2);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec3 defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_vec3);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztVec4 defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_vec4);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, ztQuat defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_quat);
}

// ================================================================================================================================================================================================

ztVariant *zt_variableCacheGet(ztVariableCache *cache, i32 id, bool defval, i32 frame_gap)
{
	_zt_variableCacheGetBody(zt_variantMake_bool);
}

// ================================================================================================================================================================================================

#undef 	_zt_variableCacheGetBody

// ================================================================================================================================================================================================

bool zt_variableCacheSetFrameGap(ztVariableCache *cache, i32 id, i32 frames)
{
	zt_returnValOnNull(cache, true);

	zt_fiz(cache->variables_count) {
		if (cache->ids[i] == id) {
			if (zt_game->game_details.current_frame - cache->frame_referenced[i] > frames) {
				cache->ids[i] = 0;
				return true;
			}
			return false;
		}
	}

	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztTweenEase_Func *zt_animCurveFindEaseFunction(ztAnimCurveEaseType_Enum type)
{
	ZT_PROFILE_ANIMATION("zt_animCurveFindEaseFunction");
	switch (type)
	{
		case ztAnimCurveEaseType_Linear  : return zt_tweenEaseLinear;
		case ztAnimCurveEaseType_Back    : return zt_tweenEaseBack;
		case ztAnimCurveEaseType_Bounce  : return zt_tweenEaseBounce;
		case ztAnimCurveEaseType_Circ    : return zt_tweenEaseCirc;
		case ztAnimCurveEaseType_Cubic   : return zt_tweenEaseCubic;
		case ztAnimCurveEaseType_Elastic : return zt_tweenEaseElastic;
		case ztAnimCurveEaseType_Expo    : return zt_tweenEaseExpo;
		case ztAnimCurveEaseType_Quad    : return zt_tweenEaseQuad;
		case ztAnimCurveEaseType_Quart   : return zt_tweenEaseQuart;
		case ztAnimCurveEaseType_Quint   : return zt_tweenEaseQuint;
		case ztAnimCurveEaseType_Sine    : return zt_tweenEaseSine;
	}

	zt_assert(false);
	return nullptr;
}

// ================================================================================================================================================================================================

r32 zt_animCurveGetValue(ztAnimCurve *curve, r32 percent)
{
	ZT_PROFILE_ANIMATION("zt_animCurveGetValue");
	zt_returnValOnNull(curve, 0);
	zt_assertReturnValOnFail(percent >= 0 && percent <= 1, percent);

	switch (curve->type) {
		case ztAnimCurveType_Linear: {
			return zt_lerp(curve->val_beg, curve->val_end, percent);
		} break;

		case ztAnimCurveType_EaseIn: {
			ztTweenEase_Func *ease_in = zt_animCurveFindEaseFunction(curve->ease_in);
			if (ease_in) {
				return zt_lerp(curve->val_beg, curve->val_end, ease_in(percent, nullptr));
			}
		} break;

		case ztAnimCurveType_EaseOut: {
			ztTweenEase_Func *ease_out = zt_animCurveFindEaseFunction(curve->ease_out);
			if (ease_out) {
				return zt_lerp(curve->val_end, curve->val_beg, ease_out(1 - percent, nullptr));
			}
		} break;

		case ztAnimCurveType_EaseInOut: {
			ztTweenEase_Func *ease_in = zt_animCurveFindEaseFunction(curve->ease_in);
			ztTweenEase_Func *ease_out = zt_animCurveFindEaseFunction(curve->ease_out);

			return zt_tweenValue(curve->val_beg, curve->val_end, percent, ease_in, ease_out);
		} break;

		case ztAnimCurveType_Spline: {
			zt_fiz(curve->segments_count) {
				if (percent <= curve->segments[i].pos_end.x) {
					percent -= curve->segments[i].pos_beg.x;

					percent = percent / (curve->segments[i].pos_end.x - curve->segments[i].pos_beg.x);

					ztVec2 &beg = curve->segments[i].pos_beg;
					ztVec2 &end = curve->segments[i].pos_end;
					ztVec2 beg_cp = curve->segments[i].control_point_beg * zt_vec2(.5f, .25f) + beg;
					ztVec2 end_cp = curve->segments[i].control_point_end * zt_vec2(.5f, .25f) + end;

					ztVec2 curr_pnt = zt_pow(1 - percent, 3) * beg + 3 * percent * zt_pow(1 - percent, 2) * beg_cp + 3 * zt_pow(percent, 2) * (1 - percent) * end_cp + zt_pow(percent, 3) * end;
					return curr_pnt.y * curve->val_max; // zt_lerp(curve->val_beg, curve->val_end, curr_pnt.y);
				}
			}
		} break;
	}

	zt_assert(false);
	return 0;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztAnimCurve *curve)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 type = 0;
		if (!zt_serialRead(serial, &type)) return false;
		curve->type = (ztAnimCurveType_Enum)type;

		if (!zt_serialRead(serial, &curve->val_max)) return false;
		if (!zt_serialRead(serial, &curve->val_beg)) return false;
		if (!zt_serialRead(serial, &curve->val_end)) return false;

		switch (curve->type)
		{
			case ztAnimCurveType_Linear: {
				// ...
			} break;

			case ztAnimCurveType_EaseIn: 
			case ztAnimCurveType_EaseOut: 
			case ztAnimCurveType_EaseInOut: {
				i32 ease_in = 0, ease_out = 0;
				if (!zt_serialRead(serial, &ease_in)) return false;
				curve->ease_in = (ztAnimCurveEaseType_Enum)ease_in;

				if (!zt_serialRead(serial, &ease_out)) return false;
				curve->ease_out = (ztAnimCurveEaseType_Enum)ease_out;
			} break;

			case ztAnimCurveType_Spline: {
				if (!zt_serialRead(serial, &curve->segments_count)) return false;

				zt_fiz(curve->segments_count) {
					if (!zt_serialRead(serial, &curve->segments[i].pos_beg)) return false;
					if (!zt_serialRead(serial, &curve->segments[i].pos_end)) return false;
					if (!zt_serialRead(serial, &curve->segments[i].control_point_beg)) return false;
					if (!zt_serialRead(serial, &curve->segments[i].control_point_end)) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztAnimCurve *curve)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialWrite(serial, (i32)curve->type)) return false;

		if (!zt_serialWrite(serial, curve->val_max)) return false;
		if (!zt_serialWrite(serial, curve->val_beg)) return false;
		if (!zt_serialWrite(serial, curve->val_end)) return false;

		switch (curve->type)
		{
			case ztAnimCurveType_Linear: {
				// ...
			} break;

			case ztAnimCurveType_EaseIn: 
			case ztAnimCurveType_EaseOut: 
			case ztAnimCurveType_EaseInOut: {
				if (!zt_serialWrite(serial, curve->ease_in)) return false;
				if (!zt_serialWrite(serial, curve->ease_out)) return false;
			} break;

			case ztAnimCurveType_Spline: {
				if (!zt_serialWrite(serial, curve->segments_count)) return false;

				zt_fiz(curve->segments_count) {
					if (!zt_serialWrite(serial, curve->segments[i].pos_beg)) return false;
					if (!zt_serialWrite(serial, curve->segments[i].pos_end)) return false;
					if (!zt_serialWrite(serial, curve->segments[i].control_point_beg)) return false;
					if (!zt_serialWrite(serial, curve->segments[i].control_point_end)) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztAnimKey zt_animKeyMake(ztVariant value, r32 time)
{
	ZT_PROFILE_ANIMATION("zt_animKeyMake");
	ztAnimKey anim_key;
	anim_key.value   = value;
	anim_key.time = time;

	return anim_key;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztAnimLayer zt_animLayerMake(ztVariantPointer target, ztAnimKey *keys, int keys_count, const char *name)
{
	ZT_PROFILE_ANIMATION("zt_animLayerMake");
	ztAnimLayer layer;

	layer.target = target;

	if (name) {
		layer.name = zt_stringMakeFrom(name);
	}
	else {
		layer.name = nullptr;
	}

	layer.keys = zt_mallocStructArray(ztAnimKey, keys_count);
	layer.keys_count = keys_count;
	zt_fiz(keys_count) {
		layer.keys[i] = keys[i];
	}

	layer.state        = ztAnimLayerState_Sleeping;
	layer.current_key  = 0;
	layer.current_time = 0;
	layer.target_time  = 0;

	return layer;
}

// ================================================================================================================================================================================================

void zt_animLayerFree(ztAnimLayer *layer)
{
	ZT_PROFILE_ANIMATION("zt_animLayerFree");
	if (layer == nullptr) {
		return;
	}

	zt_free(layer->keys);

	if (layer->name) {
		zt_stringFree(layer->name);
		layer->name = nullptr;
	}
}

// ================================================================================================================================================================================================

ztInternal ztInline void _zt_animLayerTransitionInto(ztAnimLayer *layer, r32 transition_time)
{
	ZT_PROFILE_ANIMATION("_zt_animLayerTransitionInto");
	zt_variantAssignValue(&layer->value_beg, zt_variantMake(&layer->target));
	zt_variantAssignValue(&layer->value_end, layer->keys[0].value);
	layer->state        = ztAnimLayerState_Transitioning;
	layer->current_time = 0;
	layer->current_key  = -1;
	layer->target_time  = transition_time;
}

// ================================================================================================================================================================================================

ztInternal ztInline void _zt_animLayerStart(ztAnimLayer *layer)
{
	ZT_PROFILE_ANIMATION("_zt_animLayerStart");
	zt_variantAssignValue(&layer->value_beg, layer->keys[0].value);
	zt_variantAssignValue(&layer->value_end, layer->keys[0].value);
	zt_variantAssignValue(&layer->target, layer->keys[0].value);
	layer->state        = ztAnimLayerState_Playing;
	layer->current_time = 0;
	layer->current_key  = 0;
	layer->target_time  = layer->keys[0].time;
}

// ================================================================================================================================================================================================

ztInternal ztInline bool _zt_animLayerUpdate(ztAnimLayer *layer, r32 dt)
{
	ZT_PROFILE_ANIMATION("_zt_animLayerUpdate");
	if (layer->state == ztAnimLayerState_Sleeping) {
		return false;
	}

	layer->current_time += dt;

	zt_variantAssignValue(&layer->target, zt_variantLerp(&layer->value_beg, &layer->value_end, zt_min(1, layer->current_time / layer->target_time)));

	if (layer->current_time >= layer->target_time) {
		layer->current_time -= layer->target_time;

		if (layer->state == ztAnimLayerState_Transitioning) {
			_zt_animLayerStart(layer);
		}
		else {
			layer->current_key += 1;
			if (layer->current_key >= layer->keys_count) {
				layer->state = ztAnimLayerState_Sleeping;
				return false;
			}
			else {
				layer->target_time = layer->keys[layer->current_key].time;
			}

			zt_variantAssignValue(&layer->value_beg, zt_variantMake(&layer->target));
			zt_variantAssignValue(&layer->value_end, layer->keys[layer->current_key].value);

			if (layer->current_time >= layer->target_time) {
				_zt_animLayerUpdate(layer, 0);
			}
		}
	}

	return true;
}

// ================================================================================================================================================================================================

r32 zt_animLayerRunTime(ztAnimLayer *layer)
{
	ZT_PROFILE_ANIMATION("zt_animLayerRunTime");

	r32 total_time = 0;
	zt_fiz(layer->keys_count) {
		total_time += layer->keys[i].time;
	}

	return total_time;
}

// ================================================================================================================================================================================================

r32 zt_animLayerPercentComplete(ztAnimLayer *layer)
{
	ZT_PROFILE_ANIMATION("zt_animLayerPercentComplete");
	if (layer->state == ztAnimLayerState_Sleeping) {
		return 1.f;
	}

	r32 total_time = 0;
	r32 current_time = 0;
	zt_fiz(layer->keys_count) {
		total_time += layer->keys[i].time;
		if (i < layer->current_key) {
			current_time += layer->keys[i].time;
		}
		else if (i == layer->current_key) {
			current_time += layer->current_time;
		}
	}

	if (total_time == 0) {
		return 1.f;
	}

	return current_time / total_time;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztAnimSequence *zt_animSequenceMake(ztAnimSequenceType_Enum type, ztAnimLayer *layers, int layers_count, bool loops)
{
	ZT_PROFILE_ANIMATION("zt_animSequenceMake");
	ztAnimSequence *sequence = zt_mallocStruct(ztAnimSequence);

	sequence->type = type;

	sequence->layers = zt_mallocStructArray(ztAnimLayer, layers_count);
	sequence->layers_count = layers_count;
	zt_fiz(layers_count) {
		sequence->layers[i] = layers[i];
	}

	sequence->loops = loops;

	return sequence;
}

// ================================================================================================================================================================================================

void zt_animSequenceFree(ztAnimSequence *sequence)
{
	ZT_PROFILE_ANIMATION("zt_animSequenceFree");
	if (sequence == nullptr) {
		return;
	}
	zt_fiz(sequence->layers_count) {
		zt_animLayerFree(&sequence->layers[i]);
	}
	zt_free(sequence->layers);
	zt_free(sequence);
}

// ================================================================================================================================================================================================

r32 zt_animSequenceRunTime(ztAnimSequence *sequence)
{
	ZT_PROFILE_ANIMATION("zt_animSequenceRunTime");

	r32 max_length = 0;

	zt_fiz(sequence->layers_count) {
		r32 length = zt_animLayerRunTime(&sequence->layers[i]);
		max_length = zt_max(max_length, length);
	}

	return max_length;
}

// ================================================================================================================================================================================================

r32 zt_animSequencePercentComplete(ztAnimSequence *sequence)
{
	ZT_PROFILE_ANIMATION("zt_animSequencePercentComplete");

	r32 min_percent_complete = ztReal32Max;

	zt_fiz(sequence->layers_count) {
		r32 percent_complete = zt_animLayerPercentComplete(&sequence->layers[i]);
		min_percent_complete = zt_min(min_percent_complete, percent_complete);
	}

	return min_percent_complete;
}

// ================================================================================================================================================================================================

ztInternal void _zt_animSequenceStart(ztAnimSequence *sequence, bool transition, r32 transition_time)
{
	ZT_PROFILE_ANIMATION("_zt_animSequenceStart");
	if (transition) {
		zt_fiz(sequence->layers_count) {
			_zt_animLayerTransitionInto(&sequence->layers[i], transition_time);
		}
	}
	else {
		zt_fiz(sequence->layers_count) {
			_zt_animLayerStart(&sequence->layers[i]);
		}
	}
}

// ================================================================================================================================================================================================

ztInternal bool _zt_animSequenceUpdate(ztAnimSequence *sequence, r32 dt)
{
	ZT_PROFILE_ANIMATION("_zt_animSequenceUpdate");
	int layers_processed = 0;
	{
		ZT_PROFILE_ANIMATION("_zt_animSequenceUpdate:layer_loop");
		zt_fiz(sequence->layers_count) {
			ZT_PROFILE_ANIMATION("_zt_animSequenceUpdate:per_layer");
			if (sequence->layers[i].state == ztAnimLayerState_Sleeping) {
				continue;
			}

			if (_zt_animLayerUpdate(&sequence->layers[i], dt)) {
				layers_processed += 1;
			}
		}
	}
	{
		ZT_PROFILE_ANIMATION("_zt_animSequenceUpdate:loop_check");
		if (layers_processed == 0 && sequence->loops) {
			_zt_animSequenceStart(sequence, false, 0);
			return true;
		}
	}
	return layers_processed != 0;
}

// ================================================================================================================================================================================================

void zt_animSequenceSetPercentComplete(ztAnimSequence *sequence, r32 percent)
{
	ZT_PROFILE_ANIMATION("zt_animSequenceSetPercentComplete");
	int longest_layer_idx = -1;
	r32 longest_layer_time = -1;

	zt_fiz(sequence->layers_count) {
		r32 layer_time = zt_animLayerRunTime(&sequence->layers[i]);
		if (layer_time > longest_layer_time) {
			longest_layer_time = layer_time;
			longest_layer_idx = i;
		}
	}

	_zt_animSequenceStart(sequence, false, 0);
	_zt_animSequenceUpdate(sequence, longest_layer_time * percent);
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztAnimController *zt_animControllerMake(int max_sequences, int max_async)
{
	ZT_PROFILE_ANIMATION("zt_animControllerMake");
	ztAnimController *controller = zt_mallocStruct(ztAnimController);

	controller->sequences_name_hash = zt_mallocStructArray(i32, max_sequences);
	controller->sequences_name      = zt_mallocStructArray(ztString, max_sequences);
	controller->sequences           = zt_mallocStructArray(ztAnimSequence*, max_sequences);
	controller->sequences_size      = max_sequences;
	controller->sequences_count     = 0;

	controller->anim_sync           = nullptr;

	controller->anim_async_count = max_async;
	controller->anim_async = max_async > 0 ? zt_mallocStructArray(ztAnimSequence*, max_async) : nullptr;

	zt_fiz(max_async) {
		controller->anim_async[i] = nullptr;
	}

	controller->queued = 0;

	return controller;
}

// ================================================================================================================================================================================================

void zt_animControllerFree(ztAnimController *controller)
{
	ZT_PROFILE_ANIMATION("zt_animControllerFree");
	if (controller == nullptr) {
		return;
	}

	zt_fiz(controller->sequences_count) {
		zt_stringFree(controller->sequences_name[i], zt_memGetGlobalArena());
		zt_animSequenceFree(controller->sequences[i]);
	}

	if (controller->anim_async) {
		zt_free(controller->anim_async);
	}

	zt_free(controller->sequences);
	zt_free(controller->sequences_name);
	zt_free(controller->sequences_name_hash);
	zt_free(controller);
}

// ================================================================================================================================================================================================

i32 zt_animControllerAddSequence(ztAnimController *controller, const char *sequence_name, ztAnimSequence *sequence)
{
	ZT_PROFILE_ANIMATION("zt_animControllerAddSequence");
	zt_returnValOnNull(controller, -1);
	zt_returnValOnNull(sequence_name, -1);
	zt_returnValOnNull(sequence, -1);
	zt_assertReturnValOnFail(sequence->layers_count > 0, -1);

	if (controller->sequences_count >= controller->sequences_size) {
		return -1;
	}

	int idx = controller->sequences_count++;
	controller->sequences          [idx] = sequence;
	controller->sequences_name     [idx] = zt_stringMakeFrom(sequence_name, zt_memGetGlobalArena());
	controller->sequences_name_hash[idx] = zt_strHash(sequence_name);

	return controller->sequences_name_hash[idx];
}

// ================================================================================================================================================================================================

int zt_animControllerStartSequence(ztAnimController *controller, i32 sequence_name_hash, r32 transition_time)
{
	ZT_PROFILE_ANIMATION("zt_animControllerStartSequence");
	ztAnimSequence *sequence = nullptr;

	int result = -1;
	zt_fiz(controller->sequences_count) {
		if (controller->sequences_name_hash[i] == sequence_name_hash) {
			sequence = controller->sequences[i];
			result = i;
			break;
		}
	}

	if (!sequence) return -1;

	if (sequence->type == ztAnimSequenceType_Synchronous) {
		controller->anim_sync = sequence;
	}
	else if (sequence->type == ztAnimSequenceType_Asynchronous) {
		int idx = -1;
		zt_fxz(3) {
			r32 most_complete = 0;
			zt_fiz(controller->anim_async_count) {
				r32 pct = controller->anim_async[i] == nullptr ? 1 : zt_animSequencePercentComplete(controller->anim_async[i]);

				if (x == 0 && pct == 1) {
					idx = i;
					break;
				}
				else if (x == 1 && controller->anim_async[i]->layers[0].state == ztAnimLayerState_Transitioning) {
					if (1 - pct > most_complete) {
						most_complete = 1 - pct;
						idx = i;
					}
				}
				else if (x == 2) {
					if (pct > most_complete) {
						most_complete = pct;
						idx = i;
					}
				}
			}
			if (idx != -1) {
				controller->anim_async[idx] = sequence;
				break;
			}
		}
		if (idx == -1) {
			return -1;
		}
	}

	_zt_animSequenceStart(sequence, transition_time > 0.0001f, transition_time);

	return result;
}

// ================================================================================================================================================================================================

void zt_animControllerUpdate(ztAnimController **controllers, int controllers_count, r32 dt)
{
	ZT_PROFILE_ANIMATION("zt_animControllerUpdate");
	zt_fvz(cidx, controllers_count) {
		ztAnimController *controller = controllers[cidx];

		if (controller->anim_sync) {
			if (!_zt_animSequenceUpdate(controller->anim_sync, dt)) {
				//zt_logDebug("Starting sequence: %s", controller->sequences_name[result]);
				if (controller->queued != 0) {
					i32 queued = controller->queued;
					controller->queued = 0;
					zt_animControllerStartSequence(controller, queued, 0);
				}
				else {
					controller->anim_sync = nullptr;
				}
			}
		}

		zt_fiz(controller->anim_async_count) {
			if (controller->anim_async[i] == nullptr) {
				continue;
			}
			if (!_zt_animSequenceUpdate(controller->anim_async[i], dt)) {
				controller->anim_async[i] = nullptr;
			}
		}
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztSpriteAnimController *zt_spriteAnimControllerMake(int max_sequences)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerMake");
	ztSpriteAnimController *controller = zt_mallocStruct(ztSpriteAnimController);
	controller->sequences = zt_mallocStructArray(ztSpriteAnimController::Sequence, max_sequences);
	controller->sequences_size = max_sequences;
	controller->sequences_count = 0;

	controller->controller = zt_animControllerMake(max_sequences, 0);

	return controller;
}

// ================================================================================================================================================================================================

void zt_spriteAnimControllerFree(ztSpriteAnimController *controller)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerFree");
	if (controller == nullptr) {
		return;
	}

	zt_animControllerFree(controller->controller);

	zt_fiz(controller->sequences_count) {
		zt_free(controller->sequences[i].sprites);
	}

	zt_free(controller->sequences);
	zt_free(controller);
}

// ================================================================================================================================================================================================

void zt_spriteAnimControllerAddSequence(ztSpriteAnimController *controller, const char *sequence_name, ztSprite *sprites, r32 *times, int sprites_count, bool loops)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerAddSequence");
	zt_returnOnNull(controller);
	zt_returnOnNull(sequence_name);
	zt_returnOnNull(sprites);
	zt_returnOnNull(times);
	zt_assertReturnOnFail(sprites_count > 0);
	zt_assertReturnOnFail(controller->sequences_count < controller->sequences_size);

	ztSpriteAnimController::Sequence *sequence = &controller->sequences[controller->sequences_count++];

	ztAnimKey *keys = zt_mallocStructArray(ztAnimKey, sprites_count + 1);
	keys[0] = zt_animKeyMake(zt_variantMake_i32(0), 0);
	zt_fiz(sprites_count) {
		keys[i+1] = zt_animKeyMake(zt_variantMake_i32(i+1), times[i]);
	}

	ztAnimLayer layer = zt_animLayerMake(zt_variantPointerMake_i32(&sequence->current_sprite), keys, sprites_count + 1);

	zt_free(keys);

	ztAnimSequence *a_sequence = zt_animSequenceMake(ztAnimSequenceType_Synchronous, &layer, 1, loops);
	zt_animControllerAddSequence(controller->controller, sequence_name, a_sequence);

	sequence->sprites = zt_mallocStructArray(ztSprite, sprites_count);
	sequence->sprites_size = sprites_count;
	sequence->current_sprite = -1;

	zt_fiz(sprites_count) {
		sequence->sprites[i] = sprites[i];
	}
}

// ================================================================================================================================================================================================

void zt_spriteAnimControllerStartSequence(ztSpriteAnimController *controller, i32 sequence_name_hash)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerStartSequence");
	zt_returnOnNull(controller);

	int active = zt_animControllerStartSequence(controller->controller, sequence_name_hash, 0);
	if (active == -1 ) {
		return;
	}

	controller->active_sequence = active;
	controller->sequences[active].current_sprite = 0;
	return;
}

// ================================================================================================================================================================================================

void zt_spriteAnimControllerUpdate(ztSpriteAnimController **controllers, int controllers_count, r32 dt)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerUpdate");
	zt_fiz(controllers_count) {
		//zt_animControllerUpdate(&controllers[i]->controller, 1, dt);

		if (controllers[i]->active_sequence >= 0 && controllers[i]->active_sequence < controllers[i]->sequences_count) {

			ztSpriteAnimController::Sequence *sequence = &controllers[i]->sequences[controllers[i]->active_sequence];

			if (sequence->current_sprite >= 0 && sequence->current_sprite < sequence->sprites_size) {
				zt_animControllerUpdate(&controllers[i]->controller, 1, dt);
			}
		}
	}
}

// ================================================================================================================================================================================================

bool zt_spriteAnimControllerIsActive(ztSpriteAnimController *controller)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerIsActive");
	if (controller->active_sequence < 0 || controller->active_sequence >= controller->sequences_count) {
		return false;
	}

	ztSpriteAnimController::Sequence *sequence = &controller->sequences[controller->active_sequence];

	if (sequence->current_sprite < 0 || sequence->current_sprite >= sequence->sprites_size) {
		return false;
	}

	return true;
}

// ================================================================================================================================================================================================

ztSprite *zt_spriteAnimControllerActiveSprite(ztSpriteAnimController *controller)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerActiveSprite");
	if (controller->active_sequence < 0 || controller->active_sequence >= controller->sequences_count) {
		return nullptr;
	}

	ztSpriteAnimController::Sequence *sequence = &controller->sequences[controller->active_sequence];

	if (sequence->current_sprite < 0 || sequence->current_sprite >= sequence->sprites_size) {
		if (sequence->sprites_size <= 0) {
			return nullptr;
		}
		return &sequence->sprites[0];
	}

	return &sequence->sprites[sequence->current_sprite];
}

// ================================================================================================================================================================================================

r32 zt_spriteAnimControllerActiveSequencePercentComplete(ztSpriteAnimController *controller)
{
	ZT_PROFILE_ANIMATION("zt_spriteAnimControllerActiveSequencePercentComplete");
	if (controller->active_sequence < 0 || controller->active_sequence >= controller->sequences_count) {
		return 1;
	}

	ztAnimLayer *layer = &controller->controller->sequences[controller->active_sequence]->layers[0];
	r32 total_time = 0;
	r32 current_time = 0;
	zt_fiz(layer->keys_count) {
		total_time += layer->keys[i].time;

		if(layer->current_key == i) {
			current_time += layer->current_time;
		}
		else if(i < layer->current_key) {
			current_time += layer->keys[i].time;
		}
	}

	return current_time / total_time;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_spriteAnimManagerMake(ztSpriteAnimManager *anim_manager, int max_sequences)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerMake");
	zt_returnOnNull(anim_manager);
	zt_assertReturnOnFail(max_sequences > 0);

	anim_manager->sequences = zt_mallocStructArray(ztSpriteAnimManager::Entry, max_sequences);
	anim_manager->sequences_count = max_sequences;

	zt_fiz(max_sequences) {
		anim_manager->sequences[i].hash = 0;
		anim_manager->sequences[i].name[0] = 0;
		anim_manager->sequences[i].sprite_count = 0;
		anim_manager->sequences[i].length = 0;
		anim_manager->sequences[i].loops = false;

		zt_fjz(ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES) {
			anim_manager->sequences[i].sprite_hash[j] = 0;
			anim_manager->sequences[i].sprite_prop[j] = 1;
		}
	}
}

// ================================================================================================================================================================================================

bool zt_spriteAnimManagerLoad(ztSpriteAnimManager *anim_manager, ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerLoad");
	zt_returnValOnNull(anim_manager, false);
	zt_returnValOnNull(asset_mgr, false);
	if (asset_id == ztInvalidID) {
		return false;
	}
	zt_assertReturnValOnFail(asset_id >= 0 && asset_id < asset_mgr->asset_count, false);

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return false;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return false;
	}

	const char *error = nullptr;

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size, true)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	ztSerial serial;
	if (!zt_serialMakeReader(&serial, data, size, ZT_SPRITE_ANIM_FILE_GUID)) {
		goto on_error;
	}

	if (!zt_spriteAnimManagerLoad(anim_manager, &serial)) {
		zt_serialClose(&serial);
		goto on_error;
	}

	zt_serialClose(&serial);
	zt_freeArena(data, asset_mgr->arena);
	return true;

on_error:
	zt_logCritical(error);
	zt_freeArena(data, asset_mgr->arena);
	return false;
}

// ================================================================================================================================================================================================

bool zt_spriteAnimManagerLoad(ztSpriteAnimManager *anim_manager, ztSerial *serial)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerLoad");
	zt_returnValOnNull(anim_manager, false);
	zt_returnValOnNull(serial, false);

#	define _serialCheck(CODE) if(!CODE) return false;

	_serialCheck(zt_serialGroupPush(serial));
	{
		int idx = 0;
		zt_fiz(anim_manager->sequences_count) {
			if (anim_manager->sequences[i].hash == 0) {
				idx = i;
				break;
			}
		}

		while(true) {
			_serialCheck(zt_serialGroupPush(serial));
			{
				i32 hash = 0;
				_serialCheck(zt_serialRead(serial, &hash));

				if (hash == 0) {
					_serialCheck(zt_serialGroupPop(serial));
					break;
				}
				if (idx >= anim_manager->sequences_count) {
					_serialCheck(zt_serialGroupPop(serial));
					break;
				}

				_serialCheck(zt_serialRead(serial, anim_manager->sequences[idx].name, zt_elementsOf(anim_manager->sequences[idx].name), nullptr));
				_serialCheck(zt_serialRead(serial, &anim_manager->sequences[idx].sprite_count));
				_serialCheck(zt_serialRead(serial, &anim_manager->sequences[idx].length));
				_serialCheck(zt_serialRead(serial, &anim_manager->sequences[idx].loops));

				anim_manager->sequences[idx].hash = zt_strHash(anim_manager->sequences[idx].name);

				_serialCheck(zt_serialGroupPush(serial));
				{
					zt_fiz(zt_min(anim_manager->sequences[idx].sprite_count, ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES)) {
						_serialCheck(zt_serialGroupPush(serial));
						{
							_serialCheck(zt_serialRead(serial, &anim_manager->sequences[idx].sprite_hash[i]));
							_serialCheck(zt_serialRead(serial, &anim_manager->sequences[idx].sprite_prop[i]));
						}
						_serialCheck(zt_serialGroupPop(serial));
					}
				}
				_serialCheck(zt_serialGroupPop(serial));

				idx += 1;
			}
			_serialCheck(zt_serialGroupPop(serial));
		}
	}
	_serialCheck(zt_serialGroupPop(serial));

#	undef _serialCheck

	return true;}

// ================================================================================================================================================================================================

bool zt_spriteAnimManagerSave(ztSpriteAnimManager *anim_manager, ztSerial *serial)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerSave");
	zt_returnValOnNull(anim_manager, false);
	zt_returnValOnNull(serial, false);

#	define _serialCheck(CODE) if(!CODE) return false;

	_serialCheck(zt_serialGroupPush(serial));
	{
		zt_fiz(anim_manager->sequences_count) {
			if (anim_manager->sequences[i].hash != 0) {
				_serialCheck(zt_serialGroupPush(serial));
				{
					_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].hash));
					_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].name, zt_elementsOf(anim_manager->sequences[i].name)));
					_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].sprite_count));
					_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].length));
					_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].loops));

					_serialCheck(zt_serialGroupPush(serial));
					{
						zt_fjz(anim_manager->sequences[i].sprite_count) {
							_serialCheck(zt_serialGroupPush(serial));
							{
								_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].sprite_hash[j]));
								_serialCheck(zt_serialWrite(serial, anim_manager->sequences[i].sprite_prop[j]));
							}
							_serialCheck(zt_serialGroupPop(serial));
						}
					}
					_serialCheck(zt_serialGroupPop(serial));
				}
				_serialCheck(zt_serialGroupPop(serial));
			}
		}

		_serialCheck(zt_serialGroupPush(serial));
		{
			_serialCheck(zt_serialWrite(serial, 0)); // indicates end of file
		}
		_serialCheck(zt_serialGroupPop(serial));
	}
	_serialCheck(zt_serialGroupPop(serial));

#	undef _serialCheck

	return true;
}

// ================================================================================================================================================================================================

void zt_spriteAnimManagerFree(ztSpriteAnimManager *anim_manager)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerFree");
	if (anim_manager == nullptr || anim_manager->sequences == nullptr) {
		return;
	}

	zt_free(anim_manager->sequences);
	anim_manager->sequences = nullptr;
	anim_manager->sequences_count = 0;
}

// ================================================================================================================================================================================================

void zt_spriteAnimManagerAddSequence(ztSpriteAnimManager *anim_manager, const char *name, i32 *sprite_hash, int *sprite_prop, int sprites,  r32 length, bool loops)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerAddSequence");
	zt_returnOnNull(anim_manager);
	zt_returnOnNull(sprite_hash);
	zt_returnOnNull(sprite_prop);
	zt_assertReturnOnFail(name != nullptr);

	i32 sequence_hash = zt_strHash(name);

	int idx = -1;
	zt_fiz(anim_manager->sequences_count) {
		if(idx < 0 && anim_manager->sequences[i].hash == 0) {
			idx = i;
			break;
		}
		if(anim_manager->sequences[i].hash == sequence_hash) {
			idx = i;
			break;
		}
	}

	if (idx < 0) {
		zt_assert(false);
		return;
	}

	zt_strCpy(anim_manager->sequences[idx].name, zt_elementsOf(anim_manager->sequences[idx].name), name);
	anim_manager->sequences[idx].hash = sequence_hash;
	anim_manager->sequences[idx].sprite_count = sprites;
	anim_manager->sequences[idx].length = length;
	anim_manager->sequences[idx].loops = loops;

	zt_fiz(zt_min(sprites, ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES)) {
		anim_manager->sequences[idx].sprite_hash[i] = sprite_hash[i];
		anim_manager->sequences[idx].sprite_prop[i] = sprite_prop[i];
	}
}

// ================================================================================================================================================================================================

bool zt_spriteAnimManagerLoadSequence(ztSpriteAnimManager *anim_manager, ztSpriteManager *sprite_manager, ztSpriteAnimController *anim_controller, const char *name)
{
	ZT_PROFILE_RENDERING("zt_spriteAnimManagerLoadSequence");
	zt_returnValOnNull(anim_manager, false);
	zt_returnValOnNull(sprite_manager, false);
	zt_returnValOnNull(anim_controller, false);
	zt_assertReturnValOnFail(name != nullptr, false);

	i32 hash = zt_strHash(name);

	zt_fiz(anim_manager->sequences_count) {
		if(anim_manager->sequences[i].hash == hash) {

			ztSprite sprites[ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES];
			r32      times  [ZT_SPRITE_ANIM_MANAGER_MAX_SPRITES];

			int total_prop = 0;
			zt_fjz(anim_manager->sequences[i].sprite_count) {
				ztSprite *sprite = zt_spriteManagerGetSprite(sprite_manager, anim_manager->sequences[i].sprite_hash[j]);
				if (sprite) {
					total_prop += anim_manager->sequences[i].sprite_prop[j];
					sprites[j] = *sprite;
				}
				else {
					zt_logCritical("sprite manager is missing sprite hash %d for sequence %s", anim_manager->sequences[i].sprite_hash[j], anim_manager->sequences[i].name);
					sprites[j] = zt_spriteMake(ztTextureDefault, 0, 0, 1, 1);
				}
			}

			r32 time_per_prop = anim_manager->sequences[i].length / total_prop;
			zt_fjz(anim_manager->sequences[i].sprite_count) {
				times[j] = anim_manager->sequences[i].sprite_prop[j] * time_per_prop;
			}

			zt_spriteAnimControllerAddSequence(anim_controller, name, sprites, times, anim_manager->sequences[i].sprite_count, anim_manager->sequences[i].loops);
			return true;
		}
	}

	return false;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztColor zt_colorGradientGetValue(ztColorGradient *color_gradient, r32 percent)
{
	ztColor result = zt_color(1,1,1,1);
	zt_colorGradientGetValue(color_gradient, percent, &result);
	return result;
}

// ================================================================================================================================================================================================

void zt_colorGradientGetValue(ztColorGradient *color_gradient, r32 percent, ztColor *color)
{
	ZT_PROFILE_PARTICLES("zt_colorGradientGetValue");
	zt_returnOnNull(color_gradient);
	zt_returnOnNull(color);

	i32 total_prop = 0;
	zt_fiz(color_gradient->colors_count) {
		total_prop += color_gradient->colors[i].proportion;
	}

	r32 this_prop = zt_clamp(percent, 0, 1) * total_prop;
	r32 curr_prop = 0;
	for (int j = 1; j < color_gradient->colors_count; ++j) {
		r32 next_prop = curr_prop + (r32)color_gradient->colors[j - 1].proportion;
		if (this_prop < next_prop) {
			r32 pct = (this_prop - curr_prop) / (next_prop - curr_prop);
			*color = ztVec4::lerp(color_gradient->colors[j - 1].color, color_gradient->colors[j].color, pct);
			return;
		}
		curr_prop = next_prop;
	}

	if (color_gradient->colors_count == 0) {
		*color = ztColor_White;
	}
	else {
		*color = color_gradient->colors[color_gradient->colors_count - 1].color;
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztColor zt_colorGradientColorAtLocation(ztColorGradient2 *gradient, r32 location)
{
	zt_returnValOnNull(gradient, ztColor_White);

	if (location < 0 || location > 1) {
		location = zt_clamp(location, 0, 1);
	}

	ztColor result = gradient->color_vals[0];
	r32 current_loc = 0;
	zt_fiz(gradient->color_entries) {
		if (location <= gradient->color_locs[i]) {
			if (gradient->color_locs[i] == 0) {
				return result;
			}

			r32 pct_of_sec = (location - current_loc) / (gradient->color_locs[i] - current_loc);
			return ztVec4::lerp(result, gradient->color_vals[i], pct_of_sec);
		}
		current_loc = gradient->color_locs[i];
		result = gradient->color_vals[i];
	}

	return result;
}

// ================================================================================================================================================================================================

r32 zt_colorGradientAlphaAtLocation(ztColorGradient2 *gradient, r32 location)
{
	zt_returnValOnNull(gradient, 1);

	if (location < 0 || location > 1) {
		location = zt_clamp(location, 0, 1);
	}

	r32 result = gradient->alpha_vals[0];
	r32 current_loc = 0;
	zt_fiz(gradient->alpha_entries) {
		if (location <= gradient->alpha_locs[i]) {
			if (gradient->alpha_locs[i] == 0) {
				return result;
			}

			r32 pct_of_sec = (location - current_loc) / (gradient->alpha_locs[i] - current_loc);
			return zt_lerp(result, gradient->alpha_vals[i], pct_of_sec);
		}
		current_loc = gradient->alpha_locs[i];
		result = gradient->alpha_vals[i];
	}

	return result;
}

// ================================================================================================================================================================================================

ztColor zt_colorGradientGetValue(ztColorGradient2 *gradient, r32 location)
{
	return zt_vec4(zt_colorGradientColorAtLocation(gradient, location).xyz, zt_colorGradientAlphaAtLocation(gradient, location));
}

// ================================================================================================================================================================================================

void zt_colorGradientGetValue(ztColorGradient2 *gradient, r32 location, ztColor *color)
{
	color->xyz = zt_colorGradientColorAtLocation(gradient, location).xyz;
	color->a   = zt_colorGradientAlphaAtLocation(gradient, location);
}

// ================================================================================================================================================================================================

int zt_colorGradientGetColors(ztColorGradient2 *gradient, ztColor *colors, r32 *locations, int colors_count)
{
	zt_returnValOnNull(gradient, 0);
	zt_returnValOnNull(colors, 0);
	zt_returnValOnNull(locations, 0);

	struct Entry
	{
		r32    location;
		ztVec3 color;
		r32    alpha;

		static int compare(const void *vone, const void *vtwo)
		{
			Entry *e1 = (Entry*)vone;
			Entry *e2 = (Entry*)vtwo;

			if (e1->location < e2->location) return -1;
			if (e1->location > e2->location) return  1;
			return 0;
		}
	};

	Entry entries[ZT_COLOR_GRADIENT_MAX_VALUES * 2];
	int entries_idx = 0;

	zt_fiz(gradient->alpha_entries) {
		// see if this location exists in color, if so, skip
		bool exists_in_color = false;
		zt_fjz(gradient->color_entries) {
			if (zt_real32Eq(gradient->alpha_locs[i], gradient->color_locs[j])) {
				exists_in_color = true;
				break;
			}
		}
		if (!exists_in_color) {
			Entry *entry = &entries[entries_idx++];
			entry->alpha = gradient->alpha_vals[i];
			entry->color = zt_colorGradientColorAtLocation(gradient, gradient->alpha_locs[i]).xyz;
			entry->location = gradient->alpha_locs[i];
		}
	}

	zt_fiz(gradient->color_entries) {
		Entry *entry = &entries[entries_idx++];
		entry->alpha = zt_colorGradientAlphaAtLocation(gradient, gradient->color_locs[i]);
		entry->color = gradient->color_vals[i].xyz;
		entry->location = gradient->color_locs[i];
	}

	qsort(entries, entries_idx, sizeof(Entry), Entry::compare);

	zt_fiz(zt_min(entries_idx, colors_count)) {
		colors[i] = zt_color(entries[i].color, entries[i].alpha);
		locations[i] = entries[i].location;
	}

	return entries_idx;
}

// ================================================================================================================================================================================================

bool zt_colorGradientIsEqual(ztColorGradient2 *grad1, ztColorGradient2 *grad2)
{
	zt_returnValOnNull(grad1, false);
	zt_returnValOnNull(grad2, false);

	if (grad1->color_entries != grad2->color_entries || grad1->alpha_entries != grad2->alpha_entries) {
		return false;
	}

	zt_fiz(grad1->color_entries) {
		if (grad1->color_vals[i] != grad2->color_vals[i]) {
			return false;
		}
		if (!zt_real32Eq(grad1->color_locs[i], grad2->color_locs[i])) {
			return false;
		}
	}

	zt_fiz(grad1->alpha_entries) {
		if (grad1->alpha_vals[i] != grad2->alpha_vals[i]) {
			return false;
		}
		if (!zt_real32Eq(grad1->alpha_locs[i], grad2->alpha_locs[i])) {
			return false;
		}
	}

	return true;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztColorGradient2 *gradient)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialRead(serial, &gradient->alpha_entries)) return false;
		zt_fiz(gradient->alpha_entries) {
			if (!zt_serialRead(serial, &gradient->alpha_vals[i])) return false;
			if (!zt_serialRead(serial, &gradient->alpha_locs[i])) return false;
		}

		if (!zt_serialRead(serial, &gradient->color_entries)) return false;
		zt_fiz(gradient->color_entries) {
			if (!zt_serialRead(serial, &gradient->color_vals[i])) return false;
			if (!zt_serialRead(serial, &gradient->color_locs[i])) return false;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztColorGradient2 *gradient)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialWrite(serial, gradient->alpha_entries)) return false;
		zt_fiz(gradient->alpha_entries) {
			if (!zt_serialWrite(serial, gradient->alpha_vals[i])) return false;
			if (!zt_serialWrite(serial, gradient->alpha_locs[i])) return false;
		}

		if (!zt_serialWrite(serial, gradient->color_entries)) return false;
		zt_fiz(gradient->color_entries) {
			if (!zt_serialWrite(serial, gradient->color_vals[i])) return false;
			if (!zt_serialWrite(serial, gradient->color_locs[i])) return false;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

r32 zt_valueGradientGetValue(ztValueGradient *value_gradient, r32 percent)
{
	ZT_PROFILE_PARTICLES("zt_valueGradientGetValue	");
	zt_returnValOnNull(value_gradient, 0);

	i32 total_prop = 0;
	zt_fiz(value_gradient->values_count) {
		total_prop += value_gradient->values[i].proportion;
	}

	r32 this_prop = zt_clamp(percent, 0, 1) * total_prop;
	r32 curr_prop = 0;
	for (int j = 1; j < value_gradient->values_count; ++j) {
		r32 next_prop = curr_prop + (r32)value_gradient->values[j - 1].proportion;
		if (this_prop <= next_prop) {
			r32 pct = (this_prop - curr_prop) / (next_prop - curr_prop);
			return zt_lerp(value_gradient->values[j - 1].value, value_gradient->values[j].value, pct);
		}
		curr_prop = next_prop;
	}

	if (value_gradient->values_count == 0) {
		return 0;
	}
	else {
		return value_gradient->values[value_gradient->values_count - 1].value;
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================


void zt_particleVariableRealInit(ztParticleVariableRealValue *value, ztParticleVariableReal *variable, ztRandom *random)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableRealInit");
	zt_returnOnNull(value);
	zt_returnOnNull(variable);

	value->variable = variable;

	switch (variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			value->random_value = zt_randomVal(random, variable->random_value_min, variable->random_value_max);
		} break;

		case ztParticleVariableRealType_Curve: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			value->curve_lerp = zt_randomVal(random);
		} break;
	}
}

// ================================================================================================================================================================================================

r32 zt_particleVariableRealGetValue(ztParticleVariableRealValue *value, r32 percent)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableRealGetValue");
	zt_returnValOnNull(value, 0);
	zt_returnValOnNull(value->variable, 0);

	switch (value->variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			return value->variable->constant;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			return value->random_value;
		} break;

		case ztParticleVariableRealType_Curve: {
			return zt_animCurveGetValue(&value->variable->curve, percent);
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			return zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min, percent), zt_animCurveGetValue(&value->variable->random_curve_max, percent), value->curve_lerp);
		} break;
	}

	zt_assert(false);
	return 0;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztParticleVariableReal *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 type = 0;
		zt_serialRead(serial, &type);
		variable->type = (ztParticleVariableRealType_Enum)type;

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialRead(serial, &variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialRead(serial, &variable->random_value_min)) return false;
				if (!zt_serialRead(serial, &variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				if (!zt_serialRead(serial, &variable->curve)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				if (!zt_serialRead(serial, &variable->random_curve_min)) return false;
				if (!zt_serialRead(serial, &variable->random_curve_max)) return false;
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztParticleVariableReal *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		zt_serialWrite(serial, (i32)variable->type);

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialWrite(serial, variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialWrite(serial, variable->random_value_min)) return false;
				if (!zt_serialWrite(serial, variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				if (!zt_serialWrite(serial, &variable->curve)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				if (!zt_serialWrite(serial, &variable->random_curve_min)) return false;
				if (!zt_serialWrite(serial, &variable->random_curve_max)) return false;
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_particleVariableVec2Init(ztParticleVariableVec2Value *value, ztParticleVariableVec2 *variable, ztRandom *random)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableVec2Init");
	zt_returnOnNull(value);
	zt_returnOnNull(variable);

	value->variable = variable;

	switch (variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			value->random_value.x = zt_randomVal(random, variable->random_value_min.x, variable->random_value_max.x);
			value->random_value.y = zt_randomVal(random, variable->random_value_min.y, variable->random_value_max.y);
		} break;

		case ztParticleVariableRealType_Curve: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			zt_fiz(2) {
				value->curve_lerp[i] = zt_randomVal(random);
			}
		} break;
	}
}

// ================================================================================================================================================================================================

ztVec2 zt_particleVariableVec2GetValue(ztParticleVariableVec2Value *value, r32 percent)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableVec3GetValue");
	zt_returnValOnNull(value, ztVec2::zero);
	zt_returnValOnNull(value->variable, ztVec2::zero);

	switch (value->variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			return value->variable->constant;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			return value->random_value;
		} break;

		case ztParticleVariableRealType_Curve: {
			return zt_vec2(zt_animCurveGetValue(&value->variable->curve[0], percent), zt_animCurveGetValue(&value->variable->curve[1], percent));
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			return zt_vec2(zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min[0], percent), zt_animCurveGetValue(&value->variable->random_curve_max[0], percent), value->curve_lerp[0]),
			               zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min[1], percent), zt_animCurveGetValue(&value->variable->random_curve_max[1], percent), value->curve_lerp[1]));
		} break;
	}

	zt_assert(false);
	return ztVec2::zero;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztParticleVariableVec2 *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 type = 0;
		zt_serialRead(serial, &type);
		variable->type = (ztParticleVariableRealType_Enum)type;

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialRead(serial, &variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialRead(serial, &variable->random_value_min)) return false;
				if (!zt_serialRead(serial, &variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				zt_fize(variable->curve) {
					if (!zt_serialRead(serial, &variable->curve[i])) return false;
				}
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				zt_fize(variable->curve) {
					if (!zt_serialRead(serial, &variable->random_curve_min[i])) return false;
					if (!zt_serialRead(serial, &variable->random_curve_max[i])) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztParticleVariableVec2 *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		zt_serialWrite(serial, (i32)variable->type);

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialWrite(serial, variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialWrite(serial, variable->random_value_min)) return false;
				if (!zt_serialWrite(serial, variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				zt_fize(variable->curve) {
					if (!zt_serialWrite(serial, &variable->curve[i])) return false;
				}
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				zt_fize(variable->curve) {
					if (!zt_serialWrite(serial, &variable->random_curve_min[i])) return false;
					if (!zt_serialWrite(serial, &variable->random_curve_max[i])) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_particleVariableVec3Init(ztParticleVariableVec3Value *value, ztParticleVariableVec3 *variable, ztRandom *random)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableVec3Init");
	zt_returnOnNull(value);
	zt_returnOnNull(variable);

	value->variable = variable;

	switch (variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			value->random_value.x = zt_randomVal(random, variable->random_value_min.x, variable->random_value_max.x);

			if (variable->random_value_min.y == variable->random_value_min.x && variable->random_value_max.y == variable->random_value_max.x) {
				value->random_value.y = value->random_value.x;
			}
			else {
				value->random_value.y = zt_randomVal(random, variable->random_value_min.y, variable->random_value_max.y);
			}

			if (variable->random_value_min.z == variable->random_value_min.x && variable->random_value_max.z == variable->random_value_max.x) {
				value->random_value.z = value->random_value.z;
			}
			else {
				value->random_value.z = zt_randomVal(random, variable->random_value_min.z, variable->random_value_max.z);
			}
		} break;

		case ztParticleVariableRealType_Curve: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			zt_fiz(3) {
				value->curve_lerp[i] = zt_randomVal(random);
			}
		} break;
	}
}

// ================================================================================================================================================================================================

ztVec3 zt_particleVariableVec3GetValue(ztParticleVariableVec3Value *value, r32 percent)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableVec3GetValue");
	zt_returnValOnNull(value, ztVec3::zero);
	zt_returnValOnNull(value->variable, ztVec3::zero);

	switch (value->variable->type)
	{
		case ztParticleVariableRealType_Constant: {
			return value->variable->constant;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			return value->random_value;
		} break;

		case ztParticleVariableRealType_Curve: {
			return zt_vec3(zt_animCurveGetValue(&value->variable->curve[0], percent), zt_animCurveGetValue(&value->variable->curve[1], percent), zt_animCurveGetValue(&value->variable->curve[2], percent));
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			return zt_vec3(zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min[0], percent), zt_animCurveGetValue(&value->variable->random_curve_max[0], percent), value->curve_lerp[0]),
				zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min[1], percent), zt_animCurveGetValue(&value->variable->random_curve_max[1], percent), value->curve_lerp[1]),
				zt_lerp(zt_animCurveGetValue(&value->variable->random_curve_min[2], percent), zt_animCurveGetValue(&value->variable->random_curve_max[2], percent), value->curve_lerp[2]));
		} break;
	}

	zt_assert(false);
	return ztVec3::zero;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztParticleVariableVec3 *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 type = 0;
		zt_serialRead(serial, &type);
		variable->type = (ztParticleVariableRealType_Enum)type;

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialRead(serial, &variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialRead(serial, &variable->random_value_min)) return false;
				if (!zt_serialRead(serial, &variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				zt_fize(variable->curve) {
					if (!zt_serialRead(serial, &variable->curve[i])) return false;
				}
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				zt_fize(variable->curve) {
					if (!zt_serialRead(serial, &variable->random_curve_min[i])) return false;
					if (!zt_serialRead(serial, &variable->random_curve_max[i])) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztParticleVariableVec3 *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		zt_serialWrite(serial, (i32)variable->type);

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialWrite(serial, variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialWrite(serial, variable->random_value_min)) return false;
				if (!zt_serialWrite(serial, variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				zt_fize(variable->curve) {
					if (!zt_serialWrite(serial, &variable->curve[i])) return false;
				}
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				zt_fize(variable->curve) {
					if (!zt_serialWrite(serial, &variable->random_curve_min[i])) return false;
					if (!zt_serialWrite(serial, &variable->random_curve_max[i])) return false;
				}
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void zt_particleVariableColorInit(ztParticleVariableColorValue *value, ztParticleVariableColor *variable, ztRandom *random)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableColorInit");
	zt_returnOnNull(value);
	zt_returnOnNull(variable);

	value->variable = variable;

	switch (variable->type)
	{
		case ztParticleVariableColorType_Constant: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableColorType_RandomBetweenTwoConstants: {
			value->random_value.x = zt_randomVal(random, variable->random_value_min.x, variable->random_value_max.x);
			value->random_value.y = zt_randomVal(random, variable->random_value_min.y, variable->random_value_max.y);
			value->random_value.z = zt_randomVal(random, variable->random_value_min.z, variable->random_value_max.z);
			value->random_value.w = zt_randomVal(random, variable->random_value_min.w, variable->random_value_max.w);
		} break;

		case ztParticleVariableColorType_Gradient: {
			// ... nothing to do
			return;
		} break;

		case ztParticleVariableColorType_RandomBetweenTwoGradients: {
			value->gradient_lerp = zt_randomVal(random);
		} break;
	}
}

// ================================================================================================================================================================================================

ztColor zt_particleVariableColorGetValue(ztParticleVariableColorValue *value, r32 percent)
{
	ZT_PROFILE_PARTICLES("zt_particleVariableColorGetValue");
	zt_returnValOnNull(value, ztColor_White);
	zt_returnValOnNull(value->variable, ztColor_White);

	switch (value->variable->type)
	{
		case ztParticleVariableColorType_Constant: {
			return value->variable->constant;
		} break;

		case ztParticleVariableColorType_RandomBetweenTwoConstants: {
			return value->random_value;
		} break;

		case ztParticleVariableColorType_Gradient: {
			return zt_colorGradientGetValue(&value->variable->gradient, percent);
		} break;

		case ztParticleVariableColorType_RandomBetweenTwoGradients: {
			return ztVec4::lerp(zt_colorGradientGetValue(&value->variable->random_gradient_min, percent), zt_colorGradientGetValue(&value->variable->random_gradient_max, percent), value->gradient_lerp);
		} break;
	}

	zt_assert(false);
	return ztColor_White;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztParticleVariableColor *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 type = 0;
		zt_serialRead(serial, &type);
		variable->type = (ztParticleVariableColorType_Enum)type;

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialRead(serial, &variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialRead(serial, &variable->random_value_min)) return false;
				if (!zt_serialRead(serial, &variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				if (!zt_serialRead(serial, &variable->gradient)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				if (!zt_serialRead(serial, &variable->random_gradient_min)) return false;
				if (!zt_serialRead(serial, &variable->random_gradient_max)) return false;
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztParticleVariableColor *variable)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		zt_serialWrite(serial, (i32)variable->type);

		switch (variable->type)
		{
			case ztParticleVariableRealType_Constant: {
				if (!zt_serialWrite(serial, variable->constant)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoConstants: {
				if (!zt_serialWrite(serial, variable->random_value_min)) return false;
				if (!zt_serialWrite(serial, variable->random_value_max)) return false;
			} break;

			case ztParticleVariableRealType_Curve: {
				if (!zt_serialWrite(serial, &variable->gradient)) return false;
			} break;

			case ztParticleVariableRealType_RandomBetweenTwoCurves: {
				if (!zt_serialWrite(serial, &variable->random_gradient_min)) return false;
				if (!zt_serialWrite(serial, &variable->random_gradient_max)) return false;
			} break;
		}
	}
	if (!zt_serialGroupPop(serial)) return false;
	return true;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

#define ZT_PARTICLE_SYSTEM_ID	(i32)2798871240

#define ZT_PARTICLE_SYSTEM_ID_V1 (i32)2798871238
#define ZT_PARTICLE_SYSTEM_ID_V2 (i32)2798871239
#define ZT_PARTICLE_SYSTEM_ID_V3 ZT_PARTICLE_SYSTEM_ID

// ================================================================================================================================================================================================

bool zt_particleSystemLoad(ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count, ztAssetManager *asset_mgr, ztAssetID asset_id)
{
	ZT_PROFILE_RENDERING("zt_particleSystemLoad");
	zt_returnValOnNull(system, false);
	zt_returnValOnNull(asset_mgr, false);

	char *data = nullptr;
	const char *error = nullptr;
	i32 size = 0;
	ztSerial serial;

	if (asset_id == ztInvalidID) {
		error = "Invalid asset id";
		goto on_error;
	}
	zt_assertReturnValOnFail(asset_id >= 0 && asset_id < asset_mgr->asset_count, false);

	size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		error = "Unable to get asset size";
		goto on_error;
	}

	data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		error = "Unable to allocate memory";
		goto on_error;
	}

	if (!zt_assetLoadData(asset_mgr, asset_id, data, size, true)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	if (!zt_serialMakeReader(&serial, data, size, ZT_PARTICLE_SYSTEM_FILE_GUID)) {
		error = "Unable to load particle system file";
		goto on_error;
	}

	if (!zt_serialRead(&serial, system, sprite_manager, mesh_info, mesh_info_count)) {
		zt_serialClose(&serial);
		error = "Unable to read particle system file";
		goto on_error;
	}

	zt_serialClose(&serial);
	zt_freeArena(data, asset_mgr->arena);
	return true;

on_error:
	zt_logCritical(error);
	zt_freeArena(data, asset_mgr->arena);
	return false;
}

// ================================================================================================================================================================================================

bool zt_serialRead(ztSerial *serial, ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count)
{
	zt_memSet(system, zt_sizeof(ztParticleSystem), 0);

	if (!zt_serialGroupPush(serial)) return false;
	{
		i32 id = 0;
		if (!zt_serialRead(serial, &id)) return false;

		int version = 0;
		if (id == ZT_PARTICLE_SYSTEM_ID_V1) version = 1;
		if (id == ZT_PARTICLE_SYSTEM_ID_V2) version = 2;
		if (id == ZT_PARTICLE_SYSTEM_ID_V3) version = 3;
		if (version == 0) return false;

		if (!zt_serialRead(serial, &system->system_duration)) return false;

		if(version >= 2) {
			if (!zt_serialRead(serial, &system->system_delay)) return false;
		}
		else {
			system->system_delay = 0;
		}

		if (!zt_serialRead(serial, &system->system_loops)) return false;
		if (!zt_serialRead(serial, &system->system_prewarm)) return false;
		if (!zt_serialRead(serial, &system->system_gravity_multiplier)) return false;
		if (!zt_serialRead(serial, &system->system_local_space)) return false;
		if (!zt_serialRead(serial, &system->system_rate_over_time)) return false;
		if (!zt_serialRead(serial, &system->system_rotation)) return false;

		if (!zt_serialRead(serial, &system->system_burst)) return false;
		if (!zt_serialRead(serial, &system->system_bursts_count)) return false;

		zt_fiz(system->system_bursts_count) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialRead(serial, &system->system_bursts[i].time_start)) return false;
				if (!zt_serialRead(serial, &system->system_bursts[i].min_particles)) return false;
				if (!zt_serialRead(serial, &system->system_bursts[i].max_particles)) return false;
				if (!zt_serialRead(serial, &system->system_bursts[i].cycles)) return false;
				if (!zt_serialRead(serial, &system->system_bursts[i].interval)) return false;
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		i32 shape_type = 0;
		if (!zt_serialRead(serial, &shape_type)) return false;
		system->system_shape.type = (ztParticleShapeType_Enum)shape_type;
		if (!zt_serialRead(serial, &system->system_shape.spawn_volume)) return false;
		if (!zt_serialRead(serial, &system->system_shape.spawn_volume_local)) return false;

		switch (system->system_shape.type)
		{
			case ztParticleShapeType_Point: {
			} break;

			case ztParticleShapeType_Sphere: {
				if (!zt_serialRead(serial, &system->system_shape.sphere.radius)) return false;
				if (!zt_serialRead(serial, &system->system_shape.sphere.volume_angle_min)) return false;
				if (!zt_serialRead(serial, &system->system_shape.sphere.volume_angle_max)) return false;
			} break;

			case ztParticleShapeType_Circle: {
				if (!zt_serialRead(serial, &system->system_shape.circle.radius)) return false;
				if (!zt_serialRead(serial, &system->system_shape.circle.volume_angle_min)) return false;
				if (!zt_serialRead(serial, &system->system_shape.circle.volume_angle_max)) return false;
			} break;

			case ztParticleShapeType_Box: {
				if (!zt_serialRead(serial, &system->system_shape.box.extents)) return false;
			} break;

			case ztParticleShapeType_Square: {
				if (!zt_serialRead(serial, &system->system_shape.square.extents)) return false;
			} break;

			default: zt_assert(false);
		}

		i32 rendering_type = 0;
		if (!zt_serialRead(serial, &rendering_type)) return false;
		system->system_rendering.type = (ztParticleRenderingType_Enum)rendering_type;

		switch (system->system_rendering.type)
		{
			case ztParticleRenderingType_BillBoard: {
				i32 hash = 0;
				if (!zt_serialRead(serial, &hash)) return false;
				ztSprite *sprite = zt_spriteManagerGetSprite(sprite_manager, hash);
				if (sprite) {
					system->system_rendering.billboard.sprite = *sprite;
				}
				else zt_logCritical("particle system has invalid billboard sprite");
			} break;

			case ztParticleRenderingType_Facing: {
				i32 hash = 0;
				if (!zt_serialRead(serial, &hash)) return false;
				ztSprite *sprite = zt_spriteManagerGetSprite(sprite_manager, hash);
				if (sprite) {
					system->system_rendering.facing.sprite = *sprite;
				}
				else zt_logCritical("particle system has invalid facing sprite");
			} break;

			case ztParticleRenderingType_Mesh: {
				i32 hash = 0;
				if (!zt_serialRead(serial, &hash)) return false;
				ztMeshID mesh_id = ztInvalidID;
				zt_fvz(midx, mesh_info_count) {
					if(zt_strHash(mesh_info[midx].name) == hash) {
						mesh_id = mesh_info[midx].mesh_id;
						break;
					}
				}
				if (mesh_id == ztInvalidID) {
					zt_logCritical("particle system has invalid mesh");
				}
				system->system_rendering.mesh.mesh_id  = mesh_id;
			} break;

			default: zt_assert(false);
		}

		i32 blend_mode_src = 0, blend_mode_dst = 0;
		if (!zt_serialRead(serial, &blend_mode_src)) return false;
		if (!zt_serialRead(serial, &blend_mode_dst)) return false;

		system->system_rendering.blend_mode_src = (ztRendererBlendMode_Enum)blend_mode_src;
		system->system_rendering.blend_mode_dst = (ztRendererBlendMode_Enum)blend_mode_dst;

		if (!zt_serialRead(serial, &system->lifetime)) return false;
		if (!zt_serialRead(serial, &system->start_speed)) return false;
		if (!zt_serialRead(serial, &system->start_scale)) return false;
		if (!zt_serialRead(serial, &system->start_rotation)) return false;

		if (version >= 3) {
			if (!zt_serialRead(serial, &system->start_color)) return false;
		}
		else {
			system->start_color.type = ztParticleVariableColorType_Constant;
			system->start_color.constant = ztColor_White;
		}

		if (!zt_serialRead(serial, &system->velocity_inherit)) return false;
		if (!zt_serialRead(serial, &system->velocity_over_lifetime_used)) return false;
		if (!zt_serialRead(serial, &system->velocity_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->velocity_damping_over_lifetime_used)) return false;
		if (!zt_serialRead(serial, &system->velocity_damping_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->speed_over_lifetime_used)) return false;
		if (!zt_serialRead(serial, &system->speed_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->color_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->color_over_speed_used)) return false;
		if (!zt_serialRead(serial, &system->color_over_speed)) return false;
		if (!zt_serialRead(serial, &system->color_over_speed_range[0])) return false;
		if (!zt_serialRead(serial, &system->color_over_speed_range[1])) return false;
		if (!zt_serialRead(serial, &system->size_over_lifetime_used)) return false;
		if (!zt_serialRead(serial, &system->size_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->size_over_speed_used)) return false;
		if (!zt_serialRead(serial, &system->size_over_speed)) return false;
		if (!zt_serialRead(serial, &system->size_over_speed_range[0])) return false;
		if (!zt_serialRead(serial, &system->size_over_speed_range[1])) return false;
		if (!zt_serialRead(serial, &system->rotate_towards_movement)) return false;
		if (!zt_serialRead(serial, &system->rotation_over_lifetime_used)) return false;
		if (!zt_serialRead(serial, &system->rotation_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->rotation_over_speed_used)) return false;
		if (!zt_serialRead(serial, &system->rotation_over_speed)) return false;
		if (!zt_serialRead(serial, &system->rotation_over_speed_range[0])) return false;
		if (!zt_serialRead(serial, &system->rotation_over_speed_range[1])) return false;
		if (!zt_serialRead(serial, &system->noise_use)) return false;
		if (!zt_serialRead(serial, &system->noise_multiplier)) return false;
		if (!zt_serialRead(serial, &system->noise_position_amount)) return false;
		if (!zt_serialRead(serial, &system->noise_rotation_amount)) return false;
		if (!zt_serialRead(serial, &system->noise_scale_amount)) return false;
		if (!zt_serialRead(serial, &system->trails_use)) return false;
		if (!zt_serialRead(serial, &system->trails_percentage)) return false;
		if (!zt_serialRead(serial, &system->trails_lifetime)) return false;
		if (!zt_serialRead(serial, &system->trails_width_is_size)) return false;
		if (!zt_serialRead(serial, &system->trails_inherit_color)) return false;
		if (!zt_serialRead(serial, &system->trails_color_over_lifetime_use)) return false;
		if (!zt_serialRead(serial, &system->trails_color_over_lifetime)) return false;
		if (!zt_serialRead(serial, &system->trails_width)) return false;
		if (!zt_serialRead(serial, &system->trails_color_over_trail)) return false;


		i32 trails_sprite_hash = 0;
		if (!zt_serialRead(serial, &trails_sprite_hash)) return false;
		if (trails_sprite_hash != 0) {
			ztSprite *sprite = zt_spriteManagerGetSprite(sprite_manager, trails_sprite_hash);
			if (sprite) {
				system->trails_sprite = *sprite;
			}
			else zt_logCritical("particle system has invalid trail sprite");
		}
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}

// ================================================================================================================================================================================================

bool zt_serialWrite(ztSerial *serial, ztParticleSystem *system, ztSpriteManager *sprite_manager, ztParticleMeshInfo *mesh_info, i32 mesh_info_count)
{
	if (!zt_serialGroupPush(serial)) return false;
	{
		if (!zt_serialWrite(serial, ZT_PARTICLE_SYSTEM_ID)) return false;

		if (!zt_serialWrite(serial, system->system_duration)) return false;
		if (!zt_serialWrite(serial, system->system_delay)) return false;
		if (!zt_serialWrite(serial, system->system_loops)) return false;
		if (!zt_serialWrite(serial, system->system_prewarm)) return false;
		if (!zt_serialWrite(serial, &system->system_gravity_multiplier)) return false;
		if (!zt_serialWrite(serial, system->system_local_space)) return false;
		if (!zt_serialWrite(serial, &system->system_rate_over_time)) return false;
		if (!zt_serialWrite(serial, &system->system_rotation)) return false;

		if (!zt_serialWrite(serial, system->system_burst)) return false;
		if (!zt_serialWrite(serial, system->system_bursts_count)) return false;

		zt_fiz(system->system_bursts_count) {
			if (!zt_serialGroupPush(serial)) return false;
			{
				if (!zt_serialWrite(serial, system->system_bursts[i].time_start)) return false;
				if (!zt_serialWrite(serial, system->system_bursts[i].min_particles)) return false;
				if (!zt_serialWrite(serial, system->system_bursts[i].max_particles)) return false;
				if (!zt_serialWrite(serial, system->system_bursts[i].cycles)) return false;
				if (!zt_serialWrite(serial, system->system_bursts[i].interval)) return false;
			}
			if (!zt_serialGroupPop(serial)) return false;
		}

		if (!zt_serialWrite(serial, (i32)system->system_shape.type)) return false;
		if (!zt_serialWrite(serial, &system->system_shape.spawn_volume)) return false;
		if (!zt_serialWrite(serial, system->system_shape.spawn_volume_local)) return false;

		switch (system->system_shape.type)
		{
			case ztParticleShapeType_Point: {
			} break;

			case ztParticleShapeType_Sphere: {
				if (!zt_serialWrite(serial, &system->system_shape.sphere.radius)) return false;
				if (!zt_serialWrite(serial, &system->system_shape.sphere.volume_angle_min)) return false;
				if (!zt_serialWrite(serial, &system->system_shape.sphere.volume_angle_max)) return false;
			} break;

			case ztParticleShapeType_Circle: {
				if (!zt_serialWrite(serial, &system->system_shape.circle.radius)) return false;
				if (!zt_serialWrite(serial, &system->system_shape.circle.volume_angle_min)) return false;
				if (!zt_serialWrite(serial, &system->system_shape.circle.volume_angle_max)) return false;
			} break;

			case ztParticleShapeType_Box: {
				if (!zt_serialWrite(serial, &system->system_shape.box.extents)) return false;
			} break;

			case ztParticleShapeType_Square: {
				if (!zt_serialWrite(serial, &system->system_shape.square.extents)) return false;
			} break;

			default: zt_assert(false);
		}

		i32 rendering_type = 0;
		if (!zt_serialWrite(serial, rendering_type)) return false;
		system->system_rendering.type = (ztParticleRenderingType_Enum)rendering_type;

		switch (system->system_rendering.type)
		{
			case ztParticleRenderingType_BillBoard: {
				if (!zt_serialWrite(serial, zt_spriteManagerFindSpriteHash(sprite_manager, &system->system_rendering.billboard.sprite))) return false;
			} break;

			case ztParticleRenderingType_Facing: {
				if (!zt_serialWrite(serial, zt_spriteManagerFindSpriteHash(sprite_manager, &system->system_rendering.facing.sprite))) return false;
			} break;

			case ztParticleRenderingType_Mesh: {
				i32 hash = 0;
				zt_fiz(mesh_info_count) {
					if(system->system_rendering.mesh.mesh_id == mesh_info[i].mesh_id) {
						hash = zt_strHash(mesh_info[i].name);
						break;
					}
				}
				if(!zt_serialWrite(serial, hash)) return false;
			} break;

			default: zt_assert(false);
		}

		if (!zt_serialWrite(serial, (i32)system->system_rendering.blend_mode_src)) return false;
		if (!zt_serialWrite(serial, (i32)system->system_rendering.blend_mode_dst)) return false;

		if (!zt_serialWrite(serial, &system->lifetime)) return false;
		if (!zt_serialWrite(serial, &system->start_speed)) return false;
		if (!zt_serialWrite(serial, &system->start_scale)) return false;
		if (!zt_serialWrite(serial, &system->start_rotation)) return false;
		if (!zt_serialWrite(serial, &system->start_color)) return false;
		if (!zt_serialWrite(serial, system->velocity_inherit)) return false;
		if (!zt_serialWrite(serial, system->velocity_over_lifetime_used)) return false;
		if (!zt_serialWrite(serial, &system->velocity_over_lifetime)) return false;
		if (!zt_serialWrite(serial, system->velocity_damping_over_lifetime_used)) return false;
		if (!zt_serialWrite(serial, &system->velocity_damping_over_lifetime)) return false;
		if (!zt_serialWrite(serial, system->speed_over_lifetime_used)) return false;
		if (!zt_serialWrite(serial, &system->speed_over_lifetime)) return false;
		if (!zt_serialWrite(serial, &system->color_over_lifetime)) return false;
		if (!zt_serialWrite(serial, system->color_over_speed_used)) return false;
		if (!zt_serialWrite(serial, &system->color_over_speed)) return false;
		if (!zt_serialWrite(serial, system->color_over_speed_range[0])) return false;
		if (!zt_serialWrite(serial, system->color_over_speed_range[1])) return false;
		if (!zt_serialWrite(serial, system->size_over_lifetime_used)) return false;
		if (!zt_serialWrite(serial, &system->size_over_lifetime)) return false;
		if (!zt_serialWrite(serial, system->size_over_speed_used)) return false;
		if (!zt_serialWrite(serial, &system->size_over_speed)) return false;
		if (!zt_serialWrite(serial, system->size_over_speed_range[0])) return false;
		if (!zt_serialWrite(serial, system->size_over_speed_range[1])) return false;
		if (!zt_serialWrite(serial, system->rotate_towards_movement)) return false;
		if (!zt_serialWrite(serial, system->rotation_over_lifetime_used)) return false;
		if (!zt_serialWrite(serial, &system->rotation_over_lifetime)) return false;
		if (!zt_serialWrite(serial, system->rotation_over_speed_used)) return false;
		if (!zt_serialWrite(serial, &system->rotation_over_speed)) return false;
		if (!zt_serialWrite(serial, system->rotation_over_speed_range[0])) return false;
		if (!zt_serialWrite(serial, system->rotation_over_speed_range[1])) return false;
		if (!zt_serialWrite(serial, system->noise_use)) return false;
		if (!zt_serialWrite(serial, &system->noise_multiplier)) return false;
		if (!zt_serialWrite(serial, &system->noise_position_amount)) return false;
		if (!zt_serialWrite(serial, &system->noise_rotation_amount)) return false;
		if (!zt_serialWrite(serial, &system->noise_scale_amount)) return false;
		if (!zt_serialWrite(serial, system->trails_use)) return false;
		if (!zt_serialWrite(serial, &system->trails_percentage)) return false;
		if (!zt_serialWrite(serial, &system->trails_lifetime)) return false;
		if (!zt_serialWrite(serial, system->trails_width_is_size)) return false;
		if (!zt_serialWrite(serial, system->trails_inherit_color)) return false;
		if (!zt_serialWrite(serial, system->trails_color_over_lifetime_use)) return false;
		if (!zt_serialWrite(serial, &system->trails_color_over_lifetime)) return false;
		if (!zt_serialWrite(serial, &system->trails_width)) return false;
		if (!zt_serialWrite(serial, &system->trails_color_over_trail)) return false;

		if (!zt_serialWrite(serial, zt_spriteManagerFindSpriteHash(sprite_manager, &system->trails_sprite))) return false;
	}
	if (!zt_serialGroupPop(serial)) return false;

	return true;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

void _zt_particleEmitterInit(ztParticleEmitter *emitter, ztParticleSystem *system, i32 seed)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterInit");
	emitter->system = system;
	emitter->enabled = true;
	emitter->speed = 0;
	emitter->seed = seed;

	zt_memSet(emitter->particles, zt_sizeof(ztParticle2) * emitter->particles_size, 0);

	emitter->speed = 1;
	emitter->life_left = emitter->system->system_duration;
	emitter->delay = emitter->system->system_delay;
	emitter->prev_pos = emitter->position;
	emitter->time_last_particle = ztReal32Max;

	if (emitter->life_left == 0) {
		emitter->life_left = 1 / 1000.f;
	}

	zt_randomInit(&emitter->random, seed);

	zt_particleVariableRealInit(&emitter->system_gravity_multiplier, &emitter->system->system_gravity_multiplier, &emitter->random);
	zt_particleVariableRealInit(&emitter->system_rate_over_time, &emitter->system->system_rate_over_time, &emitter->random);
	zt_particleVariableRealInit(&emitter->system_shape_spawn_volume, &emitter->system->system_shape.spawn_volume, &emitter->random);
	zt_particleVariableVec3Init(&emitter->system_rotation, &emitter->system->system_rotation, &emitter->random);

	if (emitter->system->noise_use) {
		if(emitter->noise == nullptr) {
			emitter->noise = zt_simplexNoiseMake(seed);
		}
		zt_particleVariableRealInit(&emitter->noise_multiplier, &emitter->system->noise_multiplier, &emitter->random);
		zt_particleVariableVec3Init(&emitter->noise_position_amount, &emitter->system->noise_position_amount, &emitter->random);
		zt_particleVariableVec3Init(&emitter->noise_rotation_amount, &emitter->system->noise_rotation_amount, &emitter->random);
		zt_particleVariableVec3Init(&emitter->noise_scale_amount, &emitter->system->noise_scale_amount, &emitter->random);
	}
	else {
		emitter->noise = nullptr;
	}

	zt_particleVariableRealInit(&emitter->trails_width, &emitter->system->trails_width, &emitter->random);
	zt_particleVariableColorInit(&emitter->trails_color_over_time, &emitter->system->trails_color_over_lifetime, &emitter->random);
	zt_particleVariableColorInit(&emitter->trails_color, &emitter->system->trails_color_over_trail, &emitter->random);

	switch (emitter->system->system_shape.type)
	{
		case ztParticleShapeType_Point: {
		} break;

		case ztParticleShapeType_Sphere: {
			zt_particleVariableRealInit(&emitter->system_shape_sphere.radius, &emitter->system->system_shape.sphere.radius, &emitter->random);
			zt_particleVariableRealInit(&emitter->system_shape_sphere.volume_angle_min, &emitter->system->system_shape.sphere.volume_angle_min, &emitter->random);
			zt_particleVariableRealInit(&emitter->system_shape_sphere.volume_angle_max, &emitter->system->system_shape.sphere.volume_angle_max, &emitter->random);
		} break;

		case ztParticleShapeType_Circle: {
			zt_particleVariableRealInit(&emitter->system_shape_circle.radius, &emitter->system->system_shape.circle.radius, &emitter->random);
			zt_particleVariableRealInit(&emitter->system_shape_circle.volume_angle_min, &emitter->system->system_shape.circle.volume_angle_min, &emitter->random);
			zt_particleVariableRealInit(&emitter->system_shape_circle.volume_angle_max, &emitter->system->system_shape.circle.volume_angle_max, &emitter->random);
		} break;

		case ztParticleShapeType_Box: {
			zt_particleVariableVec3Init(&emitter->system_shape_box.extents, &emitter->system->system_shape.box.extents, &emitter->random);
		} break;

		case ztParticleShapeType_Square: {
			zt_particleVariableVec2Init(&emitter->system_shape_square.extents, &emitter->system->system_shape.square.extents, &emitter->random);
		} break;
	}

	r32 prewarm_time = emitter->system->system_prewarm;
	if (prewarm_time > 0) {
		r32 dt = 1 / 60.f;
		while (prewarm_time > 0) {
			prewarm_time -= dt;
			zt_particleEmitterUpdate(emitter, dt);
		}
	}
}

// ================================================================================================================================================================================================

ztInternal r32 _zt_particleEmitterVarRealGetMaxValue(ztParticleVariableReal *var)
{
	r32 val = 0;

	switch(var->type)
	{
		case ztParticleVariableRealType_Constant: {
			val = var->constant;
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoConstants: {
			val = zt_max(var->random_value_min, var->random_value_max);
		} break;

		case ztParticleVariableRealType_Curve: {
			zt_fiz(100) {
				val = zt_max(val, zt_animCurveGetValue(&var->curve, i / 100.f));
			}
		} break;

		case ztParticleVariableRealType_RandomBetweenTwoCurves: {
			zt_fiz(100) {
				val = zt_max(val, zt_animCurveGetValue(&var->random_curve_min, i / 100.f));
				val = zt_max(val, zt_animCurveGetValue(&var->random_curve_max, i / 100.f));
			}
		} break;
	}

	return val;
}

// ================================================================================================================================================================================================

ztInternal i32 _zt_particleEmitterGetEachEmitterSize(ztParticleSystem *system, i32 *max_particles_ptr)
{
	i32 size = zt_sizeof(ztParticleEmitter);

	r32 rate_over_time = _zt_particleEmitterVarRealGetMaxValue(&system->system_rate_over_time);
	r32 duration_multiple = _zt_particleEmitterVarRealGetMaxValue(&system->lifetime);
	
	int max_particles = zt_convertToi32Ceil(duration_multiple * rate_over_time);

	if (max_particles_ptr) {
		*max_particles_ptr = max_particles;
	}

	return size + max_particles * zt_sizeof(ztParticle2);
}

// ================================================================================================================================================================================================

ztParticleEmitter *zt_particleEmitterInit(ztParticleSystem *system, i32 seed)
{
	zt_returnValOnNull(system, nullptr);

	i32 max_particles = 0;
	i32 size = _zt_particleEmitterGetEachEmitterSize(system, &max_particles);

	ztParticleEmitter *emitter = (ztParticleEmitter*)zt_mallocStructArray(byte, size);
	emitter->particles = (ztParticle2*)(((byte*)emitter) + zt_sizeof(ztParticleEmitter));
	emitter->particles_size = max_particles;

	zt_memValidateArena(zt_memGetGlobalArena());

	_zt_particleEmitterInit(emitter, system, seed);

	zt_memValidateArena(zt_memGetGlobalArena());
	return emitter;
}

// ================================================================================================================================================================================================

void zt_particleEmitterFree(ztParticleEmitter *emitter)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterFree");

	if (emitter == nullptr) {
		return;
	}

	if (emitter->noise) {
		zt_simplexNoiseFree(emitter->noise);
	}

	zt_free(emitter);
}

// ================================================================================================================================================================================================

void zt_particleEmitterReset(ztParticleEmitter *emitter)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterReset");

	zt_returnOnNull(emitter);
	_zt_particleEmitterInit(emitter, emitter->system, zt_randomInt(&emitter->random, 0, ztInt32Max));
}

// ================================================================================================================================================================================================

bool zt_particleEmitterUpdate(ztParticleEmitter *emitter, r32 dt)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterUpdate");
	zt_returnValOnNull(emitter, false);
	if (emitter->enabled == false) {
		return false;
	}

	if(emitter->delay > 0) {
		emitter->delay -= dt;
		if (emitter->delay <= 0) {
			emitter->delay = 0;
		}
		else return true;
	}

	r32 emitter_life_pct = emitter->system->system_duration == 0 ? 0 : 1 - (zt_max(0, emitter->life_left) / emitter->system->system_duration);

	int live_particles = 0;
	zt_fiz(emitter->particles_size) {
		if (emitter->particles[i].life_left <= 0) {
			continue;
		}

		live_particles += 1;
	}

	ztVec3 system_rotation_euler = zt_particleVariableVec3GetValue(&emitter->system_rotation, emitter_life_pct) + emitter->rotation;
	ztQuat system_rotation = system_rotation_euler != ztVec3::zero ? ztQuat::makeFromEuler(system_rotation_euler) : ztQuat::identity;

	// emit new particles if needed
	{
		r32 system_rate = zt_particleVariableRealGetValue(&emitter->system_rate_over_time, emitter_life_pct);
		r32 particles_per_second = zt_max(1, system_rate);
		r32 time_between_particles = 1 / particles_per_second;

		{
			ZT_PROFILE_PARTICLES("zt_particleEmitterUpdate:Spawn");

			r32 radius = ztReal32Min;
			r32 angle_min = ztReal32Min, angle_max = ztReal32Min;
			ztVec3 extents = ztVec3::min;
			r32 spawn_volume = zt_particleVariableRealGetValue(&emitter->system_shape_spawn_volume, emitter_life_pct);

			int new_particles;

			if (emitter->system->system_burst) {
				if (live_particles == 0) {
					new_particles = live_particles = zt_convertToi32Ceil(system_rate);
				}
				else {
					new_particles = 0;
				}
			}
			else {
#				if defined(ZT_EMSCRIPTEN) || defined(ZT_ANDROID)
				if (zt_real32Eq(emitter->time_last_particle, ztReal32Max)) {
					emitter->time_last_particle = dt;
				}
#				endif
				new_particles = zt_convertToi32Ceil(emitter->time_last_particle / time_between_particles);
			}

			if (new_particles >= 0 && !emitter->system->system_burst) {
				emitter->time_last_particle -= time_between_particles * new_particles;
			}
			else if (new_particles < 0) {
				new_particles = 1;
			}

			zt_fzz(new_particles) {
				if(emitter_life_pct >= 1) {
					break;
				}

				live_particles += 1;

				if (zt_real32Eq(emitter->time_last_particle, ztReal32Max)) {
					emitter->time_last_particle = dt;
				}

				zt_fiz(emitter->particles_size) {
					if (emitter->particles[i].life_left > 0) {
						continue;
					}

					ztParticle2 *particle = &emitter->particles[i];

					ztParticleVariableRealValue life_left;
					zt_particleVariableRealInit(&life_left, &emitter->system->lifetime, &emitter->random);
					particle->life_left = particle->life_span = zt_particleVariableRealGetValue(&life_left, emitter_life_pct);

					switch (emitter->system->system_shape.type)
					{
						case ztParticleShapeType_Point: {
							particle->velocity.x = zt_randomVal(&emitter->random, -1, 1);
							particle->velocity.y = zt_randomVal(&emitter->random, -1, 1);
							particle->velocity.z = zt_randomVal(&emitter->random, -1, 1);
							particle->velocity.normalize();
							particle->position = emitter->system->system_local_space ? ztVec3::zero : emitter->position;

						} break;

						case ztParticleShapeType_Sphere: {
							if (zt_real32Eq(radius, ztReal32Min)) { // only do this once per frame
								radius = zt_particleVariableRealGetValue(&emitter->system_shape_sphere.radius, emitter_life_pct);
								angle_min = zt_particleVariableRealGetValue(&emitter->system_shape_sphere.volume_angle_min, emitter_life_pct) * .5f;
								angle_max = zt_particleVariableRealGetValue(&emitter->system_shape_sphere.volume_angle_max, emitter_life_pct) * .5f;
							}

							r32 vol = (1 - zt_randomVal(&emitter->random, 0, spawn_volume));
							r32 s = zt_degreesToRadians(zt_randomVal(&emitter->random, 0, 360));
							r32 t = zt_degreesToRadians(zt_randomVal(&emitter->random, angle_min, angle_max));

							particle->position.z = (radius * vol) * zt_cos(s) * zt_sin(t);
							particle->position.x = (radius * vol) * zt_sin(s) * zt_sin(t);
							particle->position.y = (radius * vol) * zt_cos(t);

							if (system_rotation != ztQuat::identity) {
								system_rotation.rotatePosition(&particle->position);
							}

							particle->velocity = particle->position.getNormal();
							if(!emitter->system->system_local_space) {
								particle->position += emitter->position;
							}
						} break;

						case ztParticleShapeType_Circle: {
							if (zt_real32Eq(radius, ztReal32Min)) { // only do this once per frame
								radius = zt_particleVariableRealGetValue(&emitter->system_shape_circle.radius, emitter_life_pct);
								angle_min = zt_particleVariableRealGetValue(&emitter->system_shape_circle.volume_angle_min, emitter_life_pct);
								angle_max = zt_particleVariableRealGetValue(&emitter->system_shape_circle.volume_angle_max, emitter_life_pct);
							}

							r32 vol = (1 - zt_randomVal(&emitter->random, 0, spawn_volume));
							r32 t = zt_degreesToRadians(zt_randomVal(&emitter->random, angle_min, angle_max));

							particle->position.y = (radius * vol) * zt_cos(t);
							particle->position.x = (radius * vol) * zt_sin(t);
							particle->position.z = 0;

							if (system_rotation != ztQuat::identity) {
								system_rotation.rotatePosition(&particle->position);
							}

							particle->velocity = particle->position.getNormal();
							if (!emitter->system->system_local_space) {
								particle->position += emitter->position;
							}
						} break;

						case ztParticleShapeType_Box: {
							if (extents == ztVec3::min) {
								extents = zt_particleVariableVec3GetValue(&emitter->system_shape_box.extents, emitter_life_pct);
							}

							r32 vol = (1 - zt_randomVal(&emitter->random, 0, spawn_volume));

							switch (zt_randomInt(&emitter->random, 0, 6))
							{
								case 0: { // top
									particle->position.y = zt_randomVal(&emitter->random, vol, 1) * (extents.y / 2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->position.z = zt_randomVal(&emitter->random, extents.z / -2, extents.z / 2);
									particle->velocity = zt_vec3(0, 1, 0);
								} break;

								case 1: { // bottom
									particle->position.y = zt_randomVal(&emitter->random, vol, 1) * (extents.y / -2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->position.z = zt_randomVal(&emitter->random, extents.z / -2, extents.z / 2);
									particle->velocity = zt_vec3(0, -1, 0);
								} break;

								case 2: { // left
									particle->position.x = zt_randomVal(&emitter->random, vol, 1) * (extents.x / -2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.z = zt_randomVal(&emitter->random, extents.z / -2, extents.z / 2);
									particle->velocity = zt_vec3(-1, 0, 0);
								} break;

								case 3: { // right
									particle->position.x = zt_randomVal(&emitter->random, vol, 1) * (extents.x / 2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.z = zt_randomVal(&emitter->random, extents.z / -2, extents.z / 2);
									particle->velocity = zt_vec3(1, 0, 0);
								} break;

								case 4: { // front
									particle->position.z = zt_randomVal(&emitter->random, vol, 1) * (extents.z / 2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->velocity = zt_vec3(0, 0, 1);
								} break;

								case 5: { // back
									particle->position.z = zt_randomVal(&emitter->random, vol, 1) * (extents.z / -2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->velocity = zt_vec3(0, 0, -1);
								} break;

								default: zt_assert(false);
							}

							if (system_rotation != ztQuat::identity) {
								system_rotation.rotatePosition(&particle->position);
								system_rotation.rotatePosition(&particle->velocity);
							}

							if (!emitter->system->system_local_space) {
								particle->position += emitter->position;
							}
						} break;

						case ztParticleShapeType_Square: {
							if (extents == ztVec3::min) {
								extents.xy = zt_particleVariableVec2GetValue(&emitter->system_shape_square.extents, emitter_life_pct);
							}

							r32 vol = (1 - zt_randomVal(&emitter->random, 0, spawn_volume));

							switch (zt_randomInt(&emitter->random, 0, 4))
							{
								case 0: { // top
									particle->position.y = zt_randomVal(&emitter->random, vol, 1) * (extents.y / 2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->position.z = 0;
									particle->velocity = zt_vec3(0, 1, 0);
								} break;

								case 1: { // bottom
									particle->position.y = zt_randomVal(&emitter->random, vol, 1) * (extents.y / -2);
									particle->position.x = zt_randomVal(&emitter->random, extents.x / -2, extents.x / 2);
									particle->position.z = 0;
									particle->velocity = zt_vec3(0, -1, 0);
								} break;

								case 2: { // left
									particle->position.x = zt_randomVal(&emitter->random, vol, 1) * (extents.x / -2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.z = 0;
									particle->velocity = zt_vec3(-1, 0, 0);
								} break;

								case 3: { // right
									particle->position.x = zt_randomVal(&emitter->random, vol, 1) * (extents.x / 2);
									particle->position.y = zt_randomVal(&emitter->random, extents.y / -2, extents.y / 2);
									particle->position.z = 0;
									particle->velocity = zt_vec3(1, 0, 0);
								} break;

								default: zt_assert(false);
							}

							if (system_rotation != ztQuat::identity) {
								system_rotation.rotatePosition(&particle->position);
								system_rotation.rotatePosition(&particle->velocity);
							}

							if (!emitter->system->system_local_space) {
								particle->position += emitter->position;
							}
						} break;
					}

					particle->history[0] = particle->position;
					for (int j = 1; j < zt_elementsOf(particle->history); ++j) {
						particle->history[j] = ztVec3::min;
					}

					ztParticleVariableVec3Value scale;
					zt_particleVariableVec3Init(&scale, &emitter->system->start_scale, &emitter->random);
					particle->scale = zt_particleVariableVec3GetValue(&scale, emitter_life_pct);

					ztParticleVariableColorValue color;
					zt_particleVariableColorInit(&color, &emitter->system->start_color, &emitter->random);
					particle->start_color = zt_particleVariableColorGetValue(&color, emitter_life_pct);

					if (emitter->system->size_over_speed_used) {
						zt_particleVariableVec3Init(&particle->size_over_speed, &emitter->system->size_over_speed, &emitter->random);
					}

					ztParticleVariableRealValue speed;
					zt_particleVariableRealInit(&speed, &emitter->system->start_speed, &emitter->random);
					particle->speed = zt_particleVariableRealGetValue(&speed, emitter_life_pct);

					zt_particleVariableVec3Init(&emitter->particles[i].velocity_over_lifetime, &emitter->system->velocity_over_lifetime, &emitter->random);
					zt_particleVariableVec3Init(&emitter->particles[i].size_over_lifetime, &emitter->system->size_over_lifetime, &emitter->random);

					zt_particleVariableColorInit(&emitter->particles[i].color_over_lifetime, &emitter->system->color_over_lifetime, &emitter->random);

					if (emitter->system->color_over_speed_used) {
						zt_particleVariableColorInit(&emitter->particles[i].color_over_speed, &emitter->system->color_over_speed, &emitter->random);
					}

					ztParticleVariableVec3Value rotation;
					zt_particleVariableVec3Init(&rotation, &emitter->system->start_rotation, &emitter->random);
					particle->rotation = zt_particleVariableVec3GetValue(&rotation, emitter_life_pct);

					if (emitter->system->rotation_over_lifetime_used) {
						zt_particleVariableVec3Init(&particle->rotation_over_lifetime, &emitter->system->rotation_over_lifetime, &emitter->random);
					}
					if (emitter->system->rotation_over_speed_used) {
						zt_particleVariableVec3Init(&particle->rotation_over_speed, &emitter->system->rotation_over_speed, &emitter->random);
					}

					if (emitter->system->speed_over_lifetime_used) {
						zt_particleVariableRealInit(&particle->speed_over_lifetime, &emitter->system->speed_over_lifetime, &emitter->random);
					}

					if (emitter->system->velocity_damping_over_lifetime_used) {
						zt_particleVariableVec3Init(&particle->velocity_damping_over_lifetime, &emitter->system->velocity_damping_over_lifetime, &emitter->random);
					}

					break;
				}
			}

			if (new_particles > 0 && emitter->system->system_burst) {
				//emitter->life_left = 0;
			}
		}
	}

	{
		ZT_PROFILE_PARTICLES("zt_particleEmitterUpdate:Update");
		r32 gravity = zt_particleVariableRealGetValue(&emitter->system_gravity_multiplier, emitter_life_pct);

		int trail_segments = zt_elementsOf(emitter->particles[0].history);

		emitter->particle_ext_min = ztVec3::max;
		emitter->particle_ext_max = ztVec3::min;

		zt_fiz(emitter->particles_size) {
			if (emitter->particles[i].life_left <= 0) {
				continue;
			}

			ztParticle2 *particle = &emitter->particles[i];

			particle->life_left -= dt;
			if (particle->life_left <= 0) {
				live_particles -= 1;
				continue;
			}

			r32 particle_life_pct = 1 - (particle->life_left / particle->life_span);

			if (!zt_real32Eq(gravity, 0)) {
				particle->velocity.y -= (gravity * 1) * dt;
			}

			if (emitter->system->velocity_damping_over_lifetime_used) {
				ztVec3 damping = zt_particleVariableVec3GetValue(&particle->velocity_damping_over_lifetime, particle_life_pct);
				particle->velocity -= damping * dt;
				if (particle->velocity.x < 0) particle->velocity.x = 0;
				if (particle->velocity.y < 0) particle->velocity.y = 0;
				if (particle->velocity.z < 0) particle->velocity.z = 0;
			}

			r32 particle_speed = particle->speed * (emitter->system->speed_over_lifetime_used ? zt_particleVariableRealGetValue(&particle->speed_over_lifetime, particle_life_pct) : 1);
			ztVec3 particle_velocity;

			if (emitter->system->velocity_over_lifetime_used) {
				particle_velocity = particle->velocity * zt_particleVariableVec3GetValue(&particle->velocity_over_lifetime, particle_life_pct);
			}
			else {
				particle_velocity = particle->velocity;
			}

			if (emitter->system->rotation_over_lifetime_used) {
				ztVec3 rot = zt_particleVariableVec3GetValue(&particle->rotation_over_lifetime, particle_life_pct);
				particle->rotation += rot * dt;
			}
			if (emitter->system->rotation_over_speed_used) {
				r32 range = emitter->system->rotation_over_speed_range[1] - emitter->system->rotation_over_speed_range[0];
				if (range > 0) {
					r32 percent = (zt_clamp(particle->final_speed, emitter->system->rotation_over_speed_range[0], emitter->system->rotation_over_speed_range[1]) - emitter->system->rotation_over_speed_range[0]) / range;
					ztVec3 rot = zt_particleVariableVec3GetValue(&particle->rotation_over_speed, percent);
					particle->rotation += rot * dt;
				}
			}

			ztVec3 position_last = particle->position;
			particle->position += particle_velocity * particle_speed * dt;

			if (emitter->system->noise_use) {
				r32 multiplier = zt_particleVariableRealGetValue(&emitter->noise_multiplier, particle_life_pct);

				ztVec3 pos = zt_particleVariableVec3GetValue(&emitter->noise_position_amount, particle_life_pct);
				if (pos != ztVec3::zero) {
					pos *= zt_vec3(
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 10000) * multiplier, (particle->position.y + 10000) * multiplier, (particle->position.z + 10000) * multiplier),
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 20000) * multiplier, (particle->position.y + 20000) * multiplier, (particle->position.z + 20000) * multiplier),
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 30000) * multiplier, (particle->position.y + 30000) * multiplier, (particle->position.z + 30000) * multiplier));

					particle->position += pos * dt;
				}

				ztVec3 rot = zt_particleVariableVec3GetValue(&emitter->noise_rotation_amount, particle_life_pct);
				if (rot != ztVec3::zero) {
					rot *= zt_vec3(
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 40000) * multiplier, (particle->position.y + 40000) * multiplier, (particle->position.z + 40000) * multiplier),
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 50000) * multiplier, (particle->position.y + 50000) * multiplier, (particle->position.z + 50000) * multiplier),
						zt_simplexNoise3D(emitter->noise, (particle->position.x + 60000) * multiplier, (particle->position.y + 60000) * multiplier, (particle->position.z + 60000) * multiplier));

					particle->rotation += rot * dt;
				}

				ztVec3 sca = zt_particleVariableVec3GetValue(&emitter->noise_scale_amount, particle_life_pct);
				if (sca != ztVec3::zero) {

					if (zt_real32Eq(sca.x, sca.y) && zt_real32Eq(sca.y, sca.z)) {
						r32 val = zt_simplexNoise3D(emitter->noise, (particle->position.x + 70000) * multiplier, (particle->position.y + 70000) * multiplier, (particle->position.z + 70000) * multiplier);
						sca *= val;
					}
					else {
						sca *= zt_vec3(
							zt_simplexNoise3D(emitter->noise, (particle->position.x + 70000) * multiplier, (particle->position.y + 70000) * multiplier, (particle->position.z + 70000) * multiplier),
							zt_simplexNoise3D(emitter->noise, (particle->position.x + 80000) * multiplier, (particle->position.y + 80000) * multiplier, (particle->position.z + 80000) * multiplier),
							zt_simplexNoise3D(emitter->noise, (particle->position.x + 90000) * multiplier, (particle->position.y + 90000) * multiplier, (particle->position.z + 90000) * multiplier));
					}

					particle->scale += sca * dt;
				}

				//particle->velocity += pos * dt;
			}

			if (particle->position.x < emitter->particle_ext_min.x) emitter->particle_ext_min.x = particle->position.x;
			if (particle->position.y < emitter->particle_ext_min.y) emitter->particle_ext_min.y = particle->position.y;
			if (particle->position.z < emitter->particle_ext_min.z) emitter->particle_ext_min.z = particle->position.z;
			if (particle->position.x > emitter->particle_ext_max.x) emitter->particle_ext_max.x = particle->position.x;
			if (particle->position.y > emitter->particle_ext_max.y) emitter->particle_ext_max.y = particle->position.y;
			if (particle->position.z > emitter->particle_ext_max.z) emitter->particle_ext_max.z = particle->position.z;

			if (emitter->system->rotate_towards_movement) {
				ztMat4 mat = ztMat4::identity.getLookAt(position_last, particle->position, system_rotation.rotatePosition(zt_vec3(0, 1, 0)));
				mat.extract(nullptr, &particle->rotation, nullptr);
			}

			if (emitter->system->size_over_speed_used || emitter->system->rotation_over_speed_used || emitter->system->color_over_speed_used) {
				particle->final_speed = zt_abs(particle->position.distance(position_last)) / dt;
			}

			r32 times_per = particle->life_span / trail_segments;
			r32 times = particle->life_span - times_per;
			zt_fjz(trail_segments - 1) {
				r32 times_beg = times - times_per;
				if (zt_between(particle->life_left, times_beg, times)) {
					particle->history[j + 1] = particle->position;
					break;
				}
				times = times_beg;
			}

			if (emitter->system->color_over_speed_used) {
				r32 range = emitter->system->color_over_speed_range[1] - emitter->system->color_over_speed_range[0];
				if (range > 0) {
					r32 percent = (zt_clamp(particle->final_speed, emitter->system->color_over_speed_range[0], emitter->system->color_over_speed_range[1]) - emitter->system->color_over_speed_range[0]) / range;
					particle->color = zt_particleVariableColorGetValue(&particle->color_over_speed, percent);
				}
				else {
					particle->color = zt_particleVariableColorGetValue(&particle->color_over_lifetime, particle_life_pct);
				}
			}
			else {
				particle->color = zt_particleVariableColorGetValue(&particle->color_over_lifetime, particle_life_pct);
			}

			particle->color = particle->start_color * particle->color;
		}
	}

	emitter->time_last_particle += dt;
	if (emitter->life_left > 0) {
		emitter->life_left -= dt;
	}

	if (live_particles == 0) {
		// no remaining particles, see if we need to do anything to continue

		bool enabled = false;

		if (emitter->system->system_loops) {
			if(emitter->system->system_duration > 0) {
				emitter->life_left = emitter->system->system_duration;
			}

			enabled = true;
		}

		emitter->enabled = enabled;
	}

	return true;
}

// ================================================================================================================================================================================================

int _zt_particleEmitterRender(ztParticleEmitter *emitter, ztCamera *camera, ztDrawList *draw_list, ztVec3 *ptr_pos, ztVec2 *ptr_uv, ztVec4 *ptr_colors, ztVertexDefault *vertex_default, ztVertexDefaultLit *vertex_default_lit, int size, ztParticleEmitterRenderMesh_Func *render_mesh, void *render_mesh_user_data)
{
	ZT_PROFILE_PARTICLES("_zt_particleEmitterRender");

	zt_returnValOnNull(emitter, 0);

	if (emitter->enabled == false) {
		return 0;
	}

	int index = 0;

	if (camera != nullptr) {
		if(camera->type == ztCameraType_Perspective) {
			zt_fiz(emitter->particles_size) {
				if (emitter->particles[i].life_left <= 0) {
					continue;
				}

				emitter->particles[i].dist_from_camera = emitter->particles[i].position.distanceForCompare(camera->position);
			}
		}

		struct sort
		{
			static int compare_z(const void *one, const void *two)
			{
				ztParticle2 *pone = (ztParticle2*)one;
				ztParticle2 *ptwo = (ztParticle2*)two;

				if (pone->life_left <= 0 && ptwo->life_left <= 0) return pone < ptwo ? -1 : 1;
				if (pone->life_left <= 0) return 1;
				if (ptwo->life_left <= 0) return -1;

				if (pone->position.z < ptwo->position.z) {
					return 1;
				}
				else if (ptwo->position.z < pone->position.z) {
					return -1;
				}
				else return pone < ptwo ? -1 : 1;
			}

			static int compare_l(const void *one, const void *two)
			{
				ztParticle2 *pone = (ztParticle2*)one;
				ztParticle2 *ptwo = (ztParticle2*)two;

				if (pone->life_left <= 0 && ptwo->life_left <= 0) return pone < ptwo ? -1 : 1;
				if (pone->life_left <= 0) return 1;
				if (ptwo->life_left <= 0) return -1;

				if (pone->life_left < ptwo->life_left) {
					return 1;
				}
				else if (ptwo->life_left < pone->life_left) {
					return -1;
				}
				else return pone < ptwo ? -1 : 1;
			}

			static int compare_d(const void *one, const void *two)
			{
				ztParticle2 *pone = (ztParticle2*)one;
				ztParticle2 *ptwo = (ztParticle2*)two;

				if (pone->life_left <= 0 && ptwo->life_left <= 0) return pone < ptwo ? -1 : 1;
				if (pone->life_left <= 0) return 1;
				if (ptwo->life_left <= 0) return -1;

				if (pone->dist_from_camera < ptwo->dist_from_camera) {
					return 1;
				}
				else if (ptwo->dist_from_camera < pone->dist_from_camera) {
					return -1;
				}
				else return pone < ptwo ? -1 : 1;
			}
		};

		ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::sort");
		qsort(emitter->particles, emitter->particles_size, zt_sizeof(ztParticle2), camera->type == ztCameraType_Perspective ? sort::compare_d : sort::compare_z);
	}

	ztVec2 facing_uvs[4];
	ztVec3 facing_nml[4];

	if (camera->type == ztCameraType_Perspective && draw_list != nullptr) {
		zt_rendererSetFaceCulling(ztRendererFaceCulling_CullNone);
	}

	if (emitter->system->trails_use) {
		ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::trials");
		if (draw_list != nullptr) {
			zt_drawListPushTexture(draw_list, emitter->system->trails_sprite.tex);
			zt_drawListPushBlendMode(draw_list, emitter->system->system_rendering.blend_mode_src, emitter->system->system_rendering.blend_mode_dst);
		}

		r32 trail_width = emitter->system->trails_width_is_size ? emitter->system->trails_sprite.half_size.x : 1;

		ztVec3 nmls[4] = { ztVec3::zero, ztVec3::zero, ztVec3::zero };

		zt_fiz(emitter->particles_size) {
			if (emitter->particles[i].life_left <= 0) {
				continue;
			}

			ztParticle2 *particle = &emitter->particles[i];

			r32 particle_life_pct = 1 - (particle->life_left / particle->life_span);

			int trail_parts = 0;
			zt_fize(particle->history) {
				if (particle->history[i] != ztVec3::min) {
					trail_parts += 1;
				}
				else break;
			}

			r32 uv_pct = (emitter->system->trails_sprite.tex_uv.w - emitter->system->trails_sprite.tex_uv.y) / (trail_parts - 0);
			r32 uv_start = emitter->system->trails_sprite.tex_uv.y;

			ztVec3 prev_pos[2] = { particle->history[0], particle->history[0] };
			ztVec2 prev_uvs[2] = { zt_vec2(emitter->system->trails_sprite.tex_uv.z, emitter->system->trails_sprite.tex_uv.y), emitter->system->trails_sprite.tex_uv.xy };

			ztVec4 over_color = emitter->system->trails_inherit_color ? particle->color : ztColor_White;

			ztVec4 color = over_color * zt_particleVariableColorGetValue(&emitter->trails_color, 0);
			if (emitter->system->trails_color_over_lifetime_use) {
				color *= zt_particleVariableColorGetValue(&emitter->trails_color_over_time, 0);
			}

			for (int j = 0; j < trail_parts - 1; ++j) {
				if (particle->history[j] != ztVec3::min && particle->history[j + 1] != ztVec3::min) {
					ztQuat rotation;
					
					if (camera->type == ztCameraType_Perspective) {
						rotation = ztQuat::makeFromMat4(ztMat4::identity.getLookAt(particle->history[j], camera->position, particle->history[j + 1] - particle->history[j])).getInverse();
					}
					else {
						rotation = ztQuat::makeFromDirection(particle->history[j+1] - particle->history[j + 1]);
					}

					ztVec4 prev_color = color;
					r32 percent = (j + 1) / (r32)(trail_parts);
					color = over_color * zt_particleVariableColorGetValue(&emitter->trails_color, percent);
					if (emitter->system->trails_color_over_lifetime_use) {
						color *= zt_particleVariableColorGetValue(&emitter->trails_color_over_time, particle_life_pct);
					}

					r32 halfwidth_end = trail_width * zt_particleVariableRealGetValue(&emitter->trails_width, percent);
					ztVec3 offset_end = zt_vec3(halfwidth_end, 0, 0);

					if (j == 0) {
						r32 halfwidth_beg = trail_width * zt_particleVariableRealGetValue(&emitter->trails_width, 0);
						ztVec3 offset_beg = zt_vec3(halfwidth_beg, 0, 0);
						prev_pos[0] = particle->history[j] + (rotation.rotatePosition(offset_beg));
						prev_pos[1] = particle->history[j] - (rotation.rotatePosition(offset_beg));
					}

					ztVec3 pos[] = {
						prev_pos[0],
						particle->history[j + 1] + (rotation.rotatePosition(offset_end)),
						particle->history[j + 1] - (rotation.rotatePosition(offset_end)),
						prev_pos[1],
					};

					ztVec2 uvs[] = {
						prev_uvs[0],
						zt_vec2(emitter->system->trails_sprite.tex_uv.z, uv_start + uv_pct),
						zt_vec2(emitter->system->trails_sprite.tex_uv.x, uv_start + uv_pct),
						prev_uvs[1],
					};

					ztVec4 colors[] = {
						prev_color,
						color,
						color,
						prev_color,
					};

					bool reverse_vertices = prev_pos[0].y < offset_end.y;

					prev_pos[0] = pos[1];
					prev_pos[1] = pos[2];

					prev_uvs[0] = uvs[1];
					prev_uvs[1] = uvs[2];

					if (reverse_vertices) {
						zt_swap(pos[0], pos[3]);
						zt_swap(pos[1], pos[2]);
						zt_swap(uvs[0], uvs[3]);
						zt_swap(uvs[1], uvs[2]);
					}

					if (draw_list) {
						zt_drawListAddFilledQuad(draw_list, pos, uvs, nmls, colors);
					}
					else {
						zt_fiz(2) {
							if (index >= size - 6) {
								zt_assert(false);
								return index;
							}

							if (vertex_default_lit) {
								ztVec3 normal = rotation.rotatePosition(zt_vec3(0, 0, 1));
								ztVec4 tangent, bitangent;
								zt_triangleCalculateTangentBitangent(pos[0], pos[1], pos[2], uvs[0], uvs[1], uvs[2], &tangent, &bitangent);

								vertex_default_lit[index  ].position  = pos   [0];
								vertex_default_lit[index  ].uv        = uvs   [0];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;

								vertex_default_lit[index  ].position  = pos   [1];
								vertex_default_lit[index  ].uv        = uvs   [1];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;

								vertex_default_lit[index  ].position  = pos   [2];
								vertex_default_lit[index  ].uv        = uvs   [2];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;

								zt_triangleCalculateTangentBitangent(pos[0], pos[2], pos[3], uvs[0], uvs[2], uvs[3], &tangent, &bitangent);

								vertex_default_lit[index  ].position  = pos   [0];
								vertex_default_lit[index  ].uv        = uvs   [0];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;

								vertex_default_lit[index  ].position  = pos   [2];
								vertex_default_lit[index  ].uv        = uvs   [2];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;

								vertex_default_lit[index  ].position  = pos   [3];
								vertex_default_lit[index  ].uv        = uvs   [3];
								vertex_default_lit[index  ].color     = particle->color;
								vertex_default_lit[index  ].tangent   = tangent;
								vertex_default_lit[index  ].bitangent = bitangent;
								vertex_default_lit[index++].normal    = normal;
							}
							else if (vertex_default) {
								ztVec3 normal = rotation.rotatePosition(zt_vec3(0, 0, 1));
								vertex_default_lit[index  ].position = pos   [0];
								vertex_default_lit[index  ].uv       = uvs   [0];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;

								vertex_default_lit[index  ].position = pos   [1];
								vertex_default_lit[index  ].uv       = uvs   [1];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;

								vertex_default_lit[index  ].position = pos   [2];
								vertex_default_lit[index  ].uv       = uvs   [2];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;

								vertex_default_lit[index  ].position = pos   [0];
								vertex_default_lit[index  ].uv       = uvs   [0];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;

								vertex_default_lit[index  ].position = pos   [2];
								vertex_default_lit[index  ].uv       = uvs   [2];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;

								vertex_default_lit[index  ].position = pos   [3];
								vertex_default_lit[index  ].uv       = uvs   [3];
								vertex_default_lit[index  ].color    = particle->color;
								vertex_default_lit[index++].normal   = normal;
							}
							else {
								ptr_pos   [index  ] = pos   [0];
								ptr_uv    [index  ] = uvs   [0];
								ptr_colors[index++] = colors[0];

								ptr_pos   [index  ] = pos   [1];
								ptr_uv    [index  ] = uvs   [1];
								ptr_colors[index++] = colors[1];

								ptr_pos   [index  ] = pos   [2];
								ptr_uv    [index  ] = uvs   [2];
								ptr_colors[index++] = colors[2];

								ptr_pos   [index  ] = pos   [0];
								ptr_uv    [index  ] = uvs   [0];
								ptr_colors[index++] = colors[0];

								ptr_pos   [index  ] = pos   [2];
								ptr_uv    [index  ] = uvs   [2];
								ptr_colors[index++] = colors[2];

								ptr_pos   [index  ] = pos   [3];
								ptr_uv    [index  ] = uvs   [3];
								ptr_colors[index++] = colors[3];
							}
						}
					}

					uv_start += uv_pct;
				}
			}
		}

		if (draw_list) {
			zt_drawListPopBlendMode(draw_list);
			zt_drawListPopTexture(draw_list);
		}
	}

	bool need_uvs = false, need_anchor_adjust = false;
	ztSprite *uvs_sprite = nullptr;
	ztVec2 anchor_adjust = ztVec2::zero;
	if (emitter->system->system_rendering.type == ztParticleRenderingType_BillBoard) {
		if (emitter->system->system_rendering.billboard.sprite.half_size == ztVec2::zero) {
			return 0;
		}
		if (draw_list) {
			zt_drawListPushTexture(draw_list, emitter->system->system_rendering.billboard.sprite.tex);
			zt_drawListPushColor(draw_list, ztColor_White);
		}

		if(camera) {// && camera->type == ztCameraType_Orthographic) {
			need_uvs = true;
			uvs_sprite = &emitter->system->system_rendering.billboard.sprite;
		}
	}
	else if (emitter->system->system_rendering.type == ztParticleRenderingType_Facing) {
		if (emitter->system->system_rendering.facing.sprite.half_size == ztVec2::zero) {
			return 0;
		}
		if (draw_list) {
			zt_drawListPushTexture(draw_list, emitter->system->system_rendering.facing.sprite.tex);
			zt_drawListPushColor(draw_list, ztColor_White);
		}
		need_uvs = true;
		uvs_sprite = &emitter->system->system_rendering.facing.sprite;
	}

	if (uvs_sprite) {
		need_anchor_adjust = uvs_sprite->anchor != ztVec2::zero;
		if (need_anchor_adjust) {
			anchor_adjust = uvs_sprite->anchor * -1;
		}
	}

	if (need_uvs) {
		if (camera->type == ztCameraType_Perspective) {
			facing_uvs[0] = zt_vec2(uvs_sprite->tex_uv.z, uvs_sprite->tex_uv.y);
			facing_uvs[1] = uvs_sprite->tex_uv.xy;
			facing_uvs[2] = zt_vec2(uvs_sprite->tex_uv.x, uvs_sprite->tex_uv.w);
			facing_uvs[3] = uvs_sprite->tex_uv.zw;
		}
		else {
			facing_uvs[0] = zt_vec2(uvs_sprite->tex_uv.x, uvs_sprite->tex_uv.y);
			facing_uvs[1] = zt_vec2(uvs_sprite->tex_uv.x, uvs_sprite->tex_uv.w);
			facing_uvs[2] = zt_vec2(uvs_sprite->tex_uv.z, uvs_sprite->tex_uv.w);
			facing_uvs[3] = zt_vec2(uvs_sprite->tex_uv.z, uvs_sprite->tex_uv.y);;
		}
		facing_nml[0] = zt_vec3(0, 0, 1);
		facing_nml[1] = zt_vec3(0, 0, 1);
		facing_nml[2] = zt_vec3(0, 0, 1);
		facing_nml[3] = zt_vec3(0, 0, 1);
	}

	bool mesh_render = emitter->system->system_rendering.type == ztParticleRenderingType_Mesh;

	if (draw_list && !mesh_render) {
		zt_drawListPushBlendMode(draw_list, emitter->system->system_rendering.blend_mode_src, emitter->system->system_rendering.blend_mode_dst);
	}

	ztMat4 mat_billboard;

	if (camera->type == ztCameraType_Perspective && emitter->system->system_rendering.type == ztParticleRenderingType_BillBoard && draw_list == nullptr) {
		mat_billboard = ztMat4::identity.getLookAt(camera->position, emitter->position, zt_vec3(0, 1, 0)).getInverse();
		mat_billboard.values[ztMat4_Col3Row0] = mat_billboard.values[ztMat4_Col3Row1] = mat_billboard.values[ztMat4_Col3Row2] = 0; // remove translation
	}

	zt_fiz(emitter->particles_size) {
		if (emitter->particles[i].life_left <= 0) {
			continue;
		}

		ztParticle2 *particle = &emitter->particles[i];

		r32 particle_life_pct = 1 - (particle->life_left / particle->life_span);

		ztVec3 position = particle->position;
		if (emitter->system->system_local_space) {
			position += emitter->position;
		}
		ztVec3 scale = particle->scale;

		if (emitter->system->size_over_lifetime_used) {
			scale *= zt_particleVariableVec3GetValue(&particle->size_over_lifetime, particle_life_pct);
		}
		if (emitter->system->size_over_speed_used) {
			r32 range = emitter->system->size_over_speed_range[1] - emitter->system->size_over_speed_range[0];
			if (range > 0) {
				r32 percent = (zt_clamp(particle->final_speed, emitter->system->size_over_speed_range[0], emitter->system->size_over_speed_range[1]) - emitter->system->size_over_speed_range[0]) / range;
				ztVec3 speed_factor = zt_particleVariableVec3GetValue(&particle->size_over_speed, percent);
				scale *= speed_factor;
			}
		}

		if(camera->type == ztCameraType_Perspective) {
			ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::perspective");
			if (draw_list && !mesh_render) {
				zt_drawListPushColor(draw_list, particle->color);
			}

			switch (emitter->system->system_rendering.type)
			{
				case ztParticleRenderingType_BillBoard: {
					if (draw_list) {
						if (emitter->system->rotate_towards_movement) {
							zt_drawListAddBillboard(draw_list, position, emitter->system->system_rendering.billboard.sprite.half_size * 2 * scale.xy, 0, emitter->system->system_rendering.billboard.sprite.tex_uv.xy, emitter->system->system_rendering.billboard.sprite.tex_uv.zw, ztDrawCommandBillboardFlags_AxisX | ztDrawCommandBillboardFlags_AxisY | ztDrawCommandBillboardFlags_AxisZ, particle->velocity.getNormal());
						}
						else {
							zt_drawListAddBillboard(draw_list, position, emitter->system->system_rendering.billboard.sprite.half_size * 2 * scale.xy, particle->rotation.z, emitter->system->system_rendering.billboard.sprite.tex_uv.xy, emitter->system->system_rendering.billboard.sprite.tex_uv.zw);
						}
					}
					else {
						ztVec3 pos[4];
						ztVec3 normal = zt_vec3(0, 0, 1);

						if (particle->rotation == ztVec3::zero) {
							pos[0] = zt_vec3((anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[1] = zt_vec3((anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[2] = zt_vec3((anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[3] = zt_vec3((anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);

							if (need_anchor_adjust) {
								zt_fize(pos) {
									pos[i].xy += anchor_adjust;
								}
							}
						}
						else {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::rotate_billboard");
							pos[0] = zt_vec3((anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[1] = zt_vec3((anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[2] = zt_vec3((anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x - emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);
							pos[3] = zt_vec3((anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.x) * scale.x, (anchor_adjust.x + emitter->system->system_rendering.billboard.sprite.half_size.y) * scale.y, 0);

							if (need_anchor_adjust) {
								zt_fize(pos) {
									pos[i].xy += anchor_adjust;
								}
							}

							ztQuat quat = ztQuat::makeFromEuler(0, 0, particle->rotation.z);
						
							quat.rotatePosition(&pos[0]);
							quat.rotatePosition(&pos[1]);
							quat.rotatePosition(&pos[2]);
							quat.rotatePosition(&pos[3]);
							quat.rotatePosition(&normal);
						}

						{
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::apply_billboard");
							// apply billboard transform
							zt_fize(pos) {
								pos[i] = position + (mat_billboard * pos[i]);
							}
							normal = mat_billboard * normal;
						}

						if (index >= size - 6) {
							zt_assert(false);
							return index;
						}

						if (vertex_default_lit) {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::billboard_vertex_default_lit");

							ztVec4 tangent, bitangent;
							zt_triangleCalculateTangentBitangent(pos[0], pos[1], pos[2], facing_uvs[0], facing_uvs[1], facing_uvs[2], &tangent, &bitangent);

							vertex_default_lit[index  ].position  = pos       [0];
							vertex_default_lit[index  ].uv        = facing_uvs[0];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [1];
							vertex_default_lit[index  ].uv        = facing_uvs[1];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [2];
							vertex_default_lit[index  ].uv        = facing_uvs[2];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							zt_triangleCalculateTangentBitangent(pos[0], pos[2], pos[3], facing_uvs[0], facing_uvs[2], facing_uvs[3], &tangent, &bitangent);

							vertex_default_lit[index  ].position  = pos       [0];
							vertex_default_lit[index  ].uv        = facing_uvs[0];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [2];
							vertex_default_lit[index  ].uv        = facing_uvs[2];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [3];
							vertex_default_lit[index  ].uv        = facing_uvs[3];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;
						}
						else if (vertex_default) {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::billboard_vertex_default");
							ztVec3 normal = zt_vec3(0, 0, 1);

							vertex_default_lit[index  ].position = pos       [0];
							vertex_default_lit[index  ].uv       = facing_uvs[0];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [1];
							vertex_default_lit[index  ].uv       = facing_uvs[1];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [2];
							vertex_default_lit[index  ].uv       = facing_uvs[2];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [0];
							vertex_default_lit[index  ].uv       = facing_uvs[0];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [2];
							vertex_default_lit[index  ].uv       = facing_uvs[2];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [3];
							vertex_default_lit[index  ].uv       = facing_uvs[3];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;
						}
						else {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::billboard_arrays");
							ptr_pos[index] = pos[0];
							ptr_uv    [index  ] = facing_uvs[0];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [1];
							ptr_uv    [index  ] = facing_uvs[1];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [2];
							ptr_uv    [index  ] = facing_uvs[2];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [0];
							ptr_uv    [index  ] = facing_uvs[0];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [2];
							ptr_uv    [index  ] = facing_uvs[2];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [3];
							ptr_uv    [index  ] = facing_uvs[3];
							ptr_colors[index++] = particle->color;
						}

					}
				} break;

				case ztParticleRenderingType_Facing: {
					ztVec3 pos[4];
					ztVec3 normal = zt_vec3(0, 0, 1);

					if (particle->rotation == ztVec3::zero) {
						pos[0] = zt_vec3(position.x + (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x, position.y + (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, position.z);
						pos[1] = zt_vec3(position.x + (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x, position.y + (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, position.z);
						pos[2] = zt_vec3(position.x + (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x, position.y + (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, position.z);
						pos[3] = zt_vec3(position.x + (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x, position.y + (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, position.z);
					}
					else {
						ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::facing_rotation");
						pos[0] = zt_vec3(0, (anchor_adjust.y + emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x);
						pos[1] = zt_vec3(0, (anchor_adjust.y - emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, (anchor_adjust.x - emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x);
						pos[2] = zt_vec3(0, (anchor_adjust.y - emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x);
						pos[3] = zt_vec3(0, (anchor_adjust.y + emitter->system->system_rendering.facing.sprite.half_size.y) * scale.y, (anchor_adjust.x + emitter->system->system_rendering.facing.sprite.half_size.x) * scale.x);

						ztQuat quat = ztQuat::makeFromEuler(particle->rotation.x, particle->rotation.y, particle->rotation.z);

						quat.rotatePosition(&pos[0]);
						quat.rotatePosition(&pos[1]);
						quat.rotatePosition(&pos[2]);
						quat.rotatePosition(&pos[3]);
						quat.rotatePosition(&normal);

						pos[0] += position;
						pos[1] += position;
						pos[2] += position;
						pos[3] += position;
					}

					if (draw_list) {
						zt_drawListAddFilledPoly(draw_list, pos, facing_uvs, facing_nml, 4);
					}
					else {
						if (index >= size - 6) {
							zt_assert(false);
							return index;
						}

						if (vertex_default_lit) {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::facing_vertex_default_lit");

							ztVec4 tangent, bitangent;
							zt_triangleCalculateTangentBitangent(pos[0], pos[1], pos[2], facing_uvs[0], facing_uvs[1], facing_uvs[2], &tangent, &bitangent);

							vertex_default_lit[index  ].position  = pos       [0];
							vertex_default_lit[index  ].uv        = facing_uvs[0];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [1];
							vertex_default_lit[index  ].uv        = facing_uvs[1];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [2];
							vertex_default_lit[index  ].uv        = facing_uvs[2];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							zt_triangleCalculateTangentBitangent(pos[0], pos[2], pos[3], facing_uvs[0], facing_uvs[2], facing_uvs[3], &tangent, &bitangent);

							vertex_default_lit[index  ].position  = pos       [0];
							vertex_default_lit[index  ].uv        = facing_uvs[0];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [2];
							vertex_default_lit[index  ].uv        = facing_uvs[2];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;

							vertex_default_lit[index  ].position  = pos       [3];
							vertex_default_lit[index  ].uv        = facing_uvs[3];
							vertex_default_lit[index  ].color     = particle->color;
							vertex_default_lit[index  ].tangent   = tangent;
							vertex_default_lit[index  ].bitangent = bitangent;
							vertex_default_lit[index++].normal    = normal;
						}
						else if (vertex_default) {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::facing_vertex_default");
							ztVec3 normal = zt_vec3(0, 0, 1);

							vertex_default_lit[index  ].position = pos       [0];
							vertex_default_lit[index  ].uv       = facing_uvs[0];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [1];
							vertex_default_lit[index  ].uv       = facing_uvs[1];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [2];
							vertex_default_lit[index  ].uv       = facing_uvs[2];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [0];
							vertex_default_lit[index  ].uv       = facing_uvs[0];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [2];
							vertex_default_lit[index  ].uv       = facing_uvs[2];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;

							vertex_default_lit[index  ].position = pos       [3];
							vertex_default_lit[index  ].uv       = facing_uvs[3];
							vertex_default_lit[index  ].color    = particle->color;
							vertex_default_lit[index++].normal   = normal;
						}
						else {
							ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::facing_arrays");
							ptr_pos[index] = pos[0];
							ptr_uv    [index  ] = facing_uvs[0];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [1];
							ptr_uv    [index  ] = facing_uvs[1];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [2];
							ptr_uv    [index  ] = facing_uvs[2];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [0];
							ptr_uv    [index  ] = facing_uvs[0];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [2];
							ptr_uv    [index  ] = facing_uvs[2];
							ptr_colors[index++] = particle->color;

							ptr_pos   [index  ] = pos       [3];
							ptr_uv    [index  ] = facing_uvs[3];
							ptr_colors[index++] = particle->color;
						}
					}
				} break;

				case ztParticleRenderingType_Mesh: {
					if (render_mesh != nullptr) {
						render_mesh(emitter, camera, draw_list, emitter->system->system_rendering.mesh.mesh_id, particle, position, particle->rotation, scale, particle->color, render_mesh_user_data);
					}
				} break;
			}
			if (draw_list) {
				zt_drawListPopColor(draw_list);
			}
		}
		else {
			ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::ortho");
			ztSprite *sprite = nullptr;

			switch (emitter->system->system_rendering.type)
			{
				case ztParticleRenderingType_BillBoard: {
					sprite = &emitter->system->system_rendering.billboard.sprite;
				} break;

				case ztParticleRenderingType_Facing: {
					sprite = &emitter->system->system_rendering.facing.sprite;
				} break;

				case ztParticleRenderingType_Mesh: {
					if (render_mesh != nullptr) {
						render_mesh(emitter, camera, draw_list, emitter->system->system_rendering.mesh.mesh_id, particle, position, particle->rotation, scale, particle->color, render_mesh_user_data);
					}
				} break;
			}

			//sprite = nullptr;

			if (sprite != nullptr) {
				ztVec3 pos[4];
				ztVec3 normal = zt_vec3(0, 0, 1);

				if (particle->rotation == ztVec3::zero) {
					pos[0] = zt_vec3(position.x + (anchor_adjust.x - sprite->half_size.x) * scale.x, position.y + (anchor_adjust.y + sprite->half_size.y) * scale.y, position.z);
					pos[1] = zt_vec3(position.x + (anchor_adjust.x - sprite->half_size.x) * scale.x, position.y + (anchor_adjust.y - sprite->half_size.y) * scale.y, position.z);
					pos[2] = zt_vec3(position.x + (anchor_adjust.x + sprite->half_size.x) * scale.x, position.y + (anchor_adjust.y - sprite->half_size.y) * scale.y, position.z);
					pos[3] = zt_vec3(position.x + (anchor_adjust.x + sprite->half_size.x) * scale.x, position.y + (anchor_adjust.y + sprite->half_size.y) * scale.y, position.z);
				}
				else {
					ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::rotation");
					pos[0] = zt_vec3((anchor_adjust.x - sprite->half_size.x) * scale.x, (anchor_adjust.y + sprite->half_size.y) * scale.y, 0);
					pos[1] = zt_vec3((anchor_adjust.x - sprite->half_size.x) * scale.x, (anchor_adjust.y - sprite->half_size.y) * scale.y, 0);
					pos[2] = zt_vec3((anchor_adjust.x + sprite->half_size.x) * scale.x, (anchor_adjust.y - sprite->half_size.y) * scale.y, 0);
					pos[3] = zt_vec3((anchor_adjust.x + sprite->half_size.x) * scale.x, (anchor_adjust.y + sprite->half_size.y) * scale.y, 0);

					ztQuat quat = ztQuat::makeFromEuler(0, 0, -(particle->rotation.z + (particle->velocity.x > 0 ? 90.f : -90.f)));
					quat.rotatePosition(&pos[0]);
					quat.rotatePosition(&pos[1]);
					quat.rotatePosition(&pos[2]);
					quat.rotatePosition(&pos[3]);
					quat.rotatePosition(&normal);


					pos[0] += position;
					pos[1] += position;
					pos[2] += position;
					pos[3] += position;
				}

				if (draw_list) {
					ztVec4 colors[] = {
						particle->color,
						particle->color,
						particle->color,
						particle->color,
					};

					zt_drawListAddFilledPoly(draw_list, pos, facing_uvs, facing_nml, colors, 4);
				}
				else {
					if (index >= size - 6) {
						zt_assert(false);
						return index;
					}

					if (vertex_default_lit) {
						ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::vertex_default_lit");
						ztVec4 tangent, bitangent;
						zt_triangleCalculateTangentBitangent(pos[0], pos[1], pos[2], facing_uvs[0], facing_uvs[1], facing_uvs[2], &tangent, &bitangent);

						vertex_default_lit[index  ].position  = pos       [0];
						vertex_default_lit[index  ].uv        = facing_uvs[0];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;

						vertex_default_lit[index  ].position  = pos       [1];
						vertex_default_lit[index  ].uv        = facing_uvs[1];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;

						vertex_default_lit[index  ].position  = pos       [2];
						vertex_default_lit[index  ].uv        = facing_uvs[2];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;

						zt_triangleCalculateTangentBitangent(pos[0], pos[2], pos[3], facing_uvs[0], facing_uvs[2], facing_uvs[3], &tangent, &bitangent);

						vertex_default_lit[index  ].position  = pos       [0];
						vertex_default_lit[index  ].uv        = facing_uvs[0];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;

						vertex_default_lit[index  ].position  = pos       [2];
						vertex_default_lit[index  ].uv        = facing_uvs[2];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;

						vertex_default_lit[index  ].position  = pos       [3];
						vertex_default_lit[index  ].uv        = facing_uvs[3];
						vertex_default_lit[index  ].color     = particle->color;
						vertex_default_lit[index  ].tangent   = tangent;
						vertex_default_lit[index  ].bitangent = bitangent;
						vertex_default_lit[index++].normal    = normal;
					}
					else if (vertex_default) {
						ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::vertex_default");
						vertex_default_lit[index].position = pos[0];
						vertex_default_lit[index  ].uv       = facing_uvs[0];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;

						vertex_default_lit[index  ].position = pos       [1];
						vertex_default_lit[index  ].uv       = facing_uvs[1];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;

						vertex_default_lit[index  ].position = pos       [2];
						vertex_default_lit[index  ].uv       = facing_uvs[2];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;

						vertex_default_lit[index  ].position = pos       [0];
						vertex_default_lit[index  ].uv       = facing_uvs[0];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;

						vertex_default_lit[index  ].position = pos       [2];
						vertex_default_lit[index  ].uv       = facing_uvs[2];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;

						vertex_default_lit[index  ].position = pos       [3];
						vertex_default_lit[index  ].uv       = facing_uvs[3];
						vertex_default_lit[index  ].color    = particle->color;
						vertex_default_lit[index++].normal   = normal;
					}
					else {
						ZT_PROFILE_PARTICLES("_zt_particleEmitterRender::arrays");
						ptr_pos[index] = pos[0];
						ptr_uv    [index  ] = facing_uvs[0];
						ptr_colors[index++] = particle->color;

						ptr_pos   [index  ] = pos       [1];
						ptr_uv    [index  ] = facing_uvs[1];
						ptr_colors[index++] = particle->color;

						ptr_pos   [index  ] = pos       [2];
						ptr_uv    [index  ] = facing_uvs[2];
						ptr_colors[index++] = particle->color;

						ptr_pos   [index  ] = pos       [0];
						ptr_uv    [index  ] = facing_uvs[0];
						ptr_colors[index++] = particle->color;

						ptr_pos   [index  ] = pos       [2];
						ptr_uv    [index  ] = facing_uvs[2];
						ptr_colors[index++] = particle->color;

						ptr_pos   [index  ] = pos       [3];
						ptr_uv    [index  ] = facing_uvs[3];
						ptr_colors[index++] = particle->color;
					}
				}
			}
			else {
				if (draw_list && !mesh_render) {
					zt_drawListAddSolidCircle2D(draw_list, position, .05f, 16, particle->color);
				}
			}
		}
	}

	if (draw_list && !mesh_render) {
		zt_drawListPopBlendMode(draw_list);
		if (emitter->system->system_rendering.type == ztParticleRenderingType_BillBoard || emitter->system->system_rendering.type == ztParticleRenderingType_Facing) {
			zt_drawListPopColor(draw_list);
			zt_drawListPopTexture(draw_list);
		}

		if (camera->type == ztCameraType_Perspective) {
			zt_rendererSetFaceCulling(ztRendererFaceCulling_CullBack);
		}
	}

#if 0
	zt_drawListPushTexture(draw_list, ztTextureDefault);
	zt_drawListPushColor(draw_list, ztColor_Cyan * zt_vec4(1, 1, 1, .5f));
	zt_fiz(emitter->particles_size) {
		if (emitter->particles[i].life_left <= 0) {
			continue;
		}
		ztParticle2 *particle = &emitter->particles[i];

		for (int j = 0; j < zt_elementsOf(particle->history) - 1; ++j) {
			if (particle->history[j] != ztVec3::min && particle->history[j + 1] != ztVec3::min) {
				zt_drawListAddLine(draw_list, particle->history[j], particle->history[j + 1]);
			}
		}
	}
	zt_drawListPopColor(draw_list);
	zt_drawListPopTexture(draw_list);
#endif

#if 0
	zt_drawListPushTexture(draw_list, ztTextureDefault);
	zt_fiz(emitter->particles_size) {
		if (emitter->particles[i].life_left <= 0) {
			continue;
		}
		ztParticle2 *particle = &emitter->particles[i];

		zt_drawListPushTransform(draw_list, ztMat4::identity.getTranslate(particle->position) * ztMat4::identity.getRotateEuler(particle->rotation));
		zt_drawListAddAxis(draw_list, particle->scale.x * .5f, ztVec3::zero);
		zt_drawListPopTransform(draw_list);
		zt_drawListAddLine(draw_list, ztVec3::zero, particle->position);

	}
	zt_drawListPopTexture(draw_list);
#endif

	return index;
}

// ================================================================================================================================================================================================

void zt_particleEmitterRender(ztParticleEmitter *emitter, ztDrawList *draw_list, ztCamera *camera, ztParticleEmitterRenderMesh_Func *render_mesh, void *render_mesh_user_data)
{
	//zt_returnOnNull(draw_list);
	_zt_particleEmitterRender(emitter, camera, draw_list, nullptr, nullptr, nullptr, nullptr, nullptr, 0, render_mesh, render_mesh_user_data);
}

// ================================================================================================================================================================================================

int zt_particleEmitterGetTriangles(ztParticleEmitter *emitter, ztCamera *camera, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size)
{
	return _zt_particleEmitterRender(emitter, camera, nullptr, pos, uv, colors, nullptr, nullptr, size, nullptr, nullptr);
}

// ================================================================================================================================================================================================

int zt_particleEmitterFillVertices(ztParticleEmitter *emitter, ztCamera *camera, ztVertexDefault *vertices, int size)
{
	return _zt_particleEmitterRender(emitter, camera, nullptr, nullptr, nullptr, nullptr, vertices, nullptr, size, nullptr, nullptr);
}

// ================================================================================================================================================================================================

int zt_particleEmitterFillVertices(ztParticleEmitter *emitter, ztCamera *camera, ztVertexDefaultLit *vertices, int size)
{
	return _zt_particleEmitterRender(emitter, camera, nullptr, nullptr, nullptr, nullptr, nullptr, vertices, size, nullptr, nullptr);
}

// ================================================================================================================================================================================================

void zt_particleEmitterPoolInit(ztParticleEmitterPool *pool, int emitters_count, ztParticleSystem *system, i32 seed, bool random_seeds)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolInit");
	zt_returnOnNull(pool);
	zt_returnOnNull(system);

	ztRandom random;
	if (random_seeds) {
		zt_randomInit(&random, seed);
	}

	i32 max_particles = 0;
	i32 size = _zt_particleEmitterGetEachEmitterSize(system, &max_particles);
	i32 total_size = size * emitters_count + (zt_sizeof(ztParticleEmitter*) * emitters_count);

	{
		char mem[64];
		zt_strBytesToString(mem, zt_elementsOf(mem), total_size);
		zt_logDebug("particle pool memory allocated: %s", mem);
	}

	//pool->emitters = zt_mallocStructArray(ztParticleEmitter*, emitters_count);

	byte *data = zt_mallocStructArray(byte, total_size);

	pool->emitters = (ztParticleEmitter**)data;
	pool->emitters_count = emitters_count;

	data += zt_sizeof(ztParticleEmitter*) * emitters_count;

	zt_memCpy(&pool->system, zt_sizeof(ztParticleSystem), system, zt_sizeof(ztParticleSystem));

	zt_fiz(emitters_count) {
		//ztParticleEmitter *emitter = zt_mallocStruct(ztParticleEmitter);
		//emitter->particles = zt_mallocStructArray(ztParticle2, max_particles);
		ztParticleEmitter *emitter = (ztParticleEmitter*)data;
		emitter->particles = (ztParticle2*)(((byte*)emitter) + zt_sizeof(ztParticleEmitter));
		emitter->particles_size = max_particles;

		data += size;

		_zt_particleEmitterInit(emitter, &pool->system, random_seeds ? zt_randomInt(&random, 0, ztInt32Max) : seed);

		pool->emitters[i] = emitter;
	}
}

// ================================================================================================================================================================================================

void zt_particleEmitterPoolFree(ztParticleEmitterPool *pool)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolFree");
	if (pool == nullptr) {
		return;
	}

	if (pool->emitters != nullptr) {
		zt_fiz(pool->emitters_count) {
			if (pool->emitters[i]->noise) {
				zt_simplexNoiseFree(pool->emitters[i]->noise);
			}
		}

		zt_free(pool->emitters);
	}

	pool->emitters_count = 0;
	pool->emitters = nullptr;
}

// ================================================================================================================================================================================================

void zt_particleEmitterPoolUpdate(ztParticleEmitterPool *pool, r32 dt)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolUpdate");
	zt_returnOnNull(pool);

	zt_fiz(pool->emitters_count) {
		if (pool->emitters[i]->enabled) {
			zt_particleEmitterUpdate(pool->emitters[i], dt);
		}
	}
}

// ================================================================================================================================================================================================

struct ztParticleEmitterCameraCuller
{
	union {
		struct {
			ztVec2 aabb_center;
			ztVec2 aabb_size;
		};

		struct {
			ztFrustum frustum;
		};
	};

	ztParticleEmitterCameraCuller(ztCamera *camera)
	{
		if(camera->type == ztCameraType_Perspective) {
			zt_cameraCalcViewFrustum(&frustum, camera);
		}
		else {
			aabb_center = camera->position.xy;
			aabb_size = zt_cameraOrthoGetViewportSize(camera);
		}
	}

	bool culled(ztParticleEmitter *emitter, ztCamera *camera)
	{
		ztVec3 emitter_extents = (emitter->particle_ext_max - emitter->particle_ext_min);
		if(camera->type == ztCameraType_Perspective) {
			return !zt_collisionAABBInFrustum(frustum, emitter->position, emitter_extents);
		}
		else {
			return !zt_collisionAABBInAABB(aabb_center, aabb_size, emitter->position.xy, emitter_extents.xy);
		}
	}
};

// ================================================================================================================================================================================================

void zt_particleEmitterPoolRender(ztParticleEmitterPool *pool, ztDrawList *draw_list, ztCamera *camera)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolRender");
	zt_returnOnNull(pool);

	ztParticleEmitterCameraCuller culler(camera);

	zt_fiz(pool->emitters_count) {
		if (pool->emitters[i]->enabled && !culler.culled(pool->emitters[i], camera)) {
			zt_particleEmitterRender(pool->emitters[i], draw_list, camera);
		}
	}
}

// ================================================================================================================================================================================================

int zt_particleEmitterPoolGetTriangles(ztParticleEmitterPool *pool, ztCamera *camera, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolGetTriangles");
	zt_returnValOnNull(pool, 0);

	int total = 0;

	ztParticleEmitterCameraCuller culler(camera);

	zt_fiz(pool->emitters_count) {
		if (pool->emitters[i]->enabled && !culler.culled(pool->emitters[i], camera)) {
			int this_total = zt_particleEmitterGetTriangles(pool->emitters[i], camera, pos, uv, colors, size);

			total += this_total;
			pos += this_total;
			uv += this_total;
			colors += this_total;
			size -= this_total;
		}
	}

	return total;
}

// ================================================================================================================================================================================================

int zt_particleEmitterPoolFillVertices(ztParticleEmitterPool *pool, ztCamera *camera, ztVertexDefault *vertices, int size)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolFillVertices");
	zt_returnValOnNull(pool, 0);

	int total = 0;

	ztParticleEmitterCameraCuller culler(camera);

	zt_fiz(pool->emitters_count) {
		if (pool->emitters[i]->enabled && !culler.culled(pool->emitters[i], camera)) {
			int this_total = zt_particleEmitterFillVertices(pool->emitters[i], camera, vertices, size);

			total += this_total;
			vertices += this_total;
			size -= this_total;
		}
	}

	return total;
}

// ================================================================================================================================================================================================

int zt_particleEmitterPoolFillVertices(ztParticleEmitterPool *pool, ztCamera *camera, ztVertexDefaultLit *vertices, int size)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolFillVertices");
	zt_returnValOnNull(pool, 0);

	int total = 0;

	ztParticleEmitterCameraCuller culler(camera);

	zt_fiz(pool->emitters_count) {
		if (pool->emitters[i]->enabled && !culler.culled(pool->emitters[i], camera)) {
			int this_total = zt_particleEmitterFillVertices(pool->emitters[i], camera, vertices, size);

			total += this_total;
			vertices += this_total;
			size -= this_total;
		}
	}

	return total;
}

// ================================================================================================================================================================================================

void zt_particleEmitterPoolResetAll(ztParticleEmitterPool *pool)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolResetAll");
	zt_returnOnNull(pool);

	zt_fiz(pool->emitters_count) {
		pool->emitters[i]->enabled = false;
	}
}

// ================================================================================================================================================================================================

ztParticleEmitter *zt_particleEmitterPoolGetAvailable(ztParticleEmitterPool *pool)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitterPoolGetAvailable");

	zt_fiz(pool->emitters_count) {
		if (!pool->emitters[i]->enabled) {
			zt_particleEmitterReset(pool->emitters[i]);
			pool->emitters[i]->enabled = true;
			return pool->emitters[i];
		}
	}

	//zt_assert(false);
	return nullptr;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================


ztParticleEmitter2D zt_particleEmitter2DMake(ztParticleEmitterSettings *settings, ztSprite *sprite, i32 seed, r32 prewarm_time)
{
	int props = 1;
	return zt_particleEmitter2DMake(settings, sprite, &props, 1, seed, prewarm_time);
}

// ================================================================================================================================================================================================

ztParticleEmitter2D zt_particleEmitter2DMake(ztParticleEmitterSettings *settings, ztSprite *sprites, int *sprites_props, int sprites_count, i32 seed, r32 prewarm_time)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitter2DMake");
	ztParticleEmitter2D emitter = {};

	zt_memCpy(&emitter.settings, zt_sizeof(ztParticleEmitterSettings), settings, zt_sizeof(ztParticleEmitterSettings));

	zt_fiz(sprites_count) {
		emitter.sprites[i] = sprites[i];
		emitter.sprites_props[i] = sprites_props[i];
	}
	emitter.sprites_count = sprites_count;

	emitter.particles_count = zt_min(ZT_MAX_PARTICLES, zt_convertToi32Ceil(settings->emission_rate * (settings->burst_emit || settings->emitter_lifetime  == 0 ? 1 : settings->lifetime)));
	zt_fiz(emitter.particles_count) {
		emitter.particles[i].life = 0;
	}

	emitter.live_particles = 0;
	emitter.time_between_particles = settings->burst_emit ? 0 : 1.0f / (zt_min(settings->emission_rate, ZT_MAX_PARTICLES) / (settings->emitter_lifetime == 0 ? 1 : settings->emitter_lifetime));
	emitter.time_last_particle = 0;
	emitter.lifetime = settings->lifetime;
	emitter.enabled = true;

	zt_randomInit(&emitter.randomizer, seed);

	if (prewarm_time > 0) {
		r32 dt = 1.f / 60.f;
		while (prewarm_time > 0) {
			prewarm_time -= dt;
			zt_particleEmitter2DUpdate(&emitter, dt);
		}
	}

	return emitter;
}

// ================================================================================================================================================================================================

bool zt_particleEmitter2DUpdate(ztParticleEmitter2D *emitter, r32 dt, ztParticleEmitParticle_Func emit_particle, void *user_data)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitter2DUpdate");
	zt_returnValOnNull(emitter, false);

	if (emitter->enabled == false) {
		return false;
	}

	// update existing particles before creating new ones
	zt_fiz(emitter->particles_count) {
		if (emitter->particles[i].life) {
			emitter->particles[i].life -= dt;
			if (emitter->particles[i].life > 0) {
				// should add friction affect to speed here
				// <- here

				// move particle
				if (emitter->settings.burst_emit && emitter->settings.emitter_lifetime > 0) {
					r32 pct = zt_clamp(emitter->lifetime / emitter->settings.emitter_lifetime, 0, 1);
					r32 speed = emitter->particles[i].speed * pct;
					emitter->particles[i].transform.position.x += (emitter->settings.gravity_velocity.x * dt) + zt_cos(zt_degreesToRadians(emitter->particles[i].angle)) * speed * dt;
					emitter->particles[i].transform.position.y += (emitter->settings.gravity_velocity.y * dt) + zt_sin(zt_degreesToRadians(emitter->particles[i].angle)) * speed * dt;
					emitter->particles[i].transform.position.z = zt_lerp(emitter->settings.z_life_begin, emitter->settings.z_life_end, emitter->particles[i].life / emitter->settings.lifetime);
				}
				else {
					emitter->particles[i].transform.position.x += (emitter->settings.gravity_velocity.x * dt) + zt_cos(zt_degreesToRadians(emitter->particles[i].angle)) * emitter->particles[i].speed * dt;
					emitter->particles[i].transform.position.y += (emitter->settings.gravity_velocity.y * dt) + zt_sin(zt_degreesToRadians(emitter->particles[i].angle)) * emitter->particles[i].speed * dt;
					emitter->particles[i].transform.position.z = zt_lerp(emitter->settings.z_life_begin, emitter->settings.z_life_end, emitter->particles[i].life / emitter->settings.lifetime);
				}

				if (emitter->settings.rotation != 0) {
					emitter->particles[i].transform.rotation *= ztQuat::makeFromEuler(0, 0, emitter->particles[i].rotation * dt);
				}
			}
			else {
				emitter->particles[i].life = 0;
				emitter->live_particles -= 1;
			}
		}
	}

	if (emitter->settings.z_sort) {
		struct local
		{
			static int compare(const void *one, const void *two)
			{
				ztParticle *pone = (ztParticle*)one;
				ztParticle *ptwo = (ztParticle*)two;

				if (pone->life <= 0 && ptwo->life <= 0) return pone < ptwo ? -1 : 1;
				if (pone->life <= 0) return 1;
				if (ptwo->life <= 0) return -1;

				if (pone->transform.position.z < ptwo->transform.position.z) {
					return 1;
				}
				else if (ptwo->transform.position.z < pone->transform.position.z) {
					return -1;
				}
				else return pone < ptwo ? -1 : 1;
			}
		};

		qsort(emitter->particles, emitter->particles_count, zt_sizeof(ztParticle), local::compare);
	}

	// emit new particles if needed
	if (emitter->settings.emitter_lifetime != 0 && emitter->lifetime < 0) {
		if (emitter->live_particles <= 0) {
			emitter->enabled = false;
			return false;
		}
	}
	else {
		bool first = emitter->time_last_particle == 0;
		emitter->time_last_particle += dt;
		while (emitter->time_last_particle > emitter->time_between_particles) {
			emitter->time_last_particle -= emitter->time_between_particles;
			if ((!first && emitter->live_particles >= emitter->particles_count) || (!first && emitter->settings.burst_emit)) {
				break;
			}

			zt_fiz(emitter->particles_count) {
				if (emitter->particles[i].life <= 0) {

					r32 diff = 360 * emitter->settings.velocity_angle_random * zt_randomVal(&emitter->randomizer);
					r32 angle = emitter->settings.velocity_angle - (360 * emitter->settings.velocity_angle_random * .5f) + diff;
					if (angle < 0) angle += 360;

					ztVec3 offset = emitter->settings.local_space ? ztVec3::zero : emitter->settings.origin;

					emitter->particles[i].life                = emitter->settings.lifetime - (emitter->settings.lifetime * (emitter->settings.lifetime_random * zt_randomVal(&emitter->randomizer)));
					emitter->particles[i].life_span           = emitter->particles[i].life;
					emitter->particles[i].angle               = angle;
					emitter->particles[i].transform.position  = zt_vec3(offset.x + (zt_randomVal(&emitter->randomizer) * emitter->settings.size.x) - emitter->settings.size.x / 2,
					                                                   offset.y + (zt_randomVal(&emitter->randomizer) * emitter->settings.size.y) - emitter->settings.size.y / 2,
					                                                   offset.z + (zt_randomVal(&emitter->randomizer) * emitter->settings.size.z) - emitter->settings.size.z / 2);
					emitter->particles[i].speed               = emitter->settings.velocity_speed - (emitter->settings.velocity_speed * (emitter->settings.velocity_speed_random * zt_randomVal(&emitter->randomizer)));
					emitter->particles[i].rotation            = (emitter->settings.rotation * 360) * (1 - (zt_randomVal(&emitter->randomizer) * emitter->settings.rotation_random));

					if(emitter->settings.rotation_direction == 0) {
						if(zt_randomVal(&emitter->randomizer) < .5f) {
							emitter->particles[i].rotation *= -1;
						}
					}
					if(emitter->settings.rotation_direction == -1) {
						emitter->particles[i].rotation *= -1;
					}

					if (emitter->settings.random_rotation) {
						emitter->particles[i].transform.rotation = ztQuat::makeFromEuler(0, 0, (zt_randomVal(&emitter->randomizer) * 360) - 180.f);
					}

					ztVec3 scale = zt_vec3(emitter->settings.scale, emitter->settings.scale, emitter->settings.scale);
					if (emitter->settings.scale_random != 0) {
						scale = scale * (1 - zt_randomVal(&emitter->randomizer) * emitter->settings.scale_random);
					}
					emitter->particles[i].transform.scale = scale;
					emitter->particles[i].transform.rotation = ztQuat::identity;

					emitter->particles[i].sprite_idx = 0;

					if (emitter->sprites_count > 0) {
						int total_prop = 0;
						zt_fiz(emitter->sprites_count) {
							total_prop += emitter->sprites_props[i];
						}

						int sprite_prop = zt_randomInt(&emitter->randomizer, 0, total_prop);
						total_prop = 0;
						zt_fiz(emitter->sprites_count) {
							total_prop += emitter->sprites_props[i];
							if(sprite_prop < total_prop) {
								emitter->particles[i].sprite_idx = i;
								break;
							}
						}
					}

					emitter->live_particles += 1;

					if (emit_particle != nullptr) {
						emit_particle(emitter, i, user_data);
					}

					if (!emitter->settings.burst_emit) {
						break;
					}
					else if (emitter->live_particles == emitter->particles_count) {
						first = false;
						break;
					}
				}
			}
		}
	}

	if (emitter->live_particles <= 0 && emitter->settings.burst_emit) {
		emitter->enabled = false;
	}

	if (emitter->lifetime > 0) {
		emitter->lifetime -= dt;
		if (emitter->lifetime <= 0) {
			emitter->lifetime = -1;
			return true;
		}
	}

	return true;
}

// ================================================================================================================================================================================================

ztInternal void _zt_particleEmitter2DRender(ztParticleEmitter2D *emitter, ztDrawList *draw_list, ztVec3 *tri_pos, ztVec2 *tri_uv, ztVec4 *tri_colors, int size, int *used)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitter2DRender");

	zt_returnOnNull(emitter);

	if (emitter->enabled == false) {
		return;
	}


	bool change_color = emitter->settings.color_life_begin != emitter->settings.color_life_end || emitter->settings.color_life.colors_count > 1;

	ztVec3 normals[4] = { ztVec3::one, ztVec3::one, ztVec3::one, ztVec3::one };
	ztVec4 color;

	if (!change_color) {
		color = ztColor_White;
	}

	int index = 0;

	zt_fxz(emitter->sprites_count) {
		ztSprite* sprite = &emitter->sprites[x];

		if (draw_list) {
			zt_drawListPushTexture(draw_list, sprite->tex);
		}

		ztVec2 uv[4] = {
			zt_vec2(sprite->tex_uv.x, sprite->tex_uv.y),
			zt_vec2(sprite->tex_uv.x, sprite->tex_uv.w),
			zt_vec2(sprite->tex_uv.z, sprite->tex_uv.w),
			zt_vec2(sprite->tex_uv.z, sprite->tex_uv.y)
		};

		zt_fiz(emitter->live_particles) {
			if(emitter->particles[i].sprite_idx != x) {
				continue;
			}

			if (draw_list == nullptr) {
				zt_assert(index < size - 6);
			}

			if (change_color) {
				ZT_PROFILE_PARTICLES("change_color");
				if (emitter->settings.color_life.colors_count > 1) {
					zt_colorGradientGetValue(&emitter->settings.color_life, 1 - (emitter->particles[i].life / emitter->particles[i].life_span), &color);
				}
				else {
					color = ztVec4::lerp(emitter->settings.color_life_begin, emitter->settings.color_life_end, 1 - zt_min(1, (emitter->particles[i].life / emitter->particles[i].life_span)));
				}
				if (draw_list) {
					zt_drawListPushColor(draw_list, color);
				}
				else {
					tri_colors[index + 0] = color;
					tri_colors[index + 1] = color;
					tri_colors[index + 2] = color;
					tri_colors[index + 3] = color;
					tri_colors[index + 4] = color;
					tri_colors[index + 5] = color;
				}
			}
			else {
				tri_colors[index + 0] = ztColor_White;
				tri_colors[index + 1] = ztColor_White;
				tri_colors[index + 2] = ztColor_White;
				tri_colors[index + 3] = ztColor_White;
				tri_colors[index + 4] = ztColor_White;
				tri_colors[index + 5] = ztColor_White;
			}

			ztVec3 pos = emitter->particles[i].transform.position;
			if (emitter->settings.local_space) {
				ZT_PROFILE_PARTICLES("adjust_to_local_space");
				pos += emitter->settings.origin;
			}

			ztVec3 scale = emitter->particles[i].transform.scale;

			if (emitter->settings.scale_life.values_count > 0) {
				scale *= zt_valueGradientGetValue(&emitter->settings.scale_life, 1 - (emitter->particles[i].life / emitter->particles[i].life_span));
			}


			if (emitter->particles[i].rotation) {
				ZT_PROFILE_PARTICLES("rotate");
				if (draw_list) {
					ztVec3 p[4] = {
						scale * zt_vec3(-sprite->half_size.x,  sprite->half_size.y, 0),
						scale * zt_vec3(-sprite->half_size.x, -sprite->half_size.y, 0),
						scale * zt_vec3( sprite->half_size.x, -sprite->half_size.y, 0),
						scale * zt_vec3( sprite->half_size.x,  sprite->half_size.y, 0),
					};

					zt_fjze(p) {
						emitter->particles[i].transform.rotation.rotatePosition(&p[j]);
						p[j] += pos;
					}

					zt_drawListAddFilledQuad(draw_list, p, uv, normals	);
				}
				else {
					ztVec3 positions[6];
					ztVec2 uvs[6];
					zt_spriteGetTrianglesFast(sprite, pos, emitter->particles[i].transform.rotation.euler(), scale, positions, uvs);

					zt_fize(positions) {
						tri_pos[index + i] = positions[i];
						tri_uv[index + i] = uvs[i];
					}
				}
			}
			else {
				if (draw_list) {
					//zt_drawListAddBillboard(draw_list, emitt6er->settings.origin + emitter->particles[i].transform.position, emitter->sprite.half_size * 2, emitter->sprite.tex_uv.xy, emitter->sprite.tex_uv.zw);
					zt_drawListAddFilledRect2D(draw_list, pos, scale.xy * (sprite->half_size * 2), sprite->tex_uv.xy, sprite->tex_uv.zw);
				}
				else {
					ztVec3 positions[6];
					ztVec2 uvs[6];
					zt_spriteGetTrianglesFast(sprite, pos, ztVec3::one, scale, positions, uvs);

					zt_fize(positions) {
						tri_pos[index + i] = positions[i];
						tri_uv[index + i] = uvs[i];
					}
				}
			}
			if (draw_list) {
				if (change_color) {
					zt_drawListPopColor(draw_list);
				}
			}
			else {
				index += 6;
			}
		}

		if (draw_list) {
			zt_drawListPopTexture(draw_list);
		}
	}

	if (used != nullptr) {
		*used = index;
	}
}

// ================================================================================================================================================================================================

void zt_particleEmitter2DRender(ztParticleEmitter2D *emitter, ztDrawList *draw_list)
{
	zt_returnOnNull(draw_list);
	_zt_particleEmitter2DRender(emitter, draw_list, nullptr, nullptr, nullptr, 0, nullptr);
}

// ================================================================================================================================================================================================

int zt_particleEmitter2DGetTriangles(ztParticleEmitter2D *emitter, ztVec3 *pos, ztVec2 *uv, ztVec4 *colors, int size)
{
	ZT_PROFILE_PARTICLES("zt_particleEmitter2DGetTriangles");
	//ztInternal void _zt_particleEmitter2DRender(ztParticleEmitter2D *emitter, ztDrawList *draw_list, ztVec3 *tri_pos, ztVec2 *tri_uv, ztVec4 *tri_colors, int size, int *used)

	int used = 0;
	_zt_particleEmitter2DRender(emitter, nullptr, pos, uv, colors, size, &used);
	return used;
}

// ================================================================================================================================================================================================

void zt_particleEmitter2DEnable(ztParticleEmitter2D *emitter, bool enabled)
{
	zt_returnOnNull(emitter);

	emitter->enabled = enabled;
}

// ================================================================================================================================================================================================

void zt_particleEmitter2DReset(ztParticleEmitter2D *emitter, r32 prewarm_time)
{
	zt_returnOnNull(emitter);

	emitter->live_particles = 0;
	emitter->time_last_particle = 0;
	emitter->lifetime = emitter->settings.emitter_lifetime;

	zt_fiz(emitter->particles_count) {
		emitter->particles[i].life = 0;
	}

	if (prewarm_time > 0) {
		r32 dt = 1.f / 60.f;
		while (prewarm_time > 0) {
			prewarm_time -= dt;
			zt_particleEmitter2DUpdate(emitter, dt);
		}
	}
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztPathNode *zt_pathNodesFindClosest(ztPathNode *nodes, int nodes_count, ztVec3 point)
{
	r32 closest_dist = ztReal32Max;
	i32 closest_idx = -1;

	zt_fiz(nodes_count) {
		r32 dist = nodes[i].position.distanceForCompare(point);
		if (dist < closest_dist) {
			closest_dist = dist;
			closest_idx = i;
		}
	}

	if (closest_idx >= 0) {
		return &nodes[closest_idx];
	}

	return nullptr;
}

// ================================================================================================================================================================================================

void zt_pathNodesPrepareForPathfinding(ztPathNode *nodes, int nodes_count, ztPathProgress *progress)
{
	ZT_PROFILE_PATHFINDING("zt_pathNodesPrepareForPathfinding");
	zt_fiz(nodes_count) {
		zt_bitRemove(nodes[i].flags, ztPathNodeFlags_Ignore);
		nodes[i]._my_move_cost = ztPathNodeValue_Reset;
	}

	progress->frontier_idx = 0;
	progress->visited_idx = 0;
}

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztPathGridSquare *zt_pathGridSquareMake(int rows, int cols, bool allow_diagonals)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareMake");
	ztPathGridSquare *grid = zt_mallocStruct(ztPathGridSquare);
	grid->rows = rows;
	grid->cols = cols;

	grid->nodes = zt_mallocStructArray(ztPathNode, rows * cols);

#	define get_idx(R,C) (((R) < 0 || (R) > rows - 1 || (C) < 0 || (C) > cols - 1) ? -1 : ((R) * cols) + (C))

	for (int r = 0; r < rows; ++r) {
		for (int c = 0; c < cols; ++c) {
			int idx = (r * cols) + c;
			grid->nodes[idx].position.x = (r32)c;
			grid->nodes[idx].position.y = (r32)r;
			grid->nodes[idx].position.z = 0.0f;
			grid->nodes[idx].flags = 0;

			int neighbors = (r == 0 ? 0 : 1) + (r == rows - 1 ? 0 : 1) + (c == 0 ? 0 : 1) + (c == cols - 1 ? 0 : 1);

			if (allow_diagonals) {
				neighbors +=
					(r > 0 && c < cols - 1 ? 1 : 0) + // ne
					(r < rows - 1 && c < cols - 1 ? 1 : 0) + // se
					(r < rows - 1 && c > 0 ? 1 : 0) + // sw
					(r > 0 && c > 0 ? 1 : 0);// nw
			}

			zt_assert(neighbors <= ZT_PATH_NODE_MAX_NEIGHBORS);

			grid->nodes[idx].neighbors_count = neighbors;

			int idx_n = get_idx(r - 1, c);
			int idx_s = get_idx(r + 1, c);
			int idx_e = get_idx(r, c + 1);
			int idx_w = get_idx(r, c - 1);

			int idx_ne = allow_diagonals ? get_idx(r - 1, c + 1) : -1;
			int idx_se = allow_diagonals ? get_idx(r + 1, c + 1) : -1;
			int idx_sw = allow_diagonals ? get_idx(r + 1, c - 1) : -1;
			int idx_nw = allow_diagonals ? get_idx(r - 1, c - 1) : -1;

			int n_idx = 0;
			if (idx_n != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_n];
			if (idx_ne != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_ne];
			if (idx_s != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_s];
			if (idx_se != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_se];
			if (idx_e != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_e];
			if (idx_sw != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_sw];
			if (idx_w != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_w];
			if (idx_nw != -1) grid->nodes[idx].neighbors[n_idx++] = &grid->nodes[idx_nw];

			zt_assert(n_idx == grid->nodes[idx].neighbors_count);
		}
	}

#	undef get_idx

	return grid;
}

// ================================================================================================================================================================================================

void zt_pathGridSquareFree(ztPathGridSquare *grid)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareFree");
	if (grid == nullptr) {
		return;
	}

	if (grid->nodes) {
		zt_free(grid->nodes);
	}
	zt_free(grid);
}

// ================================================================================================================================================================================================

ztPathNode *zt_pathGridSquareAccessNode(ztPathGridSquare *grid, int row, int col)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareAccessNode");
	zt_returnValOnNull(grid, nullptr);
	if (row < 0 || row >= grid->rows || col < 0 || col >= grid->cols) {
		return nullptr;
	}

	int idx = (row * grid->cols) + col;
	return &grid->nodes[idx];
}

// ================================================================================================================================================================================================

bool zt_pathGridSquareGetCoords(ztPathGridSquare *grid, ztPathNode *node, int *row, int *col)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareGetCoords");
	zt_returnValOnNull(grid, false);
	zt_returnValOnNull(node, false);
	zt_returnValOnNull(row, false);
	zt_returnValOnNull(col, false);

	int max = grid->rows * grid->cols;
	for (int i = 0; i < max; ++i) {
		if (node == &grid->nodes[i]) {
			*row = i / grid->cols;
			*col = i - ((*row) * grid->cols);
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

bool zt_pathGridSquareGetNodeIndex(ztPathGridSquare *grid, ztPathNode *node, int *index)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareGetNodeIndex");
	zt_returnValOnNull(grid, false);
	zt_returnValOnNull(node, false);
	zt_returnValOnNull(index, false);

	int max = grid->rows * grid->cols;
	for (int i = 0; i < max; ++i) {
		if (node == &grid->nodes[i]) {
			*index = i;
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

r32 zt_pathNodeGetDistance(ztPathNode *node_one, ztPathNode *node_two)
{
	ZT_PROFILE_PATHFINDING("zt_pathNodeGetDistance");
	zt_returnValOnNull(node_one, 0);
	zt_returnValOnNull(node_two, 0);

	return node_one->position.distance(node_two->position);
}

// ================================================================================================================================================================================================

ztPathNode *zt_pathGridSquareGetNode(ztPathGridSquare *grid, int col, int row)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquareGetNode");
	zt_returnValOnNull(grid, nullptr);
	return &grid->nodes[col + row * grid->cols];
}

// ================================================================================================================================================================================================

void zt_pathGridSquarePrepareForPathfinding(ztPathGridSquare *grid, ztPathProgress *progress)
{
	ZT_PROFILE_PATHFINDING("zt_pathGridSquarePrepareForPathfinding");
	int max = grid->rows * grid->cols;
	zt_fiz(max) {
		zt_bitRemove(grid->nodes[i].flags, ztPathNodeFlags_Ignore);
		grid->nodes[i]._my_move_cost = ztPathNodeValue_Reset;
	}

	progress->frontier_idx = 0;
	progress->visited_idx = 0;
}

// ================================================================================================================================================================================================

ztInternal ztInline bool _zt_pathNodeArrayContains(ztPathNode **arr, int len, ztPathNode *node)
{
	ZT_PROFILE_PATHFINDING("_zt_pathNodeArrayContains");
	zt_fiz(len) {
		if (arr[i] == node) {
			return true;
		}
	}
	return false;
}

// ================================================================================================================================================================================================

ztInternal ztInline bool _zt_pathArrayInsertBefore(ztPathNode **arr, int len, int *index, int before_index, ztPathNode *node)
{
	ZT_PROFILE_PATHFINDING("_zt_pathArrayInsertBefore");
	if (*index == len) {
		return false;
	}
	for (int i = *index; i > before_index; --i) {
		arr[i] = arr[i - 1];
	}
	arr[before_index] = node;
	*index += 1;
	return true;
}

// ================================================================================================================================================================================================

ztInternal ztInline bool _zt_pathArrayAddToBegin(ztPathNode **arr, int len, int *index, ztPathNode *node)
{
	ZT_PROFILE_PATHFINDING("_zt_pathArrayAddToBegin");
	return _zt_pathArrayInsertBefore(arr, len, index, 0, node);
}

// ================================================================================================================================================================================================

ztInternal ztInline bool _zt_pathArrayAddToEnd(ztPathNode **arr, int len, int* index, ztPathNode *node)
{
	ZT_PROFILE_PATHFINDING("_zt_pathArrayAddToEnd");
	if (*index == len) {
		return false;
	}
	arr[(*index)++] = node;
	return true;
}

// ================================================================================================================================================================================================

ztInternal ztInline void _zt_pathArrayRemoveFromBegin(ztPathNode **arr, int len, int* index)
{
	ZT_PROFILE_PATHFINDING("_zt_pathArrayRemoveFromBegin");
	for (int i = 1; i < *index; ++i) {
		arr[i - 1] = arr[i];
	}
	*index -= 1;
}

// ================================================================================================================================================================================================

ztPathProgress *zt_pathProgressMake(ztPathNode *nodes, int nodes_count, ztMemoryArena *arena)
{
	ZT_PROFILE_PATHFINDING("zt_pathProgressMake");
	zt_returnValOnNull(nodes, nullptr);

	if (arena == nullptr) {
		arena = zt_memGetGlobalArena();
	}

	ztPathProgress *progress = zt_mallocStructArena(ztPathProgress, arena);

	progress->arena = arena;

	progress->origin = nullptr;
	progress->destination = nullptr;

	progress->frontier_len = nodes_count;
	progress->frontier = zt_mallocStructArrayArena(ztPathNode *, progress->frontier_len, arena);

	progress->visited_len = nodes_count;
	progress->visited = zt_mallocStructArrayArena(ztPathNode *, progress->visited_len, arena);

	progress->path_size = nodes_count;
	progress->path = zt_mallocStructArrayArena(ztPathNode *, progress->path_size, arena);

	return progress;
}

// ================================================================================================================================================================================================

ztPathProgress *zt_pathProgressMake(ztPathGridSquare *grid, ztMemoryArena *arena)
{
	ZT_PROFILE_PATHFINDING("zt_pathProgressMake");
	zt_returnValOnNull(grid, nullptr);

	return zt_pathProgressMake(grid->nodes, grid->rows * grid->cols, arena);
}

// ================================================================================================================================================================================================

void zt_pathProgressFree(ztPathProgress *progress)
{
	ZT_PROFILE_PATHFINDING("zt_pathProgressFree");
	if (progress == nullptr) {
		return;
	}

	zt_freeArena(progress->path, progress->arena);
	zt_freeArena(progress->visited, progress->arena);
	zt_freeArena(progress->frontier, progress->arena);
	zt_freeArena(progress, progress->arena);
}

// ================================================================================================================================================================================================

ztInternal int _zt_pathGridGetSteps(ztPathNode *origin, ztPathNode *destination, ztPathNode **path, int path_max)
{
	ZT_PROFILE_PATHFINDING("_zt_pathGridGetSteps");
	int steps = 0;
	bool no_mem = false;

	if (steps >= path_max) {
		steps += 1;
		no_mem = true;
	}
	else {
		path[steps++] = destination;
	}

	ztPathNode *current = destination;
	while (current != origin) {
		r32 lowest_movement_cost = ztReal32Max;
		int lowest_movement_idx = -1;
		zt_fiz(current->neighbors_count) {
			if (current->neighbors[i]->_my_move_cost >= 0 && (current->neighbors[i]->_my_move_cost < lowest_movement_cost || lowest_movement_cost == ztPathNodeValue_Impassable)) {
				lowest_movement_cost = current->neighbors[i]->_my_move_cost;
				lowest_movement_idx = i;
			}
		}

		if (lowest_movement_idx == -1) {
			return 0;
		}

		zt_fiz(current->neighbors_count) {
			if (i != lowest_movement_idx) {
				//current->neighbors[i]->_my_move_cost = ztPathNodeValue_Impassable; // prevent revisiting old nodes
			}
		}

		if (steps >= path_max) {
			no_mem = true;
		}
		else {
			path[steps] = current->neighbors[lowest_movement_idx];
		}
		steps += 1;
		//current->neighbors[lowest_movement_idx]->_my_move_cost = ztPathNodeValue_Impassable;
		current = current->neighbors[lowest_movement_idx];

		zt_assert(steps < 100000); // if you're here, you probably forgot to call zt_pathGridSquarePrepareForPathfinding - the movement costs need cleared after the last pathfinding
	}

	// now we have to reverse the array
	if (!no_mem) {
		zt_fiz(steps / 2) {
			int idx1 = i;
			int idx2 = steps - (i + 1);

			auto* temp = path[idx1];
			path[idx1] = path[idx2];
			path[idx2] = temp;
		}
	}

	return steps * (no_mem ? -1 : 1);
}

// ================================================================================================================================================================================================

int zt_pathCalculatePath(ztPathProgress *progress, ztPathNodeCost_Func *path_node_cost_func, void *path_cost_user_data, ztPathEarlyExit_Func *early_exit_func, void *early_exit_user_data, ztPathType_Enum path_type)
{
	ZT_PROFILE_PATHFINDING("zt_pathCalculatePath");
	zt_returnValOnNull(progress, 0);

	if (progress->visited_idx == 0) {
		progress->origin->_my_move_cost = 0;
		progress->frontier[progress->frontier_idx++] = progress->origin;
	}

	while (progress->frontier_idx > 0) {
		// find and remove a location in the frontier
		ztPathNode *location = progress->frontier[0];
		_zt_pathArrayRemoveFromBegin(progress->frontier, progress->frontier_len, &progress->frontier_idx);

		if (location == progress->destination) {
			break;
		}

		// mark as visited so we don't process it again
		if (!_zt_pathNodeArrayContains(progress->visited, progress->visited_idx, location)) {
			//if (!array_add_to_begin(visited, visited_len, visited_idx, location)) {
			if (!_zt_pathArrayAddToBegin(progress->visited, progress->visited_len, &progress->visited_idx, location)) {
				return 0;
			}
		}

		for (int n = 0; n < location->neighbors_count; ++n) {
			ztPathNode *neighbor = location->neighbors[n];
			if (zt_bitIsSet(neighbor->flags, ztPathNodeFlags_Ignore) || zt_bitIsSet(neighbor->flags, ztPathNodeFlags_Obstructed)) {
				continue;
			}

			if (!_zt_pathNodeArrayContains(progress->frontier, progress->frontier_idx, neighbor)) {
				r32 path_cost = (neighbor == progress->destination) ? 0.01f : (path_node_cost_func == nullptr ? zt_abs(location->position.distance(neighbor->position)) : path_node_cost_func(location, neighbor, path_cost_user_data));
				if (path_cost == ztPathNodeValue_Impassable) {
					continue;
				}
				r32 new_cost = location->_my_move_cost + path_cost;
				bool add_to_frontier = true;
				if (_zt_pathNodeArrayContains(progress->visited, progress->visited_idx, neighbor)) {
					add_to_frontier = neighbor->_my_move_cost > new_cost;
				}
				if (add_to_frontier) {
					neighbor->_my_move_cost = new_cost;

					r32 dist = progress->destination == nullptr ? 999 : progress->destination->position.distance(neighbor->position);
					int idx;
					for (idx = 0; idx < progress->frontier_idx; ++idx) {
						if (path_type == ztPathType_Dijkstra) {
							if (progress->frontier[idx]->_my_move_cost > new_cost) {
								break;
							}
						}
						else if (path_type == ztPathType_Heuristic) {
							if (progress->destination->position.distance(progress->frontier[idx]->position) > dist) {
								break;
							}
						}
						else if (path_type == ztPathType_Astar) {
							if (progress->destination->position.distance(progress->frontier[idx]->position) > dist || progress->frontier[idx]->_my_move_cost > new_cost) {
								break;
							}
						}
					}
					if (idx != progress->frontier_idx) {
						if (!_zt_pathArrayInsertBefore(progress->frontier, progress->frontier_len, &progress->frontier_idx, idx, neighbor)) {
							return 0;
						}
					}
					else {
						if (!_zt_pathArrayAddToEnd(progress->frontier, progress->frontier_len, &progress->frontier_idx, neighbor)) {
							return 0;
						}
					}
				}
			}
		}

		if (early_exit_func && early_exit_func(progress, early_exit_user_data)) {
			return -1;
		}
	}

	if (progress->destination == nullptr) {
		progress->path_count = 0;
	}
	else {
		progress->path_count = _zt_pathGridGetSteps(progress->origin, progress->destination, progress->path, progress->path_size);
	}
	return progress->path_count;
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

bool zt_eventIsTriggered(ztEvent *evt, bool condition, i32 flags, r32 timeout)
{
	ZT_PROFILE_GAME("zt_eventIsTriggered");
	zt_returnValOnNull(evt, false);

	if (evt->triggered) {
		if (zt_bitIsSet(evt->flags, ztEventFlags_TriggerOneFrameOnly) && !zt_bitIsSet(evt->flags, ztEventFlags_TrackTime)) {
			return false;
		}

		if(zt_bitIsSet(evt->flags, ztEventFlags_Disabled)) {
			return false;
		}

		if (zt_bitIsSet(evt->flags, ztEventFlags_TrackTime) || zt_bitIsSet(evt->flags, ztEventFlags_TriggerOnTimeEnd)) {
			if (evt->time < evt->time_set) {
				if (zt_bitIsSet(evt->flags, ztEventFlags_TriggerOnTimeEnd)) {
					return false;
				}

				return true;
			}
			else {
				if (zt_bitIsSet(evt->flags, ztEventFlags_DisableOnTimeEnd)) {
					evt->flags |= ztEventFlags_Disabled;
				}

				if(zt_bitIsSet(evt->flags, ztEventFlags_ResetOnTimeEnd)) {
					evt->triggered = false;
				}

				if (zt_bitIsSet(evt->flags, ztEventFlags_TriggerOnTimeEnd)) {
					if (zt_bitIsSet(evt->flags, ztEventFlags_TriggerOneFrameOnly)) {
						if (zt_real32Eq(evt->time_set, ztReal32Min)) {
							return false;
						}
						evt->time_set = ztReal32Min;
					}
					return true;
				}
			}
		}

		return evt->triggered;
	}

	if (condition) {
		evt->flags     = flags;
		evt->triggered = true;
		evt->time      = 0;
		evt->time_set  = timeout;

		if (timeout != 0) {
			evt->flags |= ztEventFlags_TrackTime;
		}

		if (zt_bitIsSet(flags, ztEventFlags_TriggerOnTimeEnd)) return false;

		return true;
	}

	return false;
}

// ================================================================================================================================================================================================

bool zt_eventIsTriggered(ztEvent *evt)
{
	zt_returnValOnNull(evt, false);
	return zt_eventIsTriggered(evt, false);
}

// ================================================================================================================================================================================================

bool zt_eventIsTriggeredAndComplete(ztEvent *evt, bool condition, i32 flags, r32 timeout)
{
	ZT_PROFILE_GAME("zt_eventIsTriggeredAndComplete");
	return zt_eventIsTriggered(evt, condition, flags, timeout) && zt_eventIsComplete(evt);
}

// ================================================================================================================================================================================================

bool zt_eventIsTriggeredAndComplete(ztEvent *evt)
{
	ZT_PROFILE_GAME("zt_eventIsTriggeredAndComplete");
	return zt_eventIsTriggered(evt) && zt_eventIsComplete(evt);
}

// ================================================================================================================================================================================================

bool zt_eventTrigger(ztEvent *evt, i32 flags, r32 timeout)
{
	return zt_eventIsTriggered(evt, true, flags, timeout);
}

// ================================================================================================================================================================================================

bool zt_eventJustTriggered(ztEvent *evt)
{
	zt_returnValOnNull(evt, false);
	return evt->triggered && evt->time == 0;
}

// ================================================================================================================================================================================================

void zt_eventDisable(ztEvent *evt)
{
	zt_returnOnNull(evt);
	evt->triggered = true;
	evt->flags |= ztEventFlags_Disabled;
}

// ================================================================================================================================================================================================

r32 zt_eventPercentComplete(ztEvent *evt)
{
	ZT_PROFILE_GAME("zt_eventPercentComplete");
	zt_returnValOnNull(evt, 1);

	if (evt->triggered == false) {
		return 0;
	}

	if(zt_bitIsSet(evt->flags, ztEventFlags_TrackTime)) {
		if(evt->time_set <= 0) {
			return 1;
		}

		return evt->time / evt->time_set;
	}

	return 1;
}

// ================================================================================================================================================================================================

r32 zt_eventPercentCompleteClamp(ztEvent *evt)
{
	ZT_PROFILE_GAME("zt_eventPercentCompleteClamp");
	return zt_clamp(zt_eventPercentComplete(evt), 0, 1);
}

// ================================================================================================================================================================================================

bool zt_eventIsComplete(ztEvent *evt)
{
	return zt_eventPercentComplete(evt) >= 1.f;
}

// ================================================================================================================================================================================================

void zt_eventReset(ztEvent *evt)
{
	ZT_PROFILE_GAME("zt_eventReset");
	zt_returnOnNull(evt);
	evt->triggered = false;
	evt->flags = 0;
}

// ================================================================================================================================================================================================

void zt_eventResetAll(ztEvent *evts, int evts_count)
{
	ZT_PROFILE_GAME("zt_eventResetAll");
	zt_returnOnNull(evts);
	zt_assertReturnOnFail(evts_count >= 0);

	zt_fiz(evts_count) {
		evts[i].triggered = false;
		evts[i].flags = 0;
	}
}

// ================================================================================================================================================================================================

void zt_eventUpdate(ztEvent *evt, r32 dt)
{
	ZT_PROFILE_GAME("zt_eventUpdate");
	zt_returnOnNull(evt);

	if (evt->triggered) {
		evt->time -= dt;
	}
}

// ================================================================================================================================================================================================

void zt_eventUpdateAll(ztEvent *evts, int evts_count, r32 dt)
{
	ZT_PROFILE_GAME("zt_eventUpdateAll");
	zt_returnOnNull(evts);
	zt_assertReturnOnFail(evts_count >= 0);

	zt_fiz(evts_count) {
		if (evts[i].triggered) {
			evts[i].time += dt;

			if (zt_bitIsSet(evts[i].flags, ztEventFlags_ResetEachFrame)) {
				evts[i].triggered = false;
			}
		}
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

ztInternal bool _zt_audioCheckContext()
{
	ZT_PROFILE_AUDIO("_zt_audioCheckContext");
#	if defined(ZT_DSOUND)
	if (zt_game->ds_context == nullptr) {
		zt_game->ds_context = ztds_contextMake(zt_game->win_details[0].handle);

		zt_fize(zt_game->audio_systems) {
			zt_game->audio_systems[i].volume = 1;
		}
	}

	return zt_game->ds_context != nullptr;

#	elif defined(ZT_OPENAL)
	if (zt_game->al_context == nullptr) {
		zt_game->al_context = ztal_contextMake();

		zt_fize(zt_game->audio_systems) {
			zt_game->audio_systems[i].volume = 1;
		}
	}

	return zt_game->al_context != nullptr;

#	elif defined(ZT_OPENSL)
	if (zt_game->sl_context == nullptr) {
		zt_game->sl_context = ztsl_contextMake();

		zt_fize(zt_game->audio_systems) {
			zt_game->audio_systems[i].volume = 1;
		}
	}

	return zt_game->sl_context != nullptr;
#	else

	return false;
#	endif
}

// ================================================================================================================================================================================================

ztInternal void _zt_audioApplyVolume(ztAudioClip *clip, r32 volume)
{
#	if defined(ZT_DSOUND)
	if (clip == nullptr || clip->ds_buffer == nullptr) {
		return;
	}

	ztds_bufferSetVolume(clip->ds_buffer, clip->volume * volume);

#	elif defined(ZT_OPENAL)
	if (clip == nullptr || clip->al_buffer == nullptr) {
		return;
	}

	ztal_bufferSetVolume(clip->al_buffer, volume);

#	elif defined(ZT_OPENSL)
	if (clip == nullptr || clip->sl_buffer == nullptr) {
		return;
	}

	ztsl_bufferSetVolume(clip->sl_buffer, volume);

#	endif
}

// ================================================================================================================================================================================================

ztInternal void _zt_audioApplySystemSettings(ztAudioClip *clip)
{
#	if defined(ZT_DSOUND)
	if (clip == nullptr || clip->ds_buffer == nullptr) {
		return;
	}

	ztds_bufferSetVolume(clip->ds_buffer, (zt_between(clip->system, 0, zt_elementsOf(zt_game->audio_systems)) ? zt_game->audio_systems[clip->system].volume : 1) * clip->volume);

#	elif defined(ZT_OPENAL)
	if (clip == nullptr || clip->al_buffer == nullptr) {
		return;
	}

	ztal_bufferSetVolume(clip->al_buffer, (zt_between(clip->system, 0, zt_elementsOf(zt_game->audio_systems)) ? zt_game->audio_systems[clip->system].volume : 1) * clip->volume);

#	elif defined(ZT_OPENSL)
	if (clip == nullptr || clip->sl_buffer == nullptr) {
		return;
	}

	ztsl_bufferSetVolume(clip->sl_buffer, (zt_between(clip->system, 0, zt_elementsOf(zt_game->audio_systems)) ? zt_game->audio_systems[clip->system].volume : 1) * clip->volume);

#	endif
}

// ================================================================================================================================================================================================

ztInternal ztAudioClipID _zt_audioClipMakeFromData(void *data, i32 data_size, i32 audio_system)
{
	ZT_PROFILE_AUDIO("_zt_audioCheckContext");
	if (!_zt_audioCheckContext()) {
		return ztInvalidID;
	}

#	if defined(ZT_DSOUND)
	ztDirectSoundBuffer *buffer = ztds_bufferMake(zt_game->ds_context, (byte*)data, data_size);
	if (buffer == nullptr) {
		return ztInvalidID;
	}

	zt_assert(zt_game->audio_clips_count < zt_elementsOf(zt_game->audio_clips));

	i32 channels = 0, bits_per_sample = 0, samples_per_second = 0;
	r32 length = 0;
	ztds_bufferGetDetails(buffer, &channels, &bits_per_sample, &samples_per_second, &length);

	ztAudioClipID audio_clip_id = ztInvalidID;
	
	zt_fiz(zt_game->audio_clips_count) {
		if (zt_game->audio_clips[i].ds_buffer == nullptr) {
			audio_clip_id = i;
			break;
		}
	}

	if (audio_clip_id == ztInvalidID) {
		audio_clip_id = zt_game->audio_clips_count++;
	}
	if (audio_clip_id == ztInvalidID) {
		zt_assert(false);
		return ztInvalidID;
	}

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
	audio_clip->ds_buffer = buffer;
	audio_clip->length    = length;
	audio_clip->play_time = 0;
	audio_clip->flags     = 0;
	audio_clip->system    = audio_system;
	audio_clip->volume    = 1;


	_zt_audioApplySystemSettings(audio_clip);

	return audio_clip_id;

#	elif defined(ZT_OPENAL)

	ztOpenALBuffer *buffer = ztal_bufferMake(zt_game->al_context, (byte*)data, data_size);
	if (buffer == nullptr) {
		return ztInvalidID;
	}

	zt_assert(zt_game->audio_clips_count < zt_elementsOf(zt_game->audio_clips));

	i32 channels = 0, bits_per_sample = 0, samples_per_second = 0;
	r32 length = 0;
	ztal_bufferGetDetails(buffer, &channels, &bits_per_sample, &samples_per_second, &length);

	ztAudioClipID audio_clip_id = ztInvalidID;

	zt_fiz(zt_game->audio_clips_count) {
		if (zt_game->audio_clips[i].al_buffer == nullptr) {
			audio_clip_id = i;
			break;
		}
	}

	if (audio_clip_id == ztInvalidID) {
		audio_clip_id = zt_game->audio_clips_count++;
	}
	if (audio_clip_id == ztInvalidID) {
		zt_assert(false);
		return ztInvalidID;
	}

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
	audio_clip->al_buffer = buffer;
	audio_clip->length = length;
	audio_clip->play_time = 0;
	audio_clip->flags = 0;
	audio_clip->system = audio_system;


	_zt_audioApplySystemSettings(audio_clip);

	return audio_clip_id;

#	elif defined(ZT_OPENSL)

	ztOpenSLBuffer *buffer = ztsl_bufferMake(zt_game->sl_context, (byte*)data, data_size);
	if (buffer == nullptr) {
		return ztInvalidID;
	}

	zt_assert(zt_game->audio_clips_count < zt_elementsOf(zt_game->audio_clips));

	i32 channels = 0, bits_per_sample = 0, samples_per_second = 0;
	r32 length = 0;
	ztsl_bufferGetDetails(buffer, &channels, &bits_per_sample, &samples_per_second, &length);

	ztAudioClipID audio_clip_id = ztInvalidID;

	zt_fiz(zt_game->audio_clips_count) {
		if (zt_game->audio_clips[i].sl_buffer == nullptr) {
			audio_clip_id = i;
			break;
		}
	}

	if (audio_clip_id == ztInvalidID) {
		audio_clip_id = zt_game->audio_clips_count++;
	}
	if (audio_clip_id == ztInvalidID) {
		zt_assert(false);
		return ztInvalidID;
	}

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
	audio_clip->sl_buffer = buffer;
	audio_clip->length = length;
	audio_clip->play_time = 0;
	audio_clip->flags = 0;
	audio_clip->system = audio_system;


	_zt_audioApplySystemSettings(audio_clip);

	return audio_clip_id;

#	else
	return ztInvalidID;
#	endif
}

// ================================================================================================================================================================================================

ztAudioClipID zt_audioClipMake(ztAssetManager *asset_mgr, ztAssetID asset_id, i32 audio_system)
{
	ZT_PROFILE_AUDIO("zt_audioClipMake");
	ztBlockProfiler bp_tex("zt_audioClipMake (from asset)");

	zt_returnValOnNull(asset_mgr, ztInvalidID);
	if(asset_id == ztInvalidID) {
		return ztInvalidID;
	}
	zt_assert(asset_id >= 0 && asset_id < asset_mgr->asset_count);

	zt_logInfo("loading audio asset: %s", asset_mgr->asset_name[asset_id]);

	if (asset_mgr->asset_type[asset_id] != ztAssetManagerType_AudioWAV) {
		return ztInvalidID;
	}

	i32 size = zt_assetSize(asset_mgr, asset_id);
	if (size <= 0) {
		return ztInvalidID;
	}

	char *data = zt_mallocStructArrayArena(char, size, asset_mgr->arena);
	if (!data) {
		return ztInvalidID;
	}

	ztAudioClipID audio_clip_id = ztInvalidID;
	const char *error = nullptr;
	if (!zt_assetLoadData(asset_mgr, asset_id, data, size)) {
		error = "Unable to load asset contents";
		goto on_error;
	}

	audio_clip_id = _zt_audioClipMakeFromData(data, size, audio_system);
	if (audio_clip_id == ztInvalidID) {
		error = "Unable to process audio data";
		goto on_error;
	}

	// TODO: Add reload callback

	zt_freeArena(data, asset_mgr->arena);
	return audio_clip_id;

on_error:
	zt_logCritical("Unable to load audio clip (%s). %s.", asset_mgr->asset_name[asset_id], error);
	zt_freeArena(data, asset_mgr->arena);
	return ztInvalidID;
}

// ================================================================================================================================================================================================

ztAudioClipID zt_audioClipMakeFromFile(const char *file_name, i32 audio_system)
{
	ZT_PROFILE_AUDIO("zt_audioClipMakeFromFile");
	ztBlockProfiler bp_tex("zt_audioClipMakeFromFile");

	i32 size = 0;
	void *data = zt_readEntireFile(file_name, &size);
	if (data == nullptr || size == 0) {
		return ztInvalidID;
	}

	ztAudioClipID audio_clip_id = _zt_audioClipMakeFromData(data, size, audio_system);

	zt_free(data);

	if (audio_clip_id == ztInvalidID) {
		zt_logCritical("Unable to load audio clip from file: %s", file_name);
	}

	return audio_clip_id;
}

// ================================================================================================================================================================================================

void zt_audioClipFree(ztAudioClipID audio_clip_id)
{
	ZT_PROFILE_AUDIO("zt_audioClipFree");
	if (audio_clip_id == ztInvalidID) {
		return;
	}

	zt_assertReturnOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count);

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];

	zt_fize(zt_game->audio_delays) {
		if (zt_game->audio_delays[i].clip_id == audio_clip_id) {
			zt_game->audio_delays[i].clip_id = ztInvalidID;
		}
	}

#	if defined(ZT_DSOUND)
	if (audio_clip->ds_buffer) {
		ztds_bufferFree(audio_clip->ds_buffer);
		audio_clip->ds_buffer = nullptr;
	}

#	elif defined(ZT_OPENAL)
	if (audio_clip->al_buffer) {
		ztal_bufferFree(audio_clip->al_buffer);
		audio_clip->al_buffer = nullptr;
	}

#	elif defined(ZT_OPENSL)
	if (audio_clip->sl_buffer) {
		ztsl_bufferFree(audio_clip->sl_buffer);
		audio_clip->sl_buffer = nullptr;
	}
#	endif
}

// ================================================================================================================================================================================================

void zt_audioClipPlayOnce(ztAudioClipID audio_clip_id, r32 frequency)
{
	ZT_PROFILE_AUDIO("zt_audioClipPlayOnce");
	if (zt_game->audio_muted) {
		return;
	}

	//zt_assertReturnOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count);
	if (audio_clip_id < 0 || audio_clip_id >= zt_game->audio_clips_count) {
		if (audio_clip_id != ztInvalidID) {
			zt_logDebug("zt_audioClipPlayOnce: audio clip out of range (%d/%d)", audio_clip_id, zt_game->audio_clips_count);
		}
		return;
	}

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
#	if defined(ZT_DSOUND)
	ztds_bufferSetFrequency(audio_clip->ds_buffer, frequency);
	ztds_bufferPlay(audio_clip->ds_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing;

#	elif defined(ZT_OPENAL)
	ztal_bufferSetFrequency(audio_clip->al_buffer, frequency);
	ztal_bufferPlay(audio_clip->al_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing;

#	elif defined(ZT_OPENSL)
	ztsl_bufferSetFrequency(audio_clip->sl_buffer, frequency);
	ztsl_bufferPlay(audio_clip->sl_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing;

#	endif

	audio_clip->fade_out_curr = audio_clip->fade_out_time = 0;
	_zt_audioApplySystemSettings(audio_clip);
}

// ================================================================================================================================================================================================

void zt_audioClipPlayOnceDelayed(ztAudioClipID audio_clip_id, r32 delay, r32 frequency )
{
	ZT_PROFILE_AUDIO("zt_audioClipPlayOnceDelayed");
	if (zt_game->audio_muted) {
		return;
	}

	if (audio_clip_id < 0 || audio_clip_id >= zt_game->audio_clips_count) {
		return;
	}

	zt_fize(zt_game->audio_delays) {
		if(zt_game->audio_delays[i].clip_id <= 0) {
			zt_game->audio_delays[i].clip_id = audio_clip_id + 1;
			zt_game->audio_delays[i].frequency = frequency;
			zt_game->audio_delays[i].delay = delay;
			zt_game->audio_has_delay = true;
			break;
		}
	}
}

// ================================================================================================================================================================================================

void zt_audioClipPlayLooped(ztAudioClipID audio_clip_id, r32 frequency)
{
	ZT_PROFILE_AUDIO("zt_audioClipPlayLooped");
	if (zt_game->audio_muted) {
		return;
	}

	//zt_assertReturnOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count);
	if (audio_clip_id < 0 || audio_clip_id >= zt_game->audio_clips_count) {
		return;
	}

	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
#	if defined(ZT_DSOUND)
	ztds_bufferSetFrequency(audio_clip->ds_buffer, frequency);
	ztds_bufferPlayLooping(audio_clip->ds_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing | ztAudioClipFlags_Looping;

#	elif defined(ZT_OPENAL)
	ztal_bufferSetFrequency(audio_clip->al_buffer, frequency);
	ztal_bufferPlayLooping(audio_clip->al_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing | ztAudioClipFlags_Looping;

#	elif defined(ZT_OPENSL)
	ztsl_bufferSetFrequency(audio_clip->sl_buffer, frequency);
	ztsl_bufferPlayLooping(audio_clip->sl_buffer);
	audio_clip->flags |= ztAudioClipFlags_Playing | ztAudioClipFlags_Looping;

#	endif

	audio_clip->fade_out_curr = audio_clip->fade_out_time = 0;
	_zt_audioApplySystemSettings(audio_clip);
}

// ================================================================================================================================================================================================

bool zt_audioClipIsPlaying(ztAudioClipID audio_clip_id)
{
	ZT_PROFILE_AUDIO("zt_audioClipIsPlaying");
	zt_assertReturnValOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count, false);
	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];
	return zt_bitIsSet(audio_clip->flags, ztAudioClipFlags_Playing);
}

// ================================================================================================================================================================================================

bool zt_audioClipStop(ztAudioClipID audio_clip_id, r32 fade_out_time)
{
	ZT_PROFILE_AUDIO("zt_audioClipStop");
	zt_assertReturnValOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count, false);
	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];

	if (fade_out_time > 0) {
		audio_clip->fade_out_time = fade_out_time;
		audio_clip->fade_out_curr = 0;
	}
	else {
#		if defined(ZT_DSOUND)
		zt_assertReturnValOnFail(audio_clip->ds_buffer != nullptr, false);
		ztds_bufferStop(audio_clip->ds_buffer);

#		elif defined(ZT_OPENAL)
		zt_assertReturnValOnFail(audio_clip->al_buffer != nullptr, false);
		ztal_bufferStop(audio_clip->al_buffer);

#		elif defined(ZT_OPENSL)
		zt_assertReturnValOnFail(audio_clip->sl_buffer != nullptr, false);
		ztsl_bufferStop(audio_clip->sl_buffer);

#		endif

		zt_bitRemove(audio_clip->flags, ztAudioClipFlags_Playing);
		zt_bitRemove(audio_clip->flags, ztAudioClipFlags_Looping);
	}
	return true;
}

// ================================================================================================================================================================================================

void zt_audioClipSetVolume(ztAudioClipID audio_clip_id, r32 volume)
{
	ZT_PROFILE_AUDIO("zt_audioClipSetVolume");
	zt_assertReturnOnFail(audio_clip_id >= 0 && audio_clip_id < zt_game->audio_clips_count);
	ztAudioClip *audio_clip = &zt_game->audio_clips[audio_clip_id];

	audio_clip->volume = volume;
	_zt_audioApplySystemSettings(audio_clip);
}

// ================================================================================================================================================================================================

void zt_audioSetMute(bool mute)
{
	ZT_PROFILE_AUDIO("zt_audioSetMute");
	if (mute) {
		zt_fiz(zt_game->audio_clips_count) {
			if (zt_bitIsSet(zt_game->audio_clips[i].flags, ztAudioClipFlags_Playing)) {
				zt_audioClipStop(i);
			}
		}
	}

	zt_game->audio_muted = mute;
}

// ================================================================================================================================================================================================

bool zt_audioGetMute()
{
	return 	zt_game->audio_muted;
}

// ================================================================================================================================================================================================

void zt_audioSystemSetVolume(i32 audio_system, r32 volume)
{
	_zt_audioCheckContext();

	if (zt_between(audio_system, 0, zt_elementsOf(zt_game->audio_systems))) {
		zt_game->audio_systems[audio_system].volume = zt_clamp(volume, 0, 1);
	}

	zt_fiz(zt_game->audio_clips_count) {
		if(zt_game->audio_clips[i].system != audio_system) {
			continue;
		}

		_zt_audioApplySystemSettings(&zt_game->audio_clips[i]);
	}
}

// ================================================================================================================================================================================================

r32 zt_audioSystemGetVolume(i32 audio_system)
{
	_zt_audioCheckContext();

	if (zt_between(audio_system, 0, zt_elementsOf(zt_game->audio_systems))) {
		return zt_game->audio_systems[audio_system].volume;
	}

	return 1;
}

// ================================================================================================================================================================================================

ztInternal void _zt_audioUpdateFrame(r32 dt)
{
	ZT_PROFILE_AUDIO("_zt_audioUpdateFrame");

#	if defined(ZT_DSOUND)
	if (!zt_game->ds_context) {
		return;
	}
#	elif defined(ZT_OPENAL)
	if (!zt_game->al_context) {
		return;
	}
#	elif defined(ZT_OPENSL)
	if (!zt_game->sl_context) {
		return;
	}
#	endif

	zt_fiz(zt_game->audio_clips_count) {
		if (zt_bitIsSet(zt_game->audio_clips[i].flags, ztAudioClipFlags_Playing)) {
			zt_game->audio_clips[i].play_time += dt;
			if (zt_game->audio_clips[i].play_time > zt_game->audio_clips[i].length) {
				if (zt_bitIsSet(zt_game->audio_clips[i].flags, ztAudioClipFlags_Looping)) {
					zt_game->audio_clips[i].play_time -= zt_game->audio_clips[i].length;
				}
				else {
					zt_bitRemove(zt_game->audio_clips[i].flags, ztAudioClipFlags_Playing);
				}
			}
			if (zt_game->audio_clips[i].fade_out_time > 0) {
				zt_game->audio_clips[i].fade_out_curr += dt;

				r32 pct = 1 - zt_clamp(zt_game->audio_clips[i].fade_out_curr / zt_game->audio_clips[i].fade_out_time, 0, 1);

				r32 vol = zt_lerp(0, zt_game->audio_systems[zt_game->audio_clips[i].system].volume, pct);
				_zt_audioApplyVolume(&zt_game->audio_clips[i], vol);
			}
		}
	}

	if(zt_game->audio_has_delay) {
		int delays = 0;
		zt_fize(zt_game->audio_delays) {
			if (zt_game->audio_delays[i].clip_id > 0) {
				zt_game->audio_delays[i].delay -= dt;
				if(zt_game->audio_delays[i].delay <= 0) {
					zt_audioClipPlayOnce(zt_game->audio_delays[i].clip_id - 1, zt_game->audio_delays[i].frequency);
					zt_game->audio_delays[i].clip_id = ztInvalidID;
				}
				else delays += 1;
			}
		}
		zt_game->audio_has_delay = delays > 0;
	}
}


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// the _zt_callFunc<function> calls are used because it's possible for the ZT_GAME_FUNC_<function> defines
// to have naming conflicts with variables in the main function

#if !defined(ZT_DLL)
	bool ZT_GAME_FUNC_SETTINGS(ztGameDetails*, ztGameSettings*);
	ztInternal ztInline bool _zt_callFuncSettings(ztGameDetails *details, ztGameSettings *settings)
	{ return ZT_GAME_FUNC_SETTINGS(details, settings); }

	bool ZT_GAME_FUNC_INIT(ztGameDetails*, ztGameSettings*);
	ztInternal ztInline bool _zt_callFuncInit(ztGameDetails *details, ztGameSettings *settings)
	{ return ZT_GAME_FUNC_INIT(details, settings); }

	void ZT_GAME_FUNC_SCREENCHANGE(ztGameSettings *settings);
	ztInternal ztInline void _zt_callFuncScreenChange(ztGameSettings *settings)
	{ ZT_GAME_FUNC_SCREENCHANGE(settings); }

	void ZT_GAME_FUNC_CLEANUP();
	ztInternal ztInline void _zt_callFuncCleanup()
	{ ZT_GAME_FUNC_CLEANUP(); }

	bool ZT_GAME_FUNC_LOOP(r32);
	ztInternal ztInline bool _zt_callFuncLoop(r32 dt)
	{ return ZT_GAME_FUNC_LOOP(dt); }
#endif

#if defined(ZT_WINDOWS)

LRESULT CALLBACK _zt_winCallback(HWND handle, UINT msg, WPARAM w_param, LPARAM l_param);

// ================================================================================================================================================================================================

#if !defined(ZT_DLL)

bool _zt_winCreateWindow(ztGameSettings* game_settings, ztWindowDetails* window_details)
{
	ZT_PROFILE_PLATFORM("_zt_winCreateWindow");
	WNDCLASS wndcls = {};
	wndcls.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wndcls.lpfnWndProc = _zt_winCallback;
	wndcls.hInstance = zt_game->hinstance;
	wndcls.hIcon = zt_game->exe_icon;
#	if defined(ZT_UNICODE)
	u16 wc_game_name[1024] = { 0 };
	zt_strConvertToUTF16(ZT_GAME_NAME, zt_strLen(ZT_GAME_NAME), wc_game_name, zt_elementsOf(wc_game_name));
	wndcls.lpszClassName = (LPCWSTR)wc_game_name;
#	else
	wndcls.lpszClassName = ZT_GAME_NAME;
#	endif

	static bool first_call = true;
	if (first_call) {
		if (!RegisterClass(&wndcls)) {
			zt_logCritical("win: failed to create window class");
			return false;
		}
		first_call = false;
	}

	DWORD style = WS_OVERLAPPEDWINDOW | WS_VISIBLE;

	RECT client_rect = { 0, 0, game_settings->screen_w, game_settings->screen_h };
	if (AdjustWindowRect(&client_rect, style, FALSE) == FALSE) {
		zt_logCritical("win: failed to adjust window rect");
	}

	window_details->client_rect_buffer = zt_vec4((r32)client_rect.left, (r32)client_rect.top, (r32)client_rect.right - game_settings->screen_w, (r32)client_rect.bottom - game_settings->screen_h);

	int screen_x = GetSystemMetrics(SM_CXSCREEN);
	int screen_y = GetSystemMetrics(SM_CYSCREEN);
	int pos_x = (screen_x - (client_rect.right - client_rect.left)) / 2;
	int pos_y = (screen_y - (client_rect.bottom - client_rect.top)) / 2;

	if (game_settings->monitor > 0) {
		ztDisplay displays[16];
		int displays_count = zt_displayGetDetails(displays, zt_elementsOf(displays));

		if(game_settings->monitor < displays_count) {
			ztDisplay *display = &displays[game_settings->monitor];
			screen_x = display->screen_area.z;
			screen_y = display->screen_area.w;

			pos_x = display->work_area.x + (screen_x - (client_rect.right - client_rect.left)) / 2;
			pos_y = display->work_area.y + (screen_y - (client_rect.bottom - client_rect.top)) / 2;
		}
	}


#	if defined(ZT_UNICODE)
	window_details->handle = CreateWindow(wndcls.lpszClassName, (LPCWSTR)wc_game_name, style, pos_x, pos_y, client_rect.right - client_rect.left, client_rect.bottom - client_rect.top, NULL, NULL, wndcls.hInstance, 0);
#	else
	window_details->handle = CreateWindow(wndcls.lpszClassName, ZT_GAME_NAME, style, pos_x, pos_y, client_rect.right - client_rect.left, client_rect.bottom - client_rect.top, NULL, NULL, wndcls.hInstance, 0);
#	endif
	if (window_details->handle == NULL) {
		zt_logCritical("win: failed to create window");
		return false;
	}

	GetClientRect(window_details->handle, &window_details->client_rect);
	GetWindowRect(window_details->handle, &window_details->window_rect);

	window_details->aspect_ratio = (window_details->window_rect.right - window_details->window_rect.left) / (r32)(window_details->window_rect.bottom - window_details->window_rect.top);

	_zt_winUpdateTitle(game_settings, window_details);

	return true;
}

// ================================================================================================================================================================================================

bool _zt_winCleanupWindow(ztWindowDetails* win_details, ztGameSettings* settings)
{
	ZT_PROFILE_PLATFORM("_zt_winCleanupWindow");
	bool context_result = _zt_rendererFreeContext(win_details);

	DestroyWindow(win_details->handle);
	
	return context_result;
}

// ================================================================================================================================================================================================

void _zt_winUpdateTitle(ztGameSettings *game_settings, ztWindowDetails *window_details)
{
	ZT_PROFILE_PLATFORM("_zt_winUpdateTitle");
	const char* renderer;
	switch(game_settings->renderer)
	{
	case ztRenderer_OpenGL: renderer = "OpenGL"; break;
	case ztRenderer_DirectX: renderer = "DirectX"; break;
	default: renderer = "Unknown Renderer"; break;
	}

	zt_debugOnly(zt_strMakePrintf(title, 1024, "%s [Renderer: %s] [Resolution: %d x %d]", ZT_GAME_NAME, renderer, game_settings->screen_w, game_settings->screen_h));
	zt_releaseOnly(zt_strMakePrintf(title, 1024, "%s", ZT_GAME_NAME));
	SetWindowTextA(window_details->handle, title);
}

#endif // !ZT_DLL

// ================================================================================================================================================================================================

void _zt_winControllerInputInit()
{
	ZT_PROFILE_INPUT("_zt_winControllerInputInit");
	const char *libs[] = { "xinput1_4.dll", "xinput9_1_0.dll", "xinput1_3.dll" };
	zt_fiz(zt_elementsOf(libs)) {
		zt_game->hmod_xinput = LoadLibraryA(libs[i]);
		if (zt_game->hmod_xinput != NULL) {
			break;
		}
	}

	if (zt_game->hmod_xinput == NULL) {
		return;
	}

	zt_game->xinput_getState = (ztGameGlobals::xinput_getState_Func)GetProcAddress(zt_game->hmod_xinput, "XInputGetState");
	zt_game->xinput_setState = (ztGameGlobals::xinput_setState_Func)GetProcAddress(zt_game->hmod_xinput, "XInputSetState");

	zt_fiz(zt_elementsOf(zt_game->input_controllers)) {
		zt_game->input_controllers[i].connected = true;
		zt_game->xinput_haptic[i] = false;
	}

	_zt_winControllerInputUpdate(0);

	zt_fiz(zt_elementsOf(zt_game->input_controllers)) {
		zt_fjz(zt_elementsOf(zt_game->input_controllers[i].button_states)) {
			zt_game->input_controllers[i].button_states[j] = 0;
			zt_game->input_controllers[i].button_times [j] = 0;
		}
		zt_fjz(zt_elementsOf(zt_game->input_controllers[i].analog_values)) {
			zt_game->input_controllers[i].analog_values[j] = 0;
		}
	}
}

// ================================================================================================================================================================================================

void _zt_winControllerInputCleanup()
{
	zt_game->xinput_getState = nullptr;
	zt_game->xinput_setState = nullptr;
}

// ================================================================================================================================================================================================

void _zt_winControllerInputUpdate(r32 dt)
{
	ZT_PROFILE_INPUT("_zt_winControllerInputUpdate");
	if (!zt_game->xinput_getState || !zt_game->app_has_focus) {
		return;
	}

	int flags[] = { XINPUT_GAMEPAD_DPAD_UP, XINPUT_GAMEPAD_DPAD_DOWN, XINPUT_GAMEPAD_DPAD_LEFT, XINPUT_GAMEPAD_DPAD_RIGHT, XINPUT_GAMEPAD_START, XINPUT_GAMEPAD_BACK, XINPUT_GAMEPAD_LEFT_THUMB, XINPUT_GAMEPAD_RIGHT_THUMB, XINPUT_GAMEPAD_LEFT_SHOULDER, XINPUT_GAMEPAD_RIGHT_SHOULDER, XINPUT_GAMEPAD_A, XINPUT_GAMEPAD_B, XINPUT_GAMEPAD_X, XINPUT_GAMEPAD_Y };
	zt_staticAssert(zt_elementsOf(flags) == ztInputControllerButton_Y+1);

	bool pressed[ztInputControllerButton_MAX];

	zt_fiz(zt_min(ZT_MAX_INPUT_CONTROLLERS, zt_elementsOf(zt_game->input_controllers))) {
		if (zt_game->input_controllers[i].connected) {
			XINPUT_STATE controller_state;
			if (zt_game->xinput_getState(i, &controller_state) == ERROR_SUCCESS) {

				// if analog controls are within the deadzone, we just zero them out
				if (controller_state.Gamepad.bLeftTrigger  < XINPUT_GAMEPAD_TRIGGER_THRESHOLD) controller_state.Gamepad.bLeftTrigger = 0;
				if (controller_state.Gamepad.bRightTrigger < XINPUT_GAMEPAD_TRIGGER_THRESHOLD) controller_state.Gamepad.bRightTrigger = 0;

				if (controller_state.Gamepad.sThumbLX > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  && controller_state.Gamepad.sThumbLX < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ) controller_state.Gamepad.sThumbLX = 0;
				if (controller_state.Gamepad.sThumbLY > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  && controller_state.Gamepad.sThumbLY < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ) controller_state.Gamepad.sThumbLY = 0;
				if (controller_state.Gamepad.sThumbRX > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE && controller_state.Gamepad.sThumbRX < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE) controller_state.Gamepad.sThumbRX = 0;
				if (controller_state.Gamepad.sThumbRY > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE && controller_state.Gamepad.sThumbRY < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE) controller_state.Gamepad.sThumbRY = 0;

				zt_fjz(zt_elementsOf(flags)) {
					pressed[j] = zt_bitIsSet(controller_state.Gamepad.wButtons, flags[j]);
				}
				pressed[ztInputControllerButton_TriggerLeft  ] = controller_state.Gamepad.bLeftTrigger != 0;
				pressed[ztInputControllerButton_TriggerRight ] = controller_state.Gamepad.bRightTrigger != 0;
				pressed[ztInputControllerButton_ThumbpadLeft ] = controller_state.Gamepad.sThumbLX != 0 || controller_state.Gamepad.sThumbLY != 0;
				pressed[ztInputControllerButton_ThumbpadRight] = controller_state.Gamepad.sThumbRX != 0 || controller_state.Gamepad.sThumbRY != 0;

				zt_fjz(zt_elementsOf(pressed)) {
					if (pressed[j]) {
						if (zt_bitIsSet(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_Pressed)) {
							zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustPressed);
							zt_game->input_controllers[i].button_times[j] += dt;
						}
						else {
							zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustReleased);
							zt_game->input_controllers[i].button_states[j] |= ztInputControllerFlags_Pressed | ztInputControllerFlags_JustPressed;
							zt_game->input_controllers[i].button_times[j] = dt;
						}
						zt_game->input_this_frame = true;
					}
					else if (zt_game->input_controllers[i].button_times[j] != 0) {
						zt_game->input_controllers[i].button_states[j] |= ztInputControllerFlags_JustReleased;
						zt_game->input_controllers[i].button_times[j] = 0;
						zt_game->input_this_frame = true;
					}
					else {
						zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_Pressed);
						zt_bitRemove(zt_game->input_controllers[i].button_states[j], ztInputControllerFlags_JustReleased);
					}
				}
				zt_game->input_controllers[i].analog_value_trigger_left      = zt_linearRemap((r32)controller_state.Gamepad.bLeftTrigger,  0.f, 255.f, 0.f, 1.f);
				zt_game->input_controllers[i].analog_value_trigger_right     = zt_linearRemap((r32)controller_state.Gamepad.bRightTrigger, 0.f, 255.f, 0.f, 1.f);
				zt_game->input_controllers[i].analog_value_thumb_pad_left_x  = zt_linearRemap((r32)controller_state.Gamepad.sThumbLX, -32768.f, 32768.f, -1.f, 1.f);
				zt_game->input_controllers[i].analog_value_thumb_pad_left_y  = zt_linearRemap((r32)controller_state.Gamepad.sThumbLY, -32768.f, 32768.f, -1.f, 1.f);
				zt_game->input_controllers[i].analog_value_thumb_pad_right_x = zt_linearRemap((r32)controller_state.Gamepad.sThumbRX, -32768.f, 32768.f, -1.f, 1.f);
				zt_game->input_controllers[i].analog_value_thumb_pad_right_y = zt_linearRemap((r32)controller_state.Gamepad.sThumbRY, -32768.f, 32768.f, -1.f, 1.f);

				for (int j = 2; j < zt_elementsOf(zt_game->input_controllers[i].analog_values); ++j) {
					if (zt_abs(zt_game->input_controllers[i].analog_values[j]) < 0.05f) {
						zt_game->input_controllers[i].analog_values[j] = 0;
					}
				}

				if (zt_game->xinput_haptic[i] != 0.f) {
					zt_game->xinput_haptic[i] += dt;
					if (zt_game->xinput_haptic[i] > 1 / 60.f) {
						zt_game->xinput_haptic[i] = 0;
						XINPUT_VIBRATION vibration = { 0, 0 };
						zt_game->xinput_setState(i, &vibration);
					}
				}
			}
			else {
				zt_game->input_controllers[i].connected = false;

				if (dt != 0) {
					zt_logInfo("Controller %d disconnected", i + 1);
				}
			}
		}
	}
}

// ================================================================================================================================================================================================

void _zt_winControllerInputHapticFeedback(int idx, r32 strength_low, r32 strength_high)
{
	ZT_PROFILE_INPUT("_zt_winControllerInputHapticFeedback");
	zt_assertReturnOnFail(idx >= 0 && idx < ZT_MAX_INPUT_CONTROLLERS);

	if (zt_game->xinput_setState) {
		XINPUT_VIBRATION vibration = { zt_convertToi32Floor(strength_low * 65535.f), zt_convertToi32Floor(strength_high * 65535.f) };
		zt_game->xinput_setState(idx, &vibration);
		zt_game->xinput_haptic[idx] = 0.01f;
	}
}

// ================================================================================================================================================================================================

void _zt_winProcessMessages()
{
	ZT_PROFILE_PLATFORM("_zt_winProcessMessages");
	MSG msg;
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	if (msg.message == WM_QUIT) {
		zt_game->quit_requested = false;
	}
}

// ================================================================================================================================================================================================

#if !defined(ZT_DLL)

void _zt_winHandleWindowSize(ztWindowDetails *window_details, ztGameSettings *game_settings)
{
	if (window_details) {
		GetClientRect(window_details->handle, &window_details->client_rect);
		GetWindowRect(window_details->handle, &window_details->window_rect);

		int screen_w = window_details->client_rect.right - window_details->client_rect.left;
		int screen_h = window_details->client_rect.bottom - window_details->client_rect.top;
		int native_w = game_settings->native_w;
		int native_h = game_settings->native_h;
		int native_w_reset = 0;
		int native_h_reset = 0;

		// the viewport scales to the width of the screen (resizing up/down doesn't affect the size of things)
		if (game_settings->renderer_screen_change_behavior == ztRendererScreenChangeBehavior_ScaleToHorz) {
			native_w_reset = native_w;
			native_h_reset = native_h;

			r32 screen_aspect_w = screen_w / (r32)native_w;
			r32 screen_aspect_h = screen_h / (r32)native_h;

			if ( zt_real32Eq(screen_aspect_w, 1.f) && zt_real32Eq(screen_aspect_h, 1.f)) {
				// no aspect change, do nothing
			}
			else {
				if (screen_aspect_w < 1.f) {
					screen_aspect_h /= screen_aspect_w;
					screen_aspect_w = 1;
				}
				native_w = zt_convertToi32Ceil(native_w * screen_aspect_w);
				native_h = zt_convertToi32Ceil(native_h * screen_aspect_h);
			}
		}
		// the viewport scales to the height of the screen (resizing left/right doesn't affect the size of things)
		else if (game_settings->renderer_screen_change_behavior == ztRendererScreenChangeBehavior_ScaleToVert) {
			native_w_reset = native_w;
			native_h_reset = native_h;

			r32 screen_aspect_w = screen_w / (r32)native_w;
			r32 screen_aspect_h = screen_h / (r32)native_h;

			if (zt_real32Eq(screen_aspect_w, 1.f) && zt_real32Eq(screen_aspect_h, 1.f)) {
				// no aspect change, do nothing
			}
			else {
				if (screen_aspect_h < 1.f) {
					screen_aspect_w /= screen_aspect_h;
					screen_aspect_h = 1;
				}
				native_w = zt_convertToi32Ceil(native_w * screen_aspect_w);
				native_h = zt_convertToi32Ceil(native_h * screen_aspect_h);
			}
		}
		else if (game_settings->renderer_screen_change_behavior == ztRendererScreenChangeBehavior_Resize) {
			native_h = screen_h;
			native_w = screen_w;
		}
		else {
			//screen_w = native_w;
			//screen_h = native_h;
		}

		game_settings->native_h = native_h;
		game_settings->native_w = native_w;
		game_settings->screen_w = screen_w;
		game_settings->screen_h = screen_h;

		zt_logInfo("screen: %d/%d; native: %d/%d", game_settings->screen_w, game_settings->screen_h, game_settings->native_w, game_settings->native_h);

		zt_openGLSupport(if (window_details->gl_context) ztgl_contextSetSize(window_details->gl_context, screen_w, screen_h, native_w, native_h));
		zt_directxSupport(if (window_details->dx_context) ztdx_contextSetSize(window_details->dx_context, native_w, native_h));

		_zt_rendererSetViewport(window_details, game_settings, true);
		_zt_callFuncScreenChange(game_settings);
		_zt_winUpdateTitle(game_settings, window_details);

		_zt_textureAdjustScreenTargets();

		if (native_w_reset != 0 && native_h_reset != 0) {
			game_settings->native_w = native_w_reset;
			game_settings->native_h = native_h_reset;
		}

		//window_details->aspect_ratio = (window_details->window_rect.right - window_details->window_rect.left) / (r32)(window_details->window_rect.bottom - window_details->window_rect.top);
		window_details->resize_cooldown = 0;
	}
}

// ================================================================================================================================================================================================

ztInternal void _zt_winLogSystemInfo()
{
	SYSTEM_INFO system_info;

	BOOL is64 = FALSE;
	if (IsWow64Process(GetCurrentProcess(), &is64) && is64 == TRUE) {
		GetNativeSystemInfo(&system_info);
	}
	else {
		GetSystemInfo(&system_info);
	}

	switch(system_info.wProcessorArchitecture)
	{
		case PROCESSOR_ARCHITECTURE_AMD64  : zt_logInfo("processor architecture: x64"); break;
		case PROCESSOR_ARCHITECTURE_ARM    : zt_logInfo("processor architecture: ARM"); break;
		case PROCESSOR_ARCHITECTURE_IA64   : zt_logInfo("processor architecture: Intel Itanium based"); break;
		case PROCESSOR_ARCHITECTURE_INTEL  : zt_logInfo("processor architecture: x86"); break;
		case PROCESSOR_ARCHITECTURE_UNKNOWN: zt_logInfo("processor architecture: Unknown"); break;
	}

	zt_logDebug("processor count: %d", system_info.dwNumberOfProcessors);

	switch(system_info.dwProcessorType)
	{
		case PROCESSOR_INTEL_386:     zt_logInfo("processor type: Intel 386"); break;
		case PROCESSOR_INTEL_486:     zt_logInfo("processor type: Intel 486"); break;
		case PROCESSOR_INTEL_PENTIUM: zt_logInfo("processor type: Intel Pentium"); break;
		case PROCESSOR_INTEL_IA64:    zt_logInfo("processor type: IA 64"); break;
		case PROCESSOR_AMD_X8664:     zt_logInfo("processor type: x8664"); break;
		default:                      zt_logInfo("processor type: Unknown (%d)", system_info.dwProcessorType); break;
	}

	{
		ztSystemInfo system_info;
		zt_systemInfo(&system_info);

		char total[64], avail[64];
		zt_strNumberToString(total, zt_elementsOf(total), system_info.physical_memory_total);
		zt_strNumberToString(avail, zt_elementsOf(avail), system_info.physical_memory_avail);
		zt_logInfo("physical memory: %s total / %s available", total, avail);

		zt_strNumberToString(total, zt_elementsOf(total), system_info.virtual_memory_total);
		zt_strNumberToString(avail, zt_elementsOf(avail), system_info.virtual_memory_avail);
		zt_logInfo("virtual memory: %s total / %s available", total, avail);

		ztDrive drives[26];
		int drives_count = zt_driveGetDetails(drives, zt_elementsOf(drives));

		zt_fiz(zt_min(drives_count, zt_elementsOf(drives))) {
			if(drives[i].type == ztDriveType_Fixed) {
				u64 space_avail = 0, space_total = 0;
				zt_driveGetSize(&drives[i], &space_avail, &space_total);

				char space_avail_str[64] = {0}, space_total_str[64] = {0};
				zt_strNumberToString(space_avail_str, zt_elementsOf(space_avail_str), (i64)space_avail);
				zt_strNumberToString(space_total_str, zt_elementsOf(space_total_str), (i64)space_total);

				zt_logInfo("drive: %s (%s) %s available out of %s total", drives[i].mount, drives[i].name, space_avail_str, space_total_str);
			}
			else {
				zt_logInfo("drive: %s (%s)", drives[i].mount, drives[i].name);
			}
		}

		ztDisplay displays[16];
		int displays_count = zt_displayGetDetails(displays, zt_elementsOf(displays));
		zt_fiz(zt_min(displays_count, zt_elementsOf(displays))) {
			zt_logInfo("display: %s (xy: %d, %d / wh: %d, %d) refresh: %d hz %s", displays[i].name, displays[i].screen_area.x, displays[i].screen_area.y, displays[i].screen_area.z, displays[i].screen_area.w, displays[i].refresh_rate_in_hz, displays[i].primary ? "primary" : "secondary");
		}
	}
}

#endif // !ZT_DLL

// ================================================================================================================================================================================================

ztInternal HINSTANCE _zt_hinstance;

#elif defined(ZT_EMSCRIPTEN) // end ZT_WINDOWS

ztInternal bool _ems_request_pointer_lock = false;

// ================================================================================================================================================================================================

void _zt_emsProcessMessages()
{
}

// ================================================================================================================================================================================================

void _zt_emsControllerInputHapticFeedback(int idx, r32 strength_low, r32 strength_high)
{
}

// ================================================================================================================================================================================================

void _zt_emsControllerInputUpdate(r32 dt)
{
}

// ================================================================================================================================================================================================

void _zt_emsControllerInputCleanup()
{
}

// ================================================================================================================================================================================================

void _zt_emsControllerInputInit()
{
}

// end ZT_EMSCRIPTEN

#elif defined(ZT_ANDROID)

ztInternal bool _ems_request_pointer_lock = false;

// ================================================================================================================================================================================================

void _zt_androidProcessEvents()
{
	int ident;
	int events;
	android_poll_source* source;

	while ((ident = ALooper_pollAll(zt_game->app_has_focus ? 0 : -1, nullptr, &events, (void**)&source)) >= 0) {

		// Process this event.
		if (source != nullptr) {
			source->process(zt_game->android_app, source);
		}

		// Check if we are exiting.
		if (zt_game->android_app->destroyRequested != 0) {
			zt_game->quit_requested = true;
			return;
		}
	}
}

// ================================================================================================================================================================================================

void _zt_androidProcessMessages()
{
	_zt_androidProcessEvents();
	
	if (ztgl_android_contextQueryChangeResolution(zt_game->win_details[0].gl_context)) {
		_zt_callFuncScreenChange(&zt_game->win_game_settings[0]);
	}

	_zt_rendererSwapBuffers(&zt_game->win_details[0]);
}

// ================================================================================================================================================================================================

#endif // ZT_EMSCRIPTEN

// ================================================================================================================================================================================================

#if !defined(ZT_DLL)

bool mainLoopCall(r64 *time_last)
{
	zt_profilerFrameBegin();
	ZT_PROFILE_PLATFORM("Game Loop");

	static bool mouse_look = zt_game->input_mouse_look;

	{
		ZT_PROFILE_INPUT("Mouse Handling");

		if (mouse_look != zt_game->input_mouse_look) {
			mouse_look = zt_game->input_mouse_look;
			if (mouse_look) {
#				if defined(ZT_WINDOWS)
				if(zt_game->app_has_focus) {
					RECT client_rect; GetClientRect(zt_game->win_details[0].handle, &client_rect);
					RECT window_rect; GetWindowRect(zt_game->win_details[0].handle, &window_rect);
					RECT clip_rect;
					clip_rect.left   = (window_rect.left + zt_convertToi32Floor(((window_rect.right - window_rect.left) - (client_rect.right)) / 2.f)) + 50;
					clip_rect.right  = (clip_rect.left + client_rect.right) - 100;
					clip_rect.top    = (window_rect.top + zt_convertToi32Floor(((window_rect.bottom - window_rect.top) - (client_rect.bottom)) / 2.f)) + 50;
					clip_rect.bottom = (clip_rect.top + client_rect.bottom) - 100;
					ClipCursor(&clip_rect);
				}
#				endif

				zt_emscriptenOnly(_ems_request_pointer_lock = true);
			}
			else {
				zt_winOnly(ClipCursor(NULL));
				zt_emscriptenOnly(_ems_request_pointer_lock = false);
			}
		}
		if (zt_game->input_mouse_look) {
			if (zt_winOnly(zt_game->app_has_focus) zt_emscriptenOnly(zt_game->app_has_focus) zt_androidOnly(true)) {
				zt_game->input_mouse.screen_x = 0;
				zt_game->input_mouse.screen_y = 0;

				zt_emscriptenOnly(SDL_WarpMouse(0, 0));
			}
			else {
				zt_game->input_mouse.screen_x = 0;
				zt_game->input_mouse.screen_y = 0;
				zt_game->input_mouse.delta_x  = 0;
				zt_game->input_mouse.delta_y  = 0;
				mouse_look = false;
				zt_winOnly(ClipCursor(NULL));
			}
		}
	}
	r64 time_this = zt_getTime();
	r32 dt = (r32)(time_this - *time_last);
	*time_last = time_this;

	zt_debugOnly(if (dt > 1.f / 30.f) dt = 1.f / 30.f); // keep the delta time meaningful during debugging
	zt_game->game_details.current_dt = dt;

	_zt_audioUpdateFrame(dt);

	if (!_zt_callFuncLoop(dt))
		return false;

	if (zt_game->renderer_requests_count) {
		if (!_zt_rendererRequestProcess()) {
			zt_logCritical("renderer request failed: exiting");
			return false;
		}
	}

#	if defined(ZT_WINDOWS)
	zt_fiz(zt_game->win_count) {
		if(zt_game->win_details[i].resize_cooldown > 0) {
			zt_game->win_details[i].resize_cooldown -= dt;
			if(zt_game->win_details[i].resize_cooldown < 0) {
				_zt_winHandleWindowSize(&zt_game->win_details[i], &zt_game->win_game_settings[i]);
			}
			zt_rendererClear(ztColor_Black);
		}

		_zt_rendererSwapBuffers(&zt_game->win_details[i]);
	}
#	endif

	_zt_inputClearState(false);
	zt_winOnly(_zt_winProcessMessages());
	zt_winOnly(_zt_winControllerInputUpdate(dt));
	zt_winOnly(_zt_threadJobQueueUpdate());

	zt_emscriptenOnly(_zt_emsProcessMessages());
	zt_emscriptenOnly(_zt_emsControllerInputUpdate(dt));

	zt_androidOnly(_zt_androidProcessMessages());


	++zt_game->game_details.current_frame;

	zt_profilerFrameEnd();
	return true;
}

// ================================================================================================================================================================================================

#if defined(ZT_EMSCRIPTEN)

EM_BOOL emsCallbackClick(int eventType, const EmscriptenMouseEvent *e, void *userData)
{
	if (e->screenX != 0 && e->screenY != 0 && e->clientX != 0 && e->clientY != 0 && e->canvasX != 0 && e->canvasY != 0 && e->targetX != 0 && e->targetY != 0) {
		if (eventType == EMSCRIPTEN_EVENT_CLICK && _ems_request_pointer_lock) {
			_ems_request_pointer_lock = false;
			EMSCRIPTEN_RESULT ret = emscripten_request_pointerlock(0, 0);
			if (ret != EMSCRIPTEN_RESULT_SUCCESS) {
				zt_logCritical("emscripten_request_pointerlock() failure");
			}
		}
	}
	return 0;
}

// ================================================================================================================================================================================================

EM_BOOL emsCallbackPointerLockChange(int event_type, const EmscriptenPointerlockChangeEvent *e, void *user_data)
{
	if (zt_game->input_mouse_look) {
		_ems_request_pointer_lock = true;
	}
	else {
		_ems_request_pointer_lock = false;
	}

	return 0;
}

// ================================================================================================================================================================================================

void mainLoopEmscripten()
{
	static r64 time = zt_getTime();
	if (!mainLoopCall(&time)) {
		zt_game->quit_requested = true;
	}

	SDL_Event sdl_evt;
	while (SDL_PollEvent(&sdl_evt)) {
		switch (sdl_evt.type)
		{
			case SDL_ACTIVEEVENT: {
				zt_game->app_has_focus = sdl_evt.active.gain == 1;
			} break;

			case SDL_KEYDOWN:
			case SDL_KEYUP: {
				u32 key_code = (u32)sdl_evt.key.keysym.sym;
				auto* input_key = &zt_game->input_keys[zt_game->input_keys_mapping[key_code]];

				bool is_down = sdl_evt.type == SDL_KEYDOWN;
				bool was_down = sdl_evt.type == SDL_KEYUP;
				bool repeated = zt_bitIsSet(input_key->flags, ztInputKeyFlags_Pressed);

				if (was_down != is_down || repeated) {
					zt_game->input_this_frame = true;

					ztInputKeys *keys[2] = {input_key, nullptr};

					if(input_key->code == ztInputKeys_LeftShift   || input_key->code == ztInputKeys_RightShift  ) keys[1] = &zt_game->input_keys[ztInputKeys_Shift];
					if(input_key->code == ztInputKeys_LeftControl || input_key->code == ztInputKeys_RightControl) keys[1] = &zt_game->input_keys[ztInputKeys_Control];
					if(input_key->code == ztInputKeys_LeftMenu    || input_key->code == ztInputKeys_RightMenu   ) keys[1] = &zt_game->input_keys[ztInputKeys_Menu];

					zt_fize(keys) {
						if(keys[i] == nullptr) break;
						input_key = keys[i];

						input_key->flags = input_key->display == 0 ? ztInputKeyFlags_StateKey : 0;

						if (is_down && !was_down) {
							input_key->flags |= ztInputKeyFlags_JustPressed;
							input_key->time_pressed = zt_getTime();
						}

						if (!is_down && was_down) input_key->flags |= ztInputKeyFlags_JustReleased;
						if (is_down) input_key->flags |= ztInputKeyFlags_Pressed;

						if (is_down && repeated) input_key->flags |= ztInputKeyFlags_JustRepeated;

						if ( is_down && (!was_down || repeated) && zt_game->input_key_strokes_count < zt_elementsOf(zt_game->input_key_strokes) ) {
							zt_game->input_key_strokes[zt_game->input_key_strokes_count++] = input_key->code;
						}
					}
				}
			} break;

			case SDL_MOUSEMOTION: {
				zt_game->input_this_frame = true;
				zt_game->input_mouse.screen_x = sdl_evt.motion.x;
				zt_game->input_mouse.screen_y = sdl_evt.motion.y;
				zt_game->input_mouse.delta_x = sdl_evt.motion.xrel;
				zt_game->input_mouse.delta_y = sdl_evt.motion.yrel;
			} break;

			case SDL_MOUSEBUTTONDOWN: {
				zt_game->input_this_frame = true;
				switch(sdl_evt.button.button)
				{
					case SDL_BUTTON_LEFT  : zt_game->input_mouse.button_state_left   = ztInputMouseFlags_JustPressed | ztInputMouseFlags_Pressed; break;
					case SDL_BUTTON_MIDDLE: zt_game->input_mouse.button_state_middle = ztInputMouseFlags_JustPressed | ztInputMouseFlags_Pressed; break;
					case SDL_BUTTON_RIGHT : zt_game->input_mouse.button_state_right  = ztInputMouseFlags_JustPressed | ztInputMouseFlags_Pressed; break;
				}
			} break;

			case SDL_MOUSEBUTTONUP: {
				zt_game->input_this_frame = true;
				switch(sdl_evt.button.button)
				{
					case SDL_BUTTON_LEFT  : zt_game->input_mouse.button_state_left   = ztInputMouseFlags_JustReleased; break;
					case SDL_BUTTON_MIDDLE: zt_game->input_mouse.button_state_middle = ztInputMouseFlags_JustReleased; break;
					case SDL_BUTTON_RIGHT : zt_game->input_mouse.button_state_right  = ztInputMouseFlags_JustReleased; break;
				}
			} break;

			case SDL_JOYAXISMOTION: {
			} break;

			case SDL_JOYBALLMOTION: {
			} break;

			case SDL_JOYHATMOTION: {
			} break;

			case SDL_JOYBUTTONDOWN: {
			} break;

			case SDL_JOYBUTTONUP: {
			} break;

			case SDL_QUIT: {
			} break;

			case SDL_SYSWMEVENT: {
			} break;

			case SDL_VIDEORESIZE: {
			} break;

			case SDL_VIDEOEXPOSE: {
			} break;

			case SDL_USEREVENT: {
			} break;

		}
	}

	if(zt_game->quit_requested) {
		zt_logDebug("quit requested");
		emscripten_cancel_main_loop();
	}
}

// ================================================================================================================================================================================================

bool mainInitializationAndLoop();

// ================================================================================================================================================================================================

void mainLoopEmscriptenWaitForFileSync()
{
	if(emscripten_run_script_int("Module.syncdone") == 1) {
		zt_logInfo("emscripten_cancel_main_loop()");
		emscripten_cancel_main_loop();

		if (!mainInitializationAndLoop()) {
			return;
		}

		zt_logInfo("emscripten_set_click_callback()");
		emscripten_set_click_callback(0, 0, 1, emsCallbackClick);
		zt_logInfo("emscripten_set_pointerlockchange_callback()");
		emscripten_set_pointerlockchange_callback("#window", 0, 1, emsCallbackPointerLockChange);
		
		//emscripten_set_some_callback(nullptr, nullptr, true, emsCallback);

		zt_logInfo("emscripten_set_main_loop()");
		emscripten_set_main_loop(mainLoopEmscripten, 0, false);

		zt_logInfo("mainLoopEmscriptenWaitForFileSync() exiting");
	}
}

// end ZT_EMSCRIPTEN

#elif defined (ZT_ANDROID)

ztInternal android_app *zt_android_app = nullptr;

// ================================================================================================================================================================================================

void androidInit()
{
	zt_game->android_app = zt_android_app;
	zt_game->win_details[0].handle = zt_game->android_app;

	zt->android_asset_manager = zt_android_app->activity->assetManager;
	if (zt->android_asset_manager == nullptr) {
		zt_logCritical("asset manager is null!");
	}

	while (true) {
		if (zt_game->android_app->window != nullptr ) {
			break;
		}
		_zt_androidProcessEvents();
	}
}

// ================================================================================================================================================================================================

void androidCleanup()
{
}

// ================================================================================================================================================================================================

bool androidMainLoop()
{
	return false;
}

// ================================================================================================================================================================================================

// Process the next main command.
void androidHandleCmd(android_app* app, int32_t cmd)
{
	switch (cmd) {
		case APP_CMD_INIT_WINDOW: {
		} break;

		case APP_CMD_TERM_WINDOW: {
			androidCleanup();
		} break;

		case APP_CMD_SAVE_STATE: {
		} break;

		case APP_CMD_GAINED_FOCUS: {
			zt_game->app_has_focus = true;
			if (zt_game->sl_context != nullptr) {
				ztsl_contextResumeAll(zt_game->sl_context);
			}
			if (zt_game->game_details.current_frame > 1) {
				ztgl_android_contextUpdateAfterResume(zt_game->win_details[0].gl_context);
			}
		} break;

		case APP_CMD_LOST_FOCUS: {
			zt_game->app_has_focus = false;
			ztsl_contextPauseAll(zt_game->sl_context);
		} break;
	}
}

// ================================================================================================================================================================================================

int32_t androidHandleInput(struct android_app* app, AInputEvent* evt)
{
	switch(AInputEvent_getType(evt))
	{
		case AINPUT_EVENT_TYPE_MOTION: {
			int m_x = AMotionEvent_getX(evt, 0);
			int m_y = AMotionEvent_getY(evt, 0);

			zt_game->input_this_frame = true;

			zt_game->input_mouse.delta_x = m_x - zt_game->input_mouse.screen_x;
			zt_game->input_mouse.delta_y = m_y - zt_game->input_mouse.screen_y;

			zt_game->input_mouse.screen_x = m_x;
			zt_game->input_mouse.screen_y = m_y;

			i32 action = AMotionEvent_getAction(evt);
			i32 flags = action & AMOTION_EVENT_ACTION_MASK;

			switch(flags)
			{
				case AMOTION_EVENT_ACTION_DOWN: {
					if (!zt_bitIsSet(zt_game->input_mouse.button_state_left, ztInputMouseFlags_Pressed)) {
						zt_game->input_mouse.button_state_left |= ztInputMouseFlags_JustPressed;
					}
					zt_game->input_mouse.button_state_left |= ztInputMouseFlags_Pressed;

					zt_logDebug("mouse_x: %d; mouse_y: %d;", m_x, m_y);
				} break;

				case AMOTION_EVENT_ACTION_UP: {
					zt_bitRemove(zt_game->input_mouse.button_state_left, ztInputMouseFlags_Pressed);
					zt_game->input_mouse.button_state_left |= ztInputMouseFlags_JustReleased;
				} break;

				default: {
				} break;
			}
		} break;
	
		default: {
		} break;
	}

	return 0;
}

// ================================================================================================================================================================================================


#endif

// ================================================================================================================================================================================================

bool mainInitializationAndLoop()
{
	ztWindowDetails *win_details;

	if(!zt_directoryExists(zt_game->game_details.user_path)) {
		zt_directoryMake(zt_game->game_details.user_path);
	}

	_zt_profilerInit();
	zt_profilerFrameBegin();
	{
		ZT_PROFILE_PLATFORM("main(init)");

		{ // init input
			_zt_inputSetupKeys();

			for (int i = 0; i < ztInputKeys_MAX; ++i) {
				zt_game->input_keys_mapping[zt_game->input_keys[i].platform_mapping] = zt_game->input_keys[i].code;
			}
			zt_memSet(&zt_game->input_mouse, zt_sizeof(ztInputMouse), 0);
			zt_game->input_mouse.cursor = ztInputMouseCursor_Arrow;
		}

		zt_game->game_details.current_frame = 1;

		ztGameSettings *game_settings = &zt_game->win_game_settings[0];
		zt_game->win_count += 1;

		game_settings->memory = zt_megabytes(64);
		game_settings->native_w = game_settings->screen_w = 1280;
		game_settings->native_h = game_settings->screen_h = 720;
		game_settings->pixels_per_unit = 64;

		game_settings->renderer = ztRenderer_OpenGL;
		game_settings->renderer_flags = ztRendererFlags_Windowed | ztRendererFlags_LockAspect;
		game_settings->renderer_screen_change_behavior = ztRendererScreenChangeBehavior_Resize;
		game_settings->renderer_memory = zt_megabytes(16);

		game_settings->threaded_frame_jobs      = zt_max(0, ZT_MAX_THREADS - 2);
		game_settings->threaded_background_jobs = 1;

		if (game_settings->threaded_frame_jobs > 3) {
			game_settings->threaded_frame_jobs -= 1;
			game_settings->threaded_background_jobs += 1;
		}

#		if defined(ZT_ANDROID)
		androidInit();
#		endif


		if (!_zt_callFuncSettings(&zt_game->game_details, game_settings))
			return false;

#	if defined(ZT_ANDROID)
		game_settings->native_w = game_settings->screen_w = ANativeWindow_getWidth(zt_game->android_app->window);
		game_settings->native_h = game_settings->screen_h = ANativeWindow_getHeight(zt_game->android_app->window);

		zt_logInfo("Android window reported dimensions: %d x %d", game_settings->screen_w, game_settings->screen_h);
#	endif

		zt_logInfo("main: app path: %s", zt_game->game_details.app_path);
		zt_logInfo("main: data path: %s", zt_game->game_details.data_path);
		zt_logInfo("main: user path: %s", zt_game->game_details.user_path);

		zt_winOnly(_zt_winLogSystemInfo());

		char app_memory_str[128];
		zt_strBytesToString(app_memory_str, sizeof(app_memory_str), game_settings->memory);
		zt_logInfo("main: initializing %s of memory", app_memory_str);

		zt_memPushGlobalArena(zt_memMakeArena(game_settings->memory));

		win_details = &zt_game->win_details[0];

#		if defined(ZT_WINDOWS)
		if (!_zt_winCreateWindow(game_settings, win_details))
			return false;

		{ // more input init
			POINT cursor_pos;
			GetCursorPos(&cursor_pos);

			zt_game->input_mouse.screen_x = cursor_pos.x - win_details->window_rect.left;
			zt_game->input_mouse.screen_y = cursor_pos.y - win_details->window_rect.top;

			_zt_winControllerInputInit();
		}
#		elif defined(ZT_EMSCRIPTEN)
		zt_logDebug("main: initializing SDL");
		SDL_Init(SDL_INIT_EVERYTHING);
		zt_game->app_has_focus = true;

#		endif

		zt_game->renderer_memory_size = game_settings->renderer_memory;
		zt_game->renderer_memory = (byte*)zt_memAlloc(zt_memGetGlobalArena(), zt_game->renderer_memory_size);

		if (!_zt_rendererSetRendererFuncs(game_settings->renderer)) {
			zt_logCritical("main: Unknown renderer (%d)", game_settings->renderer);
			return false;
		}

		if (!_zt_rendererMakeContext(win_details, game_settings, game_settings->renderer_flags)) {
			zt_logCritical("main: Failed to create renderer context on main window");
			return false;
		}

		zt_fiz(zt_elementsOf(_zt_default_shaders)) {
			zt_game->shader_defaults[i] = ztInvalidID;
		}

		// make a simple white texture to use as a default
		{
			u32 texture[] = { 0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff };

			zt_debugOnly(ztTextureID white_tex =)
				zt_textureMakeFromPixelData(texture, 8, 8);
			zt_debugOnly(zt_textureSetName(white_tex, "Solid White"));

			zt_fize(texture) {
				texture[i] = 0xff000000;
			}

			zt_debugOnly(ztTextureID black_tex =)
				zt_textureMakeFromPixelData(texture, 8, 8);
			zt_debugOnly(zt_textureSetName(black_tex, "Solid Black"));
		}
		// make the default font
		{
			_zt_fontMakeDefaults();
		}

		if (!_zt_callFuncInit(&zt_game->game_details, game_settings)) {
			zt_logCritical("main: Failed to initialize game");
			return false;
		}
		zt_logInfo("main: Game initialized successfully");

#		if !defined(ZT_EMSCRIPTEN)
		_zt_threadJobQueueInit(game_settings->threaded_frame_jobs, game_settings->threaded_background_jobs);
		zt_logInfo("main: Thread job queue initialized");
#		endif

		_zt_callFuncScreenChange(game_settings);
		zt_winOnly(_zt_winHandleWindowSize(win_details, game_settings));

		if (zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_Fullscreen)) {
			zt_bitRemove(game_settings->renderer_flags, ztRendererFlags_Fullscreen); // if we don't remove, it assumes we haven't done it yet
			zt_rendererRequestFullscreen();
		}

		zt_memArenaValidate(zt_memGetGlobalArena()); // make sure everything is ok in memory before we begin

#		if defined(ZT_DEBUG)
		{
			ztMemoryArena *temp_arena = zt_memGetTempArena();
			zt_assert(temp_arena && temp_arena->latest == nullptr);
		}
#		endif
	}
	zt_profilerFrameEnd();

	if (zt_game->input_mouse_look) {
		zt_winOnly(SetCursorPos(0, 0));
		zt_emscriptenOnly(SDL_WarpMouse(0, 0));
	}

#	if defined(ZT_WINDOWS) || defined(ZT_ANDROID)
	r64 time_last = zt_getTime();

	do {
		if(!mainLoopCall(&time_last)) {
			break;
		}
	} while (!zt_game->quit_requested);

#	endif

	return true;
}

// ================================================================================================================================================================================================

int main(int argc, const char **argv)
{
	char *app_path = (char*)malloc(ztFileMaxPath);

#	if !defined(ZT_EMSCRIPTEN) && !defined(ZT_ANDROID)
	zt_fileGetAppPath(app_path, ztFileMaxPath);
	zt_logInfo("application path: %s", app_path);
#	endif

	char *data_path_temp = (char*)malloc(ztFileMaxPath);
	char *data_path = (char*)malloc(ztFileMaxPath);
#	if defined(ZT_EMSCRIPTEN) || defined(ZT_ANDROID)
	data_path_temp[0] = 0;
#	else
	zt_fileGetCurrentPath(data_path_temp, ztFileMaxPath);
#	endif
	zt_logInfo("application data path temp: %s", data_path_temp);
	zt_fileConcatFileToPath(data_path, ztFileMaxPath, data_path_temp, ztFilePathSeparatorStr "data");
	zt_logInfo("application data path: %s", data_path);

	if(!zt_directoryExists(data_path)) {
		zt_fileConcatFileToPath(data_path, ztFileMaxPath, data_path_temp, ztFilePathSeparatorStr "run" ztFilePathSeparatorStr "data");
		zt_logInfo("adjusted application data path: %s", data_path);
	}

	free(data_path_temp);

	char *user_path = (char*)malloc(ztFileMaxPath);

	{
#	if defined(ZT_ANDROID)

#		if !defined(ZT_ANDROID_PACKAGE_NAME)
#		define ZT_ANDROID_PACKAGE_NAME "net.zeroTolerance.app"
#		warning "ZT_ANDROID_PACKAGE_NAME has not been defined.  Using default " ZT_ANDROID_PACKAGE_NAME
#		endif

		zt_strCpy( app_path, ztFileMaxPath, "@");
		zt_strCpy(data_path, ztFileMaxPath, "@data");
		zt_strCpy(user_path, ztFileMaxPath, "data/data/" ZT_ANDROID_PACKAGE_NAME "/persistent_data");

		if(!zt_directoryExists(user_path)) {
			zt_directoryMake(user_path);
		}

#	elif defined(ZT_EMSCRIPTEN)
		EM_ASM(
			FS.mkdir('/persistent_data');
			FS.mount(IDBFS,{},'/persistent_data');
			Module.print("start file sync..");
			Module.syncdone = 0;
			FS.syncfs(true, function(err) {
				assert(!err);
				Module.print("end file sync..");
				Module.syncdone = 1;
			});
		);

		zt_strCpy(user_path, ztFileMaxPath, "/persistent_data");

#	elif defined(ZT_GAME_LOCAL_ONLY)
		zt_fileGetCurrentPath(user_path, ztFileMaxPath);
#	else

#	if !defined(ZT_EMSCRIPTEN)
#		if defined(ZT_GAME_NAME_USER_DIR)
			zt_fileGetUserPath(user_path, ztFileMaxPath, ZT_GAME_NAME_USER_DIR);
#		else
			zt_fileGetUserPath(user_path, ztFileMaxPath, ZT_GAME_NAME);
#		endif
#		endif
#	endif
	}

	zt_logInfo("user path: %s", user_path);
	
	ztGameGlobals *game = (ztGameGlobals *)malloc(sizeof(ztGameGlobals));
	zt_memSet(game, zt_sizeof(ztGameGlobals), 0);
	zt_game = game;

	{
		char size[128];
		zt_strBytesToString(size, zt_sizeof(size), zt_sizeof(ztGameGlobals));
		zt_logInfo("main: initial memory: %s", size);

		zt_winOnly(zt_game->hinstance = _zt_hinstance);

		zt_winOnly(char exe_name[ztFileMaxPath]);
		zt_winOnly(GetModuleFileNameA(NULL, exe_name, zt_elementsOf(exe_name)));
		zt_winOnly(zt_game->exe_icon = ExtractIconA(_zt_hinstance, exe_name, 0));
	}

	zt_game->game_details = {};
	zt_game->game_details.argc = argc;
	zt_game->game_details.argv = argv;

	zt_game->game_details.app_path = app_path;
	zt_game->game_details.data_path = data_path;
	zt_game->game_details.user_path = user_path;

	zt_game->game_details.app_start_time = zt_getTime();

	zt_game->main_thread_id = zt_threadGetCurrentID();

#	if defined(ZT_WINDOWS) || defined(ZT_ANDROID)

	if (!mainInitializationAndLoop()) {
		return 1;
	}

#	elif defined(ZT_EMSCRIPTEN)
	EM_ASM(Module['noExitRuntime'] = true);

	emscripten_set_main_loop(mainLoopEmscriptenWaitForFileSync, 0, false);
	return 0;

#	endif

	zt_profilerFrameBegin();
	{
		zt_logInfo("initiating cleanup");
		ZT_PROFILE_PLATFORM("main(cleanup)");
		zt_textureFree(0); // free the white tex
		zt_textureFree(1); // free the black tex


		zt_fiz(zt_game->fonts_count_system) {
			zt_fontFree(i);
		}

		_zt_threadJobQueueFree();

		_zt_callFuncCleanup();

#		if defined(ZT_DSOUND)
		if (zt_game->ds_context != nullptr) {
			ztds_contextFree(zt_game->ds_context);
		}
#		elif defined(ZT_OPENAL)
		if (zt_game->al_context != nullptr) {
			ztal_contextFree(zt_game->al_context);
		}
#		elif defined(ZT_OPENSL)
		if (zt_game->sl_context != nullptr) {
			ztsl_contextFree(zt_game->sl_context);
		}

#		endif

		zt_fiz(zt_game->shaders_count) {
			zt_game->shaders[i].asset_mgr = nullptr;
			zt_shaderFree((ztShaderID)i);
		}
		zt_fiz(zt_game->textures_count) {
			//zt_textureFree((ztTextureID)i);
		}

		zt_memFree(zt_memGetGlobalArena(), zt_game->renderer_memory);

		zt_winOnly(_zt_winControllerInputCleanup());
		zt_winOnly(_zt_winCleanupWindow(&zt_game->win_details[0], &zt_game->win_game_settings[0]));
		zt_emscriptenOnly(_zt_emsControllerInputCleanup());

		_zt_debuggingCleanup();

		zt_memDumpArena(zt_memGetGlobalArena(), "main memory");
		zt_memFreeArena(zt_memGetGlobalArena());
		zt_memPopGlobalArena();
	}
	zt_profilerFrameEnd();
	_zt_profilerFree();

	free(zt_game);
	free(user_path);
	free(data_path);
	free(app_path);

	return 0;
}

#endif // !ZT_DLL

// ================================================================================================================================================================================================

#if defined(ZT_WINDOWS) && !defined(ZT_DLL)

#if !defined(ZT_PLATFORM_WIN32_CONSOLE) && !defined(ZT_PLATFORM_WIN64_CONSOLE)

int CALLBACK WinMain(HINSTANCE h_instance, HINSTANCE h_prev_instance, LPSTR cmd_line, int cmd_show)
{
	_zt_hinstance = h_instance;

	const char* argv[128];
	int argc = 0;

	if (cmd_line != nullptr) {
		static char cmd_line_buffer[1024] = {0};
		zt_strCpy(cmd_line_buffer, sizeof(cmd_line_buffer), cmd_line);

		ztToken tokens[128];
		int tokens_count = zt_strTokenize(cmd_line, " ", tokens, zt_elementsOf(tokens));
		zt_assert(tokens_count <= zt_elementsOf(tokens));

		argv[0] = nullptr;
		zt_fiz(tokens_count) {
			argv[i+1] = cmd_line_buffer + tokens[i].beg;
			cmd_line_buffer[tokens[i].beg + tokens[i].len] = 0;
		}
		argc = tokens_count ? tokens_count + 1 : 0;
	}

	return main(argc, argv);
}

#endif // WinMain


// ================================================================================================================================================================================================

ztInternal void _zt_winCallbackKeyboard(MSG& msg)
{
	ZT_PROFILE_PLATFORM("_zt_winCallbackKeyboard");

	u32 key_code = (uint32)msg.wParam;
	bool is_down = !zt_bitIsSet(msg.lParam, (1<<31));
	bool was_down = zt_bitIsSet(msg.lParam, (1<<30));
	bool repeated = (msg.lParam & 0xffff) != 0;

	if (was_down != is_down || repeated) {
		zt_game->input_this_frame = true;

		auto* input_key = &zt_game->input_keys[zt_game->input_keys_mapping[key_code]];
		
		input_key->flags = input_key->display == 0 ? ztInputKeyFlags_StateKey : 0;

		if (is_down && !was_down) {
			input_key->flags |= ztInputKeyFlags_JustPressed;
			input_key->time_pressed = zt_getTime();
		}

		if (!is_down && was_down) input_key->flags |= ztInputKeyFlags_JustReleased;
		if (is_down) input_key->flags |= ztInputKeyFlags_Pressed;

		if (is_down && repeated) input_key->flags |= ztInputKeyFlags_JustRepeated;

		if ( is_down && (!was_down || repeated) && zt_game->input_key_strokes_count < zt_elementsOf(zt_game->input_key_strokes) ) {
			zt_game->input_key_strokes[zt_game->input_key_strokes_count++] = input_key->code;
		}

		switch(key_code)
		{
			case VK_F4: {
#				if !defined(ZT_GAME_NO_ALTF4)
				if ( GetAsyncKeyState(VK_MENU) ) {
					zt_game->quit_requested = true;	// ALT+F4 needs to close our game
				}
#				endif
			} break;
		}

	}
}

// ================================================================================================================================================================================================

LRESULT CALLBACK _zt_winCallback(HWND handle, UINT msg, WPARAM w_param, LPARAM l_param)
{
	ZT_PROFILE_PLATFORM("_zt_winCallback");

	ztGameSettings *game_settings = nullptr;
	ztWindowDetails *window_details = nullptr;

	zt_fiz(zt_game->win_count) {
		if (zt_game->win_details[i].handle == handle) {
			game_settings = &zt_game->win_game_settings[i];
			window_details = &zt_game->win_details[i];
			break;
		}
	}

	LRESULT result = 0;

	switch (msg)
	{
		case WM_QUIT: {
			zt_game->quit_requested = false;
		} break;

		case WM_SYSKEYDOWN:
		case WM_SYSKEYUP:
		case WM_KEYDOWN:
		case WM_KEYUP: {
			MSG smsg;
			smsg.message = msg;
			smsg.hwnd = handle;
			smsg.lParam = l_param;
			smsg.wParam = w_param;
			_zt_winCallbackKeyboard(smsg);
		} break;

		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		case WM_MBUTTONUP:
		case WM_MOUSEWHEEL:
		case WM_MOUSEMOVE: {
			struct local
			{
				ztInternal void button_pressed(ztWindowDetails *win_details, i32& input_state, bool is_down, bool was_down)
				{
					input_state = 0;
					if (is_down) input_state |= ztInputMouseFlags_Pressed;
					if (is_down && !was_down) input_state |= ztInputMouseFlags_JustPressed;
					if (!is_down && was_down) input_state |= ztInputMouseFlags_JustReleased;

					if (is_down) {
						if (zt_game->input_mouse_captures == 0) {
							SetCapture(win_details->handle); // required so that events continue to be sent during dragging
						}
						zt_game->input_mouse_captures += 1;
					}
					else {
						if (--zt_game->input_mouse_captures == 0) {
							ReleaseCapture();
						}
					}
				}
			};

			zt_game->input_this_frame = true;

			switch (msg)
			{
				case WM_MOUSEMOVE: {
					int x = GET_X_LPARAM(l_param);
					int y = GET_Y_LPARAM(l_param);

					zt_game->input_mouse.screen_x = x;
					zt_game->input_mouse.screen_y = y;
				} break;

				case WM_LBUTTONDOWN: local::button_pressed(window_details, zt_game->input_mouse.button_state_left, true, false); break;
				case WM_LBUTTONUP: local::button_pressed(window_details, zt_game->input_mouse.button_state_left, false, true); break;

				case WM_RBUTTONDOWN: local::button_pressed(window_details, zt_game->input_mouse.button_state_right, true, false); break;
				case WM_RBUTTONUP: local::button_pressed(window_details, zt_game->input_mouse.button_state_right, false, true); break;

				case WM_MBUTTONDOWN: local::button_pressed(window_details, zt_game->input_mouse.button_state_middle, true, false); break;
				case WM_MBUTTONUP: local::button_pressed(window_details, zt_game->input_mouse.button_state_middle, false, true); break;

				case WM_MOUSEWHEEL: {
					zt_game->input_mouse.wheel_delta = GET_WHEEL_DELTA_WPARAM(w_param) / 120;
				} break;
			}
		} break;

		case WM_INPUT: {
			if (w_param == RIM_INPUT) {
				UINT size;
				GetRawInputData((HRAWINPUT)l_param, RID_INPUT, NULL, &size, sizeof(RAWINPUTHEADER));
				
				byte buffer[zt_kilobytes(1)];
				zt_assert(size < zt_elementsOf(buffer));
				
				if (GetRawInputData((HRAWINPUT)l_param, RID_INPUT, buffer, &size, sizeof(RAWINPUTHEADER)) != size) {
					zt_assert(false);
				}

				RAWINPUT* raw = (RAWINPUT*)buffer;

				if (raw->header.dwType == RIM_TYPEMOUSE) {
					zt_game->input_this_frame = true;

					if (raw->data.mouse.usFlags == MOUSE_MOVE_RELATIVE) {

						struct mouse_cfg
						{
							int speed;
							mouse_cfg() { SystemParametersInfo(SPI_GETMOUSESPEED, 0, &speed, 0); }
						};

						static mouse_cfg mouse;

						zt_game->input_mouse.delta_x += raw->data.mouse.lLastX * mouse.speed;
						zt_game->input_mouse.delta_y += raw->data.mouse.lLastY * mouse.speed;
					}

					return 0;
				} 
			}
		} break;

		case WM_DESTROY:
		case WM_CLEAR: {
			if (window_details && window_details == &zt_game->win_details[0]) {
				zt_game->quit_requested = true;
			}
			else {
				_zt_winCleanupWindow(window_details, game_settings);
			}
		} break;

		case WM_MOVE: {
		} break;

		case WM_SIZE: {
			if(!IsIconic(handle)) {
				if(window_details) {
					window_details->resize_cooldown = .05f;
				}
			}
		} break;

		case WM_SIZING: {
			if (window_details && game_settings) {
				if(zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_NoResize)) {
					RECT size;
					GetWindowRect(handle, &size);
					memcpy((void*)l_param, &size, sizeof(RECT));
				}
				else if(zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_LockAspect)) {
					r32 aspect_ratio = window_details->aspect_ratio;//game_settings->native_h / (r32)game_settings->native_w;

					RECT size;
					memcpy(&size, (const void*)l_param, sizeof(RECT));

					int width = size.right - size.left;
					int height = size.bottom - size.top;

					switch (w_param)
					{
						case WMSZ_LEFT:
						case WMSZ_RIGHT: {
							size.bottom = zt_convertToi32Floor(width * (1 / aspect_ratio)) + size.top;
						} break;

						case WMSZ_TOP:
						case WMSZ_BOTTOM: {
							size.right = zt_convertToi32Floor(height * aspect_ratio) + size.left;
						} break;

						case WMSZ_TOPRIGHT:
						case WMSZ_TOPLEFT:
						case WMSZ_BOTTOMRIGHT:
						case WMSZ_BOTTOMLEFT: {
							if (width / (r32)height > aspect_ratio) {
								width = zt_convertToi32Floor(height * aspect_ratio);
							}
							else {
								height = zt_convertToi32Floor(width / aspect_ratio);
							}

							if (w_param == WMSZ_TOPLEFT || w_param == WMSZ_TOPRIGHT) {
								size.top = size.bottom - height;
							}
							else {
								size.bottom = size.top + height;
							}

							// Adjust Width
							if (w_param == WMSZ_TOPLEFT || w_param == WMSZ_BOTTOMLEFT) {
								size.left = size.right - width;
							}
							else {
								size.right = size.left + width;
							}


						} break;
					}

					memcpy((void*)l_param, &size, sizeof(RECT));
				}
			}
		} break;

		case WM_PAINT: {
			PAINTSTRUCT ps;
			BeginPaint(handle, &ps);
			EndPaint(handle, &ps);
		} break;

		case WM_SETCURSOR: {
			bool process_l_param = true;
			if (game_settings) {
				if (zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_HideCursor) && GetFocus() == handle) {
					if (zt_game->input_mouse_look || LOWORD(l_param) == HTCLIENT) {
						SetCursor(NULL);
						zt_game->input_mouse.over_window = true;
						process_l_param = false;
					}
				}
				if(zt_bitIsSet(game_settings->renderer_flags, ztRendererFlags_NoResize)) {
					process_l_param = false;
				}
			}

			if (process_l_param) {
				zt_game->input_mouse.over_window = false;

				switch(LOWORD(l_param))
				{
					case HTTOP:
					case HTBOTTOM: {
						SetCursor(LoadCursor(0, IDC_SIZENS));
					} break;

					case HTLEFT:
					case HTRIGHT: {
						SetCursor(LoadCursor(0, IDC_SIZEWE));
					} break;

					case HTTOPRIGHT:
					case HTBOTTOMLEFT: {
						SetCursor(LoadCursor(0, IDC_SIZENESW));
					} break;

					case HTTOPLEFT:
					case HTBOTTOMRIGHT: {
						SetCursor(LoadCursor(0, IDC_SIZENWSE));
					} break;

					default: {
						zt_inputMouseSetCursor(zt_game->input_mouse.cursor);
						zt_game->input_mouse.over_window = true;
					} break;
				}
			}
		} break;

		case WM_KILLFOCUS: {
			_zt_inputClearState(true);
			zt_game->app_has_focus = false;

			RAWINPUTDEVICE rid[1];
			rid[0].usUsagePage = 0x01; 
			rid[0].usUsage     = 0x02; 
			rid[0].dwFlags     = RIDEV_REMOVE;
			rid[0].hwndTarget  = 0;

			if (RegisterRawInputDevices(rid, 1, zt_sizeof(rid[0])) == FALSE) {
				zt_logCritical("Unable to deregister raw input devices");
			}
		} break;

		case WM_SETFOCUS: {
			zt_game->app_has_focus = true;

			RAWINPUTDEVICE rid[1];
			rid[0].usUsagePage = 0x01; 
			rid[0].usUsage     = 0x02; 
			rid[0].dwFlags     = 0;
			rid[0].hwndTarget  = handle;

			if (RegisterRawInputDevices(rid, 1, zt_sizeof(rid[0])) == FALSE) {
				zt_logCritical("Unable to register raw input devices");
			}

		} break;

		default: {
			result = DefWindowProc(handle, msg, w_param, l_param);
		} break;
	}

	return result;
}

// end ZT_WINDOWS
#elif defined(ZT_ANDROID)

// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================

// This is the main entry point of a native application that is using android_native_app_glue.
// It runs in its own thread, with its own event loop for receiving input events and doing other things.

void android_main(struct android_app* app)
{
	zt_android_app = app;
	zt_android_app->onAppCmd     = androidHandleCmd;
	zt_android_app->onInputEvent = androidHandleInput;

	const char *argv[1] = {"/"};
	main(1, argv);
}

#endif // ZT_ANDROID


// ================================================================================================================================================================================================
// ================================================================================================================================================================================================
// ================================================================================================================================================================================================


// Embedded stb_image.h:
#define STB_IMAGE_IMPLEMENTATION
#define STBI_FAILURE_USERMSG

// ================================================================================================================================================================================================

/* stb_image - v2.12 - public domain image loader - http://nothings.org/stb_image.h
no warranty implied; use at your own risk

Do this:
#define STB_IMAGE_IMPLEMENTATION
before you include this file in *one* C or C++ file to create the implementation.

// i.e. it should look like this:
#include ...
#include ...
#include ...
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


QUICK NOTES:
Primarily of interest to game developers and other people who can
avoid problematic images and only need the trivial interface

JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
PNG 1/2/4/8-bit-per-channel (16 bpc not supported)

TGA (not sure what subset, if a subset)
BMP non-1bpp, non-RLE
PSD (composited view only, no extra channels, 8/16 bit-per-channel)

GIF (*comp always reports as 4-channel)
HDR (radiance rgbE format)
PIC (Softimage PIC)
PNM (PPM and PGM binary only)

Animated GIF still needs a proper API, but here's one way to do it:
http://gist.github.com/urraka/685d9a6340b26b830d49

- decode from memory or through FILE (define STBI_NO_STDIO to remove code)
- decode from arbitrary I/O callbacks
- SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

Full documentation under "DOCUMENTATION" below.


Revision 2.00 release notes:

- Progressive JPEG is now supported.

- PPM and PGM binary formats are now supported, thanks to Ken Miller.

- x86 platforms now make use of SSE2 SIMD instructions for
JPEG decoding, and ARM platforms can use NEON SIMD if requested.
This work was done by Fabian "ryg" Giesen. SSE2 is used by
default, but NEON must be enabled explicitly; see docs.

With other JPEG optimizations included in this version, we see
2x speedup on a JPEG on an x86 machine, and a 1.5x speedup
on a JPEG on an ARM machine, relative to previous versions of this
library. The same results will not obtain for all JPGs and for all
x86/ARM machines. (Note that progressive JPEGs are significantly
slower to decode than regular JPEGs.) This doesn't mean that this
is the fastest JPEG decoder in the land; rather, it brings it
closer to parity with standard libraries. If you want the fastest
decode, look elsewhere. (See "Philosophy" section of docs below.)

See final bullet items below for more info on SIMD.

- Added STBI_MALLOC, STBI_REALLOC, and STBI_FREE macros for replacing
the memory allocator. Unlike other STBI libraries, these macros don't
support a context parameter, so if you need to pass a context in to
the allocator, you'll have to store it in a global or a thread-local
variable.

- Split existing STBI_NO_HDR flag into two flags, STBI_NO_HDR and
STBI_NO_LINEAR.
STBI_NO_HDR:     suppress implementation of .hdr reader format
STBI_NO_LINEAR:  suppress high-dynamic-range light-linear float API

- You can suppress implementation of any of the decoders to reduce
your code footprint by #defining one or more of the following
symbols before creating the implementation.

STBI_NO_JPEG
STBI_NO_PNG
STBI_NO_BMP
STBI_NO_PSD
STBI_NO_TGA
STBI_NO_GIF
STBI_NO_HDR
STBI_NO_PIC
STBI_NO_PNM   (.ppm and .pgm)

- You can request *only* certain decoders and suppress all other ones
(this will be more forward-compatible, as addition of new decoders
doesn't require you to disable them explicitly):

STBI_ONLY_JPEG
STBI_ONLY_PNG
STBI_ONLY_BMP
STBI_ONLY_PSD
STBI_ONLY_TGA
STBI_ONLY_GIF
STBI_ONLY_HDR
STBI_ONLY_PIC
STBI_ONLY_PNM   (.ppm and .pgm)

Note that you can define multiples of these, and you will get all
of them ("only x" and "only y" is interpreted to mean "only x&y").

- If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB

- Compilation of all SIMD code can be suppressed with
#define STBI_NO_SIMD
It should not be necessary to disable SIMD unless you have issues
compiling (e.g. using an x86 compiler which doesn't support SSE
intrinsics or that doesn't support the method used to detect
SSE2 support at run-time), and even those can be reported as
bugs so I can refine the built-in compile-time checking to be
smarter.

- The old STBI_SIMD system which allowed installing a user-defined
IDCT etc. has been removed. If you need this, don't upgrade. My
assumption is that almost nobody was doing this, and those who
were will find the built-in SIMD more satisfactory anyway.

- RGB values computed for JPEG images are slightly different from
previous versions of stb_image. (This is due to using less
integer precision in SIMD.) The C code has been adjusted so
that the same RGB values will be computed regardless of whether
SIMD support is available, so your app should always produce
consistent results. But these results are slightly different from
previous versions. (Specifically, about 3% of available YCbCr values
will compute different RGB results from pre-1.49 versions by +-1;
most of the deviating values are one smaller in the G channel.)

- If you must produce consistent results with previous versions of
stb_image, #define STBI_JPEG_OLD and you will get the same results
you used to; however, you will not get the SIMD speedups for
the YCbCr-to-RGB conversion step (although you should still see
significant JPEG speedup from the other changes).

Please note that STBI_JPEG_OLD is a temporary feature; it will be
removed in future versions of the library. It is only intended for
near-term back-compatibility use.


Latest revision history:
2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
RGB-format JPEG; remove white matting in PSD;
allocate large structures on the stack;
correct channel count for PNG & BMP
2.10  (2016-01-22) avoid warning introduced in 2.09
2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED
2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
2.07  (2015-09-13) partial animated GIF support
limited 16-bit PSD support
minor bugs, code cleanup, and compiler warnings
2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
2.03  (2015-04-12) additional corruption checking
stbi_set_flip_vertically_on_load
fix NEON support; fix mingw support
2.02  (2015-01-19) fix incorrect assert, fix warning
2.01  (2015-01-17) fix various warnings
2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
2.00  (2014-12-25) optimize JPEG, including x86 SSE2 & ARM NEON SIMD
progressive JPEG
PGM/PPM support
STBI_MALLOC,STBI_REALLOC,STBI_FREE
STBI_NO_*, STBI_ONLY_*
GIF bugfix

See end of file for full revision history.


============================    Contributors    =========================

Image formats                          Extensions, features
Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
urraka@github (animated gif)           Junggon Kim (PNM comments)
Daniel Gibson (16-bit TGA)

Optimizations & bugfixes
Fabian "ryg" Giesen
Arseny Kapoulkine

Bug & warning fixes
Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko
Christpher Lloyd        Martin Golini      Jerry Jansson      Joseph Thomson
Dave Moore              Roy Eltham         Hayaki Saito       Phil Jordan
Won Chun                Luke Graham        Johan Duparc       Nathan Reed
the Horde3D community   Thomas Ruf         Ronny Chevalier    Nick Verigakis
Janez Zemva             John Bartholomew   Michal Cichon      svdijk@github
Jonathan Blow           Ken Hamada         Tero Hanninen      Baldur Karlsson
Laurent Gomila          Cort Stratton      Sergio Gonzalez    romigrou@github
Aruelien Pocheville     Thibault Reuille   Cass Everitt       Matthew Gregan
Ryamond Barbiero        Paul Du Bois       Engin Manap        snagar@github
Michaelangel007@github  Oriol Ferrer Mesia socks-the-fox
Blazej Dariusz Roszkowski


LICENSE

This software is dual-licensed to the public domain and under the following
license: you are granted a perpetual, irrevocable license to copy, modify,
publish, and distribute this file as you see fit.

*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 16-bit-per-channel PNG
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to see if it's trivially opaque
// because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy to use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries do not emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// make more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// The output of the JPEG decoder is slightly different from versions where
// SIMD support was introduced (that is, for versions before 1.49). The
// difference is only +-1 in the 8-bit RGB channels, and only on a small
// fraction of pixels. You can force the pre-1.49 behavior by defining
// STBI_JPEG_OLD, but this will disable some of the SIMD decoding path
// and hence cost some performance.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//


#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
	STBI_default = 0, // only used for req_comp

	STBI_grey = 1,
	STBI_grey_alpha = 2,
	STBI_rgb = 3,
	STBI_rgb_alpha = 4
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif

#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif

	//////////////////////////////////////////////////////////////////////////////
	//
	// PRIMARY API - works on images of any type
	//

	//
	// load image by filename, open file, or memory buffer
	//

	typedef struct
	{
		int(*read)  (void *user, char *data, int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
		void(*skip)  (void *user, int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
		int(*eof)   (void *user);                       // returns nonzero if we are at end of file/data
	} stbi_io_callbacks;

	STBIDEF stbi_uc *stbi_load(char              const *filename, int *x, int *y, int *comp, int req_comp);
	STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc           const *buffer, int len, int *x, int *y, int *comp, int req_comp);
	STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
	STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp);
	// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_LINEAR
	STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp);
	STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
	STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
	STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp);
#endif
#endif

#ifndef STBI_NO_HDR
	STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
	STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
	STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
	STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

	// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
	STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
	STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
	STBIDEF int      stbi_is_hdr(char const *filename);
	STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


	// get a VERY brief reason for failure
	// NOT THREADSAFE
	STBIDEF const char *stbi_failure_reason(void);

	// free the loaded image -- this is just free()
	STBIDEF void     stbi_image_free(void *retval_from_stbi_load);

	// get image dimensions & components without fully decoding
	STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
	STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
	STBIDEF int      stbi_info(char const *filename, int *x, int *y, int *comp);
	STBIDEF int      stbi_info_from_file(FILE *f, int *x, int *y, int *comp);

#endif



	// for image formats that explicitly notate that they have premultiplied alpha,
	// we just return the colors as stored in the file. set this flag to force
	// unpremultiplication. results are undefined if the unpremultiply overflow.
	STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

	// indicate whether we should process iphone images back to canonical format,
	// or just pass them through "as-is"
	STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

	// flip the image vertically, so the first pixel in the output array is the bottom left
	STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

	// ZLIB client - used by PNG, available for other purposes

	STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
	STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
	STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
	STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

	STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
	STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
#ifndef STBI_ONLY_JPEG
#define STBI_NO_JPEG
#endif
#ifndef STBI_ONLY_PNG
#define STBI_NO_PNG
#endif
#ifndef STBI_ONLY_BMP
#define STBI_NO_BMP
#endif
#ifndef STBI_ONLY_PSD
#define STBI_NO_PSD
#endif
#ifndef STBI_ONLY_TGA
#define STBI_NO_TGA
#endif
#ifndef STBI_ONLY_GIF
#define STBI_NO_GIF
#endif
#ifndef STBI_ONLY_HDR
#define STBI_NO_HDR
#endif
#ifndef STBI_ONLY_PIC
#define STBI_NO_PIC
#endif
#ifndef STBI_ONLY_PNM
#define STBI_NO_PNM
#endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif


#ifndef _MSC_VER
#ifdef __cplusplus
#define stbi_inline inline
#else
#define stbi_inline
#endif
#else
#define stbi_inline __forceinline
#endif


#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32) == 4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
#define stbi_lrot(x,y)  _lrotl(x,y)
#else
#define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET)) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// NOTE: not clear do we actually need this for the 64-bit path?
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// (but compiling with -msse2 allows the compiler to use SSE2 everywhere;
// this is just broken and gcc are jerks for not fixing it properly
// http://www.virtualdub.org/blog/pivot/entry.php?id=363 )
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
	int info[4];
	__cpuid(info, 1);
	return info[3];
}
#else
static int stbi__cpuid3(void)
{
	int res;
	__asm {
		mov  eax, 1
			cpuid
			mov  res, edx
	}
	return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

static int stbi__sse2_available()
{
	int info3 = stbi__cpuid3();
	return ((info3 >> 26) & 1) != 0;
}
#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

static int stbi__sse2_available()
{
#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 408 // GCC 4.8 or later
	// GCC 4.8+ has a nice way to do this
	return __builtin_cpu_supports("sse2");
#else
	// portable way to do this, preferably without using GCC inline ASM?
	// just bail for now.
	return 0;
#endif
}
#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
	stbi__uint32 img_x, img_y;
	int img_n, img_out_n;

	stbi_io_callbacks io;
	void *io_user_data;

	int read_from_callbacks;
	int buflen;
	stbi_uc buffer_start[128];

	stbi_uc *img_buffer, *img_buffer_end;
	stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
	s->io.read = NULL;
	s->read_from_callbacks = 0;
	s->img_buffer = s->img_buffer_original = (stbi_uc *)buffer;
	s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *)buffer + len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
	s->io = *c;
	s->io_user_data = user;
	s->buflen = sizeof(s->buffer_start);
	s->read_from_callbacks = 1;
	s->img_buffer_original = s->buffer_start;
	stbi__refill_buffer(s);
	s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
	return (int)fread(data, 1, size, (FILE*)user);
}

static void stbi__stdio_skip(void *user, int n)
{
	fseek((FILE*)user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
	return feof((FILE*)user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
	stbi__stdio_read,
	stbi__stdio_skip,
	stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
	stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *)f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
	// conceptually rewind SHOULD rewind to the beginning of the stream,
	// but we just rewind to the beginning of the initial buffer, because
	// we only use it after doing 'test', which only ever looks at at most 92 bytes
	s->img_buffer = s->img_buffer_original;
	s->img_buffer_end = s->img_buffer_original_end;
}

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static stbi_uc *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static stbi_uc *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static stbi_uc *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static stbi_uc *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

// this is not threadsafe
static const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
	return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
	stbi__g_failure_reason = str;
	return 0;
}

static void *stbi__malloc(size_t size)
{
	return STBI_MALLOC(size);
}

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
#define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
#define stbi__err(x,y)  stbi__err(y)
#else
#define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
	STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
	stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

static unsigned char *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
#ifndef STBI_NO_JPEG
	if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_PNG
	if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_BMP
	if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_GIF
	if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_PSD
	if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_PIC
	if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp);
#endif
#ifndef STBI_NO_PNM
	if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp);
#endif

#ifndef STBI_NO_HDR
	if (stbi__hdr_test(s)) {
		float *hdr = stbi__hdr_load(s, x, y, comp, req_comp);
		return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
	}
#endif

#ifndef STBI_NO_TGA
	// test tga last because it's a crappy test!
	if (stbi__tga_test(s))
		return stbi__tga_load(s, x, y, comp, req_comp);
#endif

	return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static unsigned char *stbi__load_flip(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	unsigned char *result = stbi__load_main(s, x, y, comp, req_comp);

	if (stbi__vertically_flip_on_load && result != NULL) {
		int w = *x, h = *y;
		int depth = req_comp ? req_comp : *comp;
		int row, col, z;
		stbi_uc temp;

		// @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
		for (row = 0; row < (h >> 1); row++) {
			for (col = 0; col < w; col++) {
				for (z = 0; z < depth; z++) {
					temp = result[(row * w + col) * depth + z];
					result[(row * w + col) * depth + z] = result[((h - row - 1) * w + col) * depth + z];
					result[((h - row - 1) * w + col) * depth + z] = temp;
				}
			}
		}
	}

	return result;
}

#ifndef STBI_NO_HDR
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
	if (stbi__vertically_flip_on_load && result != NULL) {
		int w = *x, h = *y;
		int depth = req_comp ? req_comp : *comp;
		int row, col, z;
		float temp;

		// @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
		for (row = 0; row < (h >> 1); row++) {
			for (col = 0; col < w; col++) {
				for (z = 0; z < depth; z++) {
					temp = result[(row * w + col) * depth + z];
					result[(row * w + col) * depth + z] = result[((h - row - 1) * w + col) * depth + z];
					result[((h - row - 1) * w + col) * depth + z] = temp;
				}
			}
		}
	}
}
#endif

#ifndef STBI_NO_STDIO

static FILE *stbi__fopen(char const *filename, char const *mode)
{
	FILE *f;
#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != fopen_s(&f, filename, mode))
		f = 0;
#else
	f = fopen(filename, mode);
#endif
	return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	unsigned char *result;
	if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
	result = stbi_load_from_file(f, x, y, comp, req_comp);
	fclose(f);
	return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
	unsigned char *result;
	stbi__context s;
	stbi__start_file(&s, f);
	result = stbi__load_flip(&s, x, y, comp, req_comp);
	if (result) {
		// need to 'unget' all the characters in the IO buffer
		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);
	}
	return result;
}
#endif //!STBI_NO_STDIO

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__load_flip(&s, x, y, comp, req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__load_flip(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	unsigned char *data;
#ifndef STBI_NO_HDR
	if (stbi__hdr_test(s)) {
		float *hdr_data = stbi__hdr_load(s, x, y, comp, req_comp);
		if (hdr_data)
			stbi__float_postprocess(hdr_data, x, y, comp, req_comp);
		return hdr_data;
	}
#endif
	data = stbi__load_flip(s, x, y, comp, req_comp);
	if (data)
		return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
	return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
	float *result;
	FILE *f = stbi__fopen(filename, "rb");
	if (!f) return stbi__errpf("can't fopen", "Unable to open file");
	result = stbi_loadf_from_file(f, x, y, comp, req_comp);
	fclose(f);
	return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s, f);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
#ifndef STBI_NO_HDR
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__hdr_test(&s);
#else
	STBI_NOTUSED(buffer);
	STBI_NOTUSED(len);
	return 0;
#endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr(char const *filename)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result = 0;
	if (f) {
		result = stbi_is_hdr_from_file(f);
		fclose(f);
	}
	return result;
}

STBIDEF int      stbi_is_hdr_from_file(FILE *f)
{
#ifndef STBI_NO_HDR
	stbi__context s;
	stbi__start_file(&s, f);
	return stbi__hdr_test(&s);
#else
	STBI_NOTUSED(f);
	return 0;
#endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
#ifndef STBI_NO_HDR
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__hdr_test(&s);
#else
	STBI_NOTUSED(clbk);
	STBI_NOTUSED(user);
	return 0;
#endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma = 2.2f, stbi__l2h_scale = 1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i = 1.0f / 2.2f, stbi__h2l_scale_i = 1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
	STBI__SCAN_load = 0,
	STBI__SCAN_type,
	STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
	int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);
	if (n == 0) {
		// at end of file, treat same as if from memory, but need to handle case
		// where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
		s->read_from_callbacks = 0;
		s->img_buffer = s->buffer_start;
		s->img_buffer_end = s->buffer_start + 1;
		*s->img_buffer = 0;
	}
	else {
		s->img_buffer = s->buffer_start;
		s->img_buffer_end = s->buffer_start + n;
	}
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
	if (s->img_buffer < s->img_buffer_end)
		return *s->img_buffer++;
	if (s->read_from_callbacks) {
		stbi__refill_buffer(s);
		return *s->img_buffer++;
	}
	return 0;
}

stbi_inline static int stbi__at_eof(stbi__context *s)
{
	if (s->io.read) {
		if (!(s->io.eof)(s->io_user_data)) return 0;
		// if feof() is true, check if buffer = end
		// special case: we've only got the special 0 character at the end
		if (s->read_from_callbacks == 0) return 1;
	}

	return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
	if (n < 0) {
		s->img_buffer = s->img_buffer_end;
		return;
	}
	if (s->io.read) {
		int blen = (int)(s->img_buffer_end - s->img_buffer);
		if (blen < n) {
			s->img_buffer = s->img_buffer_end;
			(s->io.skip)(s->io_user_data, n - blen);
			return;
		}
	}
	s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
	if (s->io.read) {
		int blen = (int)(s->img_buffer_end - s->img_buffer);
		if (blen < n) {
			int res, count;

			memcpy(buffer, s->img_buffer, blen);

			count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);
			res = (count == (n - blen));
			s->img_buffer = s->img_buffer_end;
			return res;
		}
	}

	if (s->img_buffer + n <= s->img_buffer_end) {
		memcpy(buffer, s->img_buffer, n);
		s->img_buffer += n;
		return 1;
	}
	else
		return 0;
}

static int stbi__get16be(stbi__context *s)
{
	int z = stbi__get8(s);
	return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
	stbi__uint32 z = stbi__get16be(s);
	return (z << 16) + stbi__get16be(s);
}

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
	int z = stbi__get8(s);
	return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
	stbi__uint32 z = stbi__get16le(s);
	return z + (stbi__get16le(s) << 16);
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings


//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
	return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
	int i, j;
	unsigned char *good;

	if (req_comp == img_n) return data;
	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	good = (unsigned char *)stbi__malloc(req_comp * x * y);
	if (good == NULL) {
		STBI_FREE(data);
		return stbi__errpuc("outofmem", "Out of memory");
	}

	for (j = 0; j < (int)y; ++j) {
		unsigned char *src = data + j * x * img_n;
		unsigned char *dest = good + j * x * req_comp;

#define COMBO(a,b)  ((a)*8+(b))
#define CASE(a,b)   case COMBO(a,b): for (i=x-1; i >= 0; --i, src += a, dest += b)
		// convert source image with img_n components to one with req_comp components;
		// avoid switch per pixel, so use switch per scanline and massive macros
		switch (COMBO(img_n, req_comp)) {
			CASE(1, 2) dest[0] = src[0], dest[1] = 255; break;
			CASE(1, 3) dest[0] = dest[1] = dest[2] = src[0]; break;
			CASE(1, 4) dest[0] = dest[1] = dest[2] = src[0], dest[3] = 255; break;
			CASE(2, 1) dest[0] = src[0]; break;
			CASE(2, 3) dest[0] = dest[1] = dest[2] = src[0]; break;
			CASE(2, 4) dest[0] = dest[1] = dest[2] = src[0], dest[3] = src[1]; break;
			CASE(3, 4) dest[0] = src[0], dest[1] = src[1], dest[2] = src[2], dest[3] = 255; break;
			CASE(3, 1) dest[0] = stbi__compute_y(src[0], src[1], src[2]); break;
			CASE(3, 2) dest[0] = stbi__compute_y(src[0], src[1], src[2]), dest[1] = 255; break;
			CASE(4, 1) dest[0] = stbi__compute_y(src[0], src[1], src[2]); break;
			CASE(4, 2) dest[0] = stbi__compute_y(src[0], src[1], src[2]), dest[1] = src[3]; break;
			CASE(4, 3) dest[0] = src[0], dest[1] = src[1], dest[2] = src[2]; break;
		default: STBI_ASSERT(0);
		}
#undef CASE
	}

	STBI_FREE(data);
	return good;
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
	int i, k, n;
	float *output = (float *)stbi__malloc(x * y * comp * sizeof(float));
	if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
	// compute number of non-alpha components
	if (comp & 1) n = comp; else n = comp - 1;
	for (i = 0; i < x*y; ++i) {
		for (k = 0; k < n; ++k) {
			output[i*comp + k] = (float)(pow(data[i*comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
		}
		if (k < comp) output[i*comp + k] = data[i*comp + k] / 255.0f;
	}
	STBI_FREE(data);
	return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
	int i, k, n;
	stbi_uc *output = (stbi_uc *)stbi__malloc(x * y * comp);
	if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
	// compute number of non-alpha components
	if (comp & 1) n = comp; else n = comp - 1;
	for (i = 0; i < x*y; ++i) {
		for (k = 0; k < n; ++k) {
			float z = (float)pow(data[i*comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
			if (z < 0) z = 0;
			if (z > 255) z = 255;
			output[i*comp + k] = (stbi_uc)stbi__float2int(z);
		}
		if (k < comp) {
			float z = data[i*comp + k] * 255 + 0.5f;
			if (z < 0) z = 0;
			if (z > 255) z = 255;
			output[i*comp + k] = (stbi_uc)stbi__float2int(z);
		}
	}
	STBI_FREE(data);
	return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
	stbi_uc  fast[1 << FAST_BITS];
	// weirdly, repacking this into AoS is a 10% speed loss, instead of a win
	stbi__uint16 code[256];
	stbi_uc  values[256];
	stbi_uc  size[257];
	unsigned int maxcode[18];
	int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
	stbi__context *s;
	stbi__huffman huff_dc[4];
	stbi__huffman huff_ac[4];
	stbi_uc dequant[4][64];
	stbi__int16 fast_ac[4][1 << FAST_BITS];

	// sizes for components, interleaved MCUs
	int img_h_max, img_v_max;
	int img_mcu_x, img_mcu_y;
	int img_mcu_w, img_mcu_h;

	// definition of jpeg image component
	struct
	{
		int id;
		int h, v;
		int tq;
		int hd, ha;
		int dc_pred;

		int x, y, w2, h2;
		stbi_uc *data;
		void *raw_data, *raw_coeff;
		stbi_uc *linebuf;
		short   *coeff;   // progressive only
		int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
	} img_comp[4];

	stbi__uint32   code_buffer; // jpeg entropy-coded buffer
	int            code_bits;   // number of valid bits
	unsigned char  marker;      // marker seen while filling entropy buffer
	int            nomore;      // flag if we saw a marker so must stop

	int            progressive;
	int            spec_start;
	int            spec_end;
	int            succ_high;
	int            succ_low;
	int            eob_run;
	int            rgb;

	int scan_n, order[4];
	int restart_interval, todo;

	// kernels
	void(*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
	void(*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
	stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
	int i, j, k = 0, code;
	// build size list for each symbol (from JPEG spec)
	for (i = 0; i < 16; ++i)
		for (j = 0; j < count[i]; ++j)
			h->size[k++] = (stbi_uc)(i + 1);
	h->size[k] = 0;

	// compute actual symbols (from jpeg spec)
	code = 0;
	k = 0;
	for (j = 1; j <= 16; ++j) {
		// compute delta to add to code to compute symbol id
		h->delta[j] = k - code;
		if (h->size[k] == j) {
			while (h->size[k] == j)
				h->code[k++] = (stbi__uint16)(code++);
			if (code - 1 >= (1 << j)) return stbi__err("bad code lengths", "Corrupt JPEG");
		}
		// compute largest code + 1 for this size, preshifted as needed later
		h->maxcode[j] = code << (16 - j);
		code <<= 1;
	}
	h->maxcode[j] = 0xffffffff;

	// build non-spec acceleration table; 255 is flag for not-accelerated
	memset(h->fast, 255, 1 << FAST_BITS);
	for (i = 0; i < k; ++i) {
		int s = h->size[i];
		if (s <= FAST_BITS) {
			int c = h->code[i] << (FAST_BITS - s);
			int m = 1 << (FAST_BITS - s);
			for (j = 0; j < m; ++j) {
				h->fast[c + j] = (stbi_uc)i;
			}
		}
	}
	return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
	int i;
	for (i = 0; i < (1 << FAST_BITS); ++i) {
		stbi_uc fast = h->fast[i];
		fast_ac[i] = 0;
		if (fast < 255) {
			int rs = h->values[fast];
			int run = (rs >> 4) & 15;
			int magbits = rs & 15;
			int len = h->size[fast];

			if (magbits && len + magbits <= FAST_BITS) {
				// magnitude code followed by receive_extend code
				int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
				int m = 1 << (magbits - 1);
				if (k < m) k += (-1 << magbits) + 1;
				// if the result is small enough, we can fit it in fast_ac table
				if (k >= -128 && k <= 127)
					fast_ac[i] = (stbi__int16)((k << 8) + (run << 4) + (len + magbits));
			}
		}
	}
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
	do {
		int b = j->nomore ? 0 : stbi__get8(j->s);
		if (b == 0xff) {
			int c = stbi__get8(j->s);
			if (c != 0) {
				j->marker = (unsigned char)c;
				j->nomore = 1;
				return;
			}
		}
		j->code_buffer |= b << (24 - j->code_bits);
		j->code_bits += 8;
	} while (j->code_bits <= 24);
}

// (1 << n) - 1
static stbi__uint32 stbi__bmask[17] = { 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535 };

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
	unsigned int temp;
	int c, k;

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	// look at the top FAST_BITS and determine what symbol ID it is,
	// if the code is <= FAST_BITS
	c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
	k = h->fast[c];
	if (k < 255) {
		int s = h->size[k];
		if (s > j->code_bits)
			return -1;
		j->code_buffer <<= s;
		j->code_bits -= s;
		return h->values[k];
	}

	// naive test is to shift the code_buffer down so k bits are
	// valid, then test against maxcode. To speed this up, we've
	// preshifted maxcode left so that it has (16-k) 0s at the
	// end; in other words, regardless of the number of bits, it
	// wants to be compared against something shifted to have 16;
	// that way we don't need to shift inside the loop.
	temp = j->code_buffer >> 16;
	for (k = FAST_BITS + 1;; ++k)
		if (temp < h->maxcode[k])
			break;
	if (k == 17) {
		// error! code not found
		j->code_bits -= 16;
		return -1;
	}

	if (k > j->code_bits)
		return -1;

	// convert the huffman code to the symbol id
	c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
	STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

	// convert the id to a symbol
	j->code_bits -= k;
	j->code_buffer <<= k;
	return h->values[c];
}

// bias[n] = (-1<<n) + 1
static int const stbi__jbias[16] = { 0, -1, -3, -7, -15, -31, -63, -127, -255, -511, -1023, -2047, -4095, -8191, -16383, -32767 };

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
	unsigned int k;
	int sgn;
	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
	k = stbi_lrot(j->code_buffer, n);
	STBI_ASSERT(n >= 0 && n < (int)(sizeof(stbi__bmask) / sizeof(*stbi__bmask)));
	j->code_buffer = k & ~stbi__bmask[n];
	k &= stbi__bmask[n];
	j->code_bits -= n;
	return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
	unsigned int k;
	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
	k = stbi_lrot(j->code_buffer, n);
	j->code_buffer = k & ~stbi__bmask[n];
	k &= stbi__bmask[n];
	j->code_bits -= n;
	return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
	unsigned int k;
	if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
	k = j->code_buffer;
	j->code_buffer <<= 1;
	--j->code_bits;
	return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static stbi_uc stbi__jpeg_dezigzag[64 + 15] =
{
	0, 1, 8, 16, 9, 2, 3, 10,
	17, 24, 32, 25, 18, 11, 4, 5,
	12, 19, 26, 33, 40, 48, 41, 34,
	27, 20, 13, 6, 7, 14, 21, 28,
	35, 42, 49, 56, 57, 50, 43, 36,
	29, 22, 15, 23, 30, 37, 44, 51,
	58, 59, 52, 45, 38, 31, 39, 46,
	53, 60, 61, 54, 47, 55, 62, 63,
	// let corrupt input sample past end
	63, 63, 63, 63, 63, 63, 63, 63,
	63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi_uc *dequant)
{
	int diff, dc, k;
	int t;

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
	t = stbi__jpeg_huff_decode(j, hdc);
	if (t < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	// 0 all the ac values now so we can do it 32-bits at a time
	memset(data, 0, 64 * sizeof(data[0]));

	diff = t ? stbi__extend_receive(j, t) : 0;
	dc = j->img_comp[b].dc_pred + diff;
	j->img_comp[b].dc_pred = dc;
	data[0] = (short)(dc * dequant[0]);

	// decode AC components, see JPEG spec
	k = 1;
	do {
		unsigned int zig;
		int c, r, s;
		if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
		c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
		r = fac[c];
		if (r) { // fast-AC path
			k += (r >> 4) & 15; // run
			s = r & 15; // combined length
			j->code_buffer <<= s;
			j->code_bits -= s;
			// decode into unzigzag'd location
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short)((r >> 8) * dequant[zig]);
		}
		else {
			int rs = stbi__jpeg_huff_decode(j, hac);
			if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
				if (rs != 0xf0) break; // end block
				k += 16;
			}
			else {
				k += r;
				// decode into unzigzag'd location
				zig = stbi__jpeg_dezigzag[k++];
				data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);
			}
		}
	} while (k < 64);
	return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
	int diff, dc;
	int t;
	if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	if (j->succ_high == 0) {
		// first scan for DC coefficient, must be first
		memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now
		t = stbi__jpeg_huff_decode(j, hdc);
		diff = t ? stbi__extend_receive(j, t) : 0;

		dc = j->img_comp[b].dc_pred + diff;
		j->img_comp[b].dc_pred = dc;
		data[0] = (short)(dc << j->succ_low);
	}
	else {
		// refinement scan for DC coefficient
		if (stbi__jpeg_get_bit(j))
			data[0] += (short)(1 << j->succ_low);
	}
	return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
	int k;
	if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	if (j->succ_high == 0) {
		int shift = j->succ_low;

		if (j->eob_run) {
			--j->eob_run;
			return 1;
		}

		k = j->spec_start;
		do {
			unsigned int zig;
			int c, r, s;
			if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
			c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
			r = fac[c];
			if (r) { // fast-AC path
				k += (r >> 4) & 15; // run
				s = r & 15; // combined length
				j->code_buffer <<= s;
				j->code_bits -= s;
				zig = stbi__jpeg_dezigzag[k++];
				data[zig] = (short)((r >> 8) << shift);
			}
			else {
				int rs = stbi__jpeg_huff_decode(j, hac);
				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
				s = rs & 15;
				r = rs >> 4;
				if (s == 0) {
					if (r < 15) {
						j->eob_run = (1 << r);
						if (r)
							j->eob_run += stbi__jpeg_get_bits(j, r);
						--j->eob_run;
						break;
					}
					k += 16;
				}
				else {
					k += r;
					zig = stbi__jpeg_dezigzag[k++];
					data[zig] = (short)(stbi__extend_receive(j, s) << shift);
				}
			}
		} while (k <= j->spec_end);
	}
	else {
		// refinement scan for these AC coefficients

		short bit = (short)(1 << j->succ_low);

		if (j->eob_run) {
			--j->eob_run;
			for (k = j->spec_start; k <= j->spec_end; ++k) {
				short *p = &data[stbi__jpeg_dezigzag[k]];
				if (*p != 0)
					if (stbi__jpeg_get_bit(j))
						if ((*p & bit) == 0) {
							if (*p > 0)
								*p += bit;
							else
								*p -= bit;
						}
			}
		}
		else {
			k = j->spec_start;
			do {
				int r, s;
				int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
				s = rs & 15;
				r = rs >> 4;
				if (s == 0) {
					if (r < 15) {
						j->eob_run = (1 << r) - 1;
						if (r)
							j->eob_run += stbi__jpeg_get_bits(j, r);
						r = 64; // force end of block
					}
					else {
						// r=15 s=0 should write 16 0s, so we just do
						// a run of 15 0s and then write s (which is 0),
						// so we don't have to do anything special here
					}
				}
				else {
					if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
					// sign bit
					if (stbi__jpeg_get_bit(j))
						s = bit;
					else
						s = -bit;
				}

				// advance by r
				while (k <= j->spec_end) {
					short *p = &data[stbi__jpeg_dezigzag[k++]];
					if (*p != 0) {
						if (stbi__jpeg_get_bit(j))
							if ((*p & bit) == 0) {
								if (*p > 0)
									*p += bit;
								else
									*p -= bit;
							}
					}
					else {
						if (r == 0) {
							*p = (short)s;
							break;
						}
						--r;
					}
				}
			} while (k <= j->spec_end);
		}
	}
	return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
	// trick to use a single test to catch both cases
	if ((unsigned int)x > 255) {
		if (x < 0) return 0;
		if (x > 255) return 255;
	}
	return (stbi_uc)x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) << 12)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
	int i, val[64], *v = val;
	stbi_uc *o;
	short *d = data;

	// columns
	for (i = 0; i < 8; ++i, ++d, ++v) {
		// if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
		if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
			&& d[40] == 0 && d[48] == 0 && d[56] == 0) {
			//    no shortcut                 0     seconds
			//    (1|2|3|4|5|6|7)==0          0     seconds
			//    all separate               -0.047 seconds
			//    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
			int dcterm = d[0] << 2;
			v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
		}
		else {
			STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])
				// constants scaled things up by 1<<12; let's bring them back
				// down, but keep 2 extra bits of precision
				x0 += 512; x1 += 512; x2 += 512; x3 += 512;
			v[0] = (x0 + t3) >> 10;
			v[56] = (x0 - t3) >> 10;
			v[8] = (x1 + t2) >> 10;
			v[48] = (x1 - t2) >> 10;
			v[16] = (x2 + t1) >> 10;
			v[40] = (x2 - t1) >> 10;
			v[24] = (x3 + t0) >> 10;
			v[32] = (x3 - t0) >> 10;
		}
	}

	for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {
		// no fast case since the first 1D IDCT spread components out
		STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
			// constants scaled things up by 1<<12, plus we had 1<<2 from first
			// loop, plus horizontal and vertical each scale by sqrt(8) so together
			// we've got an extra 1<<3, so 1<<17 total we need to remove.
			// so we want to round that, which means adding 0.5 * 1<<17,
			// aka 65536. Also, we'll end up with -128 to 127 that we want
			// to encode as 0..255 by adding 128, so we'll add that before the shift
			x0 += 65536 + (128 << 17);
		x1 += 65536 + (128 << 17);
		x2 += 65536 + (128 << 17);
		x3 += 65536 + (128 << 17);
		// tried computing the shifts into temps, or'ing the temps to see
		// if any were out of range, but that was slower
		o[0] = stbi__clamp((x0 + t3) >> 17);
		o[7] = stbi__clamp((x0 - t3) >> 17);
		o[1] = stbi__clamp((x1 + t2) >> 17);
		o[6] = stbi__clamp((x1 - t2) >> 17);
		o[2] = stbi__clamp((x2 + t1) >> 17);
		o[5] = stbi__clamp((x2 - t1) >> 17);
		o[3] = stbi__clamp((x3 + t0) >> 17);
		o[4] = stbi__clamp((x3 - t0) >> 17);
	}
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
	// This is constructed to match our regular (generic) integer IDCT exactly.
	__m128i row0, row1, row2, row3, row4, row5, row6, row7;
	__m128i tmp;

	// dot product constant: even elems=x, odd elems=y
#define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

	// out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
	// out(1) = c1[even]*x + c1[odd]*y
#define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

	// out = in << 12  (in 16-bit, out 32-bit)
#define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

	// wide add
#define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

	// wide sub
#define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

	// butterfly a/b, add bias, then shift by "s" and pack
#define dct_bfly32o(out0, out1, a,b,bias,s) \
	      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
	      }

	// 8-bit interleave step (for transposes)
#define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

	// 16-bit interleave step (for transposes)
#define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

#define dct_pass(bias,shift) \
	      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
	      }

	__m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
	__m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));
	__m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
	__m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
	__m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));
	__m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));
	__m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));
	__m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));

	// rounding biases in column/row passes, see stbi__idct_block for explanation.
	__m128i bias_0 = _mm_set1_epi32(512);
	__m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));

	// load
	row0 = _mm_load_si128((const __m128i *) (data + 0 * 8));
	row1 = _mm_load_si128((const __m128i *) (data + 1 * 8));
	row2 = _mm_load_si128((const __m128i *) (data + 2 * 8));
	row3 = _mm_load_si128((const __m128i *) (data + 3 * 8));
	row4 = _mm_load_si128((const __m128i *) (data + 4 * 8));
	row5 = _mm_load_si128((const __m128i *) (data + 5 * 8));
	row6 = _mm_load_si128((const __m128i *) (data + 6 * 8));
	row7 = _mm_load_si128((const __m128i *) (data + 7 * 8));

	// column pass
	dct_pass(bias_0, 10);

	{
		// 16bit 8x8 transpose pass 1
		dct_interleave16(row0, row4);
		dct_interleave16(row1, row5);
		dct_interleave16(row2, row6);
		dct_interleave16(row3, row7);

		// transpose pass 2
		dct_interleave16(row0, row2);
		dct_interleave16(row1, row3);
		dct_interleave16(row4, row6);
		dct_interleave16(row5, row7);

		// transpose pass 3
		dct_interleave16(row0, row1);
		dct_interleave16(row2, row3);
		dct_interleave16(row4, row5);
		dct_interleave16(row6, row7);
	}

	// row pass
	dct_pass(bias_1, 17);

	{
		// pack
		__m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
		__m128i p1 = _mm_packus_epi16(row2, row3);
		__m128i p2 = _mm_packus_epi16(row4, row5);
		__m128i p3 = _mm_packus_epi16(row6, row7);

		// 8bit 8x8 transpose pass 1
		dct_interleave8(p0, p2); // a0e0a1e1...
		dct_interleave8(p1, p3); // c0g0c1g1...

		// transpose pass 2
		dct_interleave8(p0, p1); // a0c0e0g0...
		dct_interleave8(p2, p3); // b0d0f0h0...

		// transpose pass 3
		dct_interleave8(p0, p2); // a0b0c0d0...
		dct_interleave8(p1, p3); // a4b4c4d4...

		// store
		_mm_storel_epi64((__m128i *) out, p0); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p2); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p1); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p3); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
	}

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
	int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

	int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
	int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
	int16x4_t rot0_2 = vdup_n_s16(stbi__f2f(0.765366865f));
	int16x4_t rot1_0 = vdup_n_s16(stbi__f2f(1.175875602f));
	int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
	int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
	int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
	int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
	int16x4_t rot3_0 = vdup_n_s16(stbi__f2f(0.298631336f));
	int16x4_t rot3_1 = vdup_n_s16(stbi__f2f(2.053119869f));
	int16x4_t rot3_2 = vdup_n_s16(stbi__f2f(3.072711026f));
	int16x4_t rot3_3 = vdup_n_s16(stbi__f2f(1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

	// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

	// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

	// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
	   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
	   }

#define dct_pass(shiftop, shift) \
	   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
	   }

	// load
	row0 = vld1q_s16(data + 0 * 8);
	row1 = vld1q_s16(data + 1 * 8);
	row2 = vld1q_s16(data + 2 * 8);
	row3 = vld1q_s16(data + 3 * 8);
	row4 = vld1q_s16(data + 4 * 8);
	row5 = vld1q_s16(data + 5 * 8);
	row6 = vld1q_s16(data + 6 * 8);
	row7 = vld1q_s16(data + 7 * 8);

	// add DC bias
	row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

	// column pass
	dct_pass(vrshrn_n_s32, 10);

	// 16bit 8x8 transpose
	{
		// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
		// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

		// pass 1
		dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
		dct_trn16(row2, row3);
		dct_trn16(row4, row5);
		dct_trn16(row6, row7);

		// pass 2
		dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
		dct_trn32(row1, row3);
		dct_trn32(row4, row6);
		dct_trn32(row5, row7);

		// pass 3
		dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
		dct_trn64(row1, row5);
		dct_trn64(row2, row6);
		dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
	}

	// row pass
	// vrshrn_n_s32 only supports shifts up to 16, we need
	// 17. so do a non-rounding shift of 16 first then follow
	// up with a rounding shift by 1.
	dct_pass(vshrn_n_s32, 16);

	{
		// pack and round
		uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
		uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
		uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
		uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
		uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
		uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
		uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
		uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

		// again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

		// sadly can't use interleaved stores here since we only write
		// 8 bytes to each scan line!

		// 8x8 8-bit transpose pass 1
		dct_trn8_8(p0, p1);
		dct_trn8_8(p2, p3);
		dct_trn8_8(p4, p5);
		dct_trn8_8(p6, p7);

		// pass 2
		dct_trn8_16(p0, p2);
		dct_trn8_16(p1, p3);
		dct_trn8_16(p4, p6);
		dct_trn8_16(p5, p7);

		// pass 3
		dct_trn8_32(p0, p4);
		dct_trn8_32(p1, p5);
		dct_trn8_32(p2, p6);
		dct_trn8_32(p3, p7);

		// store
		vst1_u8(out, p0); out += out_stride;
		vst1_u8(out, p1); out += out_stride;
		vst1_u8(out, p2); out += out_stride;
		vst1_u8(out, p3); out += out_stride;
		vst1_u8(out, p4); out += out_stride;
		vst1_u8(out, p5); out += out_stride;
		vst1_u8(out, p6); out += out_stride;
		vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
	}

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
	stbi_uc x;
	if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
	x = stbi__get8(j->s);
	if (x != 0xff) return STBI__MARKER_none;
	while (x == 0xff)
		x = stbi__get8(j->s);
	return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
	j->code_bits = 0;
	j->code_buffer = 0;
	j->nomore = 0;
	j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
	j->marker = STBI__MARKER_none;
	j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
	j->eob_run = 0;
	// no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
	// since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
	stbi__jpeg_reset(z);
	if (!z->progressive) {
		if (z->scan_n == 1) {
			int i, j;
			STBI_SIMD_ALIGN(short, data[64]);
			int n = z->order[0];
			// non-interleaved data, we just need to process one block at a time,
			// in trivial scanline order
			// number of blocks to do just depends on how many actual "pixels" this
			// component has, independent of interleaved MCU blocking and such
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					int ha = z->img_comp[n].ha;
					if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*j * 8 + i * 8, z->img_comp[n].w2, data);
					// every data block is an MCU, so countdown the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						// if it's NOT a restart, then just bail, so we get corrupt data
						// rather than no data
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
		else { // interleaved
			int i, j, k, x, y;
			STBI_SIMD_ALIGN(short, data[64]);
			for (j = 0; j < z->img_mcu_y; ++j) {
				for (i = 0; i < z->img_mcu_x; ++i) {
					// scan an interleaved mcu... process scan_n components in order
					for (k = 0; k < z->scan_n; ++k) {
						int n = z->order[k];
						// scan out an mcu's worth of this component; that's just determined
						// by the basic H and V specified for the component
						for (y = 0; y < z->img_comp[n].v; ++y) {
							for (x = 0; x < z->img_comp[n].h; ++x) {
								int x2 = (i*z->img_comp[n].h + x) * 8;
								int y2 = (j*z->img_comp[n].v + y) * 8;
								int ha = z->img_comp[n].ha;
								if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
								z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*y2 + x2, z->img_comp[n].w2, data);
							}
						}
					}
					// after all interleaved components, that's an interleaved MCU,
					// so now count down the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
	}
	else {
		if (z->scan_n == 1) {
			int i, j;
			int n = z->order[0];
			// non-interleaved data, we just need to process one block at a time,
			// in trivial scanline order
			// number of blocks to do just depends on how many actual "pixels" this
			// component has, independent of interleaved MCU blocking and such
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
					if (z->spec_start == 0) {
						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
							return 0;
					}
					else {
						int ha = z->img_comp[n].ha;
						if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
							return 0;
					}
					// every data block is an MCU, so countdown the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
		else { // interleaved
			int i, j, k, x, y;
			for (j = 0; j < z->img_mcu_y; ++j) {
				for (i = 0; i < z->img_mcu_x; ++i) {
					// scan an interleaved mcu... process scan_n components in order
					for (k = 0; k < z->scan_n; ++k) {
						int n = z->order[k];
						// scan out an mcu's worth of this component; that's just determined
						// by the basic H and V specified for the component
						for (y = 0; y < z->img_comp[n].v; ++y) {
							for (x = 0; x < z->img_comp[n].h; ++x) {
								int x2 = (i*z->img_comp[n].h + x);
								int y2 = (j*z->img_comp[n].v + y);
								short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
								if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
									return 0;
							}
						}
					}
					// after all interleaved components, that's an interleaved MCU,
					// so now count down the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
	}
}

static void stbi__jpeg_dequantize(short *data, stbi_uc *dequant)
{
	int i;
	for (i = 0; i < 64; ++i)
		data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
	if (z->progressive) {
		// dequantize and idct the data
		int i, j, n;
		for (n = 0; n < z->s->img_n; ++n) {
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
					stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*j * 8 + i * 8, z->img_comp[n].w2, data);
				}
			}
		}
	}
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
	int L;
	switch (m) {
	case STBI__MARKER_none: // no marker found
		return stbi__err("expected marker", "Corrupt JPEG");

	case 0xDD: // DRI - specify restart interval
		if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");
		z->restart_interval = stbi__get16be(z->s);
		return 1;

	case 0xDB: // DQT - define quantization table
		L = stbi__get16be(z->s) - 2;
		while (L > 0) {
			int q = stbi__get8(z->s);
			int p = q >> 4;
			int t = q & 15, i;
			if (p != 0) return stbi__err("bad DQT type", "Corrupt JPEG");
			if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");
			for (i = 0; i < 64; ++i)
				z->dequant[t][stbi__jpeg_dezigzag[i]] = stbi__get8(z->s);
			L -= 65;
		}
		return L == 0;

	case 0xC4: // DHT - define huffman table
		L = stbi__get16be(z->s) - 2;
		while (L > 0) {
			stbi_uc *v;
			int sizes[16], i, n = 0;
			int q = stbi__get8(z->s);
			int tc = q >> 4;
			int th = q & 15;
			if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");
			for (i = 0; i < 16; ++i) {
				sizes[i] = stbi__get8(z->s);
				n += sizes[i];
			}
			L -= 17;
			if (tc == 0) {
				if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;
				v = z->huff_dc[th].values;
			}
			else {
				if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;
				v = z->huff_ac[th].values;
			}
			for (i = 0; i < n; ++i)
				v[i] = stbi__get8(z->s);
			if (tc != 0)
				stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
			L -= n;
		}
		return L == 0;
	}
	// check for comment block or APP blocks
	if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
		stbi__skip(z->s, stbi__get16be(z->s) - 2);
		return 1;
	}
	return 0;
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
	int i;
	int Ls = stbi__get16be(z->s);
	z->scan_n = stbi__get8(z->s);
	if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");
	if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");
	for (i = 0; i < z->scan_n; ++i) {
		int id = stbi__get8(z->s), which;
		int q = stbi__get8(z->s);
		for (which = 0; which < z->s->img_n; ++which)
			if (z->img_comp[which].id == id)
				break;
		if (which == z->s->img_n) return 0; // no match
		z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");
		z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");
		z->order[i] = which;
	}

   {
	   int aa;
	   z->spec_start = stbi__get8(z->s);
	   z->spec_end = stbi__get8(z->s); // should be 63, but might be 0
	   aa = stbi__get8(z->s);
	   z->succ_high = (aa >> 4);
	   z->succ_low = (aa & 15);
	   if (z->progressive) {
		   if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
			   return stbi__err("bad SOS", "Corrupt JPEG");
	   }
	   else {
		   if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");
		   if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");
		   z->spec_end = 63;
	   }
   }

   return 1;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
	stbi__context *s = z->s;
	int Lf, p, i, q, h_max = 1, v_max = 1, c;
	Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG
	p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline
	s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
	s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires
	c = stbi__get8(s);
	if (c != 3 && c != 1) return stbi__err("bad component count", "Corrupt JPEG");    // JFIF requires
	s->img_n = c;
	for (i = 0; i < c; ++i) {
		z->img_comp[i].data = NULL;
		z->img_comp[i].linebuf = NULL;
	}

	if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

	z->rgb = 0;
	for (i = 0; i < s->img_n; ++i) {
		static unsigned char rgb[3] = { 'R', 'G', 'B' };
		z->img_comp[i].id = stbi__get8(s);
		if (z->img_comp[i].id != i + 1)   // JFIF requires
			if (z->img_comp[i].id != i) {  // some version of jpegtran outputs non-JFIF-compliant files!
				// somethings output this (see http://fileformats.archiveteam.org/wiki/JPEG#Color_format)
				if (z->img_comp[i].id != rgb[i])
					return stbi__err("bad component ID", "Corrupt JPEG");
				++z->rgb;
			}
		q = stbi__get8(s);
		z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");
		z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");
		z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");
	}

	if (scan != STBI__SCAN_load) return 1;

	if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	for (i = 0; i < s->img_n; ++i) {
		if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
		if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
	}

	// compute interleaved mcu info
	z->img_h_max = h_max;
	z->img_v_max = v_max;
	z->img_mcu_w = h_max * 8;
	z->img_mcu_h = v_max * 8;
	z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;
	z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

	for (i = 0; i < s->img_n; ++i) {
		// number of effective pixels (e.g. for non-interleaved MCU)
		z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;
		z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;
		// to simplify generation, we'll allocate enough memory to decode
		// the bogus oversized data from using interleaved MCUs and their
		// big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
		// discard the extra data until colorspace conversion
		z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
		z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
		z->img_comp[i].raw_data = stbi__malloc(z->img_comp[i].w2 * z->img_comp[i].h2 + 15);

		if (z->img_comp[i].raw_data == NULL) {
			for (--i; i >= 0; --i) {
				STBI_FREE(z->img_comp[i].raw_data);
				z->img_comp[i].raw_data = NULL;
			}
			return stbi__err("outofmem", "Out of memory");
		}
		// align blocks for idct using mmx/sse
		z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);
		z->img_comp[i].linebuf = NULL;
		if (z->progressive) {
			z->img_comp[i].coeff_w = (z->img_comp[i].w2 + 7) >> 3;
			z->img_comp[i].coeff_h = (z->img_comp[i].h2 + 7) >> 3;
			z->img_comp[i].raw_coeff = STBI_MALLOC(z->img_comp[i].coeff_w * z->img_comp[i].coeff_h * 64 * sizeof(short) + 15);
			z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);
		}
		else {
			z->img_comp[i].coeff = 0;
			z->img_comp[i].raw_coeff = 0;
		}
	}

	return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
	int m;
	z->marker = STBI__MARKER_none; // initialize cached marker to empty
	m = stbi__get_marker(z);
	if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");
	if (scan == STBI__SCAN_type) return 1;
	m = stbi__get_marker(z);
	while (!stbi__SOF(m)) {
		if (!stbi__process_marker(z, m)) return 0;
		m = stbi__get_marker(z);
		while (m == STBI__MARKER_none) {
			// some files have extra padding after their blocks, so ok, we'll scan
			if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
			m = stbi__get_marker(z);
		}
	}
	z->progressive = stbi__SOF_progressive(m);
	if (!stbi__process_frame_header(z, scan)) return 0;
	return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
	int m;
	for (m = 0; m < 4; m++) {
		j->img_comp[m].raw_data = NULL;
		j->img_comp[m].raw_coeff = NULL;
	}
	j->restart_interval = 0;
	if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
	m = stbi__get_marker(j);
	while (!stbi__EOI(m)) {
		if (stbi__SOS(m)) {
			if (!stbi__process_scan_header(j)) return 0;
			if (!stbi__parse_entropy_coded_data(j)) return 0;
			if (j->marker == STBI__MARKER_none) {
				// handle 0s at the end of image data from IP Kamera 9060
				while (!stbi__at_eof(j->s)) {
					int x = stbi__get8(j->s);
					if (x == 255) {
						j->marker = stbi__get8(j->s);
						break;
					}
					else if (x != 0) {
						return stbi__err("junk before marker", "Corrupt JPEG");
					}
				}
				// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
			}
		}
		else {
			if (!stbi__process_marker(j, m)) return 0;
		}
		m = stbi__get_marker(j);
	}
	if (j->progressive)
		stbi__jpeg_finish(j);
	return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
	int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	STBI_NOTUSED(out);
	STBI_NOTUSED(in_far);
	STBI_NOTUSED(w);
	STBI_NOTUSED(hs);
	return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate two samples vertically for every one in input
	int i;
	STBI_NOTUSED(hs);
	for (i = 0; i < w; ++i)
		out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);
	return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate two samples horizontally for every one in input
	int i;
	stbi_uc *input = in_near;

	if (w == 1) {
		// if only one sample, can't do any interpolation
		out[0] = out[1] = input[0];
		return out;
	}

	out[0] = input[0];
	out[1] = stbi__div4(input[0] * 3 + input[1] + 2);
	for (i = 1; i < w - 1; ++i) {
		int n = 3 * input[i] + 2;
		out[i * 2 + 0] = stbi__div4(n + input[i - 1]);
		out[i * 2 + 1] = stbi__div4(n + input[i + 1]);
	}
	out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);
	out[i * 2 + 1] = input[w - 1];

	STBI_NOTUSED(in_far);
	STBI_NOTUSED(hs);

	return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate 2x2 samples for every one in input
	int i, t0, t1;
	if (w == 1) {
		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
		return out;
	}

	t1 = 3 * in_near[0] + in_far[0];
	out[0] = stbi__div4(t1 + 2);
	for (i = 1; i < w; ++i) {
		t0 = t1;
		t1 = 3 * in_near[i] + in_far[i];
		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
	}
	out[w * 2 - 1] = stbi__div4(t1 + 2);

	STBI_NOTUSED(hs);

	return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate 2x2 samples for every one in input
	int i = 0, t0, t1;

	if (w == 1) {
		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
		return out;
	}

	t1 = 3 * in_near[0] + in_far[0];
	// process groups of 8 pixels for as long as we can.
	// note we can't handle the last pixel in a row in this loop
	// because we need to handle the filter boundary conditions.
	for (; i < ((w - 1) & ~7); i += 8) {
#if defined(STBI_SSE2)
		// load and perform the vertical filtering pass
		// this uses 3*x + y = 4*x + (y - x)
		__m128i zero = _mm_setzero_si128();
		__m128i farb = _mm_loadl_epi64((__m128i *) (in_far + i));
		__m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
		__m128i farw = _mm_unpacklo_epi8(farb, zero);
		__m128i nearw = _mm_unpacklo_epi8(nearb, zero);
		__m128i diff = _mm_sub_epi16(farw, nearw);
		__m128i nears = _mm_slli_epi16(nearw, 2);
		__m128i curr = _mm_add_epi16(nears, diff); // current row

		// horizontal filter works the same based on shifted vers of current
		// row. "prev" is current row shifted right by 1 pixel; we need to
		// insert the previous pixel value (from t1).
		// "next" is current row shifted left by 1 pixel, with first pixel
		// of next block of 8 pixels added in.
		__m128i prv0 = _mm_slli_si128(curr, 2);
		__m128i nxt0 = _mm_srli_si128(curr, 2);
		__m128i prev = _mm_insert_epi16(prv0, t1, 0);
		__m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);

		// horizontal filter, polyphase implementation since it's convenient:
		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
		// note the shared term.
		__m128i bias = _mm_set1_epi16(8);
		__m128i curs = _mm_slli_epi16(curr, 2);
		__m128i prvd = _mm_sub_epi16(prev, curr);
		__m128i nxtd = _mm_sub_epi16(next, curr);
		__m128i curb = _mm_add_epi16(curs, bias);
		__m128i even = _mm_add_epi16(prvd, curb);
		__m128i odd = _mm_add_epi16(nxtd, curb);

		// interleave even and odd pixels, then undo scaling.
		__m128i int0 = _mm_unpacklo_epi16(even, odd);
		__m128i int1 = _mm_unpackhi_epi16(even, odd);
		__m128i de0 = _mm_srli_epi16(int0, 4);
		__m128i de1 = _mm_srli_epi16(int1, 4);

		// pack and write output
		__m128i outv = _mm_packus_epi16(de0, de1);
		_mm_storeu_si128((__m128i *) (out + i * 2), outv);
#elif defined(STBI_NEON)
		// load and perform the vertical filtering pass
		// this uses 3*x + y = 4*x + (y - x)
		uint8x8_t farb = vld1_u8(in_far + i);
		uint8x8_t nearb = vld1_u8(in_near + i);
		int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
		int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
		int16x8_t curr = vaddq_s16(nears, diff); // current row

		// horizontal filter works the same based on shifted vers of current
		// row. "prev" is current row shifted right by 1 pixel; we need to
		// insert the previous pixel value (from t1).
		// "next" is current row shifted left by 1 pixel, with first pixel
		// of next block of 8 pixels added in.
		int16x8_t prv0 = vextq_s16(curr, curr, 7);
		int16x8_t nxt0 = vextq_s16(curr, curr, 1);
		int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
		int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);

		// horizontal filter, polyphase implementation since it's convenient:
		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
		// note the shared term.
		int16x8_t curs = vshlq_n_s16(curr, 2);
		int16x8_t prvd = vsubq_s16(prev, curr);
		int16x8_t nxtd = vsubq_s16(next, curr);
		int16x8_t even = vaddq_s16(curs, prvd);
		int16x8_t odd = vaddq_s16(curs, nxtd);

		// undo scaling and round, then store with even/odd phases interleaved
		uint8x8x2_t o;
		o.val[0] = vqrshrun_n_s16(even, 4);
		o.val[1] = vqrshrun_n_s16(odd, 4);
		vst2_u8(out + i * 2, o);
#endif

		// "previous" value for next iter
		t1 = 3 * in_near[i + 7] + in_far[i + 7];
	}

	t0 = t1;
	t1 = 3 * in_near[i] + in_far[i];
	out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	for (++i; i < w; ++i) {
		t0 = t1;
		t1 = 3 * in_near[i] + in_far[i];
		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
	}
	out[w * 2 - 1] = stbi__div4(t1 + 2);

	STBI_NOTUSED(hs);

	return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// resample with nearest-neighbor
	int i, j;
	STBI_NOTUSED(in_far);
	for (i = 0; i < w; ++i)
		for (j = 0; j < hs; ++j)
			out[i*hs + j] = in_near[i];
	return out;
}

#ifdef STBI_JPEG_OLD
// this is the same YCbCr-to-RGB calculation that stb_image has used
// historically before the algorithm changes in 1.49
#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
	int i;
	for (i = 0; i < count; ++i) {
		int y_fixed = (y[i] << 16) + 32768; // rounding
		int r, g, b;
		int cr = pcr[i] - 128;
		int cb = pcb[i] - 128;
		r = y_fixed + cr*float2fixed(1.40200f);
		g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
		b = y_fixed + cb*float2fixed(1.77200f);
		r >>= 16;
		g >>= 16;
		b >>= 16;
		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
		out[0] = (stbi_uc)r;
		out[1] = (stbi_uc)g;
		out[2] = (stbi_uc)b;
		out[3] = 255;
		out += step;
	}
}
#else
// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
	int i;
	for (i = 0; i < count; ++i) {
		int y_fixed = (y[i] << 20) + (1 << 19); // rounding
		int r, g, b;
		int cr = pcr[i] - 128;
		int cb = pcb[i] - 128;
		r = y_fixed + cr* float2fixed(1.40200f);
		g = y_fixed + (cr*-float2fixed(0.71414f)) + ((cb*-float2fixed(0.34414f)) & 0xffff0000);
		b = y_fixed + cb* float2fixed(1.77200f);
		r >>= 20;
		g >>= 20;
		b >>= 20;
		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
		out[0] = (stbi_uc)r;
		out[1] = (stbi_uc)g;
		out[2] = (stbi_uc)b;
		out[3] = 255;
		out += step;
	}
}
#endif

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
	int i = 0;

#ifdef STBI_SSE2
	// step == 3 is pretty ugly on the final interleave, and i'm not convinced
	// it's useful in practice (you wouldn't use it for textures, for example).
	// so just accelerate step == 4 case.
	if (step == 4) {
		// this is a fairly straightforward implementation and not super-optimized.
		__m128i signflip = _mm_set1_epi8(-0x80);
		__m128i cr_const0 = _mm_set1_epi16((short)(1.40200f*4096.0f + 0.5f));
		__m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f*4096.0f + 0.5f));
		__m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f*4096.0f + 0.5f));
		__m128i cb_const1 = _mm_set1_epi16((short)(1.77200f*4096.0f + 0.5f));
		__m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);
		__m128i xw = _mm_set1_epi16(255); // alpha channel

		for (; i + 7 < count; i += 8) {
			// load
			__m128i y_bytes = _mm_loadl_epi64((__m128i *) (y + i));
			__m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr + i));
			__m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb + i));
			__m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
			__m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

			// unpack to short (and left-shift cr, cb by 8)
			__m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);
			__m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
			__m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

			// color transform
			__m128i yws = _mm_srli_epi16(yw, 4);
			__m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
			__m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
			__m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
			__m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
			__m128i rws = _mm_add_epi16(cr0, yws);
			__m128i gwt = _mm_add_epi16(cb0, yws);
			__m128i bws = _mm_add_epi16(yws, cb1);
			__m128i gws = _mm_add_epi16(gwt, cr1);

			// descale
			__m128i rw = _mm_srai_epi16(rws, 4);
			__m128i bw = _mm_srai_epi16(bws, 4);
			__m128i gw = _mm_srai_epi16(gws, 4);

			// back to byte, set up for transpose
			__m128i brb = _mm_packus_epi16(rw, bw);
			__m128i gxb = _mm_packus_epi16(gw, xw);

			// transpose to interleave channels
			__m128i t0 = _mm_unpacklo_epi8(brb, gxb);
			__m128i t1 = _mm_unpackhi_epi8(brb, gxb);
			__m128i o0 = _mm_unpacklo_epi16(t0, t1);
			__m128i o1 = _mm_unpackhi_epi16(t0, t1);

			// store
			_mm_storeu_si128((__m128i *) (out + 0), o0);
			_mm_storeu_si128((__m128i *) (out + 16), o1);
			out += 32;
		}
	}
#endif

#ifdef STBI_NEON
	// in this version, step=3 support would be easy to add. but is there demand?
	if (step == 4) {
		// this is a fairly straightforward implementation and not super-optimized.
		uint8x8_t signflip = vdup_n_u8(0x80);
		int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f*4096.0f + 0.5f));
		int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f*4096.0f + 0.5f));
		int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f*4096.0f + 0.5f));
		int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f*4096.0f + 0.5f));

		for (; i + 7 < count; i += 8) {
			// load
			uint8x8_t y_bytes = vld1_u8(y + i);
			uint8x8_t cr_bytes = vld1_u8(pcr + i);
			uint8x8_t cb_bytes = vld1_u8(pcb + i);
			int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
			int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

			// expand to s16
			int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
			int16x8_t crw = vshll_n_s8(cr_biased, 7);
			int16x8_t cbw = vshll_n_s8(cb_biased, 7);

			// color transform
			int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
			int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
			int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
			int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
			int16x8_t rws = vaddq_s16(yws, cr0);
			int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
			int16x8_t bws = vaddq_s16(yws, cb1);

			// undo scaling, round, convert to byte
			uint8x8x4_t o;
			o.val[0] = vqrshrun_n_s16(rws, 4);
			o.val[1] = vqrshrun_n_s16(gws, 4);
			o.val[2] = vqrshrun_n_s16(bws, 4);
			o.val[3] = vdup_n_u8(255);

			// store, interleaving r/g/b/a
			vst4_u8(out, o);
			out += 8 * 4;
		}
	}
#endif

	for (; i < count; ++i) {
		int y_fixed = (y[i] << 20) + (1 << 19); // rounding
		int r, g, b;
		int cr = pcr[i] - 128;
		int cb = pcb[i] - 128;
		r = y_fixed + cr* float2fixed(1.40200f);
		g = y_fixed + cr*-float2fixed(0.71414f) + ((cb*-float2fixed(0.34414f)) & 0xffff0000);
		b = y_fixed + cb* float2fixed(1.77200f);
		r >>= 20;
		g >>= 20;
		b >>= 20;
		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
		out[0] = (stbi_uc)r;
		out[1] = (stbi_uc)g;
		out[2] = (stbi_uc)b;
		out[3] = 255;
		out += step;
	}
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
	j->idct_block_kernel = stbi__idct_block;
	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
	if (stbi__sse2_available()) {
		j->idct_block_kernel = stbi__idct_simd;
#ifndef STBI_JPEG_OLD
		j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
#endif
		j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
	}
#endif

#ifdef STBI_NEON
	j->idct_block_kernel = stbi__idct_simd;
#ifndef STBI_JPEG_OLD
	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
#endif
	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
	int i;
	for (i = 0; i < j->s->img_n; ++i) {
		if (j->img_comp[i].raw_data) {
			STBI_FREE(j->img_comp[i].raw_data);
			j->img_comp[i].raw_data = NULL;
			j->img_comp[i].data = NULL;
		}
		if (j->img_comp[i].raw_coeff) {
			STBI_FREE(j->img_comp[i].raw_coeff);
			j->img_comp[i].raw_coeff = 0;
			j->img_comp[i].coeff = 0;
		}
		if (j->img_comp[i].linebuf) {
			STBI_FREE(j->img_comp[i].linebuf);
			j->img_comp[i].linebuf = NULL;
		}
	}
}

typedef struct
{
	resample_row_func resample;
	stbi_uc *line0, *line1;
	int hs, vs;   // expansion factor in each axis
	int w_lores; // horizontal pixels pre-expansion
	int ystep;   // how far through vertical expansion we are
	int ypos;    // which pre-expansion row we're on
} stbi__resample;

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
	int n, decode_n;
	z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	// validate req_comp
	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	// load a jpeg image from whichever source, but leave in YCbCr format
	if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	// determine actual number of components to generate
	n = req_comp ? req_comp : z->s->img_n;

	if (z->s->img_n == 3 && n < 3)
		decode_n = 1;
	else
		decode_n = z->s->img_n;

	// resample and color-convert
	{
		int k;
		unsigned int i, j;
		stbi_uc *output;
		stbi_uc *coutput[4];

		stbi__resample res_comp[4];

		for (k = 0; k < decode_n; ++k) {
			stbi__resample *r = &res_comp[k];

			// allocate line buffer big enough for upsampling off the edges
			// with upsample factor of 4
			z->img_comp[k].linebuf = (stbi_uc *)stbi__malloc(z->s->img_x + 3);
			if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

			r->hs = z->img_h_max / z->img_comp[k].h;
			r->vs = z->img_v_max / z->img_comp[k].v;
			r->ystep = r->vs >> 1;
			r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;
			r->ypos = 0;
			r->line0 = r->line1 = z->img_comp[k].data;

			if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
			else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
			else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
			else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
			else                               r->resample = stbi__resample_row_generic;
		}

		// can't error after this so, this is safe
		output = (stbi_uc *)stbi__malloc(n * z->s->img_x * z->s->img_y + 1);
		if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

		// now go ahead and resample
		for (j = 0; j < z->s->img_y; ++j) {
			stbi_uc *out = output + n * z->s->img_x * j;
			for (k = 0; k < decode_n; ++k) {
				stbi__resample *r = &res_comp[k];
				int y_bot = r->ystep >= (r->vs >> 1);
				coutput[k] = r->resample(z->img_comp[k].linebuf,
					y_bot ? r->line1 : r->line0,
					y_bot ? r->line0 : r->line1,
					r->w_lores, r->hs);
				if (++r->ystep >= r->vs) {
					r->ystep = 0;
					r->line0 = r->line1;
					if (++r->ypos < z->img_comp[k].y)
						r->line1 += z->img_comp[k].w2;
				}
			}
			if (n >= 3) {
				stbi_uc *y = coutput[0];
				if (z->s->img_n == 3) {
					if (z->rgb == 3) {
						for (i = 0; i < z->s->img_x; ++i) {
							out[0] = y[i];
							out[1] = coutput[1][i];
							out[2] = coutput[2][i];
							out[3] = 255;
							out += n;
						}
					}
					else {
						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
					}
				}
				else
					for (i = 0; i < z->s->img_x; ++i) {
						out[0] = out[1] = out[2] = y[i];
						out[3] = 255; // not used if n==3
						out += n;
					}
			}
			else {
				stbi_uc *y = coutput[0];
				if (n == 1)
					for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];
				else
					for (i = 0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
			}
		}
		stbi__cleanup_jpeg(z);
		*out_x = z->s->img_x;
		*out_y = z->s->img_y;
		if (comp) *comp = z->s->img_n; // report original components, not output
		return output;
	}
}

static unsigned char *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	unsigned char* result;
	stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
	j->s = s;
	stbi__setup_jpeg(j);
	result = load_jpeg_image(j, x, y, comp, req_comp);
	STBI_FREE(j);
	return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
	int r;
	stbi__jpeg j;
	j.s = s;
	stbi__setup_jpeg(&j);
	r = stbi__decode_jpeg_header(&j, STBI__SCAN_type);
	stbi__rewind(s);
	return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
	if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
		stbi__rewind(j->s);
		return 0;
	}
	if (x) *x = j->s->img_x;
	if (y) *y = j->s->img_y;
	if (comp) *comp = j->s->img_n;
	return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
	int result;
	stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));
	j->s = s;
	result = stbi__jpeg_info_raw(j, x, y, comp);
	STBI_FREE(j);
	return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
	stbi__uint16 fast[1 << STBI__ZFAST_BITS];
	stbi__uint16 firstcode[16];
	int maxcode[17];
	stbi__uint16 firstsymbol[16];
	stbi_uc  size[288];
	stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
	n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);
	n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);
	n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);
	n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);
	return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
	STBI_ASSERT(bits <= 16);
	// to bit reverse n bits, reverse 16 and shift
	// e.g. 11 bits, bit reverse and shift away 5
	return stbi__bitreverse16(v) >> (16 - bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, stbi_uc *sizelist, int num)
{
	int i, k = 0;
	int code, next_code[16], sizes[17];

	// DEFLATE spec for generating codes
	memset(sizes, 0, sizeof(sizes));
	memset(z->fast, 0, sizeof(z->fast));
	for (i = 0; i < num; ++i)
		++sizes[sizelist[i]];
	sizes[0] = 0;
	for (i = 1; i < 16; ++i)
		if (sizes[i] >(1 << i))
			return stbi__err("bad sizes", "Corrupt PNG");
	code = 0;
	for (i = 1; i < 16; ++i) {
		next_code[i] = code;
		z->firstcode[i] = (stbi__uint16)code;
		z->firstsymbol[i] = (stbi__uint16)k;
		code = (code + sizes[i]);
		if (sizes[i])
			if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");
		z->maxcode[i] = code << (16 - i); // preshift for inner loop
		code <<= 1;
		k += sizes[i];
	}
	z->maxcode[16] = 0x10000; // sentinel
	for (i = 0; i < num; ++i) {
		int s = sizelist[i];
		if (s) {
			int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
			stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);
			z->size[c] = (stbi_uc)s;
			z->value[c] = (stbi__uint16)i;
			if (s <= STBI__ZFAST_BITS) {
				int j = stbi__bit_reverse(next_code[s], s);
				while (j < (1 << STBI__ZFAST_BITS)) {
					z->fast[j] = fastv;
					j += (1 << s);
				}
			}
			++next_code[s];
		}
	}
	return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
	stbi_uc *zbuffer, *zbuffer_end;
	int num_bits;
	stbi__uint32 code_buffer;

	char *zout;
	char *zout_start;
	char *zout_end;
	int   z_expandable;

	stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
	if (z->zbuffer >= z->zbuffer_end) return 0;
	return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
	do {
		STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
		z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;
		z->num_bits += 8;
	} while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
	unsigned int k;
	if (z->num_bits < n) stbi__fill_bits(z);
	k = z->code_buffer & ((1 << n) - 1);
	z->code_buffer >>= n;
	z->num_bits -= n;
	return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
	int b, s, k;
	// not resolved by fast table, so compute it the slow way
	// use jpeg approach, which requires MSbits at top
	k = stbi__bit_reverse(a->code_buffer, 16);
	for (s = STBI__ZFAST_BITS + 1;; ++s)
		if (k < z->maxcode[s])
			break;
	if (s == 16) return -1; // invalid code!
	// code size is s, so:
	b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];
	STBI_ASSERT(z->size[b] == s);
	a->code_buffer >>= s;
	a->num_bits -= s;
	return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
	int b, s;
	if (a->num_bits < 16) stbi__fill_bits(a);
	b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
	if (b) {
		s = b >> 9;
		a->code_buffer >>= s;
		a->num_bits -= s;
		return b & 511;
	}
	return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
	char *q;
	int cur, limit, old_limit;
	z->zout = zout;
	if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");
	cur = (int)(z->zout - z->zout_start);
	limit = old_limit = (int)(z->zout_end - z->zout_start);
	while (cur + n > limit)
		limit *= 2;
	q = (char *)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
	STBI_NOTUSED(old_limit);
	if (q == NULL) return stbi__err("outofmem", "Out of memory");
	z->zout_start = q;
	z->zout = q + cur;
	z->zout_end = q + limit;
	return 1;
}

static int stbi__zlength_base[31] = {
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13,
	15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
	67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };

static int stbi__zlength_extra[31] =
{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };

static int stbi__zdist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };

static int stbi__zdist_extra[32] =
{ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
	char *zout = a->zout;
	for (;;) {
		int z = stbi__zhuffman_decode(a, &a->z_length);
		if (z < 256) {
			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes
			if (zout >= a->zout_end) {
				if (!stbi__zexpand(a, zout, 1)) return 0;
				zout = a->zout;
			}
			*zout++ = (char)z;
		}
		else {
			stbi_uc *p;
			int len, dist;
			if (z == 256) {
				a->zout = zout;
				return 1;
			}
			z -= 257;
			len = stbi__zlength_base[z];
			if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
			z = stbi__zhuffman_decode(a, &a->z_distance);
			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG");
			dist = stbi__zdist_base[z];
			if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
			if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");
			if (zout + len > a->zout_end) {
				if (!stbi__zexpand(a, zout, len)) return 0;
				zout = a->zout;
			}
			p = (stbi_uc *)(zout - dist);
			if (dist == 1) { // run of one byte; common in images.
				stbi_uc v = *p;
				if (len) { do *zout++ = v; while (--len); }
			}
			else {
				if (len) { do *zout++ = *p++; while (--len); }
			}
		}
	}
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
	static stbi_uc length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
	stbi__zhuffman z_codelength;
	stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
	stbi_uc codelength_sizes[19];
	int i, n;

	int hlit = stbi__zreceive(a, 5) + 257;
	int hdist = stbi__zreceive(a, 5) + 1;
	int hclen = stbi__zreceive(a, 4) + 4;

	memset(codelength_sizes, 0, sizeof(codelength_sizes));
	for (i = 0; i < hclen; ++i) {
		int s = stbi__zreceive(a, 3);
		codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;
	}
	if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	n = 0;
	while (n < hlit + hdist) {
		int c = stbi__zhuffman_decode(a, &z_codelength);
		if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
		if (c < 16)
			lencodes[n++] = (stbi_uc)c;
		else if (c == 16) {
			c = stbi__zreceive(a, 2) + 3;
			memset(lencodes + n, lencodes[n - 1], c);
			n += c;
		}
		else if (c == 17) {
			c = stbi__zreceive(a, 3) + 3;
			memset(lencodes + n, 0, c);
			n += c;
		}
		else {
			STBI_ASSERT(c == 18);
			c = stbi__zreceive(a, 7) + 11;
			memset(lencodes + n, 0, c);
			n += c;
		}
	}
	if (n != hlit + hdist) return stbi__err("bad codelengths", "Corrupt PNG");
	if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
	if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;
	return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
	stbi_uc header[4];
	int len, nlen, k;
	if (a->num_bits & 7)
		stbi__zreceive(a, a->num_bits & 7); // discard
	// drain the bit-packed data into header
	k = 0;
	while (a->num_bits > 0) {
		header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check
		a->code_buffer >>= 8;
		a->num_bits -= 8;
	}
	STBI_ASSERT(a->num_bits == 0);
	// now fill header the normal way
	while (k < 4)
		header[k++] = stbi__zget8(a);
	len = header[1] * 256 + header[0];
	nlen = header[3] * 256 + header[2];
	if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");
	if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");
	if (a->zout + len > a->zout_end)
		if (!stbi__zexpand(a, a->zout, len)) return 0;
	memcpy(a->zout, a->zbuffer, len);
	a->zbuffer += len;
	a->zout += len;
	return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
	int cmf = stbi__zget8(a);
	int cm = cmf & 15;
	/* int cinfo = cmf >> 4; */
	int flg = stbi__zget8(a);
	if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec
	if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png
	if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png
	// window = 1 << (8 + cinfo)... but who cares, we fully buffer output
	return 1;
}

// @TODO: should statically initialize these for optimal thread safety
static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];
static void stbi__init_zdefaults(void)
{
	int i;   // use <= to match clearly with spec
	for (i = 0; i <= 143; ++i)     stbi__zdefault_length[i] = 8;
	for (; i <= 255; ++i)     stbi__zdefault_length[i] = 9;
	for (; i <= 279; ++i)     stbi__zdefault_length[i] = 7;
	for (; i <= 287; ++i)     stbi__zdefault_length[i] = 8;

	for (i = 0; i <= 31; ++i)     stbi__zdefault_distance[i] = 5;
}

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
	int final, type;
	if (parse_header)
		if (!stbi__parse_zlib_header(a)) return 0;
	a->num_bits = 0;
	a->code_buffer = 0;
	do {
		final = stbi__zreceive(a, 1);
		type = stbi__zreceive(a, 2);
		if (type == 0) {
			if (!stbi__parse_uncompressed_block(a)) return 0;
		}
		else if (type == 3) {
			return 0;
		}
		else {
			if (type == 1) {
				// use fixed code lengths
				if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();
				if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, 288)) return 0;
				if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;
			}
			else {
				if (!stbi__compute_huffman_codes(a)) return 0;
			}
			if (!stbi__parse_huffman_block(a)) return 0;
		}
	} while (!final);
	return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
	a->zout_start = obuf;
	a->zout = obuf;
	a->zout_end = obuf + olen;
	a->z_expandable = exp;

	return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(initial_size);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
	return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(initial_size);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
	stbi__zbuf a;
	a.zbuffer = (stbi_uc *)ibuffer;
	a.zbuffer_end = (stbi_uc *)ibuffer + ilen;
	if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
		return (int)(a.zout - a.zout_start);
	else
		return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(16384);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
	stbi__zbuf a;
	a.zbuffer = (stbi_uc *)ibuffer;
	a.zbuffer_end = (stbi_uc *)ibuffer + ilen;
	if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
		return (int)(a.zout - a.zout_start);
	else
		return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
	stbi__uint32 length;
	stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
	stbi__pngchunk c;
	c.length = stbi__get32be(s);
	c.type = stbi__get32be(s);
	return c;
}

static int stbi__check_png_header(stbi__context *s)
{
	static stbi_uc png_sig[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
	int i;
	for (i = 0; i < 8; ++i)
		if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");
	return 1;
}

typedef struct
{
	stbi__context *s;
	stbi_uc *idata, *expanded, *out;
	int depth;
} stbi__png;


enum {
	STBI__F_none = 0,
	STBI__F_sub = 1,
	STBI__F_up = 2,
	STBI__F_avg = 3,
	STBI__F_paeth = 4,
	// synthetic filters used for first scanline to avoid needing a dummy row of 0s
	STBI__F_avg_first,
	STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
	STBI__F_none,
	STBI__F_sub,
	STBI__F_none,
	STBI__F_avg_first,
	STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
	int p = a + b - c;
	int pa = abs(p - a);
	int pb = abs(p - b);
	int pc = abs(p - c);
	if (pa <= pb && pa <= pc) return a;
	if (pb <= pc) return b;
	return c;
}

static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0, 0, 0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
	int bytes = (depth == 16 ? 2 : 1);
	stbi__context *s = a->s;
	stbi__uint32 i, j, stride = x*out_n*bytes;
	stbi__uint32 img_len, img_width_bytes;
	int k;
	int img_n = s->img_n; // copy it into a local for later

	int output_bytes = out_n*bytes;
	int filter_bytes = img_n*bytes;
	int width = x;

	STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);
	a->out = (stbi_uc *)stbi__malloc(x * y * output_bytes); // extra bytes to write off the end into
	if (!a->out) return stbi__err("outofmem", "Out of memory");

	img_width_bytes = (((img_n * x * depth) + 7) >> 3);
	img_len = (img_width_bytes + 1) * y;
	if (s->img_x == x && s->img_y == y) {
		if (raw_len != img_len) return stbi__err("not enough pixels", "Corrupt PNG");
	}
	else { // interlaced:
		if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");
	}

	for (j = 0; j < y; ++j) {
		stbi_uc *cur = a->out + stride*j;
		stbi_uc *prior = cur - stride;
		int filter = *raw++;

		if (filter > 4)
			return stbi__err("invalid filter", "Corrupt PNG");

		if (depth < 8) {
			STBI_ASSERT(img_width_bytes <= x);
			cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
			filter_bytes = 1;
			width = img_width_bytes;
		}

		// if first row, use special filter that doesn't sample previous row
		if (j == 0) filter = first_row_filter[filter];

		// handle first byte explicitly
		for (k = 0; k < filter_bytes; ++k) {
			switch (filter) {
			case STBI__F_none: cur[k] = raw[k]; break;
			case STBI__F_sub: cur[k] = raw[k]; break;
			case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;
			case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;
			case STBI__F_avg_first: cur[k] = raw[k]; break;
			case STBI__F_paeth_first: cur[k] = raw[k]; break;
			}
		}

		if (depth == 8) {
			if (img_n != out_n)
				cur[img_n] = 255; // first pixel
			raw += img_n;
			cur += out_n;
			prior += out_n;
		}
		else if (depth == 16) {
			if (img_n != out_n) {
				cur[filter_bytes] = 255; // first pixel top byte
				cur[filter_bytes + 1] = 255; // first pixel bottom byte
			}
			raw += filter_bytes;
			cur += output_bytes;
			prior += output_bytes;
		}
		else {
			raw += 1;
			cur += 1;
			prior += 1;
		}

		// this is a little gross, so that we don't switch per-pixel or per-component
		if (depth < 8 || img_n == out_n) {
			int nk = (width - 1)*filter_bytes;
#define CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
			switch (filter) {
				// "none" filter turns into a memcpy here; make that explicit.
			case STBI__F_none:         memcpy(cur, raw, nk); break;
				CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); break;
				CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
				CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); break;
				CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); break;
				CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); break;
				CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); break;
			}
#undef CASE
			raw += nk;
		}
		else {
			STBI_ASSERT(img_n + 1 == out_n);
#define CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
			switch (filter) {
				CASE(STBI__F_none)         cur[k] = raw[k]; break;
				CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); break;
				CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
				CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); break;
				CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); break;
				CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); break;
				CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); break;
			}
#undef CASE

			// the loop above sets the high byte of the pixels' alpha, but for
			// 16 bit png files we also need the low byte set. we'll do that here.
			if (depth == 16) {
				cur = a->out + stride*j; // start at the beginning of the row again
				for (i = 0; i < x; ++i, cur += output_bytes) {
					cur[filter_bytes + 1] = 255;
				}
			}
		}
	}

	// we make a separate pass to expand bits to pixels; for performance,
	// this could run two scanlines behind the above code, so it won't
	// intefere with filtering but will still be in the cache.
	if (depth < 8) {
		for (j = 0; j < y; ++j) {
			stbi_uc *cur = a->out + stride*j;
			stbi_uc *in = a->out + stride*j + x*out_n - img_width_bytes;
			// unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
			// png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
			stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

			// note that the final byte might overshoot and write more data than desired.
			// we can allocate enough data that this never writes out of memory, but it
			// could also overwrite the next scanline. can it overwrite non-empty data
			// on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
			// so we need to explicitly clamp the final ones

			if (depth == 4) {
				for (k = x*img_n; k >= 2; k -= 2, ++in) {
					*cur++ = scale * ((*in >> 4));
					*cur++ = scale * ((*in) & 0x0f);
				}
				if (k > 0) *cur++ = scale * ((*in >> 4));
			}
			else if (depth == 2) {
				for (k = x*img_n; k >= 4; k -= 4, ++in) {
					*cur++ = scale * ((*in >> 6));
					*cur++ = scale * ((*in >> 4) & 0x03);
					*cur++ = scale * ((*in >> 2) & 0x03);
					*cur++ = scale * ((*in) & 0x03);
				}
				if (k > 0) *cur++ = scale * ((*in >> 6));
				if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
				if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
			}
			else if (depth == 1) {
				for (k = x*img_n; k >= 8; k -= 8, ++in) {
					*cur++ = scale * ((*in >> 7));
					*cur++ = scale * ((*in >> 6) & 0x01);
					*cur++ = scale * ((*in >> 5) & 0x01);
					*cur++ = scale * ((*in >> 4) & 0x01);
					*cur++ = scale * ((*in >> 3) & 0x01);
					*cur++ = scale * ((*in >> 2) & 0x01);
					*cur++ = scale * ((*in >> 1) & 0x01);
					*cur++ = scale * ((*in) & 0x01);
				}
				if (k > 0) *cur++ = scale * ((*in >> 7));
				if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
				if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
				if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
				if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
				if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
				if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
			}
			if (img_n != out_n) {
				int q;
				// insert alpha = 255
				cur = a->out + stride*j;
				if (img_n == 1) {
					for (q = x - 1; q >= 0; --q) {
						cur[q * 2 + 1] = 255;
						cur[q * 2 + 0] = cur[q];
					}
				}
				else {
					STBI_ASSERT(img_n == 3);
					for (q = x - 1; q >= 0; --q) {
						cur[q * 4 + 3] = 255;
						cur[q * 4 + 2] = cur[q * 3 + 2];
						cur[q * 4 + 1] = cur[q * 3 + 1];
						cur[q * 4 + 0] = cur[q * 3 + 0];
					}
				}
			}
		}
	}
	else if (depth == 16) {
		// force the image data from big-endian to platform-native.
		// this is done in a separate pass due to the decoding relying
		// on the data being untouched, but could probably be done
		// per-line during decode if care is taken.
		stbi_uc *cur = a->out;
		stbi__uint16 *cur16 = (stbi__uint16*)cur;

		for (i = 0; i < x*y*out_n; ++i, cur16++, cur += 2) {
			*cur16 = (cur[0] << 8) | cur[1];
		}
	}

	return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
	stbi_uc *final;
	int p;
	if (!interlaced)
		return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	// de-interlacing
	final = (stbi_uc *)stbi__malloc(a->s->img_x * a->s->img_y * out_n);
	for (p = 0; p < 7; ++p) {
		int xorig[] = { 0, 4, 0, 2, 0, 1, 0 };
		int yorig[] = { 0, 0, 4, 0, 2, 0, 1 };
		int xspc[] = { 8, 8, 4, 4, 2, 2, 1 };
		int yspc[] = { 8, 8, 8, 4, 4, 2, 2 };
		int i, j, x, y;
		// pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
		x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];
		y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];
		if (x && y) {
			stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
			if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
				STBI_FREE(final);
				return 0;
			}
			for (j = 0; j < y; ++j) {
				for (i = 0; i < x; ++i) {
					int out_y = j*yspc[p] + yorig[p];
					int out_x = i*xspc[p] + xorig[p];
					memcpy(final + out_y*a->s->img_x*out_n + out_x*out_n,
						a->out + (j*x + i)*out_n, out_n);
				}
			}
			STBI_FREE(a->out);
			image_data += img_len;
			image_data_len -= img_len;
		}
	}
	a->out = final;

	return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi_uc *p = z->out;

	// compute color-based transparency, assuming we've
	// already got 255 as the alpha value in the output
	STBI_ASSERT(out_n == 2 || out_n == 4);

	if (out_n == 2) {
		for (i = 0; i < pixel_count; ++i) {
			p[1] = (p[0] == tc[0] ? 0 : 255);
			p += 2;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
				p[3] = 0;
			p += 4;
		}
	}
	return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi__uint16 *p = (stbi__uint16*)z->out;

	// compute color-based transparency, assuming we've
	// already got 65535 as the alpha value in the output
	STBI_ASSERT(out_n == 2 || out_n == 4);

	if (out_n == 2) {
		for (i = 0; i < pixel_count; ++i) {
			p[1] = (p[0] == tc[0] ? 0 : 65535);
			p += 2;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
				p[3] = 0;
			p += 4;
		}
	}
	return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
	stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
	stbi_uc *p, *temp_out, *orig = a->out;

	p = (stbi_uc *)stbi__malloc(pixel_count * pal_img_n);
	if (p == NULL) return stbi__err("outofmem", "Out of memory");

	// between here and free(out) below, exitting would leak
	temp_out = p;

	if (pal_img_n == 3) {
		for (i = 0; i < pixel_count; ++i) {
			int n = orig[i] * 4;
			p[0] = palette[n];
			p[1] = palette[n + 1];
			p[2] = palette[n + 2];
			p += 3;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			int n = orig[i] * 4;
			p[0] = palette[n];
			p[1] = palette[n + 1];
			p[2] = palette[n + 2];
			p[3] = palette[n + 3];
			p += 4;
		}
	}
	STBI_FREE(a->out);
	a->out = temp_out;

	STBI_NOTUSED(len);

	return 1;
}

static int stbi__reduce_png(stbi__png *p)
{
	int i;
	int img_len = p->s->img_x * p->s->img_y * p->s->img_out_n;
	stbi_uc *reduced;
	stbi__uint16 *orig = (stbi__uint16*)p->out;

	if (p->depth != 16) return 1; // don't need to do anything if not 16-bit data

	reduced = (stbi_uc *)stbi__malloc(img_len);
	if (p == NULL) return stbi__err("outofmem", "Out of memory");

	for (i = 0; i < img_len; ++i) reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is a decent approx of 16->8 bit scaling

	p->out = reduced;
	STBI_FREE(orig);

	return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
	stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi_uc *p = z->out;

	if (s->img_out_n == 3) {  // convert bgr to rgb
		for (i = 0; i < pixel_count; ++i) {
			stbi_uc t = p[0];
			p[0] = p[2];
			p[2] = t;
			p += 3;
		}
	}
	else {
		STBI_ASSERT(s->img_out_n == 4);
		if (stbi__unpremultiply_on_load) {
			// convert bgr to rgb and unpremultiply
			for (i = 0; i < pixel_count; ++i) {
				stbi_uc a = p[3];
				stbi_uc t = p[0];
				if (a) {
					p[0] = p[2] * 255 / a;
					p[1] = p[1] * 255 / a;
					p[2] = t * 255 / a;
				}
				else {
					p[0] = p[2];
					p[2] = t;
				}
				p += 4;
			}
		}
		else {
			// convert bgr to rgb
			for (i = 0; i < pixel_count; ++i) {
				stbi_uc t = p[0];
				p[0] = p[2];
				p[2] = t;
				p += 4;
			}
		}
	}
}

#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
	stbi_uc palette[1024], pal_img_n = 0;
	stbi_uc has_trans = 0, tc[3];
	stbi__uint16 tc16[3];
	stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;
	int first = 1, k, interlace = 0, color = 0, is_iphone = 0;
	stbi__context *s = z->s;

	z->expanded = NULL;
	z->idata = NULL;
	z->out = NULL;

	if (!stbi__check_png_header(s)) return 0;

	if (scan == STBI__SCAN_type) return 1;

	for (;;) {
		stbi__pngchunk c = stbi__get_chunk_header(s);
		switch (c.type) {
		case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
			is_iphone = 1;
			stbi__skip(s, c.length);
			break;
		case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
			int comp, filter;
			if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");
			first = 0;
			if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");
			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");
			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");
			z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only", "PNG not supported: 1/2/4/8/16-bit only");
			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");
			if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype", "Corrupt PNG");
			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");
			comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");
			filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");
			interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method", "Corrupt PNG");
			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");
			if (!pal_img_n) {
				s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
				if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
				if (scan == STBI__SCAN_header) return 1;
			}
			else {
				// if paletted, then pal_n is our final components, and
				// img_n is # components to decompress/filter.
				s->img_n = 1;
				if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");
				// if SCAN_header, have to scan to see if we have a tRNS
			}
			break;
		}

		case STBI__PNG_TYPE('P', 'L', 'T', 'E'):  {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");
			pal_len = c.length / 3;
			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");
			for (i = 0; i < pal_len; ++i) {
				palette[i * 4 + 0] = stbi__get8(s);
				palette[i * 4 + 1] = stbi__get8(s);
				palette[i * 4 + 2] = stbi__get8(s);
				palette[i * 4 + 3] = 255;
			}
			break;
		}

		case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");
			if (pal_img_n) {
				if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
				if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");
				if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");
				pal_img_n = 4;
				for (i = 0; i < c.length; ++i)
					palette[i * 4 + 3] = stbi__get8(s);
			}
			else {
				if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");
				if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");
				has_trans = 1;
				if (z->depth == 16) {
					for (k = 0; k < s->img_n; ++k) tc16[k] = stbi__get16be(s); // copy the values as-is
				}
				else {
					for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
				}
			}
			break;
		}

		case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");
			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
			if ((int)(ioff + c.length) < (int)ioff) return 0;
			if (ioff + c.length > idata_limit) {
				stbi__uint32 idata_limit_old = idata_limit;
				stbi_uc *p;
				if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
				while (ioff + c.length > idata_limit)
					idata_limit *= 2;
				STBI_NOTUSED(idata_limit_old);
				p = (stbi_uc *)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
				z->idata = p;
			}
			if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");
			ioff += c.length;
			break;
		}

		case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
			stbi__uint32 raw_len, bpl;
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (scan != STBI__SCAN_load) return 1;
			if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");
			// initial guess for decoded data size to avoid unnecessary reallocs
			bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
			z->expanded = (stbi_uc *)stbi_zlib_decode_malloc_guesssize_headerflag((char *)z->idata, ioff, raw_len, (int *)&raw_len, !is_iphone);
			if (z->expanded == NULL) return 0; // zlib should set error
			STBI_FREE(z->idata); z->idata = NULL;
			if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)
				s->img_out_n = s->img_n + 1;
			else
				s->img_out_n = s->img_n;
			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
			if (has_trans) {
				if (z->depth == 16) {
					if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
				}
				else {
					if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
				}
			}
			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
				stbi__de_iphone(z);
			if (pal_img_n) {
				// pal_img_n == 3 or 4
				s->img_n = pal_img_n; // record the actual colors we had
				s->img_out_n = pal_img_n;
				if (req_comp >= 3) s->img_out_n = req_comp;
				if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
					return 0;
			}
			STBI_FREE(z->expanded); z->expanded = NULL;
			return 1;
		}

		default:
			// if critical, fail
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if ((c.type & (1 << 29)) == 0) {
#ifndef STBI_NO_FAILURE_STRINGS
				// not threadsafe
				static char invalid_chunk[] = "XXXX PNG chunk not known";
				invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
				invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
				invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);
				invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);
#endif
				return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
			}
			stbi__skip(s, c.length);
			break;
		}
		// end of PNG chunk, read and skip CRC
		stbi__get32be(s);
	}
}

static unsigned char *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp)
{
	unsigned char *result = NULL;
	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
	if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
		if (p->depth == 16) {
			if (!stbi__reduce_png(p)) {
				return result;
			}
		}
		result = p->out;
		p->out = NULL;
		if (req_comp && req_comp != p->s->img_out_n) {
			result = stbi__convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
			p->s->img_out_n = req_comp;
			if (result == NULL) return result;
		}
		*x = p->s->img_x;
		*y = p->s->img_y;
		if (n) *n = p->s->img_n;
	}
	STBI_FREE(p->out);      p->out = NULL;
	STBI_FREE(p->expanded); p->expanded = NULL;
	STBI_FREE(p->idata);    p->idata = NULL;

	return result;
}

static unsigned char *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi__png p;
	p.s = s;
	return stbi__do_png(&p, x, y, comp, req_comp);
}

static int stbi__png_test(stbi__context *s)
{
	int r;
	r = stbi__check_png_header(s);
	stbi__rewind(s);
	return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
	if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
		stbi__rewind(p->s);
		return 0;
	}
	if (x) *x = p->s->img_x;
	if (y) *y = p->s->img_y;
	if (comp) *comp = p->s->img_n;
	return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
	stbi__png p;
	p.s = s;
	return stbi__png_info_raw(&p, x, y, comp);
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
	int r;
	int sz;
	if (stbi__get8(s) != 'B') return 0;
	if (stbi__get8(s) != 'M') return 0;
	stbi__get32le(s); // discard filesize
	stbi__get16le(s); // discard reserved
	stbi__get16le(s); // discard reserved
	stbi__get32le(s); // discard data offset
	sz = stbi__get32le(s);
	r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
	return r;
}

static int stbi__bmp_test(stbi__context *s)
{
	int r = stbi__bmp_test_raw(s);
	stbi__rewind(s);
	return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
	int n = 0;
	if (z == 0) return -1;
	if (z >= 0x10000) n += 16, z >>= 16;
	if (z >= 0x00100) n += 8, z >>= 8;
	if (z >= 0x00010) n += 4, z >>= 4;
	if (z >= 0x00004) n += 2, z >>= 2;
	if (z >= 0x00002) n += 1, z >>= 1;
	return n;
}

static int stbi__bitcount(unsigned int a)
{
	a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2
	a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4
	a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
	a = (a + (a >> 8)); // max 16 per 8 bits
	a = (a + (a >> 16)); // max 32 per 8 bits
	return a & 0xff;
}

static int stbi__shiftsigned(int v, int shift, int bits)
{
	int result;
	int z = 0;

	if (shift < 0) v <<= -shift;
	else v >>= shift;
	result = v;

	z = bits;
	while (z < 8) {
		result += v >> z;
		z += bits;
	}
	return result;
}

typedef struct
{
	int bpp, offset, hsz;
	unsigned int mr, mg, mb, ma, all_a;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
	int hsz;
	if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
	stbi__get32le(s); // discard filesize
	stbi__get16le(s); // discard reserved
	stbi__get16le(s); // discard reserved
	info->offset = stbi__get32le(s);
	info->hsz = hsz = stbi__get32le(s);
	info->mr = info->mg = info->mb = info->ma = 0;

	if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
	if (hsz == 12) {
		s->img_x = stbi__get16le(s);
		s->img_y = stbi__get16le(s);
	}
	else {
		s->img_x = stbi__get32le(s);
		s->img_y = stbi__get32le(s);
	}
	if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
	info->bpp = stbi__get16le(s);
	if (info->bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");
	if (hsz != 12) {
		int compress = stbi__get32le(s);
		if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
		stbi__get32le(s); // discard sizeof
		stbi__get32le(s); // discard hres
		stbi__get32le(s); // discard vres
		stbi__get32le(s); // discard colorsused
		stbi__get32le(s); // discard max important
		if (hsz == 40 || hsz == 56) {
			if (hsz == 56) {
				stbi__get32le(s);
				stbi__get32le(s);
				stbi__get32le(s);
				stbi__get32le(s);
			}
			if (info->bpp == 16 || info->bpp == 32) {
				if (compress == 0) {
					if (info->bpp == 32) {
						info->mr = 0xffu << 16;
						info->mg = 0xffu << 8;
						info->mb = 0xffu << 0;
						info->ma = 0xffu << 24;
						info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
					}
					else {
						info->mr = 31u << 10;
						info->mg = 31u << 5;
						info->mb = 31u << 0;
					}
				}
				else if (compress == 3) {
					info->mr = stbi__get32le(s);
					info->mg = stbi__get32le(s);
					info->mb = stbi__get32le(s);
					// not documented, but generated by photoshop and handled by mspaint
					if (info->mr == info->mg && info->mg == info->mb) {
						// ?!?!?
						return stbi__errpuc("bad BMP", "bad BMP");
					}
				}
				else
					return stbi__errpuc("bad BMP", "bad BMP");
			}
		}
		else {
			int i;
			if (hsz != 108 && hsz != 124)
				return stbi__errpuc("bad BMP", "bad BMP");
			info->mr = stbi__get32le(s);
			info->mg = stbi__get32le(s);
			info->mb = stbi__get32le(s);
			info->ma = stbi__get32le(s);
			stbi__get32le(s); // discard color space
			for (i = 0; i < 12; ++i)
				stbi__get32le(s); // discard color space parameters
			if (hsz == 124) {
				stbi__get32le(s); // discard rendering intent
				stbi__get32le(s); // discard offset of profile data
				stbi__get32le(s); // discard size of profile data
				stbi__get32le(s); // discard reserved
			}
		}
	}
	return (void *)1;
}


static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *out;
	unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;
	stbi_uc pal[256][4];
	int psize = 0, i, j, width;
	int flip_vertically, pad, target;
	stbi__bmp_data info;

	info.all_a = 255;
	if (stbi__bmp_parse_header(s, &info) == NULL)
		return NULL; // error code already set

	flip_vertically = ((int)s->img_y) > 0;
	s->img_y = abs((int)s->img_y);

	mr = info.mr;
	mg = info.mg;
	mb = info.mb;
	ma = info.ma;
	all_a = info.all_a;

	if (info.hsz == 12) {
		if (info.bpp < 24)
			psize = (info.offset - 14 - 24) / 3;
	}
	else {
		if (info.bpp < 16)
			psize = (info.offset - 14 - info.hsz) >> 2;
	}

	s->img_n = ma ? 4 : 3;
	if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
		target = req_comp;
	else
		target = s->img_n; // if they want monochrome, we'll post-convert

	out = (stbi_uc *)stbi__malloc(target * s->img_x * s->img_y);
	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	if (info.bpp < 16) {
		int z = 0;
		if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
		for (i = 0; i < psize; ++i) {
			pal[i][2] = stbi__get8(s);
			pal[i][1] = stbi__get8(s);
			pal[i][0] = stbi__get8(s);
			if (info.hsz != 12) stbi__get8(s);
			pal[i][3] = 255;
		}
		stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
		if (info.bpp == 4) width = (s->img_x + 1) >> 1;
		else if (info.bpp == 8) width = s->img_x;
		else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
		pad = (-width) & 3;
		for (j = 0; j < (int)s->img_y; ++j) {
			for (i = 0; i < (int)s->img_x; i += 2) {
				int v = stbi__get8(s), v2 = 0;
				if (info.bpp == 4) {
					v2 = v & 15;
					v >>= 4;
				}
				out[z++] = pal[v][0];
				out[z++] = pal[v][1];
				out[z++] = pal[v][2];
				if (target == 4) out[z++] = 255;
				if (i + 1 == (int)s->img_x) break;
				v = (info.bpp == 8) ? stbi__get8(s) : v2;
				out[z++] = pal[v][0];
				out[z++] = pal[v][1];
				out[z++] = pal[v][2];
				if (target == 4) out[z++] = 255;
			}
			stbi__skip(s, pad);
		}
	}
	else {
		int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;
		int z = 0;
		int easy = 0;
		stbi__skip(s, info.offset - 14 - info.hsz);
		if (info.bpp == 24) width = 3 * s->img_x;
		else if (info.bpp == 16) width = 2 * s->img_x;
		else /* bpp = 32 and pad = 0 */ width = 0;
		pad = (-width) & 3;
		if (info.bpp == 24) {
			easy = 1;
		}
		else if (info.bpp == 32) {
			if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
				easy = 2;
		}
		if (!easy) {
			if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
			// right shift amt to put high bit in position #7
			rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);
			gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);
			bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);
			ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);
		}
		for (j = 0; j < (int)s->img_y; ++j) {
			if (easy) {
				for (i = 0; i < (int)s->img_x; ++i) {
					unsigned char a;
					out[z + 2] = stbi__get8(s);
					out[z + 1] = stbi__get8(s);
					out[z + 0] = stbi__get8(s);
					z += 3;
					a = (easy == 2 ? stbi__get8(s) : 255);
					all_a |= a;
					if (target == 4) out[z++] = a;
				}
			}
			else {
				int bpp = info.bpp;
				for (i = 0; i < (int)s->img_x; ++i) {
					stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));
					int a;
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
					a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
					all_a |= a;
					if (target == 4) out[z++] = STBI__BYTECAST(a);
				}
			}
			stbi__skip(s, pad);
		}
	}

	// if alpha channel is all 0s, replace with all 255s
	if (target == 4 && all_a == 0)
		for (i = 4 * s->img_x*s->img_y - 1; i >= 0; i -= 4)
			out[i] = 255;

	if (flip_vertically) {
		stbi_uc t;
		for (j = 0; j < (int)s->img_y >> 1; ++j) {
			stbi_uc *p1 = out + j     *s->img_x*target;
			stbi_uc *p2 = out + (s->img_y - 1 - j)*s->img_x*target;
			for (i = 0; i < (int)s->img_x*target; ++i) {
				t = p1[i], p1[i] = p2[i], p2[i] = t;
			}
		}
	}

	if (req_comp && req_comp != target) {
		out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}

	*x = s->img_x;
	*y = s->img_y;
	if (comp) *comp = s->img_n;
	return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
	// only RGB or RGBA (incl. 16bit) or grey allowed
	if (is_rgb16) *is_rgb16 = 0;
	switch (bits_per_pixel) {
	case 8:  return STBI_grey;
	case 16: if (is_grey) return STBI_grey_alpha;
		// else: fall-through
	case 15: if (is_rgb16) *is_rgb16 = 1;
		return STBI_rgb;
	case 24: // fall-through
	case 32: return bits_per_pixel / 8;
	default: return 0;
	}
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
	int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
	int sz, tga_colormap_type;
	stbi__get8(s);                   // discard Offset
	tga_colormap_type = stbi__get8(s); // colormap type
	if (tga_colormap_type > 1) {
		stbi__rewind(s);
		return 0;      // only RGB or indexed allowed
	}
	tga_image_type = stbi__get8(s); // image type
	if (tga_colormap_type == 1) { // colormapped (paletted) image
		if (tga_image_type != 1 && tga_image_type != 9) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
		sz = stbi__get8(s);    //   check bits per palette color entry
		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s, 4);       // skip image x and y origin
		tga_colormap_bpp = sz;
	}
	else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
		if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {
			stbi__rewind(s);
			return 0; // only RGB or grey allowed, +/- RLE
		}
		stbi__skip(s, 9); // skip colormap specification and image x/y origin
		tga_colormap_bpp = 0;
	}
	tga_w = stbi__get16le(s);
	if (tga_w < 1) {
		stbi__rewind(s);
		return 0;   // test width
	}
	tga_h = stbi__get16le(s);
	if (tga_h < 1) {
		stbi__rewind(s);
		return 0;   // test height
	}
	tga_bits_per_pixel = stbi__get8(s); // bits per pixel
	stbi__get8(s); // ignore alpha bits
	if (tga_colormap_bpp != 0) {
		if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
			// when using a colormap, tga_bits_per_pixel is the size of the indexes
			// I don't think anything but 8 or 16bit indexes makes sense
			stbi__rewind(s);
			return 0;
		}
		tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
	}
	else {
		tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
	}
	if (!tga_comp) {
		stbi__rewind(s);
		return 0;
	}
	if (x) *x = tga_w;
	if (y) *y = tga_h;
	if (comp) *comp = tga_comp;
	return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
	int res = 0;
	int sz, tga_color_type;
	stbi__get8(s);      //   discard Offset
	tga_color_type = stbi__get8(s);   //   color type
	if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed
	sz = stbi__get8(s);   //   image type
	if (tga_color_type == 1) { // colormapped (paletted) image
		if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
		sz = stbi__get8(s);    //   check bits per palette color entry
		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;
		stbi__skip(s, 4);       // skip image x and y origin
	}
	else { // "normal" image w/o colormap
		if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE
		stbi__skip(s, 9); // skip colormap specification and image x/y origin
	}
	if (stbi__get16le(s) < 1) goto errorEnd;      //   test width
	if (stbi__get16le(s) < 1) goto errorEnd;      //   test height
	sz = stbi__get8(s);   //   bits per pixel
	if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index
	if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

	res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
	stbi__rewind(s);
	return res;
}

// read 16bit value and convert to 24bit RGB
void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
	stbi__uint16 px = stbi__get16le(s);
	stbi__uint16 fiveBitMask = 31;
	// we have 3 channels with 5bits each
	int r = (px >> 10) & fiveBitMask;
	int g = (px >> 5) & fiveBitMask;
	int b = px & fiveBitMask;
	// Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
	out[0] = (r * 255) / 31;
	out[1] = (g * 255) / 31;
	out[2] = (b * 255) / 31;

	// some people claim that the most significant bit might be used for alpha
	// (possibly if an alpha-bit is set in the "image descriptor byte")
	// but that only made 16bit test images completely translucent..
	// so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	//   read in the TGA header stuff
	int tga_offset = stbi__get8(s);
	int tga_indexed = stbi__get8(s);
	int tga_image_type = stbi__get8(s);
	int tga_is_RLE = 0;
	int tga_palette_start = stbi__get16le(s);
	int tga_palette_len = stbi__get16le(s);
	int tga_palette_bits = stbi__get8(s);
	int tga_x_origin = stbi__get16le(s);
	int tga_y_origin = stbi__get16le(s);
	int tga_width = stbi__get16le(s);
	int tga_height = stbi__get16le(s);
	int tga_bits_per_pixel = stbi__get8(s);
	int tga_comp, tga_rgb16 = 0;
	int tga_inverted = stbi__get8(s);
	// int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
	//   image data
	unsigned char *tga_data;
	unsigned char *tga_palette = NULL;
	int i, j;
	unsigned char raw_data[4];
	int RLE_count = 0;
	int RLE_repeating = 0;
	int read_next_pixel = 1;

	//   do a tiny bit of precessing
	if (tga_image_type >= 8)
	{
		tga_image_type -= 8;
		tga_is_RLE = 1;
	}
	tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	//   If I'm paletted, then I'll use the number of bits from the palette
	if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
	else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

	if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
		return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

	//   tga info
	*x = tga_width;
	*y = tga_height;
	if (comp) *comp = tga_comp;

	tga_data = (unsigned char*)stbi__malloc((size_t)tga_width * tga_height * tga_comp);
	if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	// skip to the data's starting position (offset usually = 0)
	stbi__skip(s, tga_offset);

	if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {
		for (i = 0; i < tga_height; ++i) {
			int row = tga_inverted ? tga_height - i - 1 : i;
			stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
			stbi__getn(s, tga_row, tga_width * tga_comp);
		}
	}
	else  {
		//   do I need to load a palette?
		if (tga_indexed)
		{
			//   any data to skip? (offset usually = 0)
			stbi__skip(s, tga_palette_start);
			//   load the palette
			tga_palette = (unsigned char*)stbi__malloc(tga_palette_len * tga_comp);
			if (!tga_palette) {
				STBI_FREE(tga_data);
				return stbi__errpuc("outofmem", "Out of memory");
			}
			if (tga_rgb16) {
				stbi_uc *pal_entry = tga_palette;
				STBI_ASSERT(tga_comp == STBI_rgb);
				for (i = 0; i < tga_palette_len; ++i) {
					stbi__tga_read_rgb16(s, pal_entry);
					pal_entry += tga_comp;
				}
			}
			else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
				STBI_FREE(tga_data);
				STBI_FREE(tga_palette);
				return stbi__errpuc("bad palette", "Corrupt TGA");
			}
		}
		//   load the data
		for (i = 0; i < tga_width * tga_height; ++i)
		{
			//   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
			if (tga_is_RLE)
			{
				if (RLE_count == 0)
				{
					//   yep, get the next byte as a RLE command
					int RLE_cmd = stbi__get8(s);
					RLE_count = 1 + (RLE_cmd & 127);
					RLE_repeating = RLE_cmd >> 7;
					read_next_pixel = 1;
				}
				else if (!RLE_repeating)
				{
					read_next_pixel = 1;
				}
			}
			else
			{
				read_next_pixel = 1;
			}
			//   OK, if I need to read a pixel, do it now
			if (read_next_pixel)
			{
				//   load however much data we did have
				if (tga_indexed)
				{
					// read in index, then perform the lookup
					int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
					if (pal_idx >= tga_palette_len) {
						// invalid index
						pal_idx = 0;
					}
					pal_idx *= tga_comp;
					for (j = 0; j < tga_comp; ++j) {
						raw_data[j] = tga_palette[pal_idx + j];
					}
				}
				else if (tga_rgb16) {
					STBI_ASSERT(tga_comp == STBI_rgb);
					stbi__tga_read_rgb16(s, raw_data);
				}
				else {
					//   read in the data raw
					for (j = 0; j < tga_comp; ++j) {
						raw_data[j] = stbi__get8(s);
					}
				}
				//   clear the reading flag for the next pixel
				read_next_pixel = 0;
			} // end of reading a pixel

			// copy data
			for (j = 0; j < tga_comp; ++j)
				tga_data[i*tga_comp + j] = raw_data[j];

			//   in case we're in RLE mode, keep counting down
			--RLE_count;
		}
		//   do I need to invert the image?
		if (tga_inverted)
		{
			for (j = 0; j * 2 < tga_height; ++j)
			{
				int index1 = j * tga_width * tga_comp;
				int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
				for (i = tga_width * tga_comp; i > 0; --i)
				{
					unsigned char temp = tga_data[index1];
					tga_data[index1] = tga_data[index2];
					tga_data[index2] = temp;
					++index1;
					++index2;
				}
			}
		}
		//   clear my palette, if I had one
		if (tga_palette != NULL)
		{
			STBI_FREE(tga_palette);
		}
	}

	// swap RGB - if the source data was RGB16, it already is in the right order
	if (tga_comp >= 3 && !tga_rgb16)
	{
		unsigned char* tga_pixel = tga_data;
		for (i = 0; i < tga_width * tga_height; ++i)
		{
			unsigned char temp = tga_pixel[0];
			tga_pixel[0] = tga_pixel[2];
			tga_pixel[2] = temp;
			tga_pixel += tga_comp;
		}
	}

	// convert to target component count
	if (req_comp && req_comp != tga_comp)
		tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	//   the things I do to get rid of an error message, and yet keep
	//   Microsoft's C compilers happy... [8^(
	tga_palette_start = tga_palette_len = tga_palette_bits =
		tga_x_origin = tga_y_origin = 0;
	//   OK, done
	return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
	int r = (stbi__get32be(s) == 0x38425053);
	stbi__rewind(s);
	return r;
}

static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	int   pixelCount;
	int channelCount, compression;
	int channel, i, count, len;
	int bitdepth;
	int w, h;
	stbi_uc *out;

	// Check identifier
	if (stbi__get32be(s) != 0x38425053)   // "8BPS"
		return stbi__errpuc("not PSD", "Corrupt PSD image");

	// Check file type version.
	if (stbi__get16be(s) != 1)
		return stbi__errpuc("wrong version", "Unsupported version of PSD image");

	// Skip 6 reserved bytes.
	stbi__skip(s, 6);

	// Read the number of channels (R, G, B, A, etc).
	channelCount = stbi__get16be(s);
	if (channelCount < 0 || channelCount > 16)
		return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

	// Read the rows and columns of the image.
	h = stbi__get32be(s);
	w = stbi__get32be(s);

	// Make sure the depth is 8 bits.
	bitdepth = stbi__get16be(s);
	if (bitdepth != 8 && bitdepth != 16)
		return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

	// Make sure the color mode is RGB.
	// Valid options are:
	//   0: Bitmap
	//   1: Grayscale
	//   2: Indexed color
	//   3: RGB color
	//   4: CMYK color
	//   7: Multichannel
	//   8: Duotone
	//   9: Lab color
	if (stbi__get16be(s) != 3)
		return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

	// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
	stbi__skip(s, stbi__get32be(s));

	// Skip the image resources.  (resolution, pen tool paths, etc)
	stbi__skip(s, stbi__get32be(s));

	// Skip the reserved data.
	stbi__skip(s, stbi__get32be(s));

	// Find out if the data is compressed.
	// Known values:
	//   0: no compression
	//   1: RLE compressed
	compression = stbi__get16be(s);
	if (compression > 1)
		return stbi__errpuc("bad compression", "PSD has an unknown compression format");

	// Create the destination image.
	out = (stbi_uc *)stbi__malloc(4 * w*h);
	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	pixelCount = w*h;

	// Initialize the data to zero.
	//memset( out, 0, pixelCount * 4 );

	// Finally, the image data.
	if (compression) {
		// RLE as used by .PSD and .TIFF
		// Loop until you get the number of unpacked bytes you are expecting:
		//     Read the next source byte into n.
		//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
		//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
		//     Else if n is 128, noop.
		// Endloop

		// The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
		// which we're going to just skip.
		stbi__skip(s, h * channelCount * 2);

		// Read the RLE data by channel.
		for (channel = 0; channel < 4; channel++) {
			stbi_uc *p;

			p = out + channel;
			if (channel >= channelCount) {
				// Fill this channel with default data.
				for (i = 0; i < pixelCount; i++, p += 4)
					*p = (channel == 3 ? 255 : 0);
			}
			else {
				// Read the RLE data.
				count = 0;
				while (count < pixelCount) {
					len = stbi__get8(s);
					if (len == 128) {
						// No-op.
					}
					else if (len < 128) {
						// Copy next len+1 bytes literally.
						len++;
						count += len;
						while (len) {
							*p = stbi__get8(s);
							p += 4;
							len--;
						}
					}
					else if (len > 128) {
						stbi_uc   val;
						// Next -len+1 bytes in the dest are replicated from next source byte.
						// (Interpret len as a negative 8-bit int.)
						len ^= 0x0FF;
						len += 2;
						val = stbi__get8(s);
						count += len;
						while (len) {
							*p = val;
							p += 4;
							len--;
						}
					}
				}
			}
		}

	}
	else {
		// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
		// where each channel consists of an 8-bit value for each pixel in the image.

		// Read the data by channel.
		for (channel = 0; channel < 4; channel++) {
			stbi_uc *p;

			p = out + channel;
			if (channel >= channelCount) {
				// Fill this channel with default data.
				stbi_uc val = channel == 3 ? 255 : 0;
				for (i = 0; i < pixelCount; i++, p += 4)
					*p = val;
			}
			else {
				// Read the data.
				if (bitdepth == 16) {
					for (i = 0; i < pixelCount; i++, p += 4)
						*p = (stbi_uc)(stbi__get16be(s) >> 8);
				}
				else {
					for (i = 0; i < pixelCount; i++, p += 4)
						*p = stbi__get8(s);
				}
			}
		}
	}

	if (channelCount >= 4) {
		for (i = 0; i < w*h; ++i) {
			unsigned char *pixel = out + 4 * i;
			if (pixel[3] != 0 && pixel[3] != 255) {
				// remove weird white matte from PSD
				float a = pixel[3] / 255.0f;
				float ra = 1.0f / a;
				float inv_a = 255.0f * (1 - ra);
				pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);
				pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);
				pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);
			}
		}
	}

	if (req_comp && req_comp != 4) {
		out = stbi__convert_format(out, 4, req_comp, w, h);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}

	if (comp) *comp = 4;
	*y = h;
	*x = w;

	return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s, const char *str)
{
	int i;
	for (i = 0; i<4; ++i)
		if (stbi__get8(s) != (stbi_uc)str[i])
			return 0;

	return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
	int i;

	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))
		return 0;

	for (i = 0; i<84; ++i)
		stbi__get8(s);

	if (!stbi__pic_is4(s, "PICT"))
		return 0;

	return 1;
}

typedef struct
{
	stbi_uc size, type, channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
	int mask = 0x80, i;

	for (i = 0; i<4; ++i, mask >>= 1) {
		if (channel & mask) {
			if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");
			dest[i] = stbi__get8(s);
		}
	}

	return dest;
}

static void stbi__copyval(int channel, stbi_uc *dest, const stbi_uc *src)
{
	int mask = 0x80, i;

	for (i = 0; i<4; ++i, mask >>= 1)
		if (channel&mask)
			dest[i] = src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s, int width, int height, int *comp, stbi_uc *result)
{
	int act_comp = 0, num_packets = 0, y, chained;
	stbi__pic_packet packets[10];

	// this will (should...) cater for even some bizarre stuff like having data
	// for the same channel in multiple packets.
	do {
		stbi__pic_packet *packet;

		if (num_packets == sizeof(packets) / sizeof(packets[0]))
			return stbi__errpuc("bad format", "too many packets");

		packet = &packets[num_packets++];

		chained = stbi__get8(s);
		packet->size = stbi__get8(s);
		packet->type = stbi__get8(s);
		packet->channel = stbi__get8(s);

		act_comp |= packet->channel;

		if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");
		if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");
	} while (chained);

	*comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	for (y = 0; y<height; ++y) {
		int packet_idx;

		for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {
			stbi__pic_packet *packet = &packets[packet_idx];
			stbi_uc *dest = result + y*width * 4;

			switch (packet->type) {
			default:
				return stbi__errpuc("bad format", "packet has bad compression type");

			case 0: {//uncompressed
				int x;

				for (x = 0; x<width; ++x, dest += 4)
					if (!stbi__readval(s, packet->channel, dest))
						return 0;
				break;
			}

			case 1://Pure RLE
			{
				int left = width, i;

				while (left>0) {
					stbi_uc count, value[4];

					count = stbi__get8(s);
					if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

					if (count > left)
						count = (stbi_uc)left;

					if (!stbi__readval(s, packet->channel, value))  return 0;

					for (i = 0; i<count; ++i, dest += 4)
						stbi__copyval(packet->channel, dest, value);
					left -= count;
				}
			}
			break;

			case 2: {//Mixed RLE
				int left = width;
				while (left>0) {
					int count = stbi__get8(s), i;
					if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

					if (count >= 128) { // Repeated
						stbi_uc value[4];

						if (count == 128)
							count = stbi__get16be(s);
						else
							count -= 127;
						if (count > left)
							return stbi__errpuc("bad file", "scanline overrun");

						if (!stbi__readval(s, packet->channel, value))
							return 0;

						for (i = 0; i<count; ++i, dest += 4)
							stbi__copyval(packet->channel, dest, value);
					}
					else { // Raw
						++count;
						if (count>left) return stbi__errpuc("bad file", "scanline overrun");

						for (i = 0; i<count; ++i, dest += 4)
							if (!stbi__readval(s, packet->channel, dest))
								return 0;
					}
					left -= count;
				}
				break;
			}
			}
		}
	}

	return result;
}

static stbi_uc *stbi__pic_load(stbi__context *s, int *px, int *py, int *comp, int req_comp)
{
	stbi_uc *result;
	int i, x, y;

	for (i = 0; i<92; ++i)
		stbi__get8(s);

	x = stbi__get16be(s);
	y = stbi__get16be(s);
	if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");
	if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");

	stbi__get32be(s); //skip `ratio'
	stbi__get16be(s); //skip `fields'
	stbi__get16be(s); //skip `pad'

	// intermediate buffer is RGBA
	result = (stbi_uc *)stbi__malloc(x*y * 4);
	memset(result, 0xff, x*y * 4);

	if (!stbi__pic_load_core(s, x, y, comp, result)) {
		STBI_FREE(result);
		result = 0;
	}
	*px = x;
	*py = y;
	if (req_comp == 0) req_comp = *comp;
	result = stbi__convert_format(result, 4, req_comp, x, y);

	return result;
}

static int stbi__pic_test(stbi__context *s)
{
	int r = stbi__pic_test_core(s);
	stbi__rewind(s);
	return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
	stbi__int16 prefix;
	stbi_uc first;
	stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
	int w, h;
	stbi_uc *out, *old_out;             // output buffer (always 4 components)
	int flags, bgindex, ratio, transparent, eflags, delay;
	stbi_uc  pal[256][4];
	stbi_uc lpal[256][4];
	stbi__gif_lzw codes[4096];
	stbi_uc *color_table;
	int parse, step;
	int lflags;
	int start_x, start_y;
	int max_x, max_y;
	int cur_x, cur_y;
	int line_size;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
	int sz;
	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
	sz = stbi__get8(s);
	if (sz != '9' && sz != '7') return 0;
	if (stbi__get8(s) != 'a') return 0;
	return 1;
}

static int stbi__gif_test(stbi__context *s)
{
	int r = stbi__gif_test_raw(s);
	stbi__rewind(s);
	return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
	int i;
	for (i = 0; i < num_entries; ++i) {
		pal[i][2] = stbi__get8(s);
		pal[i][1] = stbi__get8(s);
		pal[i][0] = stbi__get8(s);
		pal[i][3] = transp == i ? 0 : 255;
	}
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
	stbi_uc version;
	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
		return stbi__err("not GIF", "Corrupt GIF");

	version = stbi__get8(s);
	if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
	if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

	stbi__g_failure_reason = "";
	g->w = stbi__get16le(s);
	g->h = stbi__get16le(s);
	g->flags = stbi__get8(s);
	g->bgindex = stbi__get8(s);
	g->ratio = stbi__get8(s);
	g->transparent = -1;

	if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

	if (is_info) return 1;

	if (g->flags & 0x80)
		stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

	return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
	stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));
	if (!stbi__gif_header(s, g, comp, 1)) {
		STBI_FREE(g);
		stbi__rewind(s);
		return 0;
	}
	if (x) *x = g->w;
	if (y) *y = g->h;
	STBI_FREE(g);
	return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
	stbi_uc *p, *c;

	// recurse to decode the prefixes, since the linked-list is backwards,
	// and working backwards through an interleaved image would be nasty
	if (g->codes[code].prefix >= 0)
		stbi__out_gif_code(g, g->codes[code].prefix);

	if (g->cur_y >= g->max_y) return;

	p = &g->out[g->cur_x + g->cur_y];
	c = &g->color_table[g->codes[code].suffix * 4];

	if (c[3] >= 128) {
		p[0] = c[2];
		p[1] = c[1];
		p[2] = c[0];
		p[3] = c[3];
	}
	g->cur_x += 4;

	if (g->cur_x >= g->max_x) {
		g->cur_x = g->start_x;
		g->cur_y += g->step;

		while (g->cur_y >= g->max_y && g->parse > 0) {
			g->step = (1 << g->parse) * g->line_size;
			g->cur_y = g->start_y + (g->step >> 1);
			--g->parse;
		}
	}
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
	stbi_uc lzw_cs;
	stbi__int32 len, init_code;
	stbi__uint32 first;
	stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
	stbi__gif_lzw *p;

	lzw_cs = stbi__get8(s);
	if (lzw_cs > 12) return NULL;
	clear = 1 << lzw_cs;
	first = 1;
	codesize = lzw_cs + 1;
	codemask = (1 << codesize) - 1;
	bits = 0;
	valid_bits = 0;
	for (init_code = 0; init_code < clear; init_code++) {
		g->codes[init_code].prefix = -1;
		g->codes[init_code].first = (stbi_uc)init_code;
		g->codes[init_code].suffix = (stbi_uc)init_code;
	}

	// support no starting clear code
	avail = clear + 2;
	oldcode = -1;

	len = 0;
	for (;;) {
		if (valid_bits < codesize) {
			if (len == 0) {
				len = stbi__get8(s); // start new block
				if (len == 0)
					return g->out;
			}
			--len;
			bits |= (stbi__int32)stbi__get8(s) << valid_bits;
			valid_bits += 8;
		}
		else {
			stbi__int32 code = bits & codemask;
			bits >>= codesize;
			valid_bits -= codesize;
			// @OPTIMIZE: is there some way we can accelerate the non-clear path?
			if (code == clear) {  // clear code
				codesize = lzw_cs + 1;
				codemask = (1 << codesize) - 1;
				avail = clear + 2;
				oldcode = -1;
				first = 0;
			}
			else if (code == clear + 1) { // end of stream code
				stbi__skip(s, len);
				while ((len = stbi__get8(s)) > 0)
					stbi__skip(s, len);
				return g->out;
			}
			else if (code <= avail) {
				if (first) return stbi__errpuc("no clear code", "Corrupt GIF");

				if (oldcode >= 0) {
					p = &g->codes[avail++];
					if (avail > 4096)        return stbi__errpuc("too many codes", "Corrupt GIF");
					p->prefix = (stbi__int16)oldcode;
					p->first = g->codes[oldcode].first;
					p->suffix = (code == avail) ? p->first : g->codes[code].first;
				}
				else if (code == avail)
					return stbi__errpuc("illegal code in raster", "Corrupt GIF");

				stbi__out_gif_code(g, (stbi__uint16)code);

				if ((avail & codemask) == 0 && avail <= 0x0FFF) {
					codesize++;
					codemask = (1 << codesize) - 1;
				}

				oldcode = code;
			}
			else {
				return stbi__errpuc("illegal code in raster", "Corrupt GIF");
			}
		}
	}
}

static void stbi__fill_gif_background(stbi__gif *g, int x0, int y0, int x1, int y1)
{
	int x, y;
	stbi_uc *c = g->pal[g->bgindex];
	for (y = y0; y < y1; y += 4 * g->w) {
		for (x = x0; x < x1; x += 4) {
			stbi_uc *p = &g->out[y + x];
			p[0] = c[2];
			p[1] = c[1];
			p[2] = c[0];
			p[3] = 0;
		}
	}
}

// this function is designed to support animated gifs, although stb_image doesn't support it
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
{
	int i;
	stbi_uc *prev_out = 0;

	if (g->out == 0 && !stbi__gif_header(s, g, comp, 0))
		return 0; // stbi__g_failure_reason set by stbi__gif_header

	prev_out = g->out;
	g->out = (stbi_uc *)stbi__malloc(4 * g->w * g->h);
	if (g->out == 0) return stbi__errpuc("outofmem", "Out of memory");

	switch ((g->eflags & 0x1C) >> 2) {
	case 0: // unspecified (also always used on 1st frame)
		stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);
		break;
	case 1: // do not dispose
		if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
		g->old_out = prev_out;
		break;
	case 2: // dispose to background
		if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
		stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);
		break;
	case 3: // dispose to previous
		if (g->old_out) {
			for (i = g->start_y; i < g->max_y; i += 4 * g->w)
				memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);
		}
		break;
	}

	for (;;) {
		switch (stbi__get8(s)) {
		case 0x2C: /* Image Descriptor */
		{
			int prev_trans = -1;
			stbi__int32 x, y, w, h;
			stbi_uc *o;

			x = stbi__get16le(s);
			y = stbi__get16le(s);
			w = stbi__get16le(s);
			h = stbi__get16le(s);
			if (((x + w) > (g->w)) || ((y + h) > (g->h)))
				return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

			g->line_size = g->w * 4;
			g->start_x = x * 4;
			g->start_y = y * g->line_size;
			g->max_x = g->start_x + w * 4;
			g->max_y = g->start_y + h * g->line_size;
			g->cur_x = g->start_x;
			g->cur_y = g->start_y;

			g->lflags = stbi__get8(s);

			if (g->lflags & 0x40) {
				g->step = 8 * g->line_size; // first interlaced spacing
				g->parse = 3;
			}
			else {
				g->step = g->line_size;
				g->parse = 0;
			}

			if (g->lflags & 0x80) {
				stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
				g->color_table = (stbi_uc *)g->lpal;
			}
			else if (g->flags & 0x80) {
				if (g->transparent >= 0 && (g->eflags & 0x01)) {
					prev_trans = g->pal[g->transparent][3];
					g->pal[g->transparent][3] = 0;
				}
				g->color_table = (stbi_uc *)g->pal;
			}
			else
				return stbi__errpuc("missing color table", "Corrupt GIF");

			o = stbi__process_gif_raster(s, g);
			if (o == NULL) return NULL;

			if (prev_trans != -1)
				g->pal[g->transparent][3] = (stbi_uc)prev_trans;

			return o;
		}

		case 0x21: // Comment Extension.
		{
			int len;
			if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
				len = stbi__get8(s);
				if (len == 4) {
					g->eflags = stbi__get8(s);
					g->delay = stbi__get16le(s);
					g->transparent = stbi__get8(s);
				}
				else {
					stbi__skip(s, len);
					break;
				}
			}
			while ((len = stbi__get8(s)) != 0)
				stbi__skip(s, len);
			break;
		}

		case 0x3B: // gif stream termination code
			return (stbi_uc *)s; // using '1' causes warning on some compilers

		default:
			return stbi__errpuc("unknown code", "Corrupt GIF");
		}
	}

	STBI_NOTUSED(req_comp);
}

static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *u = 0;
	stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));
	memset(g, 0, sizeof(*g));

	u = stbi__gif_load_next(s, g, comp, req_comp);
	if (u == (stbi_uc *)s) u = 0;  // end of animated gif marker
	if (u) {
		*x = g->w;
		*y = g->h;
		if (req_comp && req_comp != 4)
			u = stbi__convert_format(u, 4, req_comp, g->w, g->h);
	}
	else if (g->out)
		STBI_FREE(g->out);
	STBI_FREE(g);
	return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
	return stbi__gif_info_raw(s, x, y, comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s)
{
	const char *signature = "#?RADIANCE\n";
	int i;
	for (i = 0; signature[i]; ++i)
		if (stbi__get8(s) != signature[i])
			return 0;
	return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
	int r = stbi__hdr_test_core(s);
	stbi__rewind(s);
	return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
	int len = 0;
	char c = '\0';

	c = (char)stbi__get8(z);

	while (!stbi__at_eof(z) && c != '\n') {
		buffer[len++] = c;
		if (len == STBI__HDR_BUFLEN - 1) {
			// flush to end of line
			while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
				;
			break;
		}
		c = (char)stbi__get8(z);
	}

	buffer[len] = 0;
	return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
	if (input[3] != 0) {
		float f1;
		// Exponent
		f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));
		if (req_comp <= 2)
			output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
		else {
			output[0] = input[0] * f1;
			output[1] = input[1] * f1;
			output[2] = input[2] * f1;
		}
		if (req_comp == 2) output[1] = 1;
		if (req_comp == 4) output[3] = 1;
	}
	else {
		switch (req_comp) {
		case 4: output[3] = 1; /* fallthrough */
		case 3: output[0] = output[1] = output[2] = 0;
			break;
		case 2: output[1] = 1; /* fallthrough */
		case 1: output[0] = 0;
			break;
		}
	}
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	char buffer[STBI__HDR_BUFLEN];
	char *token;
	int valid = 0;
	int width, height;
	stbi_uc *scanline;
	float *hdr_data;
	int len;
	unsigned char count, value;
	int i, j, k, c1, c2, z;


	// Check identifier
	if (strcmp(stbi__hdr_gettoken(s, buffer), "#?RADIANCE") != 0)
		return stbi__errpf("not HDR", "Corrupt HDR image");

	// Parse header
	for (;;) {
		token = stbi__hdr_gettoken(s, buffer);
		if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
	}

	if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	// Parse width and height
	// can't use sscanf() if we're not using stdio!
	token = stbi__hdr_gettoken(s, buffer);
	if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
	token += 3;
	height = (int)strtol(token, &token, 10);
	while (*token == ' ') ++token;
	if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
	token += 3;
	width = (int)strtol(token, NULL, 10);

	*x = width;
	*y = height;

	if (comp) *comp = 3;
	if (req_comp == 0) req_comp = 3;

	// Read data
	hdr_data = (float *)stbi__malloc(height * width * req_comp * sizeof(float));

	// Load image data
	// image data is stored as some number of sca
	if (width < 8 || width >= 32768) {
		// Read flat data
		for (j = 0; j < height; ++j) {
			for (i = 0; i < width; ++i) {
				stbi_uc rgbe[4];
			main_decode_loop:
				stbi__getn(s, rgbe, 4);
				stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
			}
		}
	}
	else {
		// Read RLE-encoded data
		scanline = NULL;

		for (j = 0; j < height; ++j) {
			c1 = stbi__get8(s);
			c2 = stbi__get8(s);
			len = stbi__get8(s);
			if (c1 != 2 || c2 != 2 || (len & 0x80)) {
				// not run-length encoded, so we have to actually use THIS data as a decoded
				// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
				stbi_uc rgbe[4];
				rgbe[0] = (stbi_uc)c1;
				rgbe[1] = (stbi_uc)c2;
				rgbe[2] = (stbi_uc)len;
				rgbe[3] = (stbi_uc)stbi__get8(s);
				stbi__hdr_convert(hdr_data, rgbe, req_comp);
				i = 1;
				j = 0;
				STBI_FREE(scanline);
				goto main_decode_loop; // yes, this makes no sense
			}
			len <<= 8;
			len |= stbi__get8(s);
			if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
			if (scanline == NULL) scanline = (stbi_uc *)stbi__malloc(width * 4);

			for (k = 0; k < 4; ++k) {
				i = 0;
				while (i < width) {
					count = stbi__get8(s);
					if (count > 128) {
						// Run
						value = stbi__get8(s);
						count -= 128;
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = value;
					}
					else {
						// Dump
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = stbi__get8(s);
					}
				}
			}
			for (i = 0; i < width; ++i)
				stbi__hdr_convert(hdr_data + (j*width + i)*req_comp, scanline + i * 4, req_comp);
		}
		STBI_FREE(scanline);
	}

	return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
	char buffer[STBI__HDR_BUFLEN];
	char *token;
	int valid = 0;

	if (stbi__hdr_test(s) == 0) {
		stbi__rewind(s);
		return 0;
	}

	for (;;) {
		token = stbi__hdr_gettoken(s, buffer);
		if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
	}

	if (!valid) {
		stbi__rewind(s);
		return 0;
	}
	token = stbi__hdr_gettoken(s, buffer);
	if (strncmp(token, "-Y ", 3)) {
		stbi__rewind(s);
		return 0;
	}
	token += 3;
	*y = (int)strtol(token, &token, 10);
	while (*token == ' ') ++token;
	if (strncmp(token, "+X ", 3)) {
		stbi__rewind(s);
		return 0;
	}
	token += 3;
	*x = (int)strtol(token, NULL, 10);
	*comp = 3;
	return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
	void *p;
	stbi__bmp_data info;

	info.all_a = 255;
	p = stbi__bmp_parse_header(s, &info);
	stbi__rewind(s);
	if (p == NULL)
		return 0;
	*x = s->img_x;
	*y = s->img_y;
	*comp = info.ma ? 4 : 3;
	return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
	int channelCount;
	if (stbi__get32be(s) != 0x38425053) {
		stbi__rewind(s);
		return 0;
	}
	if (stbi__get16be(s) != 1) {
		stbi__rewind(s);
		return 0;
	}
	stbi__skip(s, 6);
	channelCount = stbi__get16be(s);
	if (channelCount < 0 || channelCount > 16) {
		stbi__rewind(s);
		return 0;
	}
	*y = stbi__get32be(s);
	*x = stbi__get32be(s);
	if (stbi__get16be(s) != 8) {
		stbi__rewind(s);
		return 0;
	}
	if (stbi__get16be(s) != 3) {
		stbi__rewind(s);
		return 0;
	}
	*comp = 4;
	return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
	int act_comp = 0, num_packets = 0, chained;
	stbi__pic_packet packets[10];

	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {
		stbi__rewind(s);
		return 0;
	}

	stbi__skip(s, 88);

	*x = stbi__get16be(s);
	*y = stbi__get16be(s);
	if (stbi__at_eof(s)) {
		stbi__rewind(s);
		return 0;
	}
	if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {
		stbi__rewind(s);
		return 0;
	}

	stbi__skip(s, 8);

	do {
		stbi__pic_packet *packet;

		if (num_packets == sizeof(packets) / sizeof(packets[0]))
			return 0;

		packet = &packets[num_packets++];
		chained = stbi__get8(s);
		packet->size = stbi__get8(s);
		packet->type = stbi__get8(s);
		packet->channel = stbi__get8(s);
		act_comp |= packet->channel;

		if (stbi__at_eof(s)) {
			stbi__rewind(s);
			return 0;
		}
		if (packet->size != 8) {
			stbi__rewind(s);
			return 0;
		}
	} while (chained);

	*comp = (act_comp & 0x10 ? 4 : 3);

	return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
	char p, t;
	p = (char)stbi__get8(s);
	t = (char)stbi__get8(s);
	if (p != 'P' || (t != '5' && t != '6')) {
		stbi__rewind(s);
		return 0;
	}
	return 1;
}

static stbi_uc *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *out;
	if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
		return 0;
	*x = s->img_x;
	*y = s->img_y;
	*comp = s->img_n;

	out = (stbi_uc *)stbi__malloc(s->img_n * s->img_x * s->img_y);
	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

	if (req_comp && req_comp != s->img_n) {
		out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}
	return out;
}

static int      stbi__pnm_isspace(char c)
{
	return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
	for (;;) {
		while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
			*c = (char)stbi__get8(s);

		if (stbi__at_eof(s) || *c != '#')
			break;

		while (!stbi__at_eof(s) && *c != '\n' && *c != '\r')
			*c = (char)stbi__get8(s);
	}
}

static int      stbi__pnm_isdigit(char c)
{
	return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
	int value = 0;

	while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
		value = value * 10 + (*c - '0');
		*c = (char)stbi__get8(s);
	}

	return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
	int maxv;
	char c, p, t;

	stbi__rewind(s);

	// Get identifier
	p = (char)stbi__get8(s);
	t = (char)stbi__get8(s);
	if (p != 'P' || (t != '5' && t != '6')) {
		stbi__rewind(s);
		return 0;
	}

	*comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

	c = (char)stbi__get8(s);
	stbi__pnm_skip_whitespace(s, &c);

	*x = stbi__pnm_getinteger(s, &c); // read width
	stbi__pnm_skip_whitespace(s, &c);

	*y = stbi__pnm_getinteger(s, &c); // read height
	stbi__pnm_skip_whitespace(s, &c);

	maxv = stbi__pnm_getinteger(s, &c);  // read max value

	if (maxv > 255)
		return stbi__err("max value > 255", "PPM image not 8-bit");
	else
		return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
#ifndef STBI_NO_JPEG
	if (stbi__jpeg_info(s, x, y, comp)) return 1;
#endif

#ifndef STBI_NO_PNG
	if (stbi__png_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_GIF
	if (stbi__gif_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_BMP
	if (stbi__bmp_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PSD
	if (stbi__psd_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PIC
	if (stbi__pic_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PNM
	if (stbi__pnm_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_HDR
	if (stbi__hdr_info(s, x, y, comp))  return 1;
#endif

	// test tga last because it's a crappy test!
#ifndef STBI_NO_TGA
	if (stbi__tga_info(s, x, y, comp))
		return 1;
#endif
	return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result;
	if (!f) return stbi__err("can't fopen", "Unable to open file");
	result = stbi_info_from_file(f, x, y, comp);
	fclose(f);
	return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
	int r;
	stbi__context s;
	long pos = ftell(f);
	stbi__start_file(&s, f);
	r = stbi__info_main(&s, x, y, comp);
	fseek(f, pos, SEEK_SET);
	return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__info_main(&s, x, y, comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)c, user);
	return stbi__info_main(&s, x, y, comp);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
revision history:
2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
2.11  (2016-04-02) allocate large structures on the stack
remove white matting for transparent PSD
fix reported channel count for PNG & BMP
re-enable SSE2 in non-gcc 64-bit
support RGB-formatted JPEG
read 16-bit PNGs (only as 8-bit)
2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
2.09  (2016-01-16) allow comments in PNM files
16-bit-per-pixel TGA (not bit-per-component)
info() for TGA could break due to .hdr handling
info() for BMP to shares code instead of sloppy parse
can use STBI_REALLOC_SIZED if allocator doesn't support realloc
code cleanup
2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
2.07  (2015-09-13) fix compiler warnings
partial animated GIF support
limited 16-bpc PSD support
#ifdef unused functions
bug with < 92 byte PIC,PNM,HDR,TGA
2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
2.03  (2015-04-12) extra corruption checking (mmozeiko)
stbi_set_flip_vertically_on_load (nguillemot)
fix NEON support; fix mingw support
2.02  (2015-01-19) fix incorrect assert, fix warning
2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
progressive JPEG (stb)
PGM/PPM support (Ken Miller)
STBI_MALLOC,STBI_REALLOC,STBI_FREE
GIF bugfix -- seemingly never worked
STBI_NO_*, STBI_ONLY_*
1.48  (2014-12-14) fix incorrectly-named assert()
1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
optimize PNG (ryg)
fix bug in interlaced PNG with user-specified channel count (stb)
1.46  (2014-08-26)
fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
1.45  (2014-08-16)
fix MSVC-ARM internal compiler error by wrapping malloc
1.44  (2014-08-07)
various warning fixes from Ronny Chevalier
1.43  (2014-07-15)
fix MSVC-only compiler problem in code changed in 1.42
1.42  (2014-07-09)
don't define _CRT_SECURE_NO_WARNINGS (affects user code)
fixes to stbi__cleanup_jpeg path
added STBI_ASSERT to avoid requiring assert.h
1.41  (2014-06-25)
fix search&replace from 1.36 that messed up comments/error messages
1.40  (2014-06-22)
fix gcc struct-initialization warning
1.39  (2014-06-15)
fix to TGA optimization when req_comp != number of components in TGA;
fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
add support for BMP version 5 (more ignored fields)
1.38  (2014-06-06)
suppress MSVC warnings on integer casts truncating values
fix accidental rename of 'skip' field of I/O
1.37  (2014-06-04)
remove duplicate typedef
1.36  (2014-06-03)
convert to header file single-file library
if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
1.35  (2014-05-27)
various warnings
fix broken STBI_SIMD path
fix bug where stbi_load_from_file no longer left file pointer in correct place
fix broken non-easy path for 32-bit BMP (possibly never used)
TGA optimization by Arseny Kapoulkine
1.34  (unknown)
use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
1.33  (2011-07-14)
make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
1.32  (2011-07-13)
support for "info" function for all supported filetypes (SpartanJ)
1.31  (2011-06-20)
a few more leak fixes, bug in PNG handling (SpartanJ)
1.30  (2011-06-11)
added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
removed deprecated format-specific test/load functions
removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
fix inefficiency in decoding 32-bit BMP (David Woo)
1.29  (2010-08-16)
various warning fixes from Aurelien Pocheville
1.28  (2010-08-01)
fix bug in GIF palette transparency (SpartanJ)
1.27  (2010-08-01)
cast-to-stbi_uc to fix warnings
1.26  (2010-07-24)
fix bug in file buffering for PNG reported by SpartanJ
1.25  (2010-07-17)
refix trans_data warning (Won Chun)
1.24  (2010-07-12)
perf improvements reading from files on platforms with lock-heavy fgetc()
minor perf improvements for jpeg
deprecated type-specific functions so we'll get feedback if they're needed
attempt to fix trans_data warning (Won Chun)
1.23    fixed bug in iPhone support
1.22  (2010-07-10)
removed image *writing* support
stbi_info support from Jetro Lauha
GIF support from Jean-Marc Lienher
iPhone PNG-extensions from James Brown
warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
1.21    fix use of 'stbi_uc' in header (reported by jon blow)
1.20    added support for Softimage PIC, by Tom Seddon
1.19    bug in interlaced PNG corruption check (found by ryg)
1.18  (2008-08-02)
fix a threading bug (local mutable static)
1.17    support interlaced PNG
1.16    major bugfix - stbi__convert_format converted one too many pixels
1.15    initialize some fields for thread safety
1.14    fix threadsafe conversion bug
header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
1.13    threadsafe
1.12    const qualifiers in the API
1.11    Support installable IDCT, colorspace conversion routines
1.10    Fixes for 64-bit (don't use "unsigned long")
optimized upsampling by Fabian "ryg" Giesen
1.09    Fix format-conversion for PSD code (bad global variables!)
1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
1.07    attempt to fix C++ warning/errors again
1.06    attempt to fix C++ warning/errors again
1.05    fix TGA loading to return correct *comp and use good luminance calc
1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
1.02    support for (subset of) HDR files, float interface for preferred access to them
1.01    fix bug: possible bug in handling right-side up bmps... not sure
fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
1.00    interface to zlib that skips zlib header
0.99    correct handling of alpha in palette
0.98    TGA loader by lonesock; dynamically add loaders (untested)
0.97    jpeg errors on too large a file; also catch another malloc failure
0.96    fix detection of invalid v value - particleman@mollyrocket forum
0.95    during header scan, seek to markers in case of padding
0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
0.93    handle jpegtran output; verbose errors
0.92    read 4,8,16,24,32-bit BMP files of several formats
0.91    output 24-bit Windows 3.0 BMP files
0.90    fix a few more warnings; bump version number to approach 1.0
0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
0.60    fix compiling as c++
0.59    fix warnings: merge Dave Moore's -Wall fixes
0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
0.56    fix bug: zlib uncompressed mode len vs. nlen
0.55    fix bug: restart_interval not initialized to 0
0.54    allow NULL for 'int *comp'
0.53    fix bug in png 3->4; speedup png decoding
0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
0.51    obey req_comp requests, 1-component jpegs return as 1-component,
on 'test' only check type, not whether we support this variant
0.50  (2006-11-19)
first released version
*/

// Embedded stb_truetype.h
#define STB_TRUETYPE_IMPLEMENTATION

// stb_truetype.h - v1.11 - public domain
// authored from 2009-2015 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket (with fix)
//       Cass Everitt
//       stoiko (Haemimont Games)
//       Brian Hook 
//       Walter van Niftrik
//       David Gow
//       David Given
//       Ivan-Assen Ivanov
//       Anthony Pesch
//       Johan Duparc
//       Hou Qiming
//       Fabian "ryg" Giesen
//       Martins Mozeiko
//       Cap Petschulat
//       Omar Cornut
//       github:aloucks
//       Peter LaValle
//       Sergey Popov
//       Giumo X. Clanjor
//       Higor Euripedes
//       Thomas Fields
//       Derek Vinyard
//
// VERSION HISTORY
//
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.
//
// USAGE
//
//   Include this file in whatever places neeed to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversample()            -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- use for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since they different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \                           .
//   Curve tesselation                  120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1 << 20];
unsigned char temp_bitmap[512 * 512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
	fread(ttf_buffer, 1, 1 << 20, fopen("c:/windows/fonts/times.ttf", "rb"));
	stbtt_BakeFontBitmap(ttf_buffer, 0, 32.0, temp_bitmap, 512, 512, 32, 96, cdata); // no guarantee this fits!
	// can free ttf_buffer at this point
	glGenTextures(1, &ftex);
	glBindTexture(GL_TEXTURE_2D, ftex);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512, 512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
	// can free temp_bitmap at this point
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
	// assume orthographic projection with units = screen pixels, origin at top left
	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, ftex);
	glBegin(GL_QUADS);
	while (*text) {
		if (*text >= 32 && *text < 128) {
			stbtt_aligned_quad q;
			stbtt_GetBakedQuad(cdata, 512, 512, *text - 32, &x, &y, &q, 1);//1=opengl & d3d10+,0=d3d9
			glTexCoord2f(q.s0, q.t1); glVertex2f(q.x0, q.y0);
			glTexCoord2f(q.s1, q.t1); glVertex2f(q.x1, q.y0);
			glTexCoord2f(q.s1, q.t0); glVertex2f(q.x1, q.y1);
			glTexCoord2f(q.s0, q.t0); glVertex2f(q.x0, q.y1);
		}
		++text;
	}
	glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1 << 25];

int main(int argc, char **argv)
{
	stbtt_fontinfo font;
	unsigned char *bitmap;
	int w, h, i, j, c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

	fread(ttf_buffer, 1, 1 << 25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

	stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer, 0));
	bitmap = stbtt_GetCodepointBitmap(&font, 0, stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0, 0);

	for (j = 0; j < h; ++j) {
		for (i = 0; i < w; ++i)
			putchar(" .:ioVM@"[bitmap[j*w + i] >> 5]);
		putchar('\n');
	}
	return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24 << 20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
	stbtt_fontinfo font;
	int i, j, ascent, baseline, ch = 0;
	float scale, xpos = 2; // leave a little padding in case the character extends left
	char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

	fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
	stbtt_InitFont(&font, buffer, 0);

	scale = stbtt_ScaleForPixelHeight(&font, 15);
	stbtt_GetFontVMetrics(&font, &ascent, 0, 0);
	baseline = (int)(ascent*scale);

	while (text[ch]) {
		int advance, lsb, x0, y0, x1, y1;
		float x_shift = xpos - (float)floor(xpos);
		stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
		stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale, scale, x_shift, 0, &x0, &y0, &x1, &y1);
		stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int)xpos + x0], x1 - x0, y1 - y0, 79, scale, scale, x_shift, 0, text[ch]);
		// note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
		// because this API is really for baking character bitmaps into textures. if you want to render
		// a sequence of characters, you really need to render each bitmap to a temp buffer, then
		// "alpha blend" that into the working buffer
		xpos += (advance * scale);
		if (text[ch + 1])
			xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch], text[ch + 1]);
		++ch;
	}

	for (j = 0; j < 20; ++j) {
		for (i = 0; i < 78; ++i)
			putchar(" .:ioVM@"[screen[j][i] >> 5]);
		putchar('\n');
	}

	return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype.

#ifdef STB_TRUETYPE_IMPLEMENTATION
// #define your own (u)stbtt_int8/16/32 before including to override this
#ifndef stbtt_uint8
typedef unsigned char   stbtt_uint8;
typedef signed   char   stbtt_int8;
typedef unsigned short  stbtt_uint16;
typedef signed   short  stbtt_int16;
typedef unsigned int    stbtt_uint32;
typedef signed   int    stbtt_int32;
#endif

typedef char stbtt__check_size32[sizeof(stbtt_int32) == 4 ? 1 : -1];
typedef char stbtt__check_size16[sizeof(stbtt_int16) == 2 ? 1 : -1];

// #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
#ifndef STBTT_ifloor
#include <math.h>
#define STBTT_ifloor(x)   ((int) floor(x))
#define STBTT_iceil(x)    ((int) ceil(x))
#endif

#ifndef STBTT_sqrt
#include <math.h>
#define STBTT_sqrt(x)      sqrt(x)
#endif

#ifndef STBTT_fabs
#include <math.h>
#define STBTT_fabs(x)      fabs(x)
#endif

// #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
#ifndef STBTT_malloc
#include <stdlib.h>
#define STBTT_malloc(x,u)  ((void)(u),malloc(x))
#define STBTT_free(x,u)    ((void)(u),free(x))
#endif

#ifndef STBTT_assert
#include <assert.h>
#define STBTT_assert(x)    assert(x)
#endif

#ifndef STBTT_strlen
#include <string.h>
#define STBTT_strlen(x)    strlen(x)
#endif

#ifndef STBTT_memcpy
#include <memory.h>
#define STBTT_memcpy       memcpy
#define STBTT_memset       memset
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

	//////////////////////////////////////////////////////////////////////////////
	//
	// TEXTURE BAKING API
	//
	// If you use this API, you only have to call two functions ever.
	//

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
	} stbtt_bakedchar;

	STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
		float pixel_height,                     // height of font in pixels
		unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
		int first_char, int num_chars,          // characters to bake
		stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
	// if return is positive, the first unused row of the bitmap
	// if return is negative, returns the negative of the number of characters that fit
	// if return is 0, no characters fit and no rows were used
	// This uses a very crappy packing.

	typedef struct
	{
		float x0, y0, s0, t0; // top-left
		float x1, y1, s1, t1; // bottom-right
	} stbtt_aligned_quad;

	STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
		int char_index,             // character to display
		float *xpos, float *ypos,   // pointers to current position in screen pixel space
		stbtt_aligned_quad *q,      // output: quad to draw
		int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
	// Call GetBakedQuad with char_index = 'character - first_char', and it
	// creates the quad you need to draw and advances the current position.
	//
	// The coordinate system used assumes y increases downwards.
	//
	// Characters will extend both above and below the current position;
	// see discussion of "BASELINE" above.
	//
	// It's inefficient; you might want to c&p it and optimize it.



	//////////////////////////////////////////////////////////////////////////////
	//
	// NEW TEXTURE BAKING API
	//
	// This provides options for packing multiple fonts into one atlas, not
	// perfectly but better than nothing.

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
		float xoff2, yoff2;
	} stbtt_packedchar;

	typedef struct stbtt_pack_context stbtt_pack_context;
	typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
	typedef struct stbrp_rect stbrp_rect;
#endif

	STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
	// Initializes a packing context stored in the passed-in stbtt_pack_context.
	// Future calls using this context will pack characters into the bitmap passed
	// in here: a 1-channel bitmap that is weight x height. stride_in_bytes is
	// the distance from one row to the next (or 0 to mean they are packed tightly
	// together). "padding" is the amount of padding to leave between each
	// character (normally you want '1' for bitmaps you'll use as textures with
	// bilinear filtering).
	//
	// Returns 0 on failure, 1 on success.

	STBTT_DEF void stbtt_PackEnd(stbtt_pack_context *spc);
	// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

	STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,
		int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
	// Creates character bitmaps from the font_index'th font found in fontdata (use
	// font_index=0 if you don't know what that is). It creates num_chars_in_range
	// bitmaps for characters with unicode values starting at first_unicode_char_in_range
	// and increasing. Data for how to render them is stored in chardata_for_range;
	// pass these to stbtt_GetPackedQuad to get back renderable quads.
	//
	// font_size is the full height of the character from ascender to descender,
	// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
	// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
	// and pass that result as 'font_size':
	//       ...,                  20 , ... // font max minus min y is 20 pixels tall
	//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

	typedef struct
	{
		float font_size;
		int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
		int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
		int num_chars;
		stbtt_packedchar *chardata_for_range; // output
		unsigned char h_oversample, v_oversample; // don't set these, they're used internally
	} stbtt_pack_range;

	STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
	// Creates character bitmaps from multiple ranges of characters stored in
	// ranges. This will usually create a better-packed bitmap than multiple
	// calls to stbtt_PackFontRange. Note that you can call this multiple
	// times within a single PackBegin/PackEnd.

	STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
	// Oversampling a font increases the quality by allowing higher-quality subpixel
	// positioning, and is especially valuable at smaller text sizes.
	//
	// This function sets the amount of oversampling for all following calls to
	// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
	// pack context. The default (no oversampling) is achieved by h_oversample=1
	// and v_oversample=1. The total number of pixels required is
	// h_oversample*v_oversample larger than the default; for example, 2x2
	// oversampling requires 4x the storage of 1x1. For best results, render
	// oversampled textures with bilinear filtering. Look at the readme in
	// stb/tests/oversample for information about oversampled fonts
	//
	// To use with PackFontRangesGather etc., you must set it before calls
	// call to PackFontRangesGatherRects.

	STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph,  // same data as above
		int char_index,             // character to display
		float *xpos, float *ypos,   // pointers to current position in screen pixel space
		stbtt_aligned_quad *q,      // output: quad to draw
		int align_to_integer);

	STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
	STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
	STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
	// Calling these functions in sequence is roughly equivalent to calling
	// stbtt_PackFontRanges(). If you more control over the packing of multiple
	// fonts, or if you want to pack custom data into a font texture, take a look
	// at the source to of stbtt_PackFontRanges() and create a custom version 
	// using these functions, e.g. call GatherRects multiple times,
	// building up a single array of rects, then call PackRects once,
	// then call RenderIntoRects repeatedly. This may result in a
	// better packing than calling PackFontRanges multiple times
	// (or it may not).

	// this is an opaque structure that you shouldn't mess with which holds
	// all the context needed from PackBegin to PackEnd.
	struct stbtt_pack_context {
		void *user_allocator_context;
		void *pack_info;
		int   width;
		int   height;
		int   stride_in_bytes;
		int   padding;
		unsigned int   h_oversample, v_oversample;
		unsigned char *pixels;
		void  *nodes;
	};

	//////////////////////////////////////////////////////////////////////////////
	//
	// FONT LOADING
	//
	//

	STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
	// Each .ttf/.ttc file may have more than one font. Each font has a sequential
	// index number starting from 0. Call this function to get the font offset for
	// a given index; it returns -1 if the index is out of range. A regular .ttf
	// file will only define one font and it always be at offset 0, so it will
	// return '0' for index 0, and -1 for all other indices. You can just skip
	// this step if you know it's that kind of font.


	// The following structure is defined publically so you can declare one on
	// the stack or as a global or etc, but you should treat it as opaque.
	struct stbtt_fontinfo
	{
		void           * userdata;
		unsigned char  * data;              // pointer to .ttf file
		int              fontstart;         // offset of start of font

		int numGlyphs;                     // number of glyphs, needed for range checking

		int loca, head, glyf, hhea, hmtx, kern; // table locations as offset from start of .ttf
		int index_map;                     // a cmap mapping for our chosen character encoding
		int indexToLocFormat;              // format needed to map from glyph index to glyph
	};

	STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
	// Given an offset into the file that defines a font, this function builds
	// the necessary cached info for the rest of the system. You must allocate
	// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
	// need to do anything special to free it, because the contents are pure
	// value data with no additional data structures. Returns 0 on failure.


	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER TO GLYPH-INDEX CONVERSIOn

	STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
	// If you're going to perform multiple operations on the same character
	// and you want a speed-up, call this function with the character you're
	// going to process, then use glyph-based functions instead of the
	// codepoint-based functions.


	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER PROPERTIES
	//

	STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
	// computes a scale factor to produce a font whose "height" is 'pixels' tall.
	// Height is measured as the distance from the highest ascender to the lowest
	// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
	// and computing:
	//       scale = pixels / (ascent - descent)
	// so if you prefer to measure height by the ascent only, use a similar calculation.

	STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
	// computes a scale factor to produce a font whose EM size is mapped to
	// 'pixels' tall. This is probably what traditional APIs compute, but
	// I'm not positive.

	STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
	// ascent is the coordinate above the baseline the font extends; descent
	// is the coordinate below the baseline the font extends (i.e. it is typically negative)
	// lineGap is the spacing between one row's descent and the next row's ascent...
	// so you should advance the vertical position by "*ascent - *descent + *lineGap"
	//   these are expressed in unscaled coordinates, so you must multiply by
	//   the scale factor for a given size

	STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
	// the bounding box around all possible characters

	STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
	// leftSideBearing is the offset from the current horizontal position to the left edge of the character
	// advanceWidth is the offset from the current horizontal position to the next horizontal position
	//   these are expressed in unscaled coordinates

	STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
	// an additional amount to add to the 'advance' value between ch1 and ch2

	STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
	// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

	STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
	STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
	STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
	// as above, but takes one or more glyph indices for greater efficiency


	//////////////////////////////////////////////////////////////////////////////
	//
	// GLYPH SHAPES (you probably don't need these, but they have to go before
	// the bitmaps for C declaration-order reasons)
	//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
	enum {
		STBTT_vmove = 1,
		STBTT_vline,
		STBTT_vcurve
	};
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
	// (we share this with other code at RAD)
#define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
	typedef struct
	{
		stbtt_vertex_type x, y, cx, cy;
		unsigned char type, padding;
	} stbtt_vertex;
#endif

	STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
	// returns non-zero if nothing is drawn for this glyph

	STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
	STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
	// returns # of vertices and fills *vertices with the pointer to them
	//   these are expressed in "unscaled" coordinates
	//
	// The shape is a series of countours. Each one starts with
	// a STBTT_moveto, then consists of a series of mixed
	// STBTT_lineto and STBTT_curveto segments. A lineto
	// draws a line from previous endpoint to its x,y; a curveto
	// draws a quadratic bezier from previous endpoint to
	// its x,y, using cx,cy as the bezier control point.

	STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
	// frees the data allocated above

	//////////////////////////////////////////////////////////////////////////////
	//
	// BITMAP RENDERING
	//

	STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
	// frees the bitmap allocated below

	STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
	// allocates a large-enough single-channel 8bpp bitmap and renders the
	// specified character/glyph at the specified scale into it, with
	// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
	// *width & *height are filled out with the width & height of the bitmap,
	// which is stored left-to-right, top-to-bottom.
	//
	// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

	STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
	// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
	// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
	// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
	// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
	// width and height and positioning info for it first.

	STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
	// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
	// get the bbox of the bitmap centered around the glyph origin; so the
	// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
	// the bitmap top left is (leftSideBearing*scale,iy0).
	// (Note that the bitmap uses y-increases-down, but the shape uses
	// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

	STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
	// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
	// shift for the character

	// the following functions are equivalent to the above functions, but operate
	// on glyph indices instead of Unicode codepoints (for efficiency)
	STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
	STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
	STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
	STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
	STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
	STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


	// @TODO: don't expose this structure
	typedef struct
	{
		int w, h, stride;
		unsigned char *pixels;
	} stbtt__bitmap;

	// rasterize a shape with quadratic beziers into a bitmap
	STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
		float flatness_in_pixels,     // allowable error of curve in pixels
		stbtt_vertex *vertices,       // array of vertices defining shape
		int num_verts,                // number of vertices in above array
		float scale_x, float scale_y, // scale applied to input vertices
		float shift_x, float shift_y, // translation applied to input vertices
		int x_off, int y_off,         // another translation applied to input
		int invert,                   // if non-zero, vertically flip shape
		void *userdata);              // context for to STBTT_MALLOC

	//////////////////////////////////////////////////////////////////////////////
	//
	// Finding the right font...
	//
	// You should really just solve this offline, keep your own tables
	// of what font is what, and don't try to get it out of the .ttf file.
	// That's because getting it out of the .ttf file is really hard, because
	// the names in the file can appear in many possible encodings, in many
	// possible languages, and e.g. if you need a case-insensitive comparison,
	// the details of that depend on the encoding & language in a complex way
	// (actually underspecified in truetype, but also gigantic).
	//
	// But you can use the provided functions in two possible ways:
	//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
	//             unicode-encoded names to try to find the font you want;
	//             you can run this before calling stbtt_InitFont()
	//
	//     stbtt_GetFontNameString() lets you get any of the various strings
	//             from the file yourself and do your own comparisons on them.
	//             You have to have called stbtt_InitFont() first.


	STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
	// returns the offset (not index) of the font that matches, or -1 if none
	//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
	//   if you use any other flag, use a font name like "Arial"; this checks
	//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

	STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
	// returns 1/0 whether the first string interpreted as utf8 is identical to
	// the second string interpreted as big-endian utf16... useful for strings from next func

	STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
	// returns the string (which may be big-endian double byte, e.g. for unicode)
	// and puts the length in bytes in *length.
	//
	// some of the values for the IDs are below; for more see the truetype spec:
	//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
	//     http://www.microsoft.com/typography/otspec/name.htm

	enum { // platformID
		STBTT_PLATFORM_ID_UNICODE = 0,
		STBTT_PLATFORM_ID_MAC = 1,
		STBTT_PLATFORM_ID_ISO = 2,
		STBTT_PLATFORM_ID_MICROSOFT = 3
	};

	enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
		STBTT_UNICODE_EID_UNICODE_1_0 = 0,
		STBTT_UNICODE_EID_UNICODE_1_1 = 1,
		STBTT_UNICODE_EID_ISO_10646 = 2,
		STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3,
		STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4
	};

	enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
		STBTT_MS_EID_SYMBOL = 0,
		STBTT_MS_EID_UNICODE_BMP = 1,
		STBTT_MS_EID_SHIFTJIS = 2,
		STBTT_MS_EID_UNICODE_FULL = 10
	};

	enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
		STBTT_MAC_EID_ROMAN = 0, STBTT_MAC_EID_ARABIC = 4,
		STBTT_MAC_EID_JAPANESE = 1, STBTT_MAC_EID_HEBREW = 5,
		STBTT_MAC_EID_CHINESE_TRAD = 2, STBTT_MAC_EID_GREEK = 6,
		STBTT_MAC_EID_KOREAN = 3, STBTT_MAC_EID_RUSSIAN = 7
	};

	enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
		// problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
		STBTT_MS_LANG_ENGLISH = 0x0409, STBTT_MS_LANG_ITALIAN = 0x0410,
		STBTT_MS_LANG_CHINESE = 0x0804, STBTT_MS_LANG_JAPANESE = 0x0411,
		STBTT_MS_LANG_DUTCH = 0x0413, STBTT_MS_LANG_KOREAN = 0x0412,
		STBTT_MS_LANG_FRENCH = 0x040c, STBTT_MS_LANG_RUSSIAN = 0x0419,
		STBTT_MS_LANG_GERMAN = 0x0407, STBTT_MS_LANG_SPANISH = 0x0409,
		STBTT_MS_LANG_HEBREW = 0x040d, STBTT_MS_LANG_SWEDISH = 0x041D
	};

	enum { // languageID for STBTT_PLATFORM_ID_MAC
		STBTT_MAC_LANG_ENGLISH = 0, STBTT_MAC_LANG_JAPANESE = 11,
		STBTT_MAC_LANG_ARABIC = 12, STBTT_MAC_LANG_KOREAN = 23,
		STBTT_MAC_LANG_DUTCH = 4, STBTT_MAC_LANG_RUSSIAN = 32,
		STBTT_MAC_LANG_FRENCH = 1, STBTT_MAC_LANG_SPANISH = 6,
		STBTT_MAC_LANG_GERMAN = 2, STBTT_MAC_LANG_SWEDISH = 5,
		STBTT_MAC_LANG_HEBREW = 10, STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
		STBTT_MAC_LANG_ITALIAN = 3, STBTT_MAC_LANG_CHINESE_TRAD = 19
	};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE - 1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

#if defined(STB_TRUETYPE_BIGENDIAN) && !defined(ALLOW_UNALIGNED_TRUETYPE)

#define ttUSHORT(p)   (* (stbtt_uint16 *) (p))
#define ttSHORT(p)    (* (stbtt_int16 *) (p))
#define ttULONG(p)    (* (stbtt_uint32 *) (p))
#define ttLONG(p)     (* (stbtt_int32 *) (p))

#else

static stbtt_uint16 ttUSHORT(const stbtt_uint8 *p) { return p[0] * 256 + p[1]; }
static stbtt_int16 ttSHORT(const stbtt_uint8 *p)   { return p[0] * 256 + p[1]; }
static stbtt_uint32 ttULONG(const stbtt_uint8 *p)  { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }
static stbtt_int32 ttLONG(const stbtt_uint8 *p)    { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

#endif

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(const stbtt_uint8 *font)
{
	// check the version number
	if (stbtt_tag4(font, '1', 0, 0, 0))  return 1; // TrueType 1
	if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
	if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
	if (stbtt_tag4(font, 0, 1, 0, 0)) return 1; // OpenType 1.0
	return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
	stbtt_int32 num_tables = ttUSHORT(data + fontstart + 4);
	stbtt_uint32 tabledir = fontstart + 12;
	stbtt_int32 i;
	for (i = 0; i < num_tables; ++i) {
		stbtt_uint32 loc = tabledir + 16 * i;
		if (stbtt_tag(data + loc + 0, tag))
			return ttULONG(data + loc + 8);
	}
	return 0;
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *font_collection, int index)
{
	// if it's just a font, there's only one valid index
	if (stbtt__isfont(font_collection))
		return index == 0 ? 0 : -1;

	// check if it's a TTC
	if (stbtt_tag(font_collection, "ttcf")) {
		// version 1?
		if (ttULONG(font_collection + 4) == 0x00010000 || ttULONG(font_collection + 4) == 0x00020000) {
			stbtt_int32 n = ttLONG(font_collection + 8);
			if (index >= n)
				return -1;
			return ttULONG(font_collection + 12 + index * 4);
		}
	}
	return -1;
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)
{
	stbtt_uint8 *data = (stbtt_uint8 *)data2;
	stbtt_uint32 cmap, t;
	stbtt_int32 i, numTables;

	info->data = data;
	info->fontstart = fontstart;

	cmap = stbtt__find_table(data, fontstart, "cmap");       // required
	info->loca = stbtt__find_table(data, fontstart, "loca"); // required
	info->head = stbtt__find_table(data, fontstart, "head"); // required
	info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
	info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
	info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
	info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
	if (!cmap || !info->loca || !info->head || !info->glyf || !info->hhea || !info->hmtx)
		return 0;

	t = stbtt__find_table(data, fontstart, "maxp");
	if (t)
		info->numGlyphs = ttUSHORT(data + t + 4);
	else
		info->numGlyphs = 0xffff;

	// find a cmap encoding table we understand *now* to avoid searching
	// later. (todo: could make this installable)
	// the same regardless of glyph.
	numTables = ttUSHORT(data + cmap + 2);
	info->index_map = 0;
	for (i = 0; i < numTables; ++i) {
		stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
		// find an encoding we understand:
		switch (ttUSHORT(data + encoding_record)) {
		case STBTT_PLATFORM_ID_MICROSOFT:
			switch (ttUSHORT(data + encoding_record + 2)) {
			case STBTT_MS_EID_UNICODE_BMP:
			case STBTT_MS_EID_UNICODE_FULL:
				// MS/Unicode
				info->index_map = cmap + ttULONG(data + encoding_record + 4);
				break;
			}
			break;
		case STBTT_PLATFORM_ID_UNICODE:
			// Mac/iOS has these
			// all the encodingIDs are unicode, so we don't bother to check it
			info->index_map = cmap + ttULONG(data + encoding_record + 4);
			break;
		}
	}
	if (info->index_map == 0)
		return 0;

	info->indexToLocFormat = ttUSHORT(data + info->head + 50);
	return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
	stbtt_uint8 *data = info->data;
	stbtt_uint32 index_map = info->index_map;

	stbtt_uint16 format = ttUSHORT(data + index_map + 0);
	if (format == 0) { // apple byte encoding
		stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
		if (unicode_codepoint < bytes - 6)
			return ttBYTE(data + index_map + 6 + unicode_codepoint);
		return 0;
	}
	else if (format == 6) {
		stbtt_uint32 first = ttUSHORT(data + index_map + 6);
		stbtt_uint32 count = ttUSHORT(data + index_map + 8);
		if ((stbtt_uint32)unicode_codepoint >= first && (stbtt_uint32)unicode_codepoint < first + count)
			return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first) * 2);
		return 0;
	}
	else if (format == 2) {
		STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
		return 0;
	}
	else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
		stbtt_uint16 segcount = ttUSHORT(data + index_map + 6) >> 1;
		stbtt_uint16 searchRange = ttUSHORT(data + index_map + 8) >> 1;
		stbtt_uint16 entrySelector = ttUSHORT(data + index_map + 10);
		stbtt_uint16 rangeShift = ttUSHORT(data + index_map + 12) >> 1;

		// do a binary search of the segments
		stbtt_uint32 endCount = index_map + 14;
		stbtt_uint32 search = endCount;

		if (unicode_codepoint > 0xffff)
			return 0;

		// they lie from endCount .. endCount + segCount
		// but searchRange is the nearest power of two, so...
		if (unicode_codepoint >= ttUSHORT(data + search + rangeShift * 2))
			search += rangeShift * 2;

		// now decrement to bias correctly to find smallest
		search -= 2;
		while (entrySelector) {
			stbtt_uint16 end;
			searchRange >>= 1;
			end = ttUSHORT(data + search + searchRange * 2);
			if (unicode_codepoint > end)
				search += searchRange * 2;
			--entrySelector;
		}
		search += 2;

		{
			stbtt_uint16 offset, start;
			stbtt_uint16 item = (stbtt_uint16)((search - endCount) >> 1);

			STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2 * item));
			start = ttUSHORT(data + index_map + 14 + segcount * 2 + 2 + 2 * item);
			if (unicode_codepoint < start)
				return 0;

			offset = ttUSHORT(data + index_map + 14 + segcount * 6 + 2 + 2 * item);
			if (offset == 0)
				return (stbtt_uint16)(unicode_codepoint + ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

			return ttUSHORT(data + offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
		}
	}
	else if (format == 12 || format == 13) {
		stbtt_uint32 ngroups = ttULONG(data + index_map + 12);
		stbtt_int32 low, high;
		low = 0; high = (stbtt_int32)ngroups;
		// Binary search the right group.
		while (low < high) {
			stbtt_int32 mid = low + ((high - low) >> 1); // rounds down, so low <= mid < high
			stbtt_uint32 start_char = ttULONG(data + index_map + 16 + mid * 12);
			stbtt_uint32 end_char = ttULONG(data + index_map + 16 + mid * 12 + 4);
			if ((stbtt_uint32)unicode_codepoint < start_char)
				high = mid;
			else if ((stbtt_uint32)unicode_codepoint > end_char)
				low = mid + 1;
			else {
				stbtt_uint32 start_glyph = ttULONG(data + index_map + 16 + mid * 12 + 8);
				if (format == 12)
					return start_glyph + unicode_codepoint - start_char;
				else // format == 13
					return start_glyph;
			}
		}
		return 0; // not found
	}
	// @TODO
	STBTT_assert(0);
	return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
	return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
	v->type = type;
	v->x = (stbtt_int16)x;
	v->y = (stbtt_int16)y;
	v->cx = (stbtt_int16)cx;
	v->cy = (stbtt_int16)cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
	int g1, g2;

	if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
	if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	if (info->indexToLocFormat == 0) {
		g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
		g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
	}
	else {
		g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);
		g2 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4 + 4);
	}

	return g1 == g2 ? -1 : g1; // if length is 0, return -1
}

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
	int g = stbtt__GetGlyfOffset(info, glyph_index);
	if (g < 0) return 0;

	if (x0) *x0 = ttSHORT(info->data + g + 2);
	if (y0) *y0 = ttSHORT(info->data + g + 4);
	if (x1) *x1 = ttSHORT(info->data + g + 6);
	if (y1) *y1 = ttSHORT(info->data + g + 8);
	return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
	return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info, codepoint), x0, y0, x1, y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
	stbtt_int16 numberOfContours;
	int g = stbtt__GetGlyfOffset(info, glyph_index);
	if (g < 0) return 1;
	numberOfContours = ttSHORT(info->data + g);
	return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
	stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
	if (start_off) {
		if (was_off)
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);
		stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, scx, scy);
	}
	else {
		if (was_off)
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, cx, cy);
		else
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, sx, sy, 0, 0);
	}
	return num_vertices;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
	stbtt_int16 numberOfContours;
	stbtt_uint8 *endPtsOfContours;
	stbtt_uint8 *data = info->data;
	stbtt_vertex *vertices = 0;
	int num_vertices = 0;
	int g = stbtt__GetGlyfOffset(info, glyph_index);

	*pvertices = NULL;

	if (g < 0) return 0;

	numberOfContours = ttSHORT(data + g);

	if (numberOfContours > 0) {
		stbtt_uint8 flags = 0, flagcount;
		stbtt_int32 ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
		stbtt_int32 x, y, cx, cy, sx, sy, scx, scy;
		stbtt_uint8 *points;
		endPtsOfContours = (data + g + 10);
		ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
		points = data + g + 10 + numberOfContours * 2 + 2 + ins;

		n = 1 + ttUSHORT(endPtsOfContours + numberOfContours * 2 - 2);

		m = n + 2 * numberOfContours;  // a loose bound on how many vertices we might need
		vertices = (stbtt_vertex *)STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
		if (vertices == 0)
			return 0;

		next_move = 0;
		flagcount = 0;

		// in first pass, we load uninterpreted data into the allocated array
		// above, shifted to the end of the array so we won't overwrite it when
		// we create our final data starting from the front

		off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

		// first load flags

		for (i = 0; i < n; ++i) {
			if (flagcount == 0) {
				flags = *points++;
				if (flags & 8)
					flagcount = *points++;
			}
			else
				--flagcount;
			vertices[off + i].type = flags;
		}

		// now load x coordinates
		x = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 2) {
				stbtt_int16 dx = *points++;
				x += (flags & 16) ? dx : -dx; // ???
			}
			else {
				if (!(flags & 16)) {
					x = x + (stbtt_int16)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].x = (stbtt_int16)x;
		}

		// now load y coordinates
		y = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 4) {
				stbtt_int16 dy = *points++;
				y += (flags & 32) ? dy : -dy; // ???
			}
			else {
				if (!(flags & 32)) {
					y = y + (stbtt_int16)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].y = (stbtt_int16)y;
		}

		// now convert them to our format
		num_vertices = 0;
		sx = sy = cx = cy = scx = scy = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			x = (stbtt_int16)vertices[off + i].x;
			y = (stbtt_int16)vertices[off + i].y;

			if (next_move == i) {
				if (i != 0)
					num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

				// now start the new one               
				start_off = !(flags & 1);
				if (start_off) {
					// if we start off with an off-curve point, then when we need to find a point on the curve
					// where we can start, and we need to save some state for when we wraparound.
					scx = x;
					scy = y;
					if (!(vertices[off + i + 1].type & 1)) {
						// next point is also a curve point, so interpolate an on-point curve
						sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;
						sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;
					}
					else {
						// otherwise just use the next point as our start point
						sx = (stbtt_int32)vertices[off + i + 1].x;
						sy = (stbtt_int32)vertices[off + i + 1].y;
						++i; // we're using point i+1 as the starting point, so skip it
					}
				}
				else {
					sx = x;
					sy = y;
				}
				stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove, sx, sy, 0, 0);
				was_off = 0;
				next_move = 1 + ttUSHORT(endPtsOfContours + j * 2);
				++j;
			}
			else {
				if (!(flags & 1)) { // if it's a curve
					if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);
					cx = x;
					cy = y;
					was_off = 1;
				}
				else {
					if (was_off)
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x, y, cx, cy);
					else
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x, y, 0, 0);
					was_off = 0;
				}
			}
		}
		num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);
	}
	else if (numberOfContours == -1) {
		// Compound shapes.
		int more = 1;
		stbtt_uint8 *comp = data + g + 10;
		num_vertices = 0;
		vertices = 0;
		while (more) {
			stbtt_uint16 flags, gidx;
			int comp_num_verts = 0, i;
			stbtt_vertex *comp_verts = 0, *tmp = 0;
			float mtx[6] = { 1, 0, 0, 1, 0, 0 }, m, n;

			flags = ttSHORT(comp); comp += 2;
			gidx = ttSHORT(comp); comp += 2;

			if (flags & 2) { // XY values
				if (flags & 1) { // shorts
					mtx[4] = ttSHORT(comp); comp += 2;
					mtx[5] = ttSHORT(comp); comp += 2;
				}
				else {
					mtx[4] = ttCHAR(comp); comp += 1;
					mtx[5] = ttCHAR(comp); comp += 1;
				}
			}
			else {
				// @TODO handle matching point
				STBTT_assert(0);
			}
			if (flags & (1 << 3)) { // WE_HAVE_A_SCALE
				mtx[0] = mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
			}
			else if (flags & (1 << 6)) { // WE_HAVE_AN_X_AND_YSCALE
				mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
				mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
			}
			else if (flags & (1 << 7)) { // WE_HAVE_A_TWO_BY_TWO
				mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[2] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
			}

			// Find transformation scales.
			m = (float)STBTT_sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
			n = (float)STBTT_sqrt(mtx[2] * mtx[2] + mtx[3] * mtx[3]);

			// Get indexed glyph.
			comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
			if (comp_num_verts > 0) {
				// Transform vertices.
				for (i = 0; i < comp_num_verts; ++i) {
					stbtt_vertex* v = &comp_verts[i];
					stbtt_vertex_type x, y;
					x = v->x; y = v->y;
					v->x = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->y = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
					x = v->cx; y = v->cy;
					v->cx = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->cy = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
				}
				// Append vertices.
				tmp = (stbtt_vertex*)STBTT_malloc((num_vertices + comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
				if (!tmp) {
					if (vertices) STBTT_free(vertices, info->userdata);
					if (comp_verts) STBTT_free(comp_verts, info->userdata);
					return 0;
				}
				if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
				STBTT_memcpy(tmp + num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
				if (vertices) STBTT_free(vertices, info->userdata);
				vertices = tmp;
				STBTT_free(comp_verts, info->userdata);
				num_vertices += comp_num_verts;
			}
			// More components ?
			more = flags & (1 << 5);
		}
	}
	else if (numberOfContours < 0) {
		// @TODO other compound variations?
		STBTT_assert(0);
	}
	else {
		// numberOfCounters == 0, do nothing
	}

	*pvertices = vertices;
	return num_vertices;
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
	stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data + info->hhea + 34);
	if (glyph_index < numOfLongHorMetrics) {
		if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);
		if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);
	}
	else {
		if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));
		if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));
	}
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
	stbtt_uint8 *data = info->data + info->kern;
	stbtt_uint32 needle, straw;
	int l, r, m;

	// we only look at the first table. it must be 'horizontal' and format 0.
	if (!info->kern)
		return 0;
	if (ttUSHORT(data + 2) < 1) // number of tables, need at least 1
		return 0;
	if (ttUSHORT(data + 8) != 1) // horizontal flag must be set in format
		return 0;

	l = 0;
	r = ttUSHORT(data + 10) - 1;
	needle = glyph1 << 16 | glyph2;
	while (l <= r) {
		m = (l + r) >> 1;
		straw = ttULONG(data + 18 + (m * 6)); // note: unaligned read
		if (needle < straw)
			r = m - 1;
		else if (needle > straw)
			l = m + 1;
		else
			return ttSHORT(data + 22 + (m * 6));
	}
	return 0;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
	if (!info->kern) // if no kerning table, don't waste time looking up both codepoint->glyphs
		return 0;
	return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info, ch1), stbtt_FindGlyphIndex(info, ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
	stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info, codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
	if (ascent) *ascent = ttSHORT(info->data + info->hhea + 4);
	if (descent) *descent = ttSHORT(info->data + info->hhea + 6);
	if (lineGap) *lineGap = ttSHORT(info->data + info->hhea + 8);
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
	*x0 = ttSHORT(info->data + info->head + 36);
	*y0 = ttSHORT(info->data + info->head + 38);
	*x1 = ttSHORT(info->data + info->head + 40);
	*y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
	int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
	return (float)height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
	int unitsPerEm = ttUSHORT(info->data + info->head + 18);
	return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
	STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
	int x0 = 0, y0 = 0, x1, y1; // =0 suppresses compiler warning
	if (!stbtt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
		// e.g. space character
		if (ix0) *ix0 = 0;
		if (iy0) *iy0 = 0;
		if (ix1) *ix1 = 0;
		if (iy1) *iy1 = 0;
	}
	else {
		// move to integral bboxes (treating pixels as little squares, what pixels get touched)?
		if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);
		if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
		if (ix1) *ix1 = STBTT_iceil(x1 * scale_x + shift_x);
		if (iy1) *iy1 = STBTT_iceil(-y0 * scale_y + shift_y);
	}
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
	stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
	stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font, codepoint), scale_x, scale_y, shift_x, shift_y, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
	stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
	struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
	struct stbtt__hheap_chunk *head;
	void   *first_free;
	int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
	if (hh->first_free) {
		void *p = hh->first_free;
		hh->first_free = *(void **)p;
		return p;
	}
	else {
		if (hh->num_remaining_in_head_chunk == 0) {
			int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
			stbtt__hheap_chunk *c = (stbtt__hheap_chunk *)STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
			if (c == NULL)
				return NULL;
			c->next = hh->head;
			hh->head = c;
			hh->num_remaining_in_head_chunk = count;
		}
		--hh->num_remaining_in_head_chunk;
		return (char *)(hh->head) + size * hh->num_remaining_in_head_chunk;
	}
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
	*(void **)p = hh->first_free;
	hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
	stbtt__hheap_chunk *c = hh->head;
	while (c) {
		stbtt__hheap_chunk *n = c->next;
		STBTT_free(c, userdata);
		c = n;
	}
}

typedef struct stbtt__edge {
	float x0, y0, x1, y1;
	int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
	struct stbtt__active_edge *next;
#if STBTT_RASTERIZER_VERSION==1
	int x, dx;
	float ey;
	int direction;
#elif STBTT_RASTERIZER_VERSION==2
	float fx, fdx, fdy;
	float direction;
	float sy;
	float ey;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
	stbtt__active_edge *z = (stbtt__active_edge *)stbtt__hheap_alloc(hh, sizeof(*z), userdata);
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	STBTT_assert(z != NULL);
	if (!z) return z;

	// round dx down to avoid overshooting
	if (dxdy < 0)
		z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
	else
		z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

	z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
	z->x -= off_x * STBTT_FIX;

	z->ey = e->y1;
	z->next = 0;
	z->direction = e->invert ? 1 : -1;
	return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
	stbtt__active_edge *z = (stbtt__active_edge *)stbtt__hheap_alloc(hh, sizeof(*z), userdata);
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	STBTT_assert(z != NULL);
	//STBTT_assert(e->y0 <= start_point);
	if (!z) return z;
	z->fdx = dxdy;
	z->fdy = dxdy != 0.0f ? (1.0f / dxdy) : 0.0f;
	z->fx = e->x0 + dxdy * (start_point - e->y0);
	z->fx -= off_x;
	z->direction = e->invert ? 1.0f : -1.0f;
	z->sy = e->y0;
	z->ey = e->y1;
	z->next = 0;
	return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	while (e) {
		if (w == 0) {
			// if we're currently at zero, we need to record the edge start point
			x0 = e->x; w += e->direction;
		}
		else {
			int x1 = e->x; w += e->direction;
			// if we went to zero, we need to draw
			if (w == 0) {
				int i = x0 >> STBTT_FIXSHIFT;
				int j = x1 >> STBTT_FIXSHIFT;

				if (i < len && j >= 0) {
					if (i == j) {
						// x0,x1 are the same pixel, so compute combined coverage
						scanline[i] = scanline[i] + (stbtt_uint8)((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
					}
					else {
						if (i >= 0) // add antialiasing for x0
							scanline[i] = scanline[i] + (stbtt_uint8)(((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
						else
							i = -1; // clip

						if (j < len) // add antialiasing for x1
							scanline[j] = scanline[j] + (stbtt_uint8)(((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
						else
							j = len; // clip

						for (++i; i < j; ++i) // fill pixels between x0 and x1
							scanline[i] = scanline[i] + (stbtt_uint8)max_weight;
					}
				}
			}
		}

		e = e->next;
	}
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge *active = NULL;
	int y, j = 0;
	int max_weight = (255 / vsubsample);  // weight per vertical scanline
	int s; // vertical subsample index
	unsigned char scanline_data[512], *scanline;

	if (result->w > 512)
		scanline = (unsigned char *)STBTT_malloc(result->w, userdata);
	else
		scanline = scanline_data;

	y = off_y * vsubsample;
	e[n].y0 = (off_y + result->h) * (float)vsubsample + 1;

	while (j < result->h) {
		STBTT_memset(scanline, 0, result->w);
		for (s = 0; s < vsubsample; ++s) {
			// find center of pixel for this scanline
			float scan_y = y + 0.5f;
			stbtt__active_edge **step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while (*step) {
				stbtt__active_edge * z = *step;
				if (z->ey <= scan_y) {
					*step = z->next; // delete from list
					STBTT_assert(z->direction);
					z->direction = 0;
					stbtt__hheap_free(&hh, z);
				}
				else {
					z->x += z->dx; // advance to position for current scanline
					step = &((*step)->next); // advance through list
				}
			}

			// resort the list if needed
			for (;;) {
				int changed = 0;
				step = &active;
				while (*step && (*step)->next) {
					if ((*step)->x > (*step)->next->x) {
						stbtt__active_edge *t = *step;
						stbtt__active_edge *q = t->next;

						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &(*step)->next;
				}
				if (!changed) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while (e->y0 <= scan_y) {
				if (e->y1 > scan_y) {
					stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
					if (z != NULL) {
						// find insertion point
						if (active == NULL)
							active = z;
						else if (z->x < active->x) {
							// insert at front
							z->next = active;
							active = z;
						}
						else {
							// find thing to insert AFTER
							stbtt__active_edge *p = active;
							while (p->next && p->next->x < z->x)
								p = p->next;
							// at this point, p->next->x is NOT < z->x
							z->next = p->next;
							p->next = z;
						}
					}
				}
				++e;
			}

			// now process all active edges in XOR fashion
			if (active)
				stbtt__fill_active_edges(scanline, result->w, active, max_weight);

			++y;
		}
		STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
		++j;
	}

	stbtt__hheap_cleanup(&hh, userdata);

	if (scanline != scanline_data)
		STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
	if (y0 == y1) return;
	STBTT_assert(y0 < y1);
	STBTT_assert(e->sy <= e->ey);
	if (y0 > e->ey) return;
	if (y1 < e->sy) return;
	if (y0 < e->sy) {
		x0 += (x1 - x0) * (e->sy - y0) / (y1 - y0);
		y0 = e->sy;
	}
	if (y1 > e->ey) {
		x1 += (x1 - x0) * (e->ey - y1) / (y1 - y0);
		y1 = e->ey;
	}

	if (x0 == x)
		STBTT_assert(x1 <= x + 1);
	else if (x0 == x + 1)
		STBTT_assert(x1 >= x);
	else if (x0 <= x)
		STBTT_assert(x1 <= x);
	else if (x0 >= x + 1)
		STBTT_assert(x1 >= x + 1);
	else
		STBTT_assert(x1 >= x && x1 <= x + 1);

	if (x0 <= x && x1 <= x)
		scanline[x] += e->direction * (y1 - y0);
	else if (x0 >= x + 1 && x1 >= x + 1)
		;
	else {
		STBTT_assert(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1);
		scanline[x] += e->direction * (y1 - y0) * (1 - ((x0 - x) + (x1 - x)) / 2); // coverage = 1 - average x position
	}
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
	float y_bottom = y_top + 1;

	while (e) {
		// brute force every pixel

		// compute intersection points with top & bottom
		STBTT_assert(e->ey >= y_top);

		if (e->fdx == 0) {
			float x0 = e->fx;
			if (x0 < len) {
				if (x0 >= 0) {
					stbtt__handle_clipped_edge(scanline, (int)x0, e, x0, y_top, x0, y_bottom);
					stbtt__handle_clipped_edge(scanline_fill - 1, (int)x0 + 1, e, x0, y_top, x0, y_bottom);
				}
				else {
					stbtt__handle_clipped_edge(scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom);
				}
			}
		}
		else {
			float x0 = e->fx;
			float dx = e->fdx;
			float xb = x0 + dx;
			float x_top, x_bottom;
			float sy0, sy1;
			float dy = e->fdy;
			STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

			// compute endpoints of line segment clipped to this scanline (if the
			// line segment starts on this scanline. x0 is the intersection of the
			// line with y_top, but that may be off the line segment.
			if (e->sy > y_top) {
				x_top = x0 + dx * (e->sy - y_top);
				sy0 = e->sy;
			}
			else {
				x_top = x0;
				sy0 = y_top;
			}
			if (e->ey < y_bottom) {
				x_bottom = x0 + dx * (e->ey - y_top);
				sy1 = e->ey;
			}
			else {
				x_bottom = xb;
				sy1 = y_bottom;
			}

			if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
				// from here on, we don't have to range check x values

				if ((int)x_top == (int)x_bottom) {
					float height;
					// simple case, only spans one pixel
					int x = (int)x_top;
					height = sy1 - sy0;
					STBTT_assert(x >= 0 && x < len);
					scanline[x] += e->direction * (1 - ((x_top - x) + (x_bottom - x)) / 2)  * height;
					scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
				}
				else {
					int x, x1, x2;
					float y_crossing, step, sign, area;
					// covers 2+ pixels
					if (x_top > x_bottom) {
						// flip scanline vertically; signed area is the same
						float t;
						sy0 = y_bottom - (sy0 - y_top);
						sy1 = y_bottom - (sy1 - y_top);
						t = sy0, sy0 = sy1, sy1 = t;
						t = x_bottom, x_bottom = x_top, x_top = t;
						dx = -dx;
						dy = -dy;
						t = x0, x0 = xb, xb = t;
					}

					x1 = (int)x_top;
					x2 = (int)x_bottom;
					// compute intersection with y axis at x1+1
					y_crossing = (x1 + 1 - x0) * dy + y_top;

					sign = e->direction;
					// area of the rectangle covered from y0..y_crossing
					area = sign * (y_crossing - sy0);
					// area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
					scanline[x1] += area * (1 - ((x_top - x1) + (x1 + 1 - x1)) / 2);

					step = sign * dy;
					for (x = x1 + 1; x < x2; ++x) {
						scanline[x] += area + step / 2;
						area += step;
					}
					y_crossing += dy * (x2 - (x1 + 1));

					STBTT_assert(STBTT_fabs(area) <= 1.01f);

					scanline[x2] += area + sign * (1 - ((x2 - x2) + (x_bottom - x2)) / 2) * (sy1 - y_crossing);

					scanline_fill[x2] += sign * (sy1 - sy0);
				}
			}
			else {
				// if edge goes outside of box we're drawing, we require
				// clipping logic. since this does not match the intended use
				// of this library, we use a different, very slow brute
				// force implementation
				int x;
				for (x = 0; x < len; ++x) {
					// cases:
					//
					// there can be up to two intersections with the pixel. any intersection
					// with left or right edges can be handled by splitting into two (or three)
					// regions. intersections with top & bottom do not necessitate case-wise logic.
					//
					// the old way of doing this found the intersections with the left & right edges,
					// then used some simple logic to produce up to three segments in sorted order
					// from top-to-bottom. however, this had a problem: if an x edge was epsilon
					// across the x border, then the corresponding y position might not be distinct
					// from the other y segment, and it might ignored as an empty segment. to avoid
					// that, we need to explicitly produce segments based on x positions.

					// rename variables to clear pairs
					float y0 = y_top;
					float x1 = (float)(x);
					float x2 = (float)(x + 1);
					float x3 = xb;
					float y3 = y_bottom;
					float y1, y2;

					// x = e->x + e->dx * (y-y_top)
					// (y-y_top) = (x - e->x) / e->dx
					// y = (x - e->x) / e->dx + y_top
					y1 = (x - x0) / dx + y_top;
					y2 = (x + 1 - x0) / dx + y_top;

					if (x0 < x1 && x3 > x2) {         // three segments descending down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else {  // one segment
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3);
					}
				}
			}
		}
		e = e->next;
	}
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge *active = NULL;
	int y, j = 0, i;
	float scanline_data[129], *scanline, *scanline2;

	STBTT__NOTUSED(vsubsample);

	if (result->w > 64)
		scanline = (float *)STBTT_malloc((result->w * 2 + 1) * sizeof(float), userdata);
	else
		scanline = scanline_data;

	scanline2 = scanline + result->w;

	y = off_y;
	e[n].y0 = (float)(off_y + result->h) + 1;

	while (j < result->h) {
		// find center of pixel for this scanline
		float scan_y_top = y + 0.0f;
		float scan_y_bottom = y + 1.0f;
		stbtt__active_edge **step = &active;

		STBTT_memset(scanline, 0, result->w*sizeof(scanline[0]));
		STBTT_memset(scanline2, 0, (result->w + 1)*sizeof(scanline[0]));

		// update all active edges;
		// remove all active edges that terminate before the top of this scanline
		while (*step) {
			stbtt__active_edge * z = *step;
			if (z->ey <= scan_y_top) {
				*step = z->next; // delete from list
				STBTT_assert(z->direction);
				z->direction = 0;
				stbtt__hheap_free(&hh, z);
			}
			else {
				step = &((*step)->next); // advance through list
			}
		}

		// insert all edges that start before the bottom of this scanline
		while (e->y0 <= scan_y_bottom) {
			if (e->y0 != e->y1) {
				stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
				if (z != NULL) {
					STBTT_assert(z->ey >= scan_y_top);
					// insert at front
					z->next = active;
					active = z;
				}
			}
			++e;
		}

		// now process all active edges
		if (active)
			stbtt__fill_active_edges_new(scanline, scanline2 + 1, result->w, active, scan_y_top);

		{
			float sum = 0;
			for (i = 0; i < result->w; ++i) {
				float k;
				int m;
				sum += scanline2[i];
				k = scanline[i] + sum;
				k = (float)STBTT_fabs(k) * 255 + 0.5f;
				m = (int)k;
				if (m > 255) m = 255;
				result->pixels[j*result->stride + i] = (unsigned char)m;
			}
		}
		// advance all the edges
		step = &active;
		while (*step) {
			stbtt__active_edge *z = *step;
			z->fx += z->fdx; // advance to position for current scanline
			step = &((*step)->next); // advance through list
		}

		++y;
		++j;
	}

	stbtt__hheap_cleanup(&hh, userdata);

	if (scanline != scanline_data)
		STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
	int i, j;
	for (i = 1; i < n; ++i) {
		stbtt__edge t = p[i], *a = &t;
		j = i;
		while (j > 0) {
			stbtt__edge *b = &p[j - 1];
			int c = STBTT__COMPARE(a, b);
			if (!c) break;
			p[j] = p[j - 1];
			--j;
		}
		if (i != j)
			p[j] = t;
	}
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
	/* threshhold for transitioning to insertion sort */
	while (n > 12) {
		stbtt__edge t;
		int c01, c12, c, m, i, j;

		/* compute median of three */
		m = n >> 1;
		c01 = STBTT__COMPARE(&p[0], &p[m]);
		c12 = STBTT__COMPARE(&p[m], &p[n - 1]);
		/* if 0 >= mid >= end, or 0 < mid < end, then use mid */
		if (c01 != c12) {
			/* otherwise, we'll need to swap something else to middle */
			int z;
			c = STBTT__COMPARE(&p[0], &p[n - 1]);
			/* 0>mid && mid<n:  0>n => n; 0<n => 0 */
			/* 0<mid && mid>n:  0>n => 0; 0<n => n */
			z = (c == c12) ? 0 : n - 1;
			t = p[z];
			p[z] = p[m];
			p[m] = t;
		}
		/* now p[m] is the median-of-three */
		/* swap it to the beginning so it won't move around */
		t = p[0];
		p[0] = p[m];
		p[m] = t;

		/* partition loop */
		i = 1;
		j = n - 1;
		for (;;) {
			/* handling of equality is crucial here */
			/* for sentinels & efficiency with duplicates */
			for (;; ++i) {
				if (!STBTT__COMPARE(&p[i], &p[0])) break;
			}
			for (;; --j) {
				if (!STBTT__COMPARE(&p[0], &p[j])) break;
			}
			/* make sure we haven't crossed */
			if (i >= j) break;
			t = p[i];
			p[i] = p[j];
			p[j] = t;

			++i;
			--j;
		}
		/* recurse on smaller side, iterate on larger */
		if (j < (n - i)) {
			stbtt__sort_edges_quicksort(p, j);
			p = p + i;
			n = n - i;
		}
		else {
			stbtt__sort_edges_quicksort(p + i, n - i);
			n = j;
		}
	}
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
	stbtt__sort_edges_quicksort(p, n);
	stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
	float x, y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
	float y_scale_inv = invert ? -scale_y : scale_y;
	stbtt__edge *e;
	int n, i, j, k, m;
#if STBTT_RASTERIZER_VERSION == 1
	int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
	int vsubsample = 1;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
	// vsubsample should divide 255 evenly; otherwise we won't reach full opacity

	// now we have to blow out the windings into explicit edge lists
	n = 0;
	for (i = 0; i < windings; ++i)
		n += wcount[i];

	e = (stbtt__edge *)STBTT_malloc(sizeof(*e) * (n + 1), userdata); // add an extra one as a sentinel
	if (e == 0) return;
	n = 0;

	m = 0;
	for (i = 0; i < windings; ++i) {
		stbtt__point *p = pts + m;
		m += wcount[i];
		j = wcount[i] - 1;
		for (k = 0; k < wcount[i]; j = k++) {
			int a = k, b = j;
			// skip the edge if horizontal
			if (p[j].y == p[k].y)
				continue;
			// add edge from j to k to the list
			e[n].invert = 0;
			if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
				e[n].invert = 1;
				a = j, b = k;
			}
			e[n].x0 = p[a].x * scale_x + shift_x;
			e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
			e[n].x1 = p[b].x * scale_x + shift_x;
			e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
			++n;
		}
	}

	// now sort the edges by their highest point (should snap to integer, and then by x)
	//STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
	stbtt__sort_edges(e, n);

	// now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
	stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

	STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
	if (!points) return; // during first pass, it's unallocated
	points[n].x = x;
	points[n].y = y;
}

// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
	// midpoint
	float mx = (x0 + 2 * x1 + x2) / 4;
	float my = (y0 + 2 * y1 + y2) / 4;
	// versus directly drawn line
	float dx = (x0 + x2) / 2 - mx;
	float dy = (y0 + y2) / 2 - my;
	if (n > 16) // 65536 segments on one curve better be enough!
		return 1;
	if (dx*dx + dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
		stbtt__tesselate_curve(points, num_points, x0, y0, (x0 + x1) / 2.f, (y0 + y1) / 2.f, mx, my, objspace_flatness_squared, n + 1);
		stbtt__tesselate_curve(points, num_points, mx, my, (x1 + x2) / 2.f, (y1 + y2) / 2.f, x2, y2, objspace_flatness_squared, n + 1);
	}
	else {
		stbtt__add_point(points, *num_points, x2, y2);
		*num_points = *num_points + 1;
	}
	return 1;
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
	stbtt__point *points = 0;
	int num_points = 0;

	float objspace_flatness_squared = objspace_flatness * objspace_flatness;
	int i, n = 0, start = 0, pass;

	// count how many "moves" there are to get the contour count
	for (i = 0; i < num_verts; ++i)
		if (vertices[i].type == STBTT_vmove)
			++n;

	*num_contours = n;
	if (n == 0) return 0;

	*contour_lengths = (int *)STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	if (*contour_lengths == 0) {
		*num_contours = 0;
		return 0;
	}

	// make two passes through the points so we don't need to realloc
	for (pass = 0; pass < 2; ++pass) {
		float x = 0, y = 0;
		if (pass == 1) {
			points = (stbtt__point *)STBTT_malloc(num_points * sizeof(points[0]), userdata);
			if (points == NULL) goto error;
		}
		num_points = 0;
		n = -1;
		for (i = 0; i < num_verts; ++i) {
			switch (vertices[i].type) {
			case STBTT_vmove:
				// start the next contour
				if (n >= 0)
					(*contour_lengths)[n] = num_points - start;
				++n;
				start = num_points;

				x = vertices[i].x, y = vertices[i].y;
				stbtt__add_point(points, num_points++, x, y);
				break;
			case STBTT_vline:
				x = vertices[i].x, y = vertices[i].y;
				stbtt__add_point(points, num_points++, x, y);
				break;
			case STBTT_vcurve:
				stbtt__tesselate_curve(points, &num_points, x, y,
					vertices[i].cx, vertices[i].cy,
					vertices[i].x, vertices[i].y,
					objspace_flatness_squared, 0);
				x = vertices[i].x, y = vertices[i].y;
				break;
			}
		}
		(*contour_lengths)[n] = num_points - start;
	}

	return points;
error:
	STBTT_free(points, userdata);
	STBTT_free(*contour_lengths, userdata);
	*contour_lengths = 0;
	*num_contours = 0;
	return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
	float scale = scale_x > scale_y ? scale_y : scale_x;
	int winding_count, *winding_lengths;
	stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
	if (windings) {
		stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
		STBTT_free(winding_lengths, userdata);
		STBTT_free(windings, userdata);
	}
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
	STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
	int ix0, iy0, ix1, iy1;
	stbtt__bitmap gbm;
	stbtt_vertex *vertices;
	int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	if (scale_x == 0) scale_x = scale_y;
	if (scale_y == 0) {
		if (scale_x == 0) {
			STBTT_free(vertices, info->userdata);
			return NULL;
		}
		scale_y = scale_x;
	}

	stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, &ix1, &iy1);

	// now we get the size
	gbm.w = (ix1 - ix0);
	gbm.h = (iy1 - iy0);
	gbm.pixels = NULL; // in case we error

	if (width) *width = gbm.w;
	if (height) *height = gbm.h;
	if (xoff) *xoff = ix0;
	if (yoff) *yoff = iy0;

	if (gbm.w && gbm.h) {
		gbm.pixels = (unsigned char *)STBTT_malloc(gbm.w * gbm.h, info->userdata);
		if (gbm.pixels) {
			gbm.stride = gbm.w;

			stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
		}
	}
	STBTT_free(vertices, info->userdata);
	return gbm.pixels;
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
	return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
	int ix0, iy0;
	stbtt_vertex *vertices;
	int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
	stbtt__bitmap gbm;

	stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, 0, 0);
	gbm.pixels = output;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;

	if (gbm.w && gbm.h)
		stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);

	STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
	stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
	return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info, codepoint), width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
	stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info, codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
	return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, codepoint, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
	stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
	float pixel_height,                     // height of font in pixels
	unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
	int first_char, int num_chars,          // characters to bake
	stbtt_bakedchar *chardata)
{
	float scale;
	int x, y, bottom_y, i;
	stbtt_fontinfo f;
	f.userdata = NULL;
	if (!stbtt_InitFont(&f, data, offset))
		return -1;
	STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
	x = y = 1;
	bottom_y = 1;

	scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

	for (i = 0; i < num_chars; ++i) {
		int advance, lsb, x0, y0, x1, y1, gw, gh;
		int g = stbtt_FindGlyphIndex(&f, first_char + i);
		stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
		stbtt_GetGlyphBitmapBox(&f, g, scale, scale, &x0, &y0, &x1, &y1);
		gw = x1 - x0;
		gh = y1 - y0;
		if (x + gw + 1 >= pw)
			y = bottom_y, x = 1; // advance to next row
		if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
			return -i;
		STBTT_assert(x + gw < pw);
		STBTT_assert(y + gh < ph);
		stbtt_MakeGlyphBitmap(&f, pixels + x + y*pw, gw, gh, pw, scale, scale, g);
		chardata[i].x0 = (stbtt_int16)x;
		chardata[i].y0 = (stbtt_int16)y;
		chardata[i].x1 = (stbtt_int16)(x + gw);
		chardata[i].y1 = (stbtt_int16)(y + gh);
		chardata[i].xadvance = scale * advance;
		chardata[i].xoff = (float)x0;
		chardata[i].yoff = (float)y0;
		x = x + gw + 1;
		if (y + gh + 1 > bottom_y)
			bottom_y = y + gh + 1;
	}
	return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
	float d3d_bias = opengl_fillrule ? 0 : -0.5f;
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	stbtt_bakedchar *b = chardata + char_index;
	int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
	int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

	q->x0 = round_x + d3d_bias;
	q->y0 = round_y + d3d_bias;
	q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
	q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
	int width, height;
	int x, y, bottom_y;
} stbrp_context;

typedef struct
{
	unsigned char x;
} stbrp_node;

struct stbrp_rect
{
	stbrp_coord x, y;
	int id, w, h, was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
	con->width = pw;
	con->height = ph;
	con->x = 0;
	con->y = 0;
	con->bottom_y = 0;
	STBTT__NOTUSED(nodes);
	STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
	int i;
	for (i = 0; i < num_rects; ++i) {
		if (con->x + rects[i].w > con->width) {
			con->x = 0;
			con->y = con->bottom_y;
		}
		if (con->y + rects[i].h > con->height)
			break;
		rects[i].x = con->x;
		rects[i].y = con->y;
		rects[i].was_packed = 1;
		con->x += rects[i].w;
		if (con->y + rects[i].h > con->bottom_y)
			con->bottom_y = con->y + rects[i].h;
	}
	for (; i < num_rects; ++i)
		rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
	stbrp_context *context = (stbrp_context *)STBTT_malloc(sizeof(*context), alloc_context);
	int            num_nodes = pw - padding;
	stbrp_node    *nodes = (stbrp_node    *)STBTT_malloc(sizeof(*nodes) * num_nodes, alloc_context);

	if (context == NULL || nodes == NULL) {
		if (context != NULL) STBTT_free(context, alloc_context);
		if (nodes != NULL) STBTT_free(nodes, alloc_context);
		return 0;
	}

	spc->user_allocator_context = alloc_context;
	spc->width = pw;
	spc->height = ph;
	spc->pixels = pixels;
	spc->pack_info = context;
	spc->nodes = nodes;
	spc->padding = padding;
	spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
	spc->h_oversample = 1;
	spc->v_oversample = 1;

	stbrp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);

	if (pixels)
		STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

	return 1;
}

STBTT_DEF void stbtt_PackEnd(stbtt_pack_context *spc)
{
	STBTT_free(spc->nodes, spc->user_allocator_context);
	STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
	STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
	STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
	if (h_oversample <= STBTT_MAX_OVERSAMPLE)
		spc->h_oversample = h_oversample;
	if (v_oversample <= STBTT_MAX_OVERSAMPLE)
		spc->v_oversample = v_oversample;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
	unsigned char buffer[STBTT_MAX_OVERSAMPLE];
	int safe_w = w - kernel_width;
	int j;
	STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
	for (j = 0; j < h; ++j) {
		int i;
		unsigned int total;
		STBTT_memset(buffer, 0, kernel_width);

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / kernel_width);
			}
			break;
		}

		for (; i < w; ++i) {
			STBTT_assert(pixels[i] == 0);
			total -= buffer[i & STBTT__OVER_MASK];
			pixels[i] = (unsigned char)(total / kernel_width);
		}

		pixels += stride_in_bytes;
	}
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
	unsigned char buffer[STBTT_MAX_OVERSAMPLE];
	int safe_h = h - kernel_width;
	int j;
	STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
	for (j = 0; j < w; ++j) {
		int i;
		unsigned int total;
		STBTT_memset(buffer, 0, kernel_width);

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
				pixels[i*stride_in_bytes] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
				pixels[i*stride_in_bytes] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
				pixels[i*stride_in_bytes] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
				pixels[i*stride_in_bytes] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
				pixels[i*stride_in_bytes] = (unsigned char)(total / kernel_width);
			}
			break;
		}

		for (; i < h; ++i) {
			STBTT_assert(pixels[i*stride_in_bytes] == 0);
			total -= buffer[i & STBTT__OVER_MASK];
			pixels[i*stride_in_bytes] = (unsigned char)(total / kernel_width);
		}

		pixels += 1;
	}
}

static float stbtt__oversample_shift(int oversample)
{
	if (!oversample)
		return 0.0f;

	// The prefilter is a box filter of width "oversample",
	// which shifts phase by (oversample - 1)/2 pixels in
	// oversampled space. We want to shift in the opposite
	// direction to counter this.
	return (float)-(oversample - 1) / (2.f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
	int i, j, k;

	k = 0;
	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
		ranges[i].h_oversample = (unsigned char)spc->h_oversample;
		ranges[i].v_oversample = (unsigned char)spc->v_oversample;
		for (j = 0; j < ranges[i].num_chars; ++j) {
			int x0, y0, x1, y1;
			int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
			int glyph = stbtt_FindGlyphIndex(info, codepoint);
			stbtt_GetGlyphBitmapBoxSubpixel(info, glyph,
				scale * spc->h_oversample,
				scale * spc->v_oversample,
				0, 0,
				&x0, &y0, &x1, &y1);
			rects[k].w = (stbrp_coord)(x1 - x0 + spc->padding + spc->h_oversample - 1);
			rects[k].h = (stbrp_coord)(y1 - y0 + spc->padding + spc->v_oversample - 1);
			++k;
		}
	}

	return k;
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
	int i, j, k, return_value = 1;

	// save current values
	int old_h_over = spc->h_oversample;
	int old_v_over = spc->v_oversample;

	k = 0;
	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
		float recip_h, recip_v, sub_x, sub_y;
		spc->h_oversample = ranges[i].h_oversample;
		spc->v_oversample = ranges[i].v_oversample;
		recip_h = 1.0f / spc->h_oversample;
		recip_v = 1.0f / spc->v_oversample;
		sub_x = stbtt__oversample_shift(spc->h_oversample);
		sub_y = stbtt__oversample_shift(spc->v_oversample);
		for (j = 0; j < ranges[i].num_chars; ++j) {
			stbrp_rect *r = &rects[k];
			if (r->was_packed) {
				stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
				int advance, lsb, x0, y0, x1, y1;
				int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
				int glyph = stbtt_FindGlyphIndex(info, codepoint);
				stbrp_coord pad = (stbrp_coord)spc->padding;

				// pad on left and top
				r->x += pad;
				r->y += pad;
				r->w -= pad;
				r->h -= pad;
				stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
				stbtt_GetGlyphBitmapBox(info, glyph,
					scale * spc->h_oversample,
					scale * spc->v_oversample,
					&x0, &y0, &x1, &y1);
				stbtt_MakeGlyphBitmapSubpixel(info,
					spc->pixels + r->x + r->y*spc->stride_in_bytes,
					r->w - spc->h_oversample + 1,
					r->h - spc->v_oversample + 1,
					spc->stride_in_bytes,
					scale * spc->h_oversample,
					scale * spc->v_oversample,
					0, 0,
					glyph);

				if (spc->h_oversample > 1)
					stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
					r->w, r->h, spc->stride_in_bytes,
					spc->h_oversample);

				if (spc->v_oversample > 1)
					stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
					r->w, r->h, spc->stride_in_bytes,
					spc->v_oversample);

				bc->x0 = (stbtt_int16)r->x;
				bc->y0 = (stbtt_int16)r->y;
				bc->x1 = (stbtt_int16)(r->x + r->w);
				bc->y1 = (stbtt_int16)(r->y + r->h);
				bc->xadvance = scale * advance;
				bc->xoff = (float)x0 * recip_h + sub_x;
				bc->yoff = (float)y0 * recip_v + sub_y;
				bc->xoff2 = (x0 + r->w) * recip_h + sub_x;
				bc->yoff2 = (y0 + r->h) * recip_v + sub_y;
			}
			else {
				return_value = 0; // if any fail, report failure
			}

			++k;
		}
	}

	// restore original values
	spc->h_oversample = old_h_over;
	spc->v_oversample = old_v_over;

	return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
	stbrp_pack_rects((stbrp_context *)spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
	stbtt_fontinfo info;
	int i, j, n, return_value = 1;
	//stbrp_context *context = (stbrp_context *) spc->pack_info;
	stbrp_rect    *rects;

	// flag all characters as NOT packed
	for (i = 0; i < num_ranges; ++i)
		for (j = 0; j < ranges[i].num_chars; ++j)
			ranges[i].chardata_for_range[j].x0 =
			ranges[i].chardata_for_range[j].y0 =
			ranges[i].chardata_for_range[j].x1 =
			ranges[i].chardata_for_range[j].y1 = 0;

	n = 0;
	for (i = 0; i < num_ranges; ++i)
		n += ranges[i].num_chars;

	rects = (stbrp_rect *)STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
	if (rects == NULL)
		return 0;

	info.userdata = spc->user_allocator_context;
	stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, font_index));

	n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

	stbtt_PackFontRangesPackRects(spc, rects, n);

	return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

	STBTT_free(rects, spc->user_allocator_context);
	return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,
	int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
	stbtt_pack_range range;
	range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
	range.array_of_unicode_codepoints = NULL;
	range.num_chars = num_chars_in_range;
	range.chardata_for_range = chardata_for_range;
	range.font_size = font_size;
	return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	stbtt_packedchar *b = chardata + char_index;

	if (align_to_integer) {
		float x = (float)STBTT_ifloor((*xpos + b->xoff) + 0.5f);
		float y = (float)STBTT_ifloor((*ypos + b->yoff) + 0.5f);
		q->x0 = x;
		q->y0 = y;
		q->x1 = x + b->xoff2 - b->xoff;
		q->y1 = y + b->yoff2 - b->yoff;
	}
	else {
		q->x0 = *xpos + b->xoff;
		q->y0 = *ypos + b->yoff;
		q->x1 = *xpos + b->xoff2;
		q->y1 = *ypos + b->yoff2;
	}

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}


//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2)
{
	stbtt_int32 i = 0;

	// convert utf16 to utf8 and compare the results while converting
	while (len2) {
		stbtt_uint16 ch = s2[0] * 256 + s2[1];
		if (ch < 0x80) {
			if (i >= len1) return -1;
			if (s1[i++] != ch) return -1;
		}
		else if (ch < 0x800) {
			if (i + 1 >= len1) return -1;
			if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
			if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
		}
		else if (ch >= 0xd800 && ch < 0xdc00) {
			stbtt_uint32 c;
			stbtt_uint16 ch2 = s2[2] * 256 + s2[3];
			if (i + 3 >= len1) return -1;
			c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
			if (s1[i++] != 0xf0 + (c >> 18)) return -1;
			if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((c >> 6) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((c)& 0x3f)) return -1;
			s2 += 2; // plus another 2 below
			len2 -= 2;
		}
		else if (ch >= 0xdc00 && ch < 0xe000) {
			return -1;
		}
		else {
			if (i + 2 >= len1) return -1;
			if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
			if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((ch)& 0x3f)) return -1;
		}
		s2 += 2;
		len2 -= 2;
	}
	return i;
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
	return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((const stbtt_uint8*)s1, len1, (const stbtt_uint8*)s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
	stbtt_int32 i, count, stringOffset;
	stbtt_uint8 *fc = font->data;
	stbtt_uint32 offset = font->fontstart;
	stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
	if (!nm) return NULL;

	count = ttUSHORT(fc + nm + 2);
	stringOffset = nm + ttUSHORT(fc + nm + 4);
	for (i = 0; i < count; ++i) {
		stbtt_uint32 loc = nm + 6 + 12 * i;
		if (platformID == ttUSHORT(fc + loc + 0) && encodingID == ttUSHORT(fc + loc + 2)
			&& languageID == ttUSHORT(fc + loc + 4) && nameID == ttUSHORT(fc + loc + 6)) {
			*length = ttUSHORT(fc + loc + 8);
			return (const char *)(fc + stringOffset + ttUSHORT(fc + loc + 10));
		}
	}
	return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
	stbtt_int32 i;
	stbtt_int32 count = ttUSHORT(fc + nm + 2);
	stbtt_int32 stringOffset = nm + ttUSHORT(fc + nm + 4);

	for (i = 0; i < count; ++i) {
		stbtt_uint32 loc = nm + 6 + 12 * i;
		stbtt_int32 id = ttUSHORT(fc + loc + 6);
		if (id == target_id) {
			// find the encoding
			stbtt_int32 platform = ttUSHORT(fc + loc + 0), encoding = ttUSHORT(fc + loc + 2), language = ttUSHORT(fc + loc + 4);

			// is this a Unicode encoding?
			if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
				stbtt_int32 slen = ttUSHORT(fc + loc + 8);
				stbtt_int32 off = ttUSHORT(fc + loc + 10);

				// check if there's a prefix match
				stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc + stringOffset + off, slen);
				if (matchlen >= 0) {
					// check for target_id+1 immediately following, with same encoding & language
					if (i + 1 < count && ttUSHORT(fc + loc + 12 + 6) == next_id && ttUSHORT(fc + loc + 12) == platform && ttUSHORT(fc + loc + 12 + 2) == encoding && ttUSHORT(fc + loc + 12 + 4) == language) {
						slen = ttUSHORT(fc + loc + 12 + 8);
						off = ttUSHORT(fc + loc + 12 + 10);
						if (slen == 0) {
							if (matchlen == nlen)
								return 1;
						}
						else if (matchlen < nlen && name[matchlen] == ' ') {
							++matchlen;
							if (stbtt_CompareUTF8toUTF16_bigendian((char*)(name + matchlen), nlen - matchlen, (char*)(fc + stringOffset + off), slen))
								return 1;
						}
					}
					else {
						// if nothing immediately following
						if (matchlen == nlen)
							return 1;
					}
				}
			}

			// @TODO handle other encodings
		}
	}
	return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
	stbtt_int32 nlen = (stbtt_int32)STBTT_strlen((char *)name);
	stbtt_uint32 nm, hd;
	if (!stbtt__isfont(fc + offset)) return 0;

	// check italics/bold/underline flags in macStyle...
	if (flags) {
		hd = stbtt__find_table(fc, offset, "head");
		if ((ttUSHORT(fc + hd + 44) & 7) != (flags & 7)) return 0;
	}

	nm = stbtt__find_table(fc, offset, "name");
	if (!nm) return 0;

	if (flags) {
		// if we checked the macStyle flags, then just check the family and ignore the subfamily
		if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 1, -1))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 3, -1))  return 1;
	}
	else {
		if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 1, 2))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 3, -1))  return 1;
	}

	return 0;
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)
{
	stbtt_int32 i;
	for (i = 0;; ++i) {
		stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
		if (off < 0) return off;
		if (stbtt__matches((stbtt_uint8 *)font_collection, off, (stbtt_uint8*)name_utf8, flags))
			return off;
	}
}

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

// end stb_truetype.h

// ================================================================================================================================================================================================

ztFontID _zt_fontMakeFromSTB(const char *name, void *data, i32 data_size, i32 size_in_pixels, const char *charset, i32 charset_size)
{
	i32 tex_size = 1024; // TODO(josh): make this dynamic based off charset

	stbtt_fontinfo f;
	if (!stbtt_InitFont(&f, (const byte *)data, 0))
		return ztInvalidID;

	byte *pixel_data = zt_mallocStructArray(byte, tex_size * tex_size);
	zt_memSet(pixel_data, 0, tex_size * tex_size); // background of 0 around pixels

	int padding = 0;
	int spacing = 2;
	int x, y, bottom_y;
	x = y = bottom_y = spacing;

	r32 scale = stbtt_ScaleForPixelHeight(&f, (r32)size_in_pixels);

	zt_assert(zt_game->fonts_count < zt_elementsOf(zt_game->fonts));
	ztFontID font_id = zt_game->fonts_count++;
	ztFont *font = &zt_game->fonts[font_id];
	zt_memSet(font, zt_sizeof(ztFont), 0);

	font->arena = zt_memGetGlobalArena();

	zt_strCpy(font->name, zt_elementsOf(font->name), name, zt_strLen(name));
	font->size_pixels = size_in_pixels;
	font->glyph_count = charset_size;
	
	font->glyph_code_point = zt_mallocStructArray(i32, charset_size);
	font->glyphs = zt_mallocStructArray(ztFont::Glyph, charset_size);

	bool font_info_kerning[2048];

	i32 space_idx = -1;
	zt_fiz(charset_size) {
		int advance, lsb, x0, y0, x1, y1, gw, gh;
		i32 code_point = zt_strCodepoint(charset, i);
		int g = stbtt_FindGlyphIndex(&f, code_point);
		stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
		stbtt_GetGlyphBitmapBox(&f, g, scale, scale, &x0, &y0, &x1, &y1);

		font_info_kerning[i] = f.kern != 0;

		gw = x1 - x0;
		gh = y1 - y0;
		if (x + gw + spacing >= tex_size) {
			y = bottom_y, x = spacing; // advance to next row
		}
		if (y + gh + spacing >= tex_size) { // check if it fits vertically AFTER potentially moving to next row
			return ztInvalidID;
		}

		zt_assert(x + gw < tex_size);
		zt_assert(y + gh < tex_size);
		stbtt_MakeGlyphBitmap(&f, pixel_data + x + y*tex_size, gw, gh, tex_size, scale, scale, g);

		font->glyph_code_point[i] = code_point;
		font->glyphs[i].tex_uv.x = (x - padding) / (r32)tex_size;
		font->glyphs[i].tex_uv.y = (y - padding) / (r32)tex_size;
		font->glyphs[i].tex_uv.z = (x + gw + padding * 2) / (r32)tex_size;
		font->glyphs[i].tex_uv.w = (y + gh + padding * 2) / (r32)tex_size;

		font->glyphs[i].size.x = gw / (r32)zt_game->win_game_settings[0].pixels_per_unit;
		font->glyphs[i].size.y = gh / (r32)zt_game->win_game_settings[0].pixels_per_unit;
		font->line_height = zt_max(font->line_height, font->glyphs[i].size.y);

		font->glyphs[i].offset.x = (r32)x0 / zt_game->win_game_settings[0].pixels_per_unit;
		font->glyphs[i].offset.y = (r32)y0 / zt_game->win_game_settings[0].pixels_per_unit;

		font->glyphs[i].kerning = nullptr;

		font->glyphs[i].x_adv = (scale * advance) / (r32)zt_game->win_game_settings[0].pixels_per_unit;

		x = x + gw + spacing;
		if (y + gh + spacing > bottom_y) {
			bottom_y = y + gh + spacing;
		}

		if (code_point == ' ') {
			space_idx = i;
		}
	}

	int kernings = 0;
	zt_fiz(charset_size) {
		if (font_info_kerning[i]) {
			i32 code_point = zt_strCodepoint(charset, i);

			zt_fjz(charset_size) {
				if (j == i) continue;
				i32 code_point_2 = zt_strCodepoint(charset, j);
				int adv = stbtt_GetGlyphKernAdvance(&f, code_point, code_point_2);
				if (adv) {
					kernings += 1;
				}
			}
		}
	}

	font->kernings_count = kernings;
	font->kernings = kernings > 0 ? zt_mallocStructArrayArena(ztFont::Kerning, kernings, font->arena) : nullptr;
	if (kernings) {
		int kidx = 0;
		zt_fiz(charset_size) {
			if (font_info_kerning[i]) {
				i32 code_point = zt_strCodepoint(charset, i);

				zt_fjz(charset_size) {
					if (j == i) continue;
					i32 code_point_2 = zt_strCodepoint(charset, j);
					int adv = stbtt_GetGlyphKernAdvance(&f, code_point, code_point_2);
					if (adv) {
						ztFont::Kerning *kerning = &font->kernings[kidx++];
						kerning->next_code = code_point_2;
						kerning->spacing = (r32)adv / zt_game->win_game_settings[0].pixels_per_unit;
						kerning->next = nullptr;
						zt_singleLinkAddToEnd(font->glyphs[i].kerning, kerning);
					}
				}
			}
		}
	}

	font->line_spacing = ((r32)size_in_pixels * .1f) / zt_game->win_game_settings[0].pixels_per_unit;

	int advance, lsb;
	stbtt_GetGlyphHMetrics(&f, stbtt_FindGlyphIndex(&f, ' '), &advance, &lsb);
	font->space_width = (scale * advance) / zt_game->win_game_settings[0].pixels_per_unit;

	if (space_idx != -1) {
		font->glyphs[space_idx].size.x = font->space_width;
	}

	byte *pixel_data_full = zt_mallocStructArray(byte, tex_size * tex_size * 4);
	int pixel_data_idx = 0;
	zt_fiz(tex_size * tex_size) {
		pixel_data_full[pixel_data_idx++] = pixel_data[i] == 0 ? 0 : 255;
		pixel_data_full[pixel_data_idx++] = pixel_data[i] == 0 ? 0 : 255;
		pixel_data_full[pixel_data_idx++] = pixel_data[i] == 0 ? 0 : 255;
		pixel_data_full[pixel_data_idx++] = pixel_data[i];
	}
	zt_free(pixel_data);

	font->texture = zt_textureMake(pixel_data_full, tex_size, tex_size, 0);
	zt_free(pixel_data_full);

	if (font->texture == ztInvalidID) {
		zt_fontFree(font_id);		
		return ztInvalidID;
	}

	return font_id;
}

// ================================================================================================================================================================================================

#endif // implementation guard
#endif // implementation